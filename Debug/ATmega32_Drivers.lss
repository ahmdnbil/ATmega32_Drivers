
ATmega32_Drivers.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007504  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000003c  00800060  00007504  00007598  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000069d  0080009c  0080009c  000075d4  2**0
                  ALLOC
  3 .stab         00008b08  00000000  00000000  000075d4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003dfe  00000000  00000000  000100dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  00013eda  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000018f  00000000  00000000  0001403a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002045  00000000  00000000  000141c9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001101  00000000  00000000  0001620e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000f82  00000000  00000000  0001730f  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000180  00000000  00000000  00018294  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002c2  00000000  00000000  00018414  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000088e  00000000  00000000  000186d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00018f64  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 fb 0c 	jmp	0x19f6	; 0x19f6 <__vector_1>
       8:	0c 94 2e 0d 	jmp	0x1a5c	; 0x1a5c <__vector_2>
       c:	0c 94 61 0d 	jmp	0x1ac2	; 0x1ac2 <__vector_3>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 a7 2e 	jmp	0x5d4e	; 0x5d4e <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 77 26 	jmp	0x4cee	; 0x4cee <__vector_10>
      2c:	0c 94 44 26 	jmp	0x4c88	; 0x4c88 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 e6 06 	jmp	0xdcc	; 0xdcc <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 e0       	ldi	r30, 0x04	; 4
      68:	f5 e7       	ldi	r31, 0x75	; 117
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ac 39       	cpi	r26, 0x9C	; 156
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	ac e9       	ldi	r26, 0x9C	; 156
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a9 33       	cpi	r26, 0x39	; 57
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 aa 26 	call	0x4d54	; 0x4d54 <main>
      8a:	0c 94 80 3a 	jmp	0x7500	; 0x7500 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 2a 3a 	jmp	0x7454	; 0x7454 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a5 e6       	ldi	r26, 0x65	; 101
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 46 3a 	jmp	0x748c	; 0x748c <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 36 3a 	jmp	0x746c	; 0x746c <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 52 3a 	jmp	0x74a4	; 0x74a4 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 36 3a 	jmp	0x746c	; 0x746c <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 52 3a 	jmp	0x74a4	; 0x74a4 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 2a 3a 	jmp	0x7454	; 0x7454 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	85 e6       	ldi	r24, 0x65	; 101
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 46 3a 	jmp	0x748c	; 0x748c <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 32 3a 	jmp	0x7464	; 0x7464 <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	65 e6       	ldi	r22, 0x65	; 101
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 4e 3a 	jmp	0x749c	; 0x749c <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 36 3a 	jmp	0x746c	; 0x746c <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 52 3a 	jmp	0x74a4	; 0x74a4 <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 36 3a 	jmp	0x746c	; 0x746c <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 52 3a 	jmp	0x74a4	; 0x74a4 <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 36 3a 	jmp	0x746c	; 0x746c <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 52 3a 	jmp	0x74a4	; 0x74a4 <__epilogue_restores__+0x18>

000008aa <__fixsfsi>:
     8aa:	ac e0       	ldi	r26, 0x0C	; 12
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 3a 3a 	jmp	0x7474	; 0x7474 <__prologue_saves__+0x20>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	be 01       	movw	r22, r28
     8c4:	6b 5f       	subi	r22, 0xFB	; 251
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	61 f1       	breq	.+88     	; 0x92a <__fixsfsi+0x80>
     8d2:	82 30       	cpi	r24, 0x02	; 2
     8d4:	50 f1       	brcs	.+84     	; 0x92a <__fixsfsi+0x80>
     8d6:	84 30       	cpi	r24, 0x04	; 4
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__fixsfsi+0x38>
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	88 23       	and	r24, r24
     8de:	51 f1       	breq	.+84     	; 0x934 <__fixsfsi+0x8a>
     8e0:	2e c0       	rjmp	.+92     	; 0x93e <__fixsfsi+0x94>
     8e2:	2f 81       	ldd	r18, Y+7	; 0x07
     8e4:	38 85       	ldd	r19, Y+8	; 0x08
     8e6:	37 fd       	sbrc	r19, 7
     8e8:	20 c0       	rjmp	.+64     	; 0x92a <__fixsfsi+0x80>
     8ea:	6e 81       	ldd	r22, Y+6	; 0x06
     8ec:	2f 31       	cpi	r18, 0x1F	; 31
     8ee:	31 05       	cpc	r19, r1
     8f0:	1c f0       	brlt	.+6      	; 0x8f8 <__fixsfsi+0x4e>
     8f2:	66 23       	and	r22, r22
     8f4:	f9 f0       	breq	.+62     	; 0x934 <__fixsfsi+0x8a>
     8f6:	23 c0       	rjmp	.+70     	; 0x93e <__fixsfsi+0x94>
     8f8:	8e e1       	ldi	r24, 0x1E	; 30
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	82 1b       	sub	r24, r18
     8fe:	93 0b       	sbc	r25, r19
     900:	29 85       	ldd	r18, Y+9	; 0x09
     902:	3a 85       	ldd	r19, Y+10	; 0x0a
     904:	4b 85       	ldd	r20, Y+11	; 0x0b
     906:	5c 85       	ldd	r21, Y+12	; 0x0c
     908:	04 c0       	rjmp	.+8      	; 0x912 <__fixsfsi+0x68>
     90a:	56 95       	lsr	r21
     90c:	47 95       	ror	r20
     90e:	37 95       	ror	r19
     910:	27 95       	ror	r18
     912:	8a 95       	dec	r24
     914:	d2 f7       	brpl	.-12     	; 0x90a <__fixsfsi+0x60>
     916:	66 23       	and	r22, r22
     918:	b1 f0       	breq	.+44     	; 0x946 <__fixsfsi+0x9c>
     91a:	50 95       	com	r21
     91c:	40 95       	com	r20
     91e:	30 95       	com	r19
     920:	21 95       	neg	r18
     922:	3f 4f       	sbci	r19, 0xFF	; 255
     924:	4f 4f       	sbci	r20, 0xFF	; 255
     926:	5f 4f       	sbci	r21, 0xFF	; 255
     928:	0e c0       	rjmp	.+28     	; 0x946 <__fixsfsi+0x9c>
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	09 c0       	rjmp	.+18     	; 0x946 <__fixsfsi+0x9c>
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	3f ef       	ldi	r19, 0xFF	; 255
     938:	4f ef       	ldi	r20, 0xFF	; 255
     93a:	5f e7       	ldi	r21, 0x7F	; 127
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__fixsfsi+0x9c>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	50 e8       	ldi	r21, 0x80	; 128
     946:	b9 01       	movw	r22, r18
     948:	ca 01       	movw	r24, r20
     94a:	2c 96       	adiw	r28, 0x0c	; 12
     94c:	e2 e0       	ldi	r30, 0x02	; 2
     94e:	0c 94 56 3a 	jmp	0x74ac	; 0x74ac <__epilogue_restores__+0x20>

00000952 <__pack_f>:
     952:	df 92       	push	r13
     954:	ef 92       	push	r14
     956:	ff 92       	push	r15
     958:	0f 93       	push	r16
     95a:	1f 93       	push	r17
     95c:	fc 01       	movw	r30, r24
     95e:	e4 80       	ldd	r14, Z+4	; 0x04
     960:	f5 80       	ldd	r15, Z+5	; 0x05
     962:	06 81       	ldd	r16, Z+6	; 0x06
     964:	17 81       	ldd	r17, Z+7	; 0x07
     966:	d1 80       	ldd	r13, Z+1	; 0x01
     968:	80 81       	ld	r24, Z
     96a:	82 30       	cpi	r24, 0x02	; 2
     96c:	48 f4       	brcc	.+18     	; 0x980 <__pack_f+0x2e>
     96e:	80 e0       	ldi	r24, 0x00	; 0
     970:	90 e0       	ldi	r25, 0x00	; 0
     972:	a0 e1       	ldi	r26, 0x10	; 16
     974:	b0 e0       	ldi	r27, 0x00	; 0
     976:	e8 2a       	or	r14, r24
     978:	f9 2a       	or	r15, r25
     97a:	0a 2b       	or	r16, r26
     97c:	1b 2b       	or	r17, r27
     97e:	a5 c0       	rjmp	.+330    	; 0xaca <__pack_f+0x178>
     980:	84 30       	cpi	r24, 0x04	; 4
     982:	09 f4       	brne	.+2      	; 0x986 <__pack_f+0x34>
     984:	9f c0       	rjmp	.+318    	; 0xac4 <__pack_f+0x172>
     986:	82 30       	cpi	r24, 0x02	; 2
     988:	21 f4       	brne	.+8      	; 0x992 <__pack_f+0x40>
     98a:	ee 24       	eor	r14, r14
     98c:	ff 24       	eor	r15, r15
     98e:	87 01       	movw	r16, r14
     990:	05 c0       	rjmp	.+10     	; 0x99c <__pack_f+0x4a>
     992:	e1 14       	cp	r14, r1
     994:	f1 04       	cpc	r15, r1
     996:	01 05       	cpc	r16, r1
     998:	11 05       	cpc	r17, r1
     99a:	19 f4       	brne	.+6      	; 0x9a2 <__pack_f+0x50>
     99c:	e0 e0       	ldi	r30, 0x00	; 0
     99e:	f0 e0       	ldi	r31, 0x00	; 0
     9a0:	96 c0       	rjmp	.+300    	; 0xace <__pack_f+0x17c>
     9a2:	62 81       	ldd	r22, Z+2	; 0x02
     9a4:	73 81       	ldd	r23, Z+3	; 0x03
     9a6:	9f ef       	ldi	r25, 0xFF	; 255
     9a8:	62 38       	cpi	r22, 0x82	; 130
     9aa:	79 07       	cpc	r23, r25
     9ac:	0c f0       	brlt	.+2      	; 0x9b0 <__pack_f+0x5e>
     9ae:	5b c0       	rjmp	.+182    	; 0xa66 <__pack_f+0x114>
     9b0:	22 e8       	ldi	r18, 0x82	; 130
     9b2:	3f ef       	ldi	r19, 0xFF	; 255
     9b4:	26 1b       	sub	r18, r22
     9b6:	37 0b       	sbc	r19, r23
     9b8:	2a 31       	cpi	r18, 0x1A	; 26
     9ba:	31 05       	cpc	r19, r1
     9bc:	2c f0       	brlt	.+10     	; 0x9c8 <__pack_f+0x76>
     9be:	20 e0       	ldi	r18, 0x00	; 0
     9c0:	30 e0       	ldi	r19, 0x00	; 0
     9c2:	40 e0       	ldi	r20, 0x00	; 0
     9c4:	50 e0       	ldi	r21, 0x00	; 0
     9c6:	2a c0       	rjmp	.+84     	; 0xa1c <__pack_f+0xca>
     9c8:	b8 01       	movw	r22, r16
     9ca:	a7 01       	movw	r20, r14
     9cc:	02 2e       	mov	r0, r18
     9ce:	04 c0       	rjmp	.+8      	; 0x9d8 <__pack_f+0x86>
     9d0:	76 95       	lsr	r23
     9d2:	67 95       	ror	r22
     9d4:	57 95       	ror	r21
     9d6:	47 95       	ror	r20
     9d8:	0a 94       	dec	r0
     9da:	d2 f7       	brpl	.-12     	; 0x9d0 <__pack_f+0x7e>
     9dc:	81 e0       	ldi	r24, 0x01	; 1
     9de:	90 e0       	ldi	r25, 0x00	; 0
     9e0:	a0 e0       	ldi	r26, 0x00	; 0
     9e2:	b0 e0       	ldi	r27, 0x00	; 0
     9e4:	04 c0       	rjmp	.+8      	; 0x9ee <__pack_f+0x9c>
     9e6:	88 0f       	add	r24, r24
     9e8:	99 1f       	adc	r25, r25
     9ea:	aa 1f       	adc	r26, r26
     9ec:	bb 1f       	adc	r27, r27
     9ee:	2a 95       	dec	r18
     9f0:	d2 f7       	brpl	.-12     	; 0x9e6 <__pack_f+0x94>
     9f2:	01 97       	sbiw	r24, 0x01	; 1
     9f4:	a1 09       	sbc	r26, r1
     9f6:	b1 09       	sbc	r27, r1
     9f8:	8e 21       	and	r24, r14
     9fa:	9f 21       	and	r25, r15
     9fc:	a0 23       	and	r26, r16
     9fe:	b1 23       	and	r27, r17
     a00:	00 97       	sbiw	r24, 0x00	; 0
     a02:	a1 05       	cpc	r26, r1
     a04:	b1 05       	cpc	r27, r1
     a06:	21 f0       	breq	.+8      	; 0xa10 <__pack_f+0xbe>
     a08:	81 e0       	ldi	r24, 0x01	; 1
     a0a:	90 e0       	ldi	r25, 0x00	; 0
     a0c:	a0 e0       	ldi	r26, 0x00	; 0
     a0e:	b0 e0       	ldi	r27, 0x00	; 0
     a10:	9a 01       	movw	r18, r20
     a12:	ab 01       	movw	r20, r22
     a14:	28 2b       	or	r18, r24
     a16:	39 2b       	or	r19, r25
     a18:	4a 2b       	or	r20, r26
     a1a:	5b 2b       	or	r21, r27
     a1c:	da 01       	movw	r26, r20
     a1e:	c9 01       	movw	r24, r18
     a20:	8f 77       	andi	r24, 0x7F	; 127
     a22:	90 70       	andi	r25, 0x00	; 0
     a24:	a0 70       	andi	r26, 0x00	; 0
     a26:	b0 70       	andi	r27, 0x00	; 0
     a28:	80 34       	cpi	r24, 0x40	; 64
     a2a:	91 05       	cpc	r25, r1
     a2c:	a1 05       	cpc	r26, r1
     a2e:	b1 05       	cpc	r27, r1
     a30:	39 f4       	brne	.+14     	; 0xa40 <__pack_f+0xee>
     a32:	27 ff       	sbrs	r18, 7
     a34:	09 c0       	rjmp	.+18     	; 0xa48 <__pack_f+0xf6>
     a36:	20 5c       	subi	r18, 0xC0	; 192
     a38:	3f 4f       	sbci	r19, 0xFF	; 255
     a3a:	4f 4f       	sbci	r20, 0xFF	; 255
     a3c:	5f 4f       	sbci	r21, 0xFF	; 255
     a3e:	04 c0       	rjmp	.+8      	; 0xa48 <__pack_f+0xf6>
     a40:	21 5c       	subi	r18, 0xC1	; 193
     a42:	3f 4f       	sbci	r19, 0xFF	; 255
     a44:	4f 4f       	sbci	r20, 0xFF	; 255
     a46:	5f 4f       	sbci	r21, 0xFF	; 255
     a48:	e0 e0       	ldi	r30, 0x00	; 0
     a4a:	f0 e0       	ldi	r31, 0x00	; 0
     a4c:	20 30       	cpi	r18, 0x00	; 0
     a4e:	a0 e0       	ldi	r26, 0x00	; 0
     a50:	3a 07       	cpc	r19, r26
     a52:	a0 e0       	ldi	r26, 0x00	; 0
     a54:	4a 07       	cpc	r20, r26
     a56:	a0 e4       	ldi	r26, 0x40	; 64
     a58:	5a 07       	cpc	r21, r26
     a5a:	10 f0       	brcs	.+4      	; 0xa60 <__pack_f+0x10e>
     a5c:	e1 e0       	ldi	r30, 0x01	; 1
     a5e:	f0 e0       	ldi	r31, 0x00	; 0
     a60:	79 01       	movw	r14, r18
     a62:	8a 01       	movw	r16, r20
     a64:	27 c0       	rjmp	.+78     	; 0xab4 <__pack_f+0x162>
     a66:	60 38       	cpi	r22, 0x80	; 128
     a68:	71 05       	cpc	r23, r1
     a6a:	64 f5       	brge	.+88     	; 0xac4 <__pack_f+0x172>
     a6c:	fb 01       	movw	r30, r22
     a6e:	e1 58       	subi	r30, 0x81	; 129
     a70:	ff 4f       	sbci	r31, 0xFF	; 255
     a72:	d8 01       	movw	r26, r16
     a74:	c7 01       	movw	r24, r14
     a76:	8f 77       	andi	r24, 0x7F	; 127
     a78:	90 70       	andi	r25, 0x00	; 0
     a7a:	a0 70       	andi	r26, 0x00	; 0
     a7c:	b0 70       	andi	r27, 0x00	; 0
     a7e:	80 34       	cpi	r24, 0x40	; 64
     a80:	91 05       	cpc	r25, r1
     a82:	a1 05       	cpc	r26, r1
     a84:	b1 05       	cpc	r27, r1
     a86:	39 f4       	brne	.+14     	; 0xa96 <__pack_f+0x144>
     a88:	e7 fe       	sbrs	r14, 7
     a8a:	0d c0       	rjmp	.+26     	; 0xaa6 <__pack_f+0x154>
     a8c:	80 e4       	ldi	r24, 0x40	; 64
     a8e:	90 e0       	ldi	r25, 0x00	; 0
     a90:	a0 e0       	ldi	r26, 0x00	; 0
     a92:	b0 e0       	ldi	r27, 0x00	; 0
     a94:	04 c0       	rjmp	.+8      	; 0xa9e <__pack_f+0x14c>
     a96:	8f e3       	ldi	r24, 0x3F	; 63
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a0 e0       	ldi	r26, 0x00	; 0
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	e8 0e       	add	r14, r24
     aa0:	f9 1e       	adc	r15, r25
     aa2:	0a 1f       	adc	r16, r26
     aa4:	1b 1f       	adc	r17, r27
     aa6:	17 ff       	sbrs	r17, 7
     aa8:	05 c0       	rjmp	.+10     	; 0xab4 <__pack_f+0x162>
     aaa:	16 95       	lsr	r17
     aac:	07 95       	ror	r16
     aae:	f7 94       	ror	r15
     ab0:	e7 94       	ror	r14
     ab2:	31 96       	adiw	r30, 0x01	; 1
     ab4:	87 e0       	ldi	r24, 0x07	; 7
     ab6:	16 95       	lsr	r17
     ab8:	07 95       	ror	r16
     aba:	f7 94       	ror	r15
     abc:	e7 94       	ror	r14
     abe:	8a 95       	dec	r24
     ac0:	d1 f7       	brne	.-12     	; 0xab6 <__pack_f+0x164>
     ac2:	05 c0       	rjmp	.+10     	; 0xace <__pack_f+0x17c>
     ac4:	ee 24       	eor	r14, r14
     ac6:	ff 24       	eor	r15, r15
     ac8:	87 01       	movw	r16, r14
     aca:	ef ef       	ldi	r30, 0xFF	; 255
     acc:	f0 e0       	ldi	r31, 0x00	; 0
     ace:	6e 2f       	mov	r22, r30
     ad0:	67 95       	ror	r22
     ad2:	66 27       	eor	r22, r22
     ad4:	67 95       	ror	r22
     ad6:	90 2f       	mov	r25, r16
     ad8:	9f 77       	andi	r25, 0x7F	; 127
     ada:	d7 94       	ror	r13
     adc:	dd 24       	eor	r13, r13
     ade:	d7 94       	ror	r13
     ae0:	8e 2f       	mov	r24, r30
     ae2:	86 95       	lsr	r24
     ae4:	49 2f       	mov	r20, r25
     ae6:	46 2b       	or	r20, r22
     ae8:	58 2f       	mov	r21, r24
     aea:	5d 29       	or	r21, r13
     aec:	b7 01       	movw	r22, r14
     aee:	ca 01       	movw	r24, r20
     af0:	1f 91       	pop	r17
     af2:	0f 91       	pop	r16
     af4:	ff 90       	pop	r15
     af6:	ef 90       	pop	r14
     af8:	df 90       	pop	r13
     afa:	08 95       	ret

00000afc <__unpack_f>:
     afc:	fc 01       	movw	r30, r24
     afe:	db 01       	movw	r26, r22
     b00:	40 81       	ld	r20, Z
     b02:	51 81       	ldd	r21, Z+1	; 0x01
     b04:	22 81       	ldd	r18, Z+2	; 0x02
     b06:	62 2f       	mov	r22, r18
     b08:	6f 77       	andi	r22, 0x7F	; 127
     b0a:	70 e0       	ldi	r23, 0x00	; 0
     b0c:	22 1f       	adc	r18, r18
     b0e:	22 27       	eor	r18, r18
     b10:	22 1f       	adc	r18, r18
     b12:	93 81       	ldd	r25, Z+3	; 0x03
     b14:	89 2f       	mov	r24, r25
     b16:	88 0f       	add	r24, r24
     b18:	82 2b       	or	r24, r18
     b1a:	28 2f       	mov	r18, r24
     b1c:	30 e0       	ldi	r19, 0x00	; 0
     b1e:	99 1f       	adc	r25, r25
     b20:	99 27       	eor	r25, r25
     b22:	99 1f       	adc	r25, r25
     b24:	11 96       	adiw	r26, 0x01	; 1
     b26:	9c 93       	st	X, r25
     b28:	11 97       	sbiw	r26, 0x01	; 1
     b2a:	21 15       	cp	r18, r1
     b2c:	31 05       	cpc	r19, r1
     b2e:	a9 f5       	brne	.+106    	; 0xb9a <__unpack_f+0x9e>
     b30:	41 15       	cp	r20, r1
     b32:	51 05       	cpc	r21, r1
     b34:	61 05       	cpc	r22, r1
     b36:	71 05       	cpc	r23, r1
     b38:	11 f4       	brne	.+4      	; 0xb3e <__unpack_f+0x42>
     b3a:	82 e0       	ldi	r24, 0x02	; 2
     b3c:	37 c0       	rjmp	.+110    	; 0xbac <__unpack_f+0xb0>
     b3e:	82 e8       	ldi	r24, 0x82	; 130
     b40:	9f ef       	ldi	r25, 0xFF	; 255
     b42:	13 96       	adiw	r26, 0x03	; 3
     b44:	9c 93       	st	X, r25
     b46:	8e 93       	st	-X, r24
     b48:	12 97       	sbiw	r26, 0x02	; 2
     b4a:	9a 01       	movw	r18, r20
     b4c:	ab 01       	movw	r20, r22
     b4e:	67 e0       	ldi	r22, 0x07	; 7
     b50:	22 0f       	add	r18, r18
     b52:	33 1f       	adc	r19, r19
     b54:	44 1f       	adc	r20, r20
     b56:	55 1f       	adc	r21, r21
     b58:	6a 95       	dec	r22
     b5a:	d1 f7       	brne	.-12     	; 0xb50 <__unpack_f+0x54>
     b5c:	83 e0       	ldi	r24, 0x03	; 3
     b5e:	8c 93       	st	X, r24
     b60:	0d c0       	rjmp	.+26     	; 0xb7c <__unpack_f+0x80>
     b62:	22 0f       	add	r18, r18
     b64:	33 1f       	adc	r19, r19
     b66:	44 1f       	adc	r20, r20
     b68:	55 1f       	adc	r21, r21
     b6a:	12 96       	adiw	r26, 0x02	; 2
     b6c:	8d 91       	ld	r24, X+
     b6e:	9c 91       	ld	r25, X
     b70:	13 97       	sbiw	r26, 0x03	; 3
     b72:	01 97       	sbiw	r24, 0x01	; 1
     b74:	13 96       	adiw	r26, 0x03	; 3
     b76:	9c 93       	st	X, r25
     b78:	8e 93       	st	-X, r24
     b7a:	12 97       	sbiw	r26, 0x02	; 2
     b7c:	20 30       	cpi	r18, 0x00	; 0
     b7e:	80 e0       	ldi	r24, 0x00	; 0
     b80:	38 07       	cpc	r19, r24
     b82:	80 e0       	ldi	r24, 0x00	; 0
     b84:	48 07       	cpc	r20, r24
     b86:	80 e4       	ldi	r24, 0x40	; 64
     b88:	58 07       	cpc	r21, r24
     b8a:	58 f3       	brcs	.-42     	; 0xb62 <__unpack_f+0x66>
     b8c:	14 96       	adiw	r26, 0x04	; 4
     b8e:	2d 93       	st	X+, r18
     b90:	3d 93       	st	X+, r19
     b92:	4d 93       	st	X+, r20
     b94:	5c 93       	st	X, r21
     b96:	17 97       	sbiw	r26, 0x07	; 7
     b98:	08 95       	ret
     b9a:	2f 3f       	cpi	r18, 0xFF	; 255
     b9c:	31 05       	cpc	r19, r1
     b9e:	79 f4       	brne	.+30     	; 0xbbe <__unpack_f+0xc2>
     ba0:	41 15       	cp	r20, r1
     ba2:	51 05       	cpc	r21, r1
     ba4:	61 05       	cpc	r22, r1
     ba6:	71 05       	cpc	r23, r1
     ba8:	19 f4       	brne	.+6      	; 0xbb0 <__unpack_f+0xb4>
     baa:	84 e0       	ldi	r24, 0x04	; 4
     bac:	8c 93       	st	X, r24
     bae:	08 95       	ret
     bb0:	64 ff       	sbrs	r22, 4
     bb2:	03 c0       	rjmp	.+6      	; 0xbba <__unpack_f+0xbe>
     bb4:	81 e0       	ldi	r24, 0x01	; 1
     bb6:	8c 93       	st	X, r24
     bb8:	12 c0       	rjmp	.+36     	; 0xbde <__unpack_f+0xe2>
     bba:	1c 92       	st	X, r1
     bbc:	10 c0       	rjmp	.+32     	; 0xbde <__unpack_f+0xe2>
     bbe:	2f 57       	subi	r18, 0x7F	; 127
     bc0:	30 40       	sbci	r19, 0x00	; 0
     bc2:	13 96       	adiw	r26, 0x03	; 3
     bc4:	3c 93       	st	X, r19
     bc6:	2e 93       	st	-X, r18
     bc8:	12 97       	sbiw	r26, 0x02	; 2
     bca:	83 e0       	ldi	r24, 0x03	; 3
     bcc:	8c 93       	st	X, r24
     bce:	87 e0       	ldi	r24, 0x07	; 7
     bd0:	44 0f       	add	r20, r20
     bd2:	55 1f       	adc	r21, r21
     bd4:	66 1f       	adc	r22, r22
     bd6:	77 1f       	adc	r23, r23
     bd8:	8a 95       	dec	r24
     bda:	d1 f7       	brne	.-12     	; 0xbd0 <__unpack_f+0xd4>
     bdc:	70 64       	ori	r23, 0x40	; 64
     bde:	14 96       	adiw	r26, 0x04	; 4
     be0:	4d 93       	st	X+, r20
     be2:	5d 93       	st	X+, r21
     be4:	6d 93       	st	X+, r22
     be6:	7c 93       	st	X, r23
     be8:	17 97       	sbiw	r26, 0x07	; 7
     bea:	08 95       	ret

00000bec <__fpcmp_parts_f>:
     bec:	1f 93       	push	r17
     bee:	dc 01       	movw	r26, r24
     bf0:	fb 01       	movw	r30, r22
     bf2:	9c 91       	ld	r25, X
     bf4:	92 30       	cpi	r25, 0x02	; 2
     bf6:	08 f4       	brcc	.+2      	; 0xbfa <__fpcmp_parts_f+0xe>
     bf8:	47 c0       	rjmp	.+142    	; 0xc88 <__fpcmp_parts_f+0x9c>
     bfa:	80 81       	ld	r24, Z
     bfc:	82 30       	cpi	r24, 0x02	; 2
     bfe:	08 f4       	brcc	.+2      	; 0xc02 <__fpcmp_parts_f+0x16>
     c00:	43 c0       	rjmp	.+134    	; 0xc88 <__fpcmp_parts_f+0x9c>
     c02:	94 30       	cpi	r25, 0x04	; 4
     c04:	51 f4       	brne	.+20     	; 0xc1a <__fpcmp_parts_f+0x2e>
     c06:	11 96       	adiw	r26, 0x01	; 1
     c08:	1c 91       	ld	r17, X
     c0a:	84 30       	cpi	r24, 0x04	; 4
     c0c:	99 f5       	brne	.+102    	; 0xc74 <__fpcmp_parts_f+0x88>
     c0e:	81 81       	ldd	r24, Z+1	; 0x01
     c10:	68 2f       	mov	r22, r24
     c12:	70 e0       	ldi	r23, 0x00	; 0
     c14:	61 1b       	sub	r22, r17
     c16:	71 09       	sbc	r23, r1
     c18:	3f c0       	rjmp	.+126    	; 0xc98 <__fpcmp_parts_f+0xac>
     c1a:	84 30       	cpi	r24, 0x04	; 4
     c1c:	21 f0       	breq	.+8      	; 0xc26 <__fpcmp_parts_f+0x3a>
     c1e:	92 30       	cpi	r25, 0x02	; 2
     c20:	31 f4       	brne	.+12     	; 0xc2e <__fpcmp_parts_f+0x42>
     c22:	82 30       	cpi	r24, 0x02	; 2
     c24:	b9 f1       	breq	.+110    	; 0xc94 <__fpcmp_parts_f+0xa8>
     c26:	81 81       	ldd	r24, Z+1	; 0x01
     c28:	88 23       	and	r24, r24
     c2a:	89 f1       	breq	.+98     	; 0xc8e <__fpcmp_parts_f+0xa2>
     c2c:	2d c0       	rjmp	.+90     	; 0xc88 <__fpcmp_parts_f+0x9c>
     c2e:	11 96       	adiw	r26, 0x01	; 1
     c30:	1c 91       	ld	r17, X
     c32:	11 97       	sbiw	r26, 0x01	; 1
     c34:	82 30       	cpi	r24, 0x02	; 2
     c36:	f1 f0       	breq	.+60     	; 0xc74 <__fpcmp_parts_f+0x88>
     c38:	81 81       	ldd	r24, Z+1	; 0x01
     c3a:	18 17       	cp	r17, r24
     c3c:	d9 f4       	brne	.+54     	; 0xc74 <__fpcmp_parts_f+0x88>
     c3e:	12 96       	adiw	r26, 0x02	; 2
     c40:	2d 91       	ld	r18, X+
     c42:	3c 91       	ld	r19, X
     c44:	13 97       	sbiw	r26, 0x03	; 3
     c46:	82 81       	ldd	r24, Z+2	; 0x02
     c48:	93 81       	ldd	r25, Z+3	; 0x03
     c4a:	82 17       	cp	r24, r18
     c4c:	93 07       	cpc	r25, r19
     c4e:	94 f0       	brlt	.+36     	; 0xc74 <__fpcmp_parts_f+0x88>
     c50:	28 17       	cp	r18, r24
     c52:	39 07       	cpc	r19, r25
     c54:	bc f0       	brlt	.+46     	; 0xc84 <__fpcmp_parts_f+0x98>
     c56:	14 96       	adiw	r26, 0x04	; 4
     c58:	8d 91       	ld	r24, X+
     c5a:	9d 91       	ld	r25, X+
     c5c:	0d 90       	ld	r0, X+
     c5e:	bc 91       	ld	r27, X
     c60:	a0 2d       	mov	r26, r0
     c62:	24 81       	ldd	r18, Z+4	; 0x04
     c64:	35 81       	ldd	r19, Z+5	; 0x05
     c66:	46 81       	ldd	r20, Z+6	; 0x06
     c68:	57 81       	ldd	r21, Z+7	; 0x07
     c6a:	28 17       	cp	r18, r24
     c6c:	39 07       	cpc	r19, r25
     c6e:	4a 07       	cpc	r20, r26
     c70:	5b 07       	cpc	r21, r27
     c72:	18 f4       	brcc	.+6      	; 0xc7a <__fpcmp_parts_f+0x8e>
     c74:	11 23       	and	r17, r17
     c76:	41 f0       	breq	.+16     	; 0xc88 <__fpcmp_parts_f+0x9c>
     c78:	0a c0       	rjmp	.+20     	; 0xc8e <__fpcmp_parts_f+0xa2>
     c7a:	82 17       	cp	r24, r18
     c7c:	93 07       	cpc	r25, r19
     c7e:	a4 07       	cpc	r26, r20
     c80:	b5 07       	cpc	r27, r21
     c82:	40 f4       	brcc	.+16     	; 0xc94 <__fpcmp_parts_f+0xa8>
     c84:	11 23       	and	r17, r17
     c86:	19 f0       	breq	.+6      	; 0xc8e <__fpcmp_parts_f+0xa2>
     c88:	61 e0       	ldi	r22, 0x01	; 1
     c8a:	70 e0       	ldi	r23, 0x00	; 0
     c8c:	05 c0       	rjmp	.+10     	; 0xc98 <__fpcmp_parts_f+0xac>
     c8e:	6f ef       	ldi	r22, 0xFF	; 255
     c90:	7f ef       	ldi	r23, 0xFF	; 255
     c92:	02 c0       	rjmp	.+4      	; 0xc98 <__fpcmp_parts_f+0xac>
     c94:	60 e0       	ldi	r22, 0x00	; 0
     c96:	70 e0       	ldi	r23, 0x00	; 0
     c98:	cb 01       	movw	r24, r22
     c9a:	1f 91       	pop	r17
     c9c:	08 95       	ret

00000c9e <MADC_voidInit>:
#include "../Include/MCAL/ADC/ADC_Configurations.h"

static void (*ADC_CallBack)(void)=NULLPTR;

void MADC_voidInit()
{
     c9e:	df 93       	push	r29
     ca0:	cf 93       	push	r28
     ca2:	cd b7       	in	r28, 0x3d	; 61
     ca4:	de b7       	in	r29, 0x3e	; 62
    //reference selection
    ADMUX&=~(0b11<<REFS0);
     ca6:	a7 e2       	ldi	r26, 0x27	; 39
     ca8:	b0 e0       	ldi	r27, 0x00	; 0
     caa:	e7 e2       	ldi	r30, 0x27	; 39
     cac:	f0 e0       	ldi	r31, 0x00	; 0
     cae:	80 81       	ld	r24, Z
     cb0:	8f 73       	andi	r24, 0x3F	; 63
     cb2:	8c 93       	st	X, r24
    ADMUX|=(REF_VOLTAGE<<REFS0);
     cb4:	a7 e2       	ldi	r26, 0x27	; 39
     cb6:	b0 e0       	ldi	r27, 0x00	; 0
     cb8:	e7 e2       	ldi	r30, 0x27	; 39
     cba:	f0 e0       	ldi	r31, 0x00	; 0
     cbc:	80 81       	ld	r24, Z
     cbe:	80 64       	ori	r24, 0x40	; 64
     cc0:	8c 93       	st	X, r24

    //left or right adjust
    #if ADC_LEFT_ADJUST==TRUE
    SET_BIT(ADMUX,ADLAR);
    #else
    CLR_BIT(ADMUX,ADLAR);
     cc2:	a7 e2       	ldi	r26, 0x27	; 39
     cc4:	b0 e0       	ldi	r27, 0x00	; 0
     cc6:	e7 e2       	ldi	r30, 0x27	; 39
     cc8:	f0 e0       	ldi	r31, 0x00	; 0
     cca:	80 81       	ld	r24, Z
     ccc:	8f 7d       	andi	r24, 0xDF	; 223
     cce:	8c 93       	st	X, r24
    #endif

    
    //Making ADC enable
    SET_BIT(ADCSRA,ADEN);
     cd0:	a6 e2       	ldi	r26, 0x26	; 38
     cd2:	b0 e0       	ldi	r27, 0x00	; 0
     cd4:	e6 e2       	ldi	r30, 0x26	; 38
     cd6:	f0 e0       	ldi	r31, 0x00	; 0
     cd8:	80 81       	ld	r24, Z
     cda:	80 68       	ori	r24, 0x80	; 128
     cdc:	8c 93       	st	X, r24
    
    //auto triggering
    #if AUTO_TRIGGERING == TRUE
    SET_BIT(ADCSRA,ADATE);
    #else
    CLR_BIT(ADCSRA,ADATE);
     cde:	a6 e2       	ldi	r26, 0x26	; 38
     ce0:	b0 e0       	ldi	r27, 0x00	; 0
     ce2:	e6 e2       	ldi	r30, 0x26	; 38
     ce4:	f0 e0       	ldi	r31, 0x00	; 0
     ce6:	80 81       	ld	r24, Z
     ce8:	8f 7d       	andi	r24, 0xDF	; 223
     cea:	8c 93       	st	X, r24
    
    //interrupt enable
    #if ADC_INTERRUPT == TRUE
    SET_BIT(ADCSRA,ADIE);
    #else
    CLR_BIT(ADCSRA,ADIE);
     cec:	a6 e2       	ldi	r26, 0x26	; 38
     cee:	b0 e0       	ldi	r27, 0x00	; 0
     cf0:	e6 e2       	ldi	r30, 0x26	; 38
     cf2:	f0 e0       	ldi	r31, 0x00	; 0
     cf4:	80 81       	ld	r24, Z
     cf6:	87 7f       	andi	r24, 0xF7	; 247
     cf8:	8c 93       	st	X, r24
    #endif

    //prescaler division factor
    ADCSRA&=~(0b111<<ADPS0);
     cfa:	a6 e2       	ldi	r26, 0x26	; 38
     cfc:	b0 e0       	ldi	r27, 0x00	; 0
     cfe:	e6 e2       	ldi	r30, 0x26	; 38
     d00:	f0 e0       	ldi	r31, 0x00	; 0
     d02:	80 81       	ld	r24, Z
     d04:	88 7f       	andi	r24, 0xF8	; 248
     d06:	8c 93       	st	X, r24
    ADCSRA|=(ADC_PRESCALER<<ADPS0);
     d08:	a6 e2       	ldi	r26, 0x26	; 38
     d0a:	b0 e0       	ldi	r27, 0x00	; 0
     d0c:	e6 e2       	ldi	r30, 0x26	; 38
     d0e:	f0 e0       	ldi	r31, 0x00	; 0
     d10:	80 81       	ld	r24, Z
     d12:	86 60       	ori	r24, 0x06	; 6
     d14:	8c 93       	st	X, r24

}
     d16:	cf 91       	pop	r28
     d18:	df 91       	pop	r29
     d1a:	08 95       	ret

00000d1c <MADC_u16GetDigitalValue>:

u16 MADC_u16GetDigitalValue(u8 A_u8Channel)
{
     d1c:	df 93       	push	r29
     d1e:	cf 93       	push	r28
     d20:	00 d0       	rcall	.+0      	; 0xd22 <MADC_u16GetDigitalValue+0x6>
     d22:	0f 92       	push	r0
     d24:	cd b7       	in	r28, 0x3d	; 61
     d26:	de b7       	in	r29, 0x3e	; 62
     d28:	8b 83       	std	Y+3, r24	; 0x03

    u16 local_u16DigitalValue=0;
     d2a:	1a 82       	std	Y+2, r1	; 0x02
     d2c:	19 82       	std	Y+1, r1	; 0x01
    
    if (A_u8Channel <=32)
     d2e:	8b 81       	ldd	r24, Y+3	; 0x03
     d30:	81 32       	cpi	r24, 0x21	; 33
     d32:	90 f5       	brcc	.+100    	; 0xd98 <MADC_u16GetDigitalValue+0x7c>
    {
        //chosing channel
        ADMUX&=~(0b11111<< MUX0);
     d34:	a7 e2       	ldi	r26, 0x27	; 39
     d36:	b0 e0       	ldi	r27, 0x00	; 0
     d38:	e7 e2       	ldi	r30, 0x27	; 39
     d3a:	f0 e0       	ldi	r31, 0x00	; 0
     d3c:	80 81       	ld	r24, Z
     d3e:	80 7e       	andi	r24, 0xE0	; 224
     d40:	8c 93       	st	X, r24
        ADMUX|=(A_u8Channel<< MUX0);
     d42:	a7 e2       	ldi	r26, 0x27	; 39
     d44:	b0 e0       	ldi	r27, 0x00	; 0
     d46:	e7 e2       	ldi	r30, 0x27	; 39
     d48:	f0 e0       	ldi	r31, 0x00	; 0
     d4a:	90 81       	ld	r25, Z
     d4c:	8b 81       	ldd	r24, Y+3	; 0x03
     d4e:	89 2b       	or	r24, r25
     d50:	8c 93       	st	X, r24

        //starting conversion
        SET_BIT(ADCSRA,ADCS);
     d52:	a6 e2       	ldi	r26, 0x26	; 38
     d54:	b0 e0       	ldi	r27, 0x00	; 0
     d56:	e6 e2       	ldi	r30, 0x26	; 38
     d58:	f0 e0       	ldi	r31, 0x00	; 0
     d5a:	80 81       	ld	r24, Z
     d5c:	80 64       	ori	r24, 0x40	; 64
     d5e:	8c 93       	st	X, r24

        //polling on flag until the conversion is finished
        while(GET_BIT(ADCSRA,ADIF)==0);
     d60:	e6 e2       	ldi	r30, 0x26	; 38
     d62:	f0 e0       	ldi	r31, 0x00	; 0
     d64:	80 81       	ld	r24, Z
     d66:	88 2f       	mov	r24, r24
     d68:	90 e0       	ldi	r25, 0x00	; 0
     d6a:	9c 01       	movw	r18, r24
     d6c:	2f 7e       	andi	r18, 0xEF	; 239
     d6e:	e6 e2       	ldi	r30, 0x26	; 38
     d70:	f0 e0       	ldi	r31, 0x00	; 0
     d72:	80 81       	ld	r24, Z
     d74:	88 2f       	mov	r24, r24
     d76:	90 e0       	ldi	r25, 0x00	; 0
     d78:	28 17       	cp	r18, r24
     d7a:	39 07       	cpc	r19, r25
     d7c:	89 f3       	breq	.-30     	; 0xd60 <MADC_u16GetDigitalValue+0x44>
        //writing one to clear the flag
        SET_BIT(ADCSRA,ADIF);
     d7e:	a6 e2       	ldi	r26, 0x26	; 38
     d80:	b0 e0       	ldi	r27, 0x00	; 0
     d82:	e6 e2       	ldi	r30, 0x26	; 38
     d84:	f0 e0       	ldi	r31, 0x00	; 0
     d86:	80 81       	ld	r24, Z
     d88:	80 61       	ori	r24, 0x10	; 16
     d8a:	8c 93       	st	X, r24
        //Read value
        local_u16DigitalValue=ADCLH;
     d8c:	e4 e2       	ldi	r30, 0x24	; 36
     d8e:	f0 e0       	ldi	r31, 0x00	; 0
     d90:	80 81       	ld	r24, Z
     d92:	91 81       	ldd	r25, Z+1	; 0x01
     d94:	9a 83       	std	Y+2, r25	; 0x02
     d96:	89 83       	std	Y+1, r24	; 0x01
    }

    return local_u16DigitalValue;
     d98:	89 81       	ldd	r24, Y+1	; 0x01
     d9a:	9a 81       	ldd	r25, Y+2	; 0x02
}
     d9c:	0f 90       	pop	r0
     d9e:	0f 90       	pop	r0
     da0:	0f 90       	pop	r0
     da2:	cf 91       	pop	r28
     da4:	df 91       	pop	r29
     da6:	08 95       	ret

00000da8 <MADC_voidCallBack>:

void MADC_voidCallBack(void (*ptrToLocal)(void))
{
     da8:	df 93       	push	r29
     daa:	cf 93       	push	r28
     dac:	00 d0       	rcall	.+0      	; 0xdae <MADC_voidCallBack+0x6>
     dae:	cd b7       	in	r28, 0x3d	; 61
     db0:	de b7       	in	r29, 0x3e	; 62
     db2:	9a 83       	std	Y+2, r25	; 0x02
     db4:	89 83       	std	Y+1, r24	; 0x01
    ADC_CallBack=ptrToLocal;
     db6:	89 81       	ldd	r24, Y+1	; 0x01
     db8:	9a 81       	ldd	r25, Y+2	; 0x02
     dba:	90 93 9d 00 	sts	0x009D, r25
     dbe:	80 93 9c 00 	sts	0x009C, r24
}
     dc2:	0f 90       	pop	r0
     dc4:	0f 90       	pop	r0
     dc6:	cf 91       	pop	r28
     dc8:	df 91       	pop	r29
     dca:	08 95       	ret

00000dcc <__vector_16>:
ISR(ADC_VECT)
{
     dcc:	1f 92       	push	r1
     dce:	0f 92       	push	r0
     dd0:	0f b6       	in	r0, 0x3f	; 63
     dd2:	0f 92       	push	r0
     dd4:	11 24       	eor	r1, r1
     dd6:	2f 93       	push	r18
     dd8:	3f 93       	push	r19
     dda:	4f 93       	push	r20
     ddc:	5f 93       	push	r21
     dde:	6f 93       	push	r22
     de0:	7f 93       	push	r23
     de2:	8f 93       	push	r24
     de4:	9f 93       	push	r25
     de6:	af 93       	push	r26
     de8:	bf 93       	push	r27
     dea:	ef 93       	push	r30
     dec:	ff 93       	push	r31
     dee:	df 93       	push	r29
     df0:	cf 93       	push	r28
     df2:	cd b7       	in	r28, 0x3d	; 61
     df4:	de b7       	in	r29, 0x3e	; 62
    if(ADC_CallBack != NULLPTR) ADC_CallBack();
     df6:	80 91 9c 00 	lds	r24, 0x009C
     dfa:	90 91 9d 00 	lds	r25, 0x009D
     dfe:	00 97       	sbiw	r24, 0x00	; 0
     e00:	29 f0       	breq	.+10     	; 0xe0c <__vector_16+0x40>
     e02:	e0 91 9c 00 	lds	r30, 0x009C
     e06:	f0 91 9d 00 	lds	r31, 0x009D
     e0a:	09 95       	icall
     e0c:	cf 91       	pop	r28
     e0e:	df 91       	pop	r29
     e10:	ff 91       	pop	r31
     e12:	ef 91       	pop	r30
     e14:	bf 91       	pop	r27
     e16:	af 91       	pop	r26
     e18:	9f 91       	pop	r25
     e1a:	8f 91       	pop	r24
     e1c:	7f 91       	pop	r23
     e1e:	6f 91       	pop	r22
     e20:	5f 91       	pop	r21
     e22:	4f 91       	pop	r20
     e24:	3f 91       	pop	r19
     e26:	2f 91       	pop	r18
     e28:	0f 90       	pop	r0
     e2a:	0f be       	out	0x3f, r0	; 63
     e2c:	0f 90       	pop	r0
     e2e:	1f 90       	pop	r1
     e30:	18 95       	reti

00000e32 <HDCMOTOR_voidHBridge>:

#include <util/delay.h>

//H-bridge using 4npn transistors 2N2222
void HDCMOTOR_voidHBridge()
{
     e32:	df 93       	push	r29
     e34:	cf 93       	push	r28
     e36:	cd b7       	in	r28, 0x3d	; 61
     e38:	de b7       	in	r29, 0x3e	; 62
     e3a:	6c 97       	sbiw	r28, 0x1c	; 28
     e3c:	0f b6       	in	r0, 0x3f	; 63
     e3e:	f8 94       	cli
     e40:	de bf       	out	0x3e, r29	; 62
     e42:	0f be       	out	0x3f, r0	; 63
     e44:	cd bf       	out	0x3d, r28	; 61
    MDIO_voidSetPinValue(DC_MOTOR_PORT,DC_MOTOR_PIN1,PIN_HIGH);
     e46:	80 e0       	ldi	r24, 0x00	; 0
     e48:	60 e0       	ldi	r22, 0x00	; 0
     e4a:	41 e0       	ldi	r20, 0x01	; 1
     e4c:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(DC_MOTOR_PORT,DC_MOTOR_PIN2,PIN_LOW);
     e50:	80 e0       	ldi	r24, 0x00	; 0
     e52:	61 e0       	ldi	r22, 0x01	; 1
     e54:	40 e0       	ldi	r20, 0x00	; 0
     e56:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
     e5a:	80 e0       	ldi	r24, 0x00	; 0
     e5c:	90 e0       	ldi	r25, 0x00	; 0
     e5e:	aa e7       	ldi	r26, 0x7A	; 122
     e60:	b4 e4       	ldi	r27, 0x44	; 68
     e62:	89 8f       	std	Y+25, r24	; 0x19
     e64:	9a 8f       	std	Y+26, r25	; 0x1a
     e66:	ab 8f       	std	Y+27, r26	; 0x1b
     e68:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     e6a:	69 8d       	ldd	r22, Y+25	; 0x19
     e6c:	7a 8d       	ldd	r23, Y+26	; 0x1a
     e6e:	8b 8d       	ldd	r24, Y+27	; 0x1b
     e70:	9c 8d       	ldd	r25, Y+28	; 0x1c
     e72:	20 e0       	ldi	r18, 0x00	; 0
     e74:	30 e0       	ldi	r19, 0x00	; 0
     e76:	4a ef       	ldi	r20, 0xFA	; 250
     e78:	54 e4       	ldi	r21, 0x44	; 68
     e7a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     e7e:	dc 01       	movw	r26, r24
     e80:	cb 01       	movw	r24, r22
     e82:	8d 8b       	std	Y+21, r24	; 0x15
     e84:	9e 8b       	std	Y+22, r25	; 0x16
     e86:	af 8b       	std	Y+23, r26	; 0x17
     e88:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
     e8a:	6d 89       	ldd	r22, Y+21	; 0x15
     e8c:	7e 89       	ldd	r23, Y+22	; 0x16
     e8e:	8f 89       	ldd	r24, Y+23	; 0x17
     e90:	98 8d       	ldd	r25, Y+24	; 0x18
     e92:	20 e0       	ldi	r18, 0x00	; 0
     e94:	30 e0       	ldi	r19, 0x00	; 0
     e96:	40 e8       	ldi	r20, 0x80	; 128
     e98:	5f e3       	ldi	r21, 0x3F	; 63
     e9a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
     e9e:	88 23       	and	r24, r24
     ea0:	2c f4       	brge	.+10     	; 0xeac <HDCMOTOR_voidHBridge+0x7a>
		__ticks = 1;
     ea2:	81 e0       	ldi	r24, 0x01	; 1
     ea4:	90 e0       	ldi	r25, 0x00	; 0
     ea6:	9c 8b       	std	Y+20, r25	; 0x14
     ea8:	8b 8b       	std	Y+19, r24	; 0x13
     eaa:	3f c0       	rjmp	.+126    	; 0xf2a <HDCMOTOR_voidHBridge+0xf8>
	else if (__tmp > 65535)
     eac:	6d 89       	ldd	r22, Y+21	; 0x15
     eae:	7e 89       	ldd	r23, Y+22	; 0x16
     eb0:	8f 89       	ldd	r24, Y+23	; 0x17
     eb2:	98 8d       	ldd	r25, Y+24	; 0x18
     eb4:	20 e0       	ldi	r18, 0x00	; 0
     eb6:	3f ef       	ldi	r19, 0xFF	; 255
     eb8:	4f e7       	ldi	r20, 0x7F	; 127
     eba:	57 e4       	ldi	r21, 0x47	; 71
     ebc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
     ec0:	18 16       	cp	r1, r24
     ec2:	4c f5       	brge	.+82     	; 0xf16 <HDCMOTOR_voidHBridge+0xe4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     ec4:	69 8d       	ldd	r22, Y+25	; 0x19
     ec6:	7a 8d       	ldd	r23, Y+26	; 0x1a
     ec8:	8b 8d       	ldd	r24, Y+27	; 0x1b
     eca:	9c 8d       	ldd	r25, Y+28	; 0x1c
     ecc:	20 e0       	ldi	r18, 0x00	; 0
     ece:	30 e0       	ldi	r19, 0x00	; 0
     ed0:	40 e2       	ldi	r20, 0x20	; 32
     ed2:	51 e4       	ldi	r21, 0x41	; 65
     ed4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     ed8:	dc 01       	movw	r26, r24
     eda:	cb 01       	movw	r24, r22
     edc:	bc 01       	movw	r22, r24
     ede:	cd 01       	movw	r24, r26
     ee0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     ee4:	dc 01       	movw	r26, r24
     ee6:	cb 01       	movw	r24, r22
     ee8:	9c 8b       	std	Y+20, r25	; 0x14
     eea:	8b 8b       	std	Y+19, r24	; 0x13
     eec:	0f c0       	rjmp	.+30     	; 0xf0c <HDCMOTOR_voidHBridge+0xda>
     eee:	88 ec       	ldi	r24, 0xC8	; 200
     ef0:	90 e0       	ldi	r25, 0x00	; 0
     ef2:	9a 8b       	std	Y+18, r25	; 0x12
     ef4:	89 8b       	std	Y+17, r24	; 0x11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     ef6:	89 89       	ldd	r24, Y+17	; 0x11
     ef8:	9a 89       	ldd	r25, Y+18	; 0x12
     efa:	01 97       	sbiw	r24, 0x01	; 1
     efc:	f1 f7       	brne	.-4      	; 0xefa <HDCMOTOR_voidHBridge+0xc8>
     efe:	9a 8b       	std	Y+18, r25	; 0x12
     f00:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     f02:	8b 89       	ldd	r24, Y+19	; 0x13
     f04:	9c 89       	ldd	r25, Y+20	; 0x14
     f06:	01 97       	sbiw	r24, 0x01	; 1
     f08:	9c 8b       	std	Y+20, r25	; 0x14
     f0a:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     f0c:	8b 89       	ldd	r24, Y+19	; 0x13
     f0e:	9c 89       	ldd	r25, Y+20	; 0x14
     f10:	00 97       	sbiw	r24, 0x00	; 0
     f12:	69 f7       	brne	.-38     	; 0xeee <HDCMOTOR_voidHBridge+0xbc>
     f14:	14 c0       	rjmp	.+40     	; 0xf3e <HDCMOTOR_voidHBridge+0x10c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     f16:	6d 89       	ldd	r22, Y+21	; 0x15
     f18:	7e 89       	ldd	r23, Y+22	; 0x16
     f1a:	8f 89       	ldd	r24, Y+23	; 0x17
     f1c:	98 8d       	ldd	r25, Y+24	; 0x18
     f1e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     f22:	dc 01       	movw	r26, r24
     f24:	cb 01       	movw	r24, r22
     f26:	9c 8b       	std	Y+20, r25	; 0x14
     f28:	8b 8b       	std	Y+19, r24	; 0x13
     f2a:	8b 89       	ldd	r24, Y+19	; 0x13
     f2c:	9c 89       	ldd	r25, Y+20	; 0x14
     f2e:	98 8b       	std	Y+16, r25	; 0x10
     f30:	8f 87       	std	Y+15, r24	; 0x0f
     f32:	8f 85       	ldd	r24, Y+15	; 0x0f
     f34:	98 89       	ldd	r25, Y+16	; 0x10
     f36:	01 97       	sbiw	r24, 0x01	; 1
     f38:	f1 f7       	brne	.-4      	; 0xf36 <HDCMOTOR_voidHBridge+0x104>
     f3a:	98 8b       	std	Y+16, r25	; 0x10
     f3c:	8f 87       	std	Y+15, r24	; 0x0f
    _delay_ms(INVERSE_MOTOR_DELAY);
    MDIO_voidSetPinValue(DC_MOTOR_PORT,DC_MOTOR_PIN1,PIN_LOW);
     f3e:	80 e0       	ldi	r24, 0x00	; 0
     f40:	60 e0       	ldi	r22, 0x00	; 0
     f42:	40 e0       	ldi	r20, 0x00	; 0
     f44:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(DC_MOTOR_PORT,DC_MOTOR_PIN2,PIN_HIGH);
     f48:	80 e0       	ldi	r24, 0x00	; 0
     f4a:	61 e0       	ldi	r22, 0x01	; 1
     f4c:	41 e0       	ldi	r20, 0x01	; 1
     f4e:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
     f52:	80 e0       	ldi	r24, 0x00	; 0
     f54:	90 e0       	ldi	r25, 0x00	; 0
     f56:	aa e7       	ldi	r26, 0x7A	; 122
     f58:	b4 e4       	ldi	r27, 0x44	; 68
     f5a:	8b 87       	std	Y+11, r24	; 0x0b
     f5c:	9c 87       	std	Y+12, r25	; 0x0c
     f5e:	ad 87       	std	Y+13, r26	; 0x0d
     f60:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     f62:	6b 85       	ldd	r22, Y+11	; 0x0b
     f64:	7c 85       	ldd	r23, Y+12	; 0x0c
     f66:	8d 85       	ldd	r24, Y+13	; 0x0d
     f68:	9e 85       	ldd	r25, Y+14	; 0x0e
     f6a:	20 e0       	ldi	r18, 0x00	; 0
     f6c:	30 e0       	ldi	r19, 0x00	; 0
     f6e:	4a ef       	ldi	r20, 0xFA	; 250
     f70:	54 e4       	ldi	r21, 0x44	; 68
     f72:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     f76:	dc 01       	movw	r26, r24
     f78:	cb 01       	movw	r24, r22
     f7a:	8f 83       	std	Y+7, r24	; 0x07
     f7c:	98 87       	std	Y+8, r25	; 0x08
     f7e:	a9 87       	std	Y+9, r26	; 0x09
     f80:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     f82:	6f 81       	ldd	r22, Y+7	; 0x07
     f84:	78 85       	ldd	r23, Y+8	; 0x08
     f86:	89 85       	ldd	r24, Y+9	; 0x09
     f88:	9a 85       	ldd	r25, Y+10	; 0x0a
     f8a:	20 e0       	ldi	r18, 0x00	; 0
     f8c:	30 e0       	ldi	r19, 0x00	; 0
     f8e:	40 e8       	ldi	r20, 0x80	; 128
     f90:	5f e3       	ldi	r21, 0x3F	; 63
     f92:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
     f96:	88 23       	and	r24, r24
     f98:	2c f4       	brge	.+10     	; 0xfa4 <HDCMOTOR_voidHBridge+0x172>
		__ticks = 1;
     f9a:	81 e0       	ldi	r24, 0x01	; 1
     f9c:	90 e0       	ldi	r25, 0x00	; 0
     f9e:	9e 83       	std	Y+6, r25	; 0x06
     fa0:	8d 83       	std	Y+5, r24	; 0x05
     fa2:	3f c0       	rjmp	.+126    	; 0x1022 <HDCMOTOR_voidHBridge+0x1f0>
	else if (__tmp > 65535)
     fa4:	6f 81       	ldd	r22, Y+7	; 0x07
     fa6:	78 85       	ldd	r23, Y+8	; 0x08
     fa8:	89 85       	ldd	r24, Y+9	; 0x09
     faa:	9a 85       	ldd	r25, Y+10	; 0x0a
     fac:	20 e0       	ldi	r18, 0x00	; 0
     fae:	3f ef       	ldi	r19, 0xFF	; 255
     fb0:	4f e7       	ldi	r20, 0x7F	; 127
     fb2:	57 e4       	ldi	r21, 0x47	; 71
     fb4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
     fb8:	18 16       	cp	r1, r24
     fba:	4c f5       	brge	.+82     	; 0x100e <HDCMOTOR_voidHBridge+0x1dc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     fbc:	6b 85       	ldd	r22, Y+11	; 0x0b
     fbe:	7c 85       	ldd	r23, Y+12	; 0x0c
     fc0:	8d 85       	ldd	r24, Y+13	; 0x0d
     fc2:	9e 85       	ldd	r25, Y+14	; 0x0e
     fc4:	20 e0       	ldi	r18, 0x00	; 0
     fc6:	30 e0       	ldi	r19, 0x00	; 0
     fc8:	40 e2       	ldi	r20, 0x20	; 32
     fca:	51 e4       	ldi	r21, 0x41	; 65
     fcc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     fd0:	dc 01       	movw	r26, r24
     fd2:	cb 01       	movw	r24, r22
     fd4:	bc 01       	movw	r22, r24
     fd6:	cd 01       	movw	r24, r26
     fd8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     fdc:	dc 01       	movw	r26, r24
     fde:	cb 01       	movw	r24, r22
     fe0:	9e 83       	std	Y+6, r25	; 0x06
     fe2:	8d 83       	std	Y+5, r24	; 0x05
     fe4:	0f c0       	rjmp	.+30     	; 0x1004 <HDCMOTOR_voidHBridge+0x1d2>
     fe6:	88 ec       	ldi	r24, 0xC8	; 200
     fe8:	90 e0       	ldi	r25, 0x00	; 0
     fea:	9c 83       	std	Y+4, r25	; 0x04
     fec:	8b 83       	std	Y+3, r24	; 0x03
     fee:	8b 81       	ldd	r24, Y+3	; 0x03
     ff0:	9c 81       	ldd	r25, Y+4	; 0x04
     ff2:	01 97       	sbiw	r24, 0x01	; 1
     ff4:	f1 f7       	brne	.-4      	; 0xff2 <HDCMOTOR_voidHBridge+0x1c0>
     ff6:	9c 83       	std	Y+4, r25	; 0x04
     ff8:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     ffa:	8d 81       	ldd	r24, Y+5	; 0x05
     ffc:	9e 81       	ldd	r25, Y+6	; 0x06
     ffe:	01 97       	sbiw	r24, 0x01	; 1
    1000:	9e 83       	std	Y+6, r25	; 0x06
    1002:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1004:	8d 81       	ldd	r24, Y+5	; 0x05
    1006:	9e 81       	ldd	r25, Y+6	; 0x06
    1008:	00 97       	sbiw	r24, 0x00	; 0
    100a:	69 f7       	brne	.-38     	; 0xfe6 <HDCMOTOR_voidHBridge+0x1b4>
    100c:	14 c0       	rjmp	.+40     	; 0x1036 <HDCMOTOR_voidHBridge+0x204>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    100e:	6f 81       	ldd	r22, Y+7	; 0x07
    1010:	78 85       	ldd	r23, Y+8	; 0x08
    1012:	89 85       	ldd	r24, Y+9	; 0x09
    1014:	9a 85       	ldd	r25, Y+10	; 0x0a
    1016:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    101a:	dc 01       	movw	r26, r24
    101c:	cb 01       	movw	r24, r22
    101e:	9e 83       	std	Y+6, r25	; 0x06
    1020:	8d 83       	std	Y+5, r24	; 0x05
    1022:	8d 81       	ldd	r24, Y+5	; 0x05
    1024:	9e 81       	ldd	r25, Y+6	; 0x06
    1026:	9a 83       	std	Y+2, r25	; 0x02
    1028:	89 83       	std	Y+1, r24	; 0x01
    102a:	89 81       	ldd	r24, Y+1	; 0x01
    102c:	9a 81       	ldd	r25, Y+2	; 0x02
    102e:	01 97       	sbiw	r24, 0x01	; 1
    1030:	f1 f7       	brne	.-4      	; 0x102e <HDCMOTOR_voidHBridge+0x1fc>
    1032:	9a 83       	std	Y+2, r25	; 0x02
    1034:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(INVERSE_MOTOR_DELAY);
    
}
    1036:	6c 96       	adiw	r28, 0x1c	; 28
    1038:	0f b6       	in	r0, 0x3f	; 63
    103a:	f8 94       	cli
    103c:	de bf       	out	0x3e, r29	; 62
    103e:	0f be       	out	0x3f, r0	; 63
    1040:	cd bf       	out	0x3d, r28	; 61
    1042:	cf 91       	pop	r28
    1044:	df 91       	pop	r29
    1046:	08 95       	ret

00001048 <MDIO_voidInit>:
#include "../Include/MCAL/DIO/DIO_Private.h"
#include "../Include/MCAL/DIO/DIO_Configuration.h"
#include "../Include/MCAL/DIO/DIO_Interface.h"

void MDIO_voidInit()
{
    1048:	df 93       	push	r29
    104a:	cf 93       	push	r28
    104c:	cd b7       	in	r28, 0x3d	; 61
    104e:	de b7       	in	r29, 0x3e	; 62
    PORTA_REG=CONC_BIT(PORTA_PIN7_VALUE,PORTA_PIN6_VALUE,PORTA_PIN5_VALUE,PORTA_PIN4_VALUE,PORTA_PIN3_VALUE,PORTA_PIN2_VALUE,PORTA_PIN1_VALUE,PORTA_PIN0_VALUE);
    1050:	eb e3       	ldi	r30, 0x3B	; 59
    1052:	f0 e0       	ldi	r31, 0x00	; 0
    1054:	10 82       	st	Z, r1
    PORTB_REG=CONC_BIT(PORTB_PIN7_VALUE,PORTB_PIN6_VALUE,PORTB_PIN5_VALUE,PORTB_PIN4_VALUE,PORTB_PIN3_VALUE,PORTB_PIN2_VALUE,PORTB_PIN1_VALUE,PORTB_PIN0_VALUE);
    1056:	e8 e3       	ldi	r30, 0x38	; 56
    1058:	f0 e0       	ldi	r31, 0x00	; 0
    105a:	10 82       	st	Z, r1
    PORTC_REG=CONC_BIT(PORTC_PIN7_VALUE,PORTC_PIN6_VALUE,PORTC_PIN5_VALUE,PORTC_PIN4_VALUE,PORTC_PIN3_VALUE,PORTC_PIN2_VALUE,PORTC_PIN1_VALUE,PORTC_PIN0_VALUE);
    105c:	e5 e3       	ldi	r30, 0x35	; 53
    105e:	f0 e0       	ldi	r31, 0x00	; 0
    1060:	10 82       	st	Z, r1
    PORTD_REG=CONC_BIT(PORTD_PIN7_VALUE,PORTD_PIN6_VALUE,PORTD_PIN5_VALUE,PORTD_PIN4_VALUE,PORTD_PIN3_VALUE,PORTD_PIN2_VALUE,PORTD_PIN1_VALUE,PORTD_PIN0_VALUE);
    1062:	e2 e3       	ldi	r30, 0x32	; 50
    1064:	f0 e0       	ldi	r31, 0x00	; 0
    1066:	10 82       	st	Z, r1
    
    DDRA_REG=CONC_BIT(DDRA_PIN7_DIRECTION,DDRA_PIN6_DIRECTION,DDRA_PIN5_DIRECTION,DDRA_PIN4_DIRECTION,DDRA_PIN3_DIRECTION,DDRA_PIN2_DIRECTION,DDRA_PIN1_DIRECTION,DDRA_PIN0_DIRECTION);
    1068:	ea e3       	ldi	r30, 0x3A	; 58
    106a:	f0 e0       	ldi	r31, 0x00	; 0
    106c:	8f ef       	ldi	r24, 0xFF	; 255
    106e:	80 83       	st	Z, r24
    DDRB_REG=CONC_BIT(DDRB_PIN7_DIRECTION,DDRB_PIN6_DIRECTION,DDRB_PIN5_DIRECTION,DDRB_PIN4_DIRECTION,DDRB_PIN3_DIRECTION,DDRB_PIN2_DIRECTION,DDRB_PIN1_DIRECTION,DDRB_PIN0_DIRECTION);
    1070:	e7 e3       	ldi	r30, 0x37	; 55
    1072:	f0 e0       	ldi	r31, 0x00	; 0
    1074:	8f ef       	ldi	r24, 0xFF	; 255
    1076:	80 83       	st	Z, r24
    DDRC_REG=CONC_BIT(DDRC_PIN7_DIRECTION,DDRC_PIN6_DIRECTION,DDRC_PIN5_DIRECTION,DDRC_PIN4_DIRECTION,DDRC_PIN3_DIRECTION,DDRC_PIN2_DIRECTION,DDRC_PIN1_DIRECTION,DDRC_PIN0_DIRECTION);
    1078:	e4 e3       	ldi	r30, 0x34	; 52
    107a:	f0 e0       	ldi	r31, 0x00	; 0
    107c:	8f ef       	ldi	r24, 0xFF	; 255
    107e:	80 83       	st	Z, r24
    DDRD_REG=CONC_BIT(DDRD_PIN7_DIRECTION,DDRD_PIN6_DIRECTION,DDRD_PIN5_DIRECTION,DDRD_PIN4_DIRECTION,DDRD_PIN3_DIRECTION,DDRD_PIN2_DIRECTION,DDRD_PIN1_DIRECTION,DDRD_PIN0_DIRECTION);
    1080:	e1 e3       	ldi	r30, 0x31	; 49
    1082:	f0 e0       	ldi	r31, 0x00	; 0
    1084:	8f ef       	ldi	r24, 0xFF	; 255
    1086:	80 83       	st	Z, r24

}
    1088:	cf 91       	pop	r28
    108a:	df 91       	pop	r29
    108c:	08 95       	ret

0000108e <MDIO_u8GetPinValue>:

u8 MDIO_u8GetPinValue(u8 A_u8Port,u8 A_u8Pin)
{
    108e:	df 93       	push	r29
    1090:	cf 93       	push	r28
    1092:	00 d0       	rcall	.+0      	; 0x1094 <MDIO_u8GetPinValue+0x6>
    1094:	00 d0       	rcall	.+0      	; 0x1096 <MDIO_u8GetPinValue+0x8>
    1096:	0f 92       	push	r0
    1098:	cd b7       	in	r28, 0x3d	; 61
    109a:	de b7       	in	r29, 0x3e	; 62
    109c:	8a 83       	std	Y+2, r24	; 0x02
    109e:	6b 83       	std	Y+3, r22	; 0x03
    u8 local_u8Value;
    switch(A_u8Port)
    10a0:	8a 81       	ldd	r24, Y+2	; 0x02
    10a2:	28 2f       	mov	r18, r24
    10a4:	30 e0       	ldi	r19, 0x00	; 0
    10a6:	3d 83       	std	Y+5, r19	; 0x05
    10a8:	2c 83       	std	Y+4, r18	; 0x04
    10aa:	8c 81       	ldd	r24, Y+4	; 0x04
    10ac:	9d 81       	ldd	r25, Y+5	; 0x05
    10ae:	81 30       	cpi	r24, 0x01	; 1
    10b0:	91 05       	cpc	r25, r1
    10b2:	c1 f1       	breq	.+112    	; 0x1124 <MDIO_u8GetPinValue+0x96>
    10b4:	2c 81       	ldd	r18, Y+4	; 0x04
    10b6:	3d 81       	ldd	r19, Y+5	; 0x05
    10b8:	22 30       	cpi	r18, 0x02	; 2
    10ba:	31 05       	cpc	r19, r1
    10bc:	2c f4       	brge	.+10     	; 0x10c8 <MDIO_u8GetPinValue+0x3a>
    10be:	8c 81       	ldd	r24, Y+4	; 0x04
    10c0:	9d 81       	ldd	r25, Y+5	; 0x05
    10c2:	00 97       	sbiw	r24, 0x00	; 0
    10c4:	71 f0       	breq	.+28     	; 0x10e2 <MDIO_u8GetPinValue+0x54>
    10c6:	8e c0       	rjmp	.+284    	; 0x11e4 <MDIO_u8GetPinValue+0x156>
    10c8:	2c 81       	ldd	r18, Y+4	; 0x04
    10ca:	3d 81       	ldd	r19, Y+5	; 0x05
    10cc:	22 30       	cpi	r18, 0x02	; 2
    10ce:	31 05       	cpc	r19, r1
    10d0:	09 f4       	brne	.+2      	; 0x10d4 <MDIO_u8GetPinValue+0x46>
    10d2:	49 c0       	rjmp	.+146    	; 0x1166 <MDIO_u8GetPinValue+0xd8>
    10d4:	8c 81       	ldd	r24, Y+4	; 0x04
    10d6:	9d 81       	ldd	r25, Y+5	; 0x05
    10d8:	83 30       	cpi	r24, 0x03	; 3
    10da:	91 05       	cpc	r25, r1
    10dc:	09 f4       	brne	.+2      	; 0x10e0 <MDIO_u8GetPinValue+0x52>
    10de:	63 c0       	rjmp	.+198    	; 0x11a6 <MDIO_u8GetPinValue+0x118>
    10e0:	81 c0       	rjmp	.+258    	; 0x11e4 <MDIO_u8GetPinValue+0x156>
    {
        case PORTA: local_u8Value=GET_BIT(PINA_REG,A_u8Pin);
    10e2:	e9 e3       	ldi	r30, 0x39	; 57
    10e4:	f0 e0       	ldi	r31, 0x00	; 0
    10e6:	80 81       	ld	r24, Z
    10e8:	48 2f       	mov	r20, r24
    10ea:	50 e0       	ldi	r21, 0x00	; 0
    10ec:	8b 81       	ldd	r24, Y+3	; 0x03
    10ee:	28 2f       	mov	r18, r24
    10f0:	30 e0       	ldi	r19, 0x00	; 0
    10f2:	81 e0       	ldi	r24, 0x01	; 1
    10f4:	90 e0       	ldi	r25, 0x00	; 0
    10f6:	02 c0       	rjmp	.+4      	; 0x10fc <MDIO_u8GetPinValue+0x6e>
    10f8:	88 0f       	add	r24, r24
    10fa:	99 1f       	adc	r25, r25
    10fc:	2a 95       	dec	r18
    10fe:	e2 f7       	brpl	.-8      	; 0x10f8 <MDIO_u8GetPinValue+0x6a>
    1100:	80 95       	com	r24
    1102:	90 95       	com	r25
    1104:	9a 01       	movw	r18, r20
    1106:	28 23       	and	r18, r24
    1108:	39 23       	and	r19, r25
    110a:	e9 e3       	ldi	r30, 0x39	; 57
    110c:	f0 e0       	ldi	r31, 0x00	; 0
    110e:	80 81       	ld	r24, Z
    1110:	88 2f       	mov	r24, r24
    1112:	90 e0       	ldi	r25, 0x00	; 0
    1114:	19 82       	std	Y+1, r1	; 0x01
    1116:	28 17       	cp	r18, r24
    1118:	39 07       	cpc	r19, r25
    111a:	09 f4       	brne	.+2      	; 0x111e <MDIO_u8GetPinValue+0x90>
    111c:	63 c0       	rjmp	.+198    	; 0x11e4 <MDIO_u8GetPinValue+0x156>
    111e:	81 e0       	ldi	r24, 0x01	; 1
    1120:	89 83       	std	Y+1, r24	; 0x01
    1122:	60 c0       	rjmp	.+192    	; 0x11e4 <MDIO_u8GetPinValue+0x156>
        break;
        case PORTB: local_u8Value=GET_BIT(PINB_REG,A_u8Pin);
    1124:	e6 e3       	ldi	r30, 0x36	; 54
    1126:	f0 e0       	ldi	r31, 0x00	; 0
    1128:	80 81       	ld	r24, Z
    112a:	48 2f       	mov	r20, r24
    112c:	50 e0       	ldi	r21, 0x00	; 0
    112e:	8b 81       	ldd	r24, Y+3	; 0x03
    1130:	28 2f       	mov	r18, r24
    1132:	30 e0       	ldi	r19, 0x00	; 0
    1134:	81 e0       	ldi	r24, 0x01	; 1
    1136:	90 e0       	ldi	r25, 0x00	; 0
    1138:	02 c0       	rjmp	.+4      	; 0x113e <MDIO_u8GetPinValue+0xb0>
    113a:	88 0f       	add	r24, r24
    113c:	99 1f       	adc	r25, r25
    113e:	2a 95       	dec	r18
    1140:	e2 f7       	brpl	.-8      	; 0x113a <MDIO_u8GetPinValue+0xac>
    1142:	80 95       	com	r24
    1144:	90 95       	com	r25
    1146:	9a 01       	movw	r18, r20
    1148:	28 23       	and	r18, r24
    114a:	39 23       	and	r19, r25
    114c:	e6 e3       	ldi	r30, 0x36	; 54
    114e:	f0 e0       	ldi	r31, 0x00	; 0
    1150:	80 81       	ld	r24, Z
    1152:	88 2f       	mov	r24, r24
    1154:	90 e0       	ldi	r25, 0x00	; 0
    1156:	19 82       	std	Y+1, r1	; 0x01
    1158:	28 17       	cp	r18, r24
    115a:	39 07       	cpc	r19, r25
    115c:	09 f4       	brne	.+2      	; 0x1160 <MDIO_u8GetPinValue+0xd2>
    115e:	42 c0       	rjmp	.+132    	; 0x11e4 <MDIO_u8GetPinValue+0x156>
    1160:	81 e0       	ldi	r24, 0x01	; 1
    1162:	89 83       	std	Y+1, r24	; 0x01
    1164:	3f c0       	rjmp	.+126    	; 0x11e4 <MDIO_u8GetPinValue+0x156>
        break;
        case PORTC: local_u8Value=GET_BIT(PINC_REG,A_u8Pin);
    1166:	e3 e3       	ldi	r30, 0x33	; 51
    1168:	f0 e0       	ldi	r31, 0x00	; 0
    116a:	80 81       	ld	r24, Z
    116c:	48 2f       	mov	r20, r24
    116e:	50 e0       	ldi	r21, 0x00	; 0
    1170:	8b 81       	ldd	r24, Y+3	; 0x03
    1172:	28 2f       	mov	r18, r24
    1174:	30 e0       	ldi	r19, 0x00	; 0
    1176:	81 e0       	ldi	r24, 0x01	; 1
    1178:	90 e0       	ldi	r25, 0x00	; 0
    117a:	02 c0       	rjmp	.+4      	; 0x1180 <MDIO_u8GetPinValue+0xf2>
    117c:	88 0f       	add	r24, r24
    117e:	99 1f       	adc	r25, r25
    1180:	2a 95       	dec	r18
    1182:	e2 f7       	brpl	.-8      	; 0x117c <MDIO_u8GetPinValue+0xee>
    1184:	80 95       	com	r24
    1186:	90 95       	com	r25
    1188:	9a 01       	movw	r18, r20
    118a:	28 23       	and	r18, r24
    118c:	39 23       	and	r19, r25
    118e:	e3 e3       	ldi	r30, 0x33	; 51
    1190:	f0 e0       	ldi	r31, 0x00	; 0
    1192:	80 81       	ld	r24, Z
    1194:	88 2f       	mov	r24, r24
    1196:	90 e0       	ldi	r25, 0x00	; 0
    1198:	19 82       	std	Y+1, r1	; 0x01
    119a:	28 17       	cp	r18, r24
    119c:	39 07       	cpc	r19, r25
    119e:	11 f1       	breq	.+68     	; 0x11e4 <MDIO_u8GetPinValue+0x156>
    11a0:	81 e0       	ldi	r24, 0x01	; 1
    11a2:	89 83       	std	Y+1, r24	; 0x01
    11a4:	1f c0       	rjmp	.+62     	; 0x11e4 <MDIO_u8GetPinValue+0x156>
        break;
        case PORTD: local_u8Value=GET_BIT(PIND_REG,A_u8Pin);
    11a6:	e0 e3       	ldi	r30, 0x30	; 48
    11a8:	f0 e0       	ldi	r31, 0x00	; 0
    11aa:	80 81       	ld	r24, Z
    11ac:	48 2f       	mov	r20, r24
    11ae:	50 e0       	ldi	r21, 0x00	; 0
    11b0:	8b 81       	ldd	r24, Y+3	; 0x03
    11b2:	28 2f       	mov	r18, r24
    11b4:	30 e0       	ldi	r19, 0x00	; 0
    11b6:	81 e0       	ldi	r24, 0x01	; 1
    11b8:	90 e0       	ldi	r25, 0x00	; 0
    11ba:	02 c0       	rjmp	.+4      	; 0x11c0 <MDIO_u8GetPinValue+0x132>
    11bc:	88 0f       	add	r24, r24
    11be:	99 1f       	adc	r25, r25
    11c0:	2a 95       	dec	r18
    11c2:	e2 f7       	brpl	.-8      	; 0x11bc <MDIO_u8GetPinValue+0x12e>
    11c4:	80 95       	com	r24
    11c6:	90 95       	com	r25
    11c8:	9a 01       	movw	r18, r20
    11ca:	28 23       	and	r18, r24
    11cc:	39 23       	and	r19, r25
    11ce:	e0 e3       	ldi	r30, 0x30	; 48
    11d0:	f0 e0       	ldi	r31, 0x00	; 0
    11d2:	80 81       	ld	r24, Z
    11d4:	88 2f       	mov	r24, r24
    11d6:	90 e0       	ldi	r25, 0x00	; 0
    11d8:	19 82       	std	Y+1, r1	; 0x01
    11da:	28 17       	cp	r18, r24
    11dc:	39 07       	cpc	r19, r25
    11de:	11 f0       	breq	.+4      	; 0x11e4 <MDIO_u8GetPinValue+0x156>
    11e0:	81 e0       	ldi	r24, 0x01	; 1
    11e2:	89 83       	std	Y+1, r24	; 0x01
        break;
    }
    return local_u8Value;
    11e4:	89 81       	ldd	r24, Y+1	; 0x01
}
    11e6:	0f 90       	pop	r0
    11e8:	0f 90       	pop	r0
    11ea:	0f 90       	pop	r0
    11ec:	0f 90       	pop	r0
    11ee:	0f 90       	pop	r0
    11f0:	cf 91       	pop	r28
    11f2:	df 91       	pop	r29
    11f4:	08 95       	ret

000011f6 <MDIO_voidSetPinValue>:

void MDIO_voidSetPinValue(u8 A_u8Port,u8 A_u8Pin, u8 A_u8Value)
{
    11f6:	df 93       	push	r29
    11f8:	cf 93       	push	r28
    11fa:	cd b7       	in	r28, 0x3d	; 61
    11fc:	de b7       	in	r29, 0x3e	; 62
    11fe:	2d 97       	sbiw	r28, 0x0d	; 13
    1200:	0f b6       	in	r0, 0x3f	; 63
    1202:	f8 94       	cli
    1204:	de bf       	out	0x3e, r29	; 62
    1206:	0f be       	out	0x3f, r0	; 63
    1208:	cd bf       	out	0x3d, r28	; 61
    120a:	89 83       	std	Y+1, r24	; 0x01
    120c:	6a 83       	std	Y+2, r22	; 0x02
    120e:	4b 83       	std	Y+3, r20	; 0x03
    switch(A_u8Port)
    1210:	89 81       	ldd	r24, Y+1	; 0x01
    1212:	28 2f       	mov	r18, r24
    1214:	30 e0       	ldi	r19, 0x00	; 0
    1216:	3d 87       	std	Y+13, r19	; 0x0d
    1218:	2c 87       	std	Y+12, r18	; 0x0c
    121a:	8c 85       	ldd	r24, Y+12	; 0x0c
    121c:	9d 85       	ldd	r25, Y+13	; 0x0d
    121e:	81 30       	cpi	r24, 0x01	; 1
    1220:	91 05       	cpc	r25, r1
    1222:	09 f4       	brne	.+2      	; 0x1226 <MDIO_voidSetPinValue+0x30>
    1224:	4f c0       	rjmp	.+158    	; 0x12c4 <MDIO_voidSetPinValue+0xce>
    1226:	2c 85       	ldd	r18, Y+12	; 0x0c
    1228:	3d 85       	ldd	r19, Y+13	; 0x0d
    122a:	22 30       	cpi	r18, 0x02	; 2
    122c:	31 05       	cpc	r19, r1
    122e:	2c f4       	brge	.+10     	; 0x123a <MDIO_voidSetPinValue+0x44>
    1230:	8c 85       	ldd	r24, Y+12	; 0x0c
    1232:	9d 85       	ldd	r25, Y+13	; 0x0d
    1234:	00 97       	sbiw	r24, 0x00	; 0
    1236:	71 f0       	breq	.+28     	; 0x1254 <MDIO_voidSetPinValue+0x5e>
    1238:	eb c0       	rjmp	.+470    	; 0x1410 <MDIO_voidSetPinValue+0x21a>
    123a:	2c 85       	ldd	r18, Y+12	; 0x0c
    123c:	3d 85       	ldd	r19, Y+13	; 0x0d
    123e:	22 30       	cpi	r18, 0x02	; 2
    1240:	31 05       	cpc	r19, r1
    1242:	09 f4       	brne	.+2      	; 0x1246 <MDIO_voidSetPinValue+0x50>
    1244:	77 c0       	rjmp	.+238    	; 0x1334 <MDIO_voidSetPinValue+0x13e>
    1246:	8c 85       	ldd	r24, Y+12	; 0x0c
    1248:	9d 85       	ldd	r25, Y+13	; 0x0d
    124a:	83 30       	cpi	r24, 0x03	; 3
    124c:	91 05       	cpc	r25, r1
    124e:	09 f4       	brne	.+2      	; 0x1252 <MDIO_voidSetPinValue+0x5c>
    1250:	a9 c0       	rjmp	.+338    	; 0x13a4 <MDIO_voidSetPinValue+0x1ae>
    1252:	de c0       	rjmp	.+444    	; 0x1410 <MDIO_voidSetPinValue+0x21a>
    {
        case PORTA:
        switch (A_u8Value)
    1254:	8b 81       	ldd	r24, Y+3	; 0x03
    1256:	28 2f       	mov	r18, r24
    1258:	30 e0       	ldi	r19, 0x00	; 0
    125a:	3b 87       	std	Y+11, r19	; 0x0b
    125c:	2a 87       	std	Y+10, r18	; 0x0a
    125e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1260:	9b 85       	ldd	r25, Y+11	; 0x0b
    1262:	00 97       	sbiw	r24, 0x00	; 0
    1264:	d1 f0       	breq	.+52     	; 0x129a <MDIO_voidSetPinValue+0xa4>
    1266:	2a 85       	ldd	r18, Y+10	; 0x0a
    1268:	3b 85       	ldd	r19, Y+11	; 0x0b
    126a:	21 30       	cpi	r18, 0x01	; 1
    126c:	31 05       	cpc	r19, r1
    126e:	09 f0       	breq	.+2      	; 0x1272 <MDIO_voidSetPinValue+0x7c>
    1270:	cf c0       	rjmp	.+414    	; 0x1410 <MDIO_voidSetPinValue+0x21a>
        {
            case PIN_HIGH: SET_BIT(PORTA_REG,A_u8Pin);
    1272:	ab e3       	ldi	r26, 0x3B	; 59
    1274:	b0 e0       	ldi	r27, 0x00	; 0
    1276:	eb e3       	ldi	r30, 0x3B	; 59
    1278:	f0 e0       	ldi	r31, 0x00	; 0
    127a:	80 81       	ld	r24, Z
    127c:	48 2f       	mov	r20, r24
    127e:	8a 81       	ldd	r24, Y+2	; 0x02
    1280:	28 2f       	mov	r18, r24
    1282:	30 e0       	ldi	r19, 0x00	; 0
    1284:	81 e0       	ldi	r24, 0x01	; 1
    1286:	90 e0       	ldi	r25, 0x00	; 0
    1288:	02 2e       	mov	r0, r18
    128a:	02 c0       	rjmp	.+4      	; 0x1290 <MDIO_voidSetPinValue+0x9a>
    128c:	88 0f       	add	r24, r24
    128e:	99 1f       	adc	r25, r25
    1290:	0a 94       	dec	r0
    1292:	e2 f7       	brpl	.-8      	; 0x128c <MDIO_voidSetPinValue+0x96>
    1294:	84 2b       	or	r24, r20
    1296:	8c 93       	st	X, r24
    1298:	bb c0       	rjmp	.+374    	; 0x1410 <MDIO_voidSetPinValue+0x21a>
            break;

            case PIN_LOW: CLR_BIT(PORTA_REG,A_u8Pin);
    129a:	ab e3       	ldi	r26, 0x3B	; 59
    129c:	b0 e0       	ldi	r27, 0x00	; 0
    129e:	eb e3       	ldi	r30, 0x3B	; 59
    12a0:	f0 e0       	ldi	r31, 0x00	; 0
    12a2:	80 81       	ld	r24, Z
    12a4:	48 2f       	mov	r20, r24
    12a6:	8a 81       	ldd	r24, Y+2	; 0x02
    12a8:	28 2f       	mov	r18, r24
    12aa:	30 e0       	ldi	r19, 0x00	; 0
    12ac:	81 e0       	ldi	r24, 0x01	; 1
    12ae:	90 e0       	ldi	r25, 0x00	; 0
    12b0:	02 2e       	mov	r0, r18
    12b2:	02 c0       	rjmp	.+4      	; 0x12b8 <MDIO_voidSetPinValue+0xc2>
    12b4:	88 0f       	add	r24, r24
    12b6:	99 1f       	adc	r25, r25
    12b8:	0a 94       	dec	r0
    12ba:	e2 f7       	brpl	.-8      	; 0x12b4 <MDIO_voidSetPinValue+0xbe>
    12bc:	80 95       	com	r24
    12be:	84 23       	and	r24, r20
    12c0:	8c 93       	st	X, r24
    12c2:	a6 c0       	rjmp	.+332    	; 0x1410 <MDIO_voidSetPinValue+0x21a>
            break;
        };
        break;

        case PORTB:
        switch (A_u8Value)
    12c4:	8b 81       	ldd	r24, Y+3	; 0x03
    12c6:	28 2f       	mov	r18, r24
    12c8:	30 e0       	ldi	r19, 0x00	; 0
    12ca:	39 87       	std	Y+9, r19	; 0x09
    12cc:	28 87       	std	Y+8, r18	; 0x08
    12ce:	88 85       	ldd	r24, Y+8	; 0x08
    12d0:	99 85       	ldd	r25, Y+9	; 0x09
    12d2:	00 97       	sbiw	r24, 0x00	; 0
    12d4:	d1 f0       	breq	.+52     	; 0x130a <MDIO_voidSetPinValue+0x114>
    12d6:	28 85       	ldd	r18, Y+8	; 0x08
    12d8:	39 85       	ldd	r19, Y+9	; 0x09
    12da:	21 30       	cpi	r18, 0x01	; 1
    12dc:	31 05       	cpc	r19, r1
    12de:	09 f0       	breq	.+2      	; 0x12e2 <MDIO_voidSetPinValue+0xec>
    12e0:	97 c0       	rjmp	.+302    	; 0x1410 <MDIO_voidSetPinValue+0x21a>
        {
            case PIN_HIGH: SET_BIT(PORTB_REG,A_u8Pin);
    12e2:	a8 e3       	ldi	r26, 0x38	; 56
    12e4:	b0 e0       	ldi	r27, 0x00	; 0
    12e6:	e8 e3       	ldi	r30, 0x38	; 56
    12e8:	f0 e0       	ldi	r31, 0x00	; 0
    12ea:	80 81       	ld	r24, Z
    12ec:	48 2f       	mov	r20, r24
    12ee:	8a 81       	ldd	r24, Y+2	; 0x02
    12f0:	28 2f       	mov	r18, r24
    12f2:	30 e0       	ldi	r19, 0x00	; 0
    12f4:	81 e0       	ldi	r24, 0x01	; 1
    12f6:	90 e0       	ldi	r25, 0x00	; 0
    12f8:	02 2e       	mov	r0, r18
    12fa:	02 c0       	rjmp	.+4      	; 0x1300 <MDIO_voidSetPinValue+0x10a>
    12fc:	88 0f       	add	r24, r24
    12fe:	99 1f       	adc	r25, r25
    1300:	0a 94       	dec	r0
    1302:	e2 f7       	brpl	.-8      	; 0x12fc <MDIO_voidSetPinValue+0x106>
    1304:	84 2b       	or	r24, r20
    1306:	8c 93       	st	X, r24
    1308:	83 c0       	rjmp	.+262    	; 0x1410 <MDIO_voidSetPinValue+0x21a>
            break;

            case PIN_LOW: CLR_BIT(PORTB_REG,A_u8Pin);
    130a:	a8 e3       	ldi	r26, 0x38	; 56
    130c:	b0 e0       	ldi	r27, 0x00	; 0
    130e:	e8 e3       	ldi	r30, 0x38	; 56
    1310:	f0 e0       	ldi	r31, 0x00	; 0
    1312:	80 81       	ld	r24, Z
    1314:	48 2f       	mov	r20, r24
    1316:	8a 81       	ldd	r24, Y+2	; 0x02
    1318:	28 2f       	mov	r18, r24
    131a:	30 e0       	ldi	r19, 0x00	; 0
    131c:	81 e0       	ldi	r24, 0x01	; 1
    131e:	90 e0       	ldi	r25, 0x00	; 0
    1320:	02 2e       	mov	r0, r18
    1322:	02 c0       	rjmp	.+4      	; 0x1328 <MDIO_voidSetPinValue+0x132>
    1324:	88 0f       	add	r24, r24
    1326:	99 1f       	adc	r25, r25
    1328:	0a 94       	dec	r0
    132a:	e2 f7       	brpl	.-8      	; 0x1324 <MDIO_voidSetPinValue+0x12e>
    132c:	80 95       	com	r24
    132e:	84 23       	and	r24, r20
    1330:	8c 93       	st	X, r24
    1332:	6e c0       	rjmp	.+220    	; 0x1410 <MDIO_voidSetPinValue+0x21a>
            break;
        };
        break;

        case PORTC:
        switch (A_u8Value)
    1334:	8b 81       	ldd	r24, Y+3	; 0x03
    1336:	28 2f       	mov	r18, r24
    1338:	30 e0       	ldi	r19, 0x00	; 0
    133a:	3f 83       	std	Y+7, r19	; 0x07
    133c:	2e 83       	std	Y+6, r18	; 0x06
    133e:	8e 81       	ldd	r24, Y+6	; 0x06
    1340:	9f 81       	ldd	r25, Y+7	; 0x07
    1342:	00 97       	sbiw	r24, 0x00	; 0
    1344:	d1 f0       	breq	.+52     	; 0x137a <MDIO_voidSetPinValue+0x184>
    1346:	2e 81       	ldd	r18, Y+6	; 0x06
    1348:	3f 81       	ldd	r19, Y+7	; 0x07
    134a:	21 30       	cpi	r18, 0x01	; 1
    134c:	31 05       	cpc	r19, r1
    134e:	09 f0       	breq	.+2      	; 0x1352 <MDIO_voidSetPinValue+0x15c>
    1350:	5f c0       	rjmp	.+190    	; 0x1410 <MDIO_voidSetPinValue+0x21a>
        {
            case PIN_HIGH: SET_BIT(PORTC_REG,A_u8Pin);
    1352:	a5 e3       	ldi	r26, 0x35	; 53
    1354:	b0 e0       	ldi	r27, 0x00	; 0
    1356:	e5 e3       	ldi	r30, 0x35	; 53
    1358:	f0 e0       	ldi	r31, 0x00	; 0
    135a:	80 81       	ld	r24, Z
    135c:	48 2f       	mov	r20, r24
    135e:	8a 81       	ldd	r24, Y+2	; 0x02
    1360:	28 2f       	mov	r18, r24
    1362:	30 e0       	ldi	r19, 0x00	; 0
    1364:	81 e0       	ldi	r24, 0x01	; 1
    1366:	90 e0       	ldi	r25, 0x00	; 0
    1368:	02 2e       	mov	r0, r18
    136a:	02 c0       	rjmp	.+4      	; 0x1370 <MDIO_voidSetPinValue+0x17a>
    136c:	88 0f       	add	r24, r24
    136e:	99 1f       	adc	r25, r25
    1370:	0a 94       	dec	r0
    1372:	e2 f7       	brpl	.-8      	; 0x136c <MDIO_voidSetPinValue+0x176>
    1374:	84 2b       	or	r24, r20
    1376:	8c 93       	st	X, r24
    1378:	4b c0       	rjmp	.+150    	; 0x1410 <MDIO_voidSetPinValue+0x21a>
            break;

            case PIN_LOW: CLR_BIT(PORTC_REG,A_u8Pin);
    137a:	a5 e3       	ldi	r26, 0x35	; 53
    137c:	b0 e0       	ldi	r27, 0x00	; 0
    137e:	e5 e3       	ldi	r30, 0x35	; 53
    1380:	f0 e0       	ldi	r31, 0x00	; 0
    1382:	80 81       	ld	r24, Z
    1384:	48 2f       	mov	r20, r24
    1386:	8a 81       	ldd	r24, Y+2	; 0x02
    1388:	28 2f       	mov	r18, r24
    138a:	30 e0       	ldi	r19, 0x00	; 0
    138c:	81 e0       	ldi	r24, 0x01	; 1
    138e:	90 e0       	ldi	r25, 0x00	; 0
    1390:	02 2e       	mov	r0, r18
    1392:	02 c0       	rjmp	.+4      	; 0x1398 <MDIO_voidSetPinValue+0x1a2>
    1394:	88 0f       	add	r24, r24
    1396:	99 1f       	adc	r25, r25
    1398:	0a 94       	dec	r0
    139a:	e2 f7       	brpl	.-8      	; 0x1394 <MDIO_voidSetPinValue+0x19e>
    139c:	80 95       	com	r24
    139e:	84 23       	and	r24, r20
    13a0:	8c 93       	st	X, r24
    13a2:	36 c0       	rjmp	.+108    	; 0x1410 <MDIO_voidSetPinValue+0x21a>
            break;
        };
        break;

        case PORTD:
        switch (A_u8Value)
    13a4:	8b 81       	ldd	r24, Y+3	; 0x03
    13a6:	28 2f       	mov	r18, r24
    13a8:	30 e0       	ldi	r19, 0x00	; 0
    13aa:	3d 83       	std	Y+5, r19	; 0x05
    13ac:	2c 83       	std	Y+4, r18	; 0x04
    13ae:	8c 81       	ldd	r24, Y+4	; 0x04
    13b0:	9d 81       	ldd	r25, Y+5	; 0x05
    13b2:	00 97       	sbiw	r24, 0x00	; 0
    13b4:	c9 f0       	breq	.+50     	; 0x13e8 <MDIO_voidSetPinValue+0x1f2>
    13b6:	2c 81       	ldd	r18, Y+4	; 0x04
    13b8:	3d 81       	ldd	r19, Y+5	; 0x05
    13ba:	21 30       	cpi	r18, 0x01	; 1
    13bc:	31 05       	cpc	r19, r1
    13be:	41 f5       	brne	.+80     	; 0x1410 <MDIO_voidSetPinValue+0x21a>
        {
            case PIN_HIGH: SET_BIT(PORTD_REG,A_u8Pin);
    13c0:	a2 e3       	ldi	r26, 0x32	; 50
    13c2:	b0 e0       	ldi	r27, 0x00	; 0
    13c4:	e2 e3       	ldi	r30, 0x32	; 50
    13c6:	f0 e0       	ldi	r31, 0x00	; 0
    13c8:	80 81       	ld	r24, Z
    13ca:	48 2f       	mov	r20, r24
    13cc:	8a 81       	ldd	r24, Y+2	; 0x02
    13ce:	28 2f       	mov	r18, r24
    13d0:	30 e0       	ldi	r19, 0x00	; 0
    13d2:	81 e0       	ldi	r24, 0x01	; 1
    13d4:	90 e0       	ldi	r25, 0x00	; 0
    13d6:	02 2e       	mov	r0, r18
    13d8:	02 c0       	rjmp	.+4      	; 0x13de <MDIO_voidSetPinValue+0x1e8>
    13da:	88 0f       	add	r24, r24
    13dc:	99 1f       	adc	r25, r25
    13de:	0a 94       	dec	r0
    13e0:	e2 f7       	brpl	.-8      	; 0x13da <MDIO_voidSetPinValue+0x1e4>
    13e2:	84 2b       	or	r24, r20
    13e4:	8c 93       	st	X, r24
    13e6:	14 c0       	rjmp	.+40     	; 0x1410 <MDIO_voidSetPinValue+0x21a>
            break;

            case PIN_LOW: CLR_BIT(PORTD_REG,A_u8Pin);
    13e8:	a2 e3       	ldi	r26, 0x32	; 50
    13ea:	b0 e0       	ldi	r27, 0x00	; 0
    13ec:	e2 e3       	ldi	r30, 0x32	; 50
    13ee:	f0 e0       	ldi	r31, 0x00	; 0
    13f0:	80 81       	ld	r24, Z
    13f2:	48 2f       	mov	r20, r24
    13f4:	8a 81       	ldd	r24, Y+2	; 0x02
    13f6:	28 2f       	mov	r18, r24
    13f8:	30 e0       	ldi	r19, 0x00	; 0
    13fa:	81 e0       	ldi	r24, 0x01	; 1
    13fc:	90 e0       	ldi	r25, 0x00	; 0
    13fe:	02 2e       	mov	r0, r18
    1400:	02 c0       	rjmp	.+4      	; 0x1406 <MDIO_voidSetPinValue+0x210>
    1402:	88 0f       	add	r24, r24
    1404:	99 1f       	adc	r25, r25
    1406:	0a 94       	dec	r0
    1408:	e2 f7       	brpl	.-8      	; 0x1402 <MDIO_voidSetPinValue+0x20c>
    140a:	80 95       	com	r24
    140c:	84 23       	and	r24, r20
    140e:	8c 93       	st	X, r24
            break;
        };
        break;
    }
}
    1410:	2d 96       	adiw	r28, 0x0d	; 13
    1412:	0f b6       	in	r0, 0x3f	; 63
    1414:	f8 94       	cli
    1416:	de bf       	out	0x3e, r29	; 62
    1418:	0f be       	out	0x3f, r0	; 63
    141a:	cd bf       	out	0x3d, r28	; 61
    141c:	cf 91       	pop	r28
    141e:	df 91       	pop	r29
    1420:	08 95       	ret

00001422 <MDIO_voidSetPinDirection>:

void MDIO_voidSetPinDirection(u8 A_u8Port,u8 A_u8Pin, u8 A_u8Value)
{
    1422:	df 93       	push	r29
    1424:	cf 93       	push	r28
    1426:	cd b7       	in	r28, 0x3d	; 61
    1428:	de b7       	in	r29, 0x3e	; 62
    142a:	2d 97       	sbiw	r28, 0x0d	; 13
    142c:	0f b6       	in	r0, 0x3f	; 63
    142e:	f8 94       	cli
    1430:	de bf       	out	0x3e, r29	; 62
    1432:	0f be       	out	0x3f, r0	; 63
    1434:	cd bf       	out	0x3d, r28	; 61
    1436:	89 83       	std	Y+1, r24	; 0x01
    1438:	6a 83       	std	Y+2, r22	; 0x02
    143a:	4b 83       	std	Y+3, r20	; 0x03
    switch(A_u8Port)
    143c:	89 81       	ldd	r24, Y+1	; 0x01
    143e:	28 2f       	mov	r18, r24
    1440:	30 e0       	ldi	r19, 0x00	; 0
    1442:	3d 87       	std	Y+13, r19	; 0x0d
    1444:	2c 87       	std	Y+12, r18	; 0x0c
    1446:	8c 85       	ldd	r24, Y+12	; 0x0c
    1448:	9d 85       	ldd	r25, Y+13	; 0x0d
    144a:	81 30       	cpi	r24, 0x01	; 1
    144c:	91 05       	cpc	r25, r1
    144e:	09 f4       	brne	.+2      	; 0x1452 <MDIO_voidSetPinDirection+0x30>
    1450:	4f c0       	rjmp	.+158    	; 0x14f0 <MDIO_voidSetPinDirection+0xce>
    1452:	2c 85       	ldd	r18, Y+12	; 0x0c
    1454:	3d 85       	ldd	r19, Y+13	; 0x0d
    1456:	22 30       	cpi	r18, 0x02	; 2
    1458:	31 05       	cpc	r19, r1
    145a:	2c f4       	brge	.+10     	; 0x1466 <MDIO_voidSetPinDirection+0x44>
    145c:	8c 85       	ldd	r24, Y+12	; 0x0c
    145e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1460:	00 97       	sbiw	r24, 0x00	; 0
    1462:	71 f0       	breq	.+28     	; 0x1480 <MDIO_voidSetPinDirection+0x5e>
    1464:	eb c0       	rjmp	.+470    	; 0x163c <MDIO_voidSetPinDirection+0x21a>
    1466:	2c 85       	ldd	r18, Y+12	; 0x0c
    1468:	3d 85       	ldd	r19, Y+13	; 0x0d
    146a:	22 30       	cpi	r18, 0x02	; 2
    146c:	31 05       	cpc	r19, r1
    146e:	09 f4       	brne	.+2      	; 0x1472 <MDIO_voidSetPinDirection+0x50>
    1470:	77 c0       	rjmp	.+238    	; 0x1560 <MDIO_voidSetPinDirection+0x13e>
    1472:	8c 85       	ldd	r24, Y+12	; 0x0c
    1474:	9d 85       	ldd	r25, Y+13	; 0x0d
    1476:	83 30       	cpi	r24, 0x03	; 3
    1478:	91 05       	cpc	r25, r1
    147a:	09 f4       	brne	.+2      	; 0x147e <MDIO_voidSetPinDirection+0x5c>
    147c:	a9 c0       	rjmp	.+338    	; 0x15d0 <MDIO_voidSetPinDirection+0x1ae>
    147e:	de c0       	rjmp	.+444    	; 0x163c <MDIO_voidSetPinDirection+0x21a>
    {
        case PORTA:
        switch (A_u8Value)
    1480:	8b 81       	ldd	r24, Y+3	; 0x03
    1482:	28 2f       	mov	r18, r24
    1484:	30 e0       	ldi	r19, 0x00	; 0
    1486:	3b 87       	std	Y+11, r19	; 0x0b
    1488:	2a 87       	std	Y+10, r18	; 0x0a
    148a:	8a 85       	ldd	r24, Y+10	; 0x0a
    148c:	9b 85       	ldd	r25, Y+11	; 0x0b
    148e:	00 97       	sbiw	r24, 0x00	; 0
    1490:	d1 f0       	breq	.+52     	; 0x14c6 <MDIO_voidSetPinDirection+0xa4>
    1492:	2a 85       	ldd	r18, Y+10	; 0x0a
    1494:	3b 85       	ldd	r19, Y+11	; 0x0b
    1496:	21 30       	cpi	r18, 0x01	; 1
    1498:	31 05       	cpc	r19, r1
    149a:	09 f0       	breq	.+2      	; 0x149e <MDIO_voidSetPinDirection+0x7c>
    149c:	cf c0       	rjmp	.+414    	; 0x163c <MDIO_voidSetPinDirection+0x21a>
        {
            case PIN_OUTPUT: SET_BIT(DDRA_REG,A_u8Pin);
    149e:	aa e3       	ldi	r26, 0x3A	; 58
    14a0:	b0 e0       	ldi	r27, 0x00	; 0
    14a2:	ea e3       	ldi	r30, 0x3A	; 58
    14a4:	f0 e0       	ldi	r31, 0x00	; 0
    14a6:	80 81       	ld	r24, Z
    14a8:	48 2f       	mov	r20, r24
    14aa:	8a 81       	ldd	r24, Y+2	; 0x02
    14ac:	28 2f       	mov	r18, r24
    14ae:	30 e0       	ldi	r19, 0x00	; 0
    14b0:	81 e0       	ldi	r24, 0x01	; 1
    14b2:	90 e0       	ldi	r25, 0x00	; 0
    14b4:	02 2e       	mov	r0, r18
    14b6:	02 c0       	rjmp	.+4      	; 0x14bc <MDIO_voidSetPinDirection+0x9a>
    14b8:	88 0f       	add	r24, r24
    14ba:	99 1f       	adc	r25, r25
    14bc:	0a 94       	dec	r0
    14be:	e2 f7       	brpl	.-8      	; 0x14b8 <MDIO_voidSetPinDirection+0x96>
    14c0:	84 2b       	or	r24, r20
    14c2:	8c 93       	st	X, r24
    14c4:	bb c0       	rjmp	.+374    	; 0x163c <MDIO_voidSetPinDirection+0x21a>
            break;

            case PIN_INPUT: CLR_BIT(DDRA_REG,A_u8Pin);
    14c6:	aa e3       	ldi	r26, 0x3A	; 58
    14c8:	b0 e0       	ldi	r27, 0x00	; 0
    14ca:	ea e3       	ldi	r30, 0x3A	; 58
    14cc:	f0 e0       	ldi	r31, 0x00	; 0
    14ce:	80 81       	ld	r24, Z
    14d0:	48 2f       	mov	r20, r24
    14d2:	8a 81       	ldd	r24, Y+2	; 0x02
    14d4:	28 2f       	mov	r18, r24
    14d6:	30 e0       	ldi	r19, 0x00	; 0
    14d8:	81 e0       	ldi	r24, 0x01	; 1
    14da:	90 e0       	ldi	r25, 0x00	; 0
    14dc:	02 2e       	mov	r0, r18
    14de:	02 c0       	rjmp	.+4      	; 0x14e4 <MDIO_voidSetPinDirection+0xc2>
    14e0:	88 0f       	add	r24, r24
    14e2:	99 1f       	adc	r25, r25
    14e4:	0a 94       	dec	r0
    14e6:	e2 f7       	brpl	.-8      	; 0x14e0 <MDIO_voidSetPinDirection+0xbe>
    14e8:	80 95       	com	r24
    14ea:	84 23       	and	r24, r20
    14ec:	8c 93       	st	X, r24
    14ee:	a6 c0       	rjmp	.+332    	; 0x163c <MDIO_voidSetPinDirection+0x21a>
            break;
        };
        break;

        case PORTB:
        switch (A_u8Value)
    14f0:	8b 81       	ldd	r24, Y+3	; 0x03
    14f2:	28 2f       	mov	r18, r24
    14f4:	30 e0       	ldi	r19, 0x00	; 0
    14f6:	39 87       	std	Y+9, r19	; 0x09
    14f8:	28 87       	std	Y+8, r18	; 0x08
    14fa:	88 85       	ldd	r24, Y+8	; 0x08
    14fc:	99 85       	ldd	r25, Y+9	; 0x09
    14fe:	00 97       	sbiw	r24, 0x00	; 0
    1500:	d1 f0       	breq	.+52     	; 0x1536 <MDIO_voidSetPinDirection+0x114>
    1502:	28 85       	ldd	r18, Y+8	; 0x08
    1504:	39 85       	ldd	r19, Y+9	; 0x09
    1506:	21 30       	cpi	r18, 0x01	; 1
    1508:	31 05       	cpc	r19, r1
    150a:	09 f0       	breq	.+2      	; 0x150e <MDIO_voidSetPinDirection+0xec>
    150c:	97 c0       	rjmp	.+302    	; 0x163c <MDIO_voidSetPinDirection+0x21a>
        {
            case PIN_OUTPUT: SET_BIT(DDRB_REG,A_u8Pin);
    150e:	a7 e3       	ldi	r26, 0x37	; 55
    1510:	b0 e0       	ldi	r27, 0x00	; 0
    1512:	e7 e3       	ldi	r30, 0x37	; 55
    1514:	f0 e0       	ldi	r31, 0x00	; 0
    1516:	80 81       	ld	r24, Z
    1518:	48 2f       	mov	r20, r24
    151a:	8a 81       	ldd	r24, Y+2	; 0x02
    151c:	28 2f       	mov	r18, r24
    151e:	30 e0       	ldi	r19, 0x00	; 0
    1520:	81 e0       	ldi	r24, 0x01	; 1
    1522:	90 e0       	ldi	r25, 0x00	; 0
    1524:	02 2e       	mov	r0, r18
    1526:	02 c0       	rjmp	.+4      	; 0x152c <MDIO_voidSetPinDirection+0x10a>
    1528:	88 0f       	add	r24, r24
    152a:	99 1f       	adc	r25, r25
    152c:	0a 94       	dec	r0
    152e:	e2 f7       	brpl	.-8      	; 0x1528 <MDIO_voidSetPinDirection+0x106>
    1530:	84 2b       	or	r24, r20
    1532:	8c 93       	st	X, r24
    1534:	83 c0       	rjmp	.+262    	; 0x163c <MDIO_voidSetPinDirection+0x21a>
            break;

            case PIN_INPUT: CLR_BIT(DDRB_REG,A_u8Pin);
    1536:	a7 e3       	ldi	r26, 0x37	; 55
    1538:	b0 e0       	ldi	r27, 0x00	; 0
    153a:	e7 e3       	ldi	r30, 0x37	; 55
    153c:	f0 e0       	ldi	r31, 0x00	; 0
    153e:	80 81       	ld	r24, Z
    1540:	48 2f       	mov	r20, r24
    1542:	8a 81       	ldd	r24, Y+2	; 0x02
    1544:	28 2f       	mov	r18, r24
    1546:	30 e0       	ldi	r19, 0x00	; 0
    1548:	81 e0       	ldi	r24, 0x01	; 1
    154a:	90 e0       	ldi	r25, 0x00	; 0
    154c:	02 2e       	mov	r0, r18
    154e:	02 c0       	rjmp	.+4      	; 0x1554 <MDIO_voidSetPinDirection+0x132>
    1550:	88 0f       	add	r24, r24
    1552:	99 1f       	adc	r25, r25
    1554:	0a 94       	dec	r0
    1556:	e2 f7       	brpl	.-8      	; 0x1550 <MDIO_voidSetPinDirection+0x12e>
    1558:	80 95       	com	r24
    155a:	84 23       	and	r24, r20
    155c:	8c 93       	st	X, r24
    155e:	6e c0       	rjmp	.+220    	; 0x163c <MDIO_voidSetPinDirection+0x21a>
            break;
        };
        break;

        case PORTC:
        switch (A_u8Value)
    1560:	8b 81       	ldd	r24, Y+3	; 0x03
    1562:	28 2f       	mov	r18, r24
    1564:	30 e0       	ldi	r19, 0x00	; 0
    1566:	3f 83       	std	Y+7, r19	; 0x07
    1568:	2e 83       	std	Y+6, r18	; 0x06
    156a:	8e 81       	ldd	r24, Y+6	; 0x06
    156c:	9f 81       	ldd	r25, Y+7	; 0x07
    156e:	00 97       	sbiw	r24, 0x00	; 0
    1570:	d1 f0       	breq	.+52     	; 0x15a6 <MDIO_voidSetPinDirection+0x184>
    1572:	2e 81       	ldd	r18, Y+6	; 0x06
    1574:	3f 81       	ldd	r19, Y+7	; 0x07
    1576:	21 30       	cpi	r18, 0x01	; 1
    1578:	31 05       	cpc	r19, r1
    157a:	09 f0       	breq	.+2      	; 0x157e <MDIO_voidSetPinDirection+0x15c>
    157c:	5f c0       	rjmp	.+190    	; 0x163c <MDIO_voidSetPinDirection+0x21a>
        {
            case PIN_OUTPUT: SET_BIT(DDRC_REG,A_u8Pin);
    157e:	a4 e3       	ldi	r26, 0x34	; 52
    1580:	b0 e0       	ldi	r27, 0x00	; 0
    1582:	e4 e3       	ldi	r30, 0x34	; 52
    1584:	f0 e0       	ldi	r31, 0x00	; 0
    1586:	80 81       	ld	r24, Z
    1588:	48 2f       	mov	r20, r24
    158a:	8a 81       	ldd	r24, Y+2	; 0x02
    158c:	28 2f       	mov	r18, r24
    158e:	30 e0       	ldi	r19, 0x00	; 0
    1590:	81 e0       	ldi	r24, 0x01	; 1
    1592:	90 e0       	ldi	r25, 0x00	; 0
    1594:	02 2e       	mov	r0, r18
    1596:	02 c0       	rjmp	.+4      	; 0x159c <MDIO_voidSetPinDirection+0x17a>
    1598:	88 0f       	add	r24, r24
    159a:	99 1f       	adc	r25, r25
    159c:	0a 94       	dec	r0
    159e:	e2 f7       	brpl	.-8      	; 0x1598 <MDIO_voidSetPinDirection+0x176>
    15a0:	84 2b       	or	r24, r20
    15a2:	8c 93       	st	X, r24
    15a4:	4b c0       	rjmp	.+150    	; 0x163c <MDIO_voidSetPinDirection+0x21a>
            break;

            case PIN_INPUT: CLR_BIT(DDRC_REG,A_u8Pin);
    15a6:	a4 e3       	ldi	r26, 0x34	; 52
    15a8:	b0 e0       	ldi	r27, 0x00	; 0
    15aa:	e4 e3       	ldi	r30, 0x34	; 52
    15ac:	f0 e0       	ldi	r31, 0x00	; 0
    15ae:	80 81       	ld	r24, Z
    15b0:	48 2f       	mov	r20, r24
    15b2:	8a 81       	ldd	r24, Y+2	; 0x02
    15b4:	28 2f       	mov	r18, r24
    15b6:	30 e0       	ldi	r19, 0x00	; 0
    15b8:	81 e0       	ldi	r24, 0x01	; 1
    15ba:	90 e0       	ldi	r25, 0x00	; 0
    15bc:	02 2e       	mov	r0, r18
    15be:	02 c0       	rjmp	.+4      	; 0x15c4 <MDIO_voidSetPinDirection+0x1a2>
    15c0:	88 0f       	add	r24, r24
    15c2:	99 1f       	adc	r25, r25
    15c4:	0a 94       	dec	r0
    15c6:	e2 f7       	brpl	.-8      	; 0x15c0 <MDIO_voidSetPinDirection+0x19e>
    15c8:	80 95       	com	r24
    15ca:	84 23       	and	r24, r20
    15cc:	8c 93       	st	X, r24
    15ce:	36 c0       	rjmp	.+108    	; 0x163c <MDIO_voidSetPinDirection+0x21a>
            break;
        };
        break;

        case PORTD:
        switch (A_u8Value)
    15d0:	8b 81       	ldd	r24, Y+3	; 0x03
    15d2:	28 2f       	mov	r18, r24
    15d4:	30 e0       	ldi	r19, 0x00	; 0
    15d6:	3d 83       	std	Y+5, r19	; 0x05
    15d8:	2c 83       	std	Y+4, r18	; 0x04
    15da:	8c 81       	ldd	r24, Y+4	; 0x04
    15dc:	9d 81       	ldd	r25, Y+5	; 0x05
    15de:	00 97       	sbiw	r24, 0x00	; 0
    15e0:	c9 f0       	breq	.+50     	; 0x1614 <MDIO_voidSetPinDirection+0x1f2>
    15e2:	2c 81       	ldd	r18, Y+4	; 0x04
    15e4:	3d 81       	ldd	r19, Y+5	; 0x05
    15e6:	21 30       	cpi	r18, 0x01	; 1
    15e8:	31 05       	cpc	r19, r1
    15ea:	41 f5       	brne	.+80     	; 0x163c <MDIO_voidSetPinDirection+0x21a>
        {
            case PIN_OUTPUT: SET_BIT(DDRD_REG,A_u8Pin);
    15ec:	a1 e3       	ldi	r26, 0x31	; 49
    15ee:	b0 e0       	ldi	r27, 0x00	; 0
    15f0:	e1 e3       	ldi	r30, 0x31	; 49
    15f2:	f0 e0       	ldi	r31, 0x00	; 0
    15f4:	80 81       	ld	r24, Z
    15f6:	48 2f       	mov	r20, r24
    15f8:	8a 81       	ldd	r24, Y+2	; 0x02
    15fa:	28 2f       	mov	r18, r24
    15fc:	30 e0       	ldi	r19, 0x00	; 0
    15fe:	81 e0       	ldi	r24, 0x01	; 1
    1600:	90 e0       	ldi	r25, 0x00	; 0
    1602:	02 2e       	mov	r0, r18
    1604:	02 c0       	rjmp	.+4      	; 0x160a <MDIO_voidSetPinDirection+0x1e8>
    1606:	88 0f       	add	r24, r24
    1608:	99 1f       	adc	r25, r25
    160a:	0a 94       	dec	r0
    160c:	e2 f7       	brpl	.-8      	; 0x1606 <MDIO_voidSetPinDirection+0x1e4>
    160e:	84 2b       	or	r24, r20
    1610:	8c 93       	st	X, r24
    1612:	14 c0       	rjmp	.+40     	; 0x163c <MDIO_voidSetPinDirection+0x21a>
            break;

            case PIN_INPUT: CLR_BIT(DDRD_REG,A_u8Pin);
    1614:	a1 e3       	ldi	r26, 0x31	; 49
    1616:	b0 e0       	ldi	r27, 0x00	; 0
    1618:	e1 e3       	ldi	r30, 0x31	; 49
    161a:	f0 e0       	ldi	r31, 0x00	; 0
    161c:	80 81       	ld	r24, Z
    161e:	48 2f       	mov	r20, r24
    1620:	8a 81       	ldd	r24, Y+2	; 0x02
    1622:	28 2f       	mov	r18, r24
    1624:	30 e0       	ldi	r19, 0x00	; 0
    1626:	81 e0       	ldi	r24, 0x01	; 1
    1628:	90 e0       	ldi	r25, 0x00	; 0
    162a:	02 2e       	mov	r0, r18
    162c:	02 c0       	rjmp	.+4      	; 0x1632 <MDIO_voidSetPinDirection+0x210>
    162e:	88 0f       	add	r24, r24
    1630:	99 1f       	adc	r25, r25
    1632:	0a 94       	dec	r0
    1634:	e2 f7       	brpl	.-8      	; 0x162e <MDIO_voidSetPinDirection+0x20c>
    1636:	80 95       	com	r24
    1638:	84 23       	and	r24, r20
    163a:	8c 93       	st	X, r24
            break;
        };
        break;
    }
}
    163c:	2d 96       	adiw	r28, 0x0d	; 13
    163e:	0f b6       	in	r0, 0x3f	; 63
    1640:	f8 94       	cli
    1642:	de bf       	out	0x3e, r29	; 62
    1644:	0f be       	out	0x3f, r0	; 63
    1646:	cd bf       	out	0x3d, r28	; 61
    1648:	cf 91       	pop	r28
    164a:	df 91       	pop	r29
    164c:	08 95       	ret

0000164e <MDIO_voidSetPortValue>:


void MDIO_voidSetPortValue(u8 A_u8Port,u8 A_u8Value)
{
    164e:	df 93       	push	r29
    1650:	cf 93       	push	r28
    1652:	00 d0       	rcall	.+0      	; 0x1654 <MDIO_voidSetPortValue+0x6>
    1654:	00 d0       	rcall	.+0      	; 0x1656 <MDIO_voidSetPortValue+0x8>
    1656:	cd b7       	in	r28, 0x3d	; 61
    1658:	de b7       	in	r29, 0x3e	; 62
    165a:	89 83       	std	Y+1, r24	; 0x01
    165c:	6a 83       	std	Y+2, r22	; 0x02
    switch(A_u8Port)
    165e:	89 81       	ldd	r24, Y+1	; 0x01
    1660:	28 2f       	mov	r18, r24
    1662:	30 e0       	ldi	r19, 0x00	; 0
    1664:	3c 83       	std	Y+4, r19	; 0x04
    1666:	2b 83       	std	Y+3, r18	; 0x03
    1668:	8b 81       	ldd	r24, Y+3	; 0x03
    166a:	9c 81       	ldd	r25, Y+4	; 0x04
    166c:	81 30       	cpi	r24, 0x01	; 1
    166e:	91 05       	cpc	r25, r1
    1670:	d1 f0       	breq	.+52     	; 0x16a6 <MDIO_voidSetPortValue+0x58>
    1672:	2b 81       	ldd	r18, Y+3	; 0x03
    1674:	3c 81       	ldd	r19, Y+4	; 0x04
    1676:	22 30       	cpi	r18, 0x02	; 2
    1678:	31 05       	cpc	r19, r1
    167a:	2c f4       	brge	.+10     	; 0x1686 <MDIO_voidSetPortValue+0x38>
    167c:	8b 81       	ldd	r24, Y+3	; 0x03
    167e:	9c 81       	ldd	r25, Y+4	; 0x04
    1680:	00 97       	sbiw	r24, 0x00	; 0
    1682:	61 f0       	breq	.+24     	; 0x169c <MDIO_voidSetPortValue+0x4e>
    1684:	1e c0       	rjmp	.+60     	; 0x16c2 <MDIO_voidSetPortValue+0x74>
    1686:	2b 81       	ldd	r18, Y+3	; 0x03
    1688:	3c 81       	ldd	r19, Y+4	; 0x04
    168a:	22 30       	cpi	r18, 0x02	; 2
    168c:	31 05       	cpc	r19, r1
    168e:	81 f0       	breq	.+32     	; 0x16b0 <MDIO_voidSetPortValue+0x62>
    1690:	8b 81       	ldd	r24, Y+3	; 0x03
    1692:	9c 81       	ldd	r25, Y+4	; 0x04
    1694:	83 30       	cpi	r24, 0x03	; 3
    1696:	91 05       	cpc	r25, r1
    1698:	81 f0       	breq	.+32     	; 0x16ba <MDIO_voidSetPortValue+0x6c>
    169a:	13 c0       	rjmp	.+38     	; 0x16c2 <MDIO_voidSetPortValue+0x74>
    {
        case PORTA:PORTA_REG=A_u8Value;
    169c:	eb e3       	ldi	r30, 0x3B	; 59
    169e:	f0 e0       	ldi	r31, 0x00	; 0
    16a0:	8a 81       	ldd	r24, Y+2	; 0x02
    16a2:	80 83       	st	Z, r24
    16a4:	0e c0       	rjmp	.+28     	; 0x16c2 <MDIO_voidSetPortValue+0x74>
        break;
        case PORTB:PORTB_REG=A_u8Value;
    16a6:	e8 e3       	ldi	r30, 0x38	; 56
    16a8:	f0 e0       	ldi	r31, 0x00	; 0
    16aa:	8a 81       	ldd	r24, Y+2	; 0x02
    16ac:	80 83       	st	Z, r24
    16ae:	09 c0       	rjmp	.+18     	; 0x16c2 <MDIO_voidSetPortValue+0x74>
        break;
        case PORTC:PORTC_REG=A_u8Value;
    16b0:	e5 e3       	ldi	r30, 0x35	; 53
    16b2:	f0 e0       	ldi	r31, 0x00	; 0
    16b4:	8a 81       	ldd	r24, Y+2	; 0x02
    16b6:	80 83       	st	Z, r24
    16b8:	04 c0       	rjmp	.+8      	; 0x16c2 <MDIO_voidSetPortValue+0x74>
        break;
        case PORTD:PORTD_REG=A_u8Value;
    16ba:	e2 e3       	ldi	r30, 0x32	; 50
    16bc:	f0 e0       	ldi	r31, 0x00	; 0
    16be:	8a 81       	ldd	r24, Y+2	; 0x02
    16c0:	80 83       	st	Z, r24
        break;
    }
}
    16c2:	0f 90       	pop	r0
    16c4:	0f 90       	pop	r0
    16c6:	0f 90       	pop	r0
    16c8:	0f 90       	pop	r0
    16ca:	cf 91       	pop	r28
    16cc:	df 91       	pop	r29
    16ce:	08 95       	ret

000016d0 <MDIO_voidSetPortDirection>:

void MDIO_voidSetPortDirection(u8 A_u8Port,u8 A_u8Value)
{
    16d0:	df 93       	push	r29
    16d2:	cf 93       	push	r28
    16d4:	00 d0       	rcall	.+0      	; 0x16d6 <MDIO_voidSetPortDirection+0x6>
    16d6:	00 d0       	rcall	.+0      	; 0x16d8 <MDIO_voidSetPortDirection+0x8>
    16d8:	cd b7       	in	r28, 0x3d	; 61
    16da:	de b7       	in	r29, 0x3e	; 62
    16dc:	89 83       	std	Y+1, r24	; 0x01
    16de:	6a 83       	std	Y+2, r22	; 0x02
    switch(A_u8Port)
    16e0:	89 81       	ldd	r24, Y+1	; 0x01
    16e2:	28 2f       	mov	r18, r24
    16e4:	30 e0       	ldi	r19, 0x00	; 0
    16e6:	3c 83       	std	Y+4, r19	; 0x04
    16e8:	2b 83       	std	Y+3, r18	; 0x03
    16ea:	8b 81       	ldd	r24, Y+3	; 0x03
    16ec:	9c 81       	ldd	r25, Y+4	; 0x04
    16ee:	81 30       	cpi	r24, 0x01	; 1
    16f0:	91 05       	cpc	r25, r1
    16f2:	d1 f0       	breq	.+52     	; 0x1728 <MDIO_voidSetPortDirection+0x58>
    16f4:	2b 81       	ldd	r18, Y+3	; 0x03
    16f6:	3c 81       	ldd	r19, Y+4	; 0x04
    16f8:	22 30       	cpi	r18, 0x02	; 2
    16fa:	31 05       	cpc	r19, r1
    16fc:	2c f4       	brge	.+10     	; 0x1708 <MDIO_voidSetPortDirection+0x38>
    16fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1700:	9c 81       	ldd	r25, Y+4	; 0x04
    1702:	00 97       	sbiw	r24, 0x00	; 0
    1704:	61 f0       	breq	.+24     	; 0x171e <MDIO_voidSetPortDirection+0x4e>
    1706:	1e c0       	rjmp	.+60     	; 0x1744 <MDIO_voidSetPortDirection+0x74>
    1708:	2b 81       	ldd	r18, Y+3	; 0x03
    170a:	3c 81       	ldd	r19, Y+4	; 0x04
    170c:	22 30       	cpi	r18, 0x02	; 2
    170e:	31 05       	cpc	r19, r1
    1710:	81 f0       	breq	.+32     	; 0x1732 <MDIO_voidSetPortDirection+0x62>
    1712:	8b 81       	ldd	r24, Y+3	; 0x03
    1714:	9c 81       	ldd	r25, Y+4	; 0x04
    1716:	83 30       	cpi	r24, 0x03	; 3
    1718:	91 05       	cpc	r25, r1
    171a:	81 f0       	breq	.+32     	; 0x173c <MDIO_voidSetPortDirection+0x6c>
    171c:	13 c0       	rjmp	.+38     	; 0x1744 <MDIO_voidSetPortDirection+0x74>
    {
        case PORTA:DDRA_REG=A_u8Value;
    171e:	ea e3       	ldi	r30, 0x3A	; 58
    1720:	f0 e0       	ldi	r31, 0x00	; 0
    1722:	8a 81       	ldd	r24, Y+2	; 0x02
    1724:	80 83       	st	Z, r24
    1726:	0e c0       	rjmp	.+28     	; 0x1744 <MDIO_voidSetPortDirection+0x74>
        break;
        case PORTB:DDRB_REG=A_u8Value;
    1728:	e7 e3       	ldi	r30, 0x37	; 55
    172a:	f0 e0       	ldi	r31, 0x00	; 0
    172c:	8a 81       	ldd	r24, Y+2	; 0x02
    172e:	80 83       	st	Z, r24
    1730:	09 c0       	rjmp	.+18     	; 0x1744 <MDIO_voidSetPortDirection+0x74>
        break;
        case PORTC:DDRC_REG=A_u8Value;
    1732:	e4 e3       	ldi	r30, 0x34	; 52
    1734:	f0 e0       	ldi	r31, 0x00	; 0
    1736:	8a 81       	ldd	r24, Y+2	; 0x02
    1738:	80 83       	st	Z, r24
    173a:	04 c0       	rjmp	.+8      	; 0x1744 <MDIO_voidSetPortDirection+0x74>
        break;
        case PORTD:DDRD_REG=A_u8Value;
    173c:	e1 e3       	ldi	r30, 0x31	; 49
    173e:	f0 e0       	ldi	r31, 0x00	; 0
    1740:	8a 81       	ldd	r24, Y+2	; 0x02
    1742:	80 83       	st	Z, r24
        break;
    }
    1744:	0f 90       	pop	r0
    1746:	0f 90       	pop	r0
    1748:	0f 90       	pop	r0
    174a:	0f 90       	pop	r0
    174c:	cf 91       	pop	r28
    174e:	df 91       	pop	r29
    1750:	08 95       	ret

00001752 <MEXTI_voidConfig>:
static void (*EXTI0_CallBack)(void)=NULLPTR;
static void (*EXTI1_CallBack)(void)=NULLPTR;
static void (*EXTI2_CallBack)(void)=NULLPTR;

void MEXTI_voidConfig(u8 A_u8EXTINo,u8 A_u8SenseMode)
{
    1752:	df 93       	push	r29
    1754:	cf 93       	push	r28
    1756:	00 d0       	rcall	.+0      	; 0x1758 <MEXTI_voidConfig+0x6>
    1758:	00 d0       	rcall	.+0      	; 0x175a <MEXTI_voidConfig+0x8>
    175a:	00 d0       	rcall	.+0      	; 0x175c <MEXTI_voidConfig+0xa>
    175c:	cd b7       	in	r28, 0x3d	; 61
    175e:	de b7       	in	r29, 0x3e	; 62
    1760:	89 83       	std	Y+1, r24	; 0x01
    1762:	6a 83       	std	Y+2, r22	; 0x02
    if(A_u8SenseMode <4)
    1764:	8a 81       	ldd	r24, Y+2	; 0x02
    1766:	84 30       	cpi	r24, 0x04	; 4
    1768:	08 f0       	brcs	.+2      	; 0x176c <MEXTI_voidConfig+0x1a>
    176a:	5a c0       	rjmp	.+180    	; 0x1820 <MEXTI_voidConfig+0xce>
    {
        switch (A_u8EXTINo)
    176c:	89 81       	ldd	r24, Y+1	; 0x01
    176e:	28 2f       	mov	r18, r24
    1770:	30 e0       	ldi	r19, 0x00	; 0
    1772:	3e 83       	std	Y+6, r19	; 0x06
    1774:	2d 83       	std	Y+5, r18	; 0x05
    1776:	8d 81       	ldd	r24, Y+5	; 0x05
    1778:	9e 81       	ldd	r25, Y+6	; 0x06
    177a:	81 30       	cpi	r24, 0x01	; 1
    177c:	91 05       	cpc	r25, r1
    177e:	d1 f0       	breq	.+52     	; 0x17b4 <MEXTI_voidConfig+0x62>
    1780:	2d 81       	ldd	r18, Y+5	; 0x05
    1782:	3e 81       	ldd	r19, Y+6	; 0x06
    1784:	22 30       	cpi	r18, 0x02	; 2
    1786:	31 05       	cpc	r19, r1
    1788:	61 f1       	breq	.+88     	; 0x17e2 <MEXTI_voidConfig+0x90>
    178a:	8d 81       	ldd	r24, Y+5	; 0x05
    178c:	9e 81       	ldd	r25, Y+6	; 0x06
    178e:	00 97       	sbiw	r24, 0x00	; 0
    1790:	09 f0       	breq	.+2      	; 0x1794 <MEXTI_voidConfig+0x42>
    1792:	46 c0       	rjmp	.+140    	; 0x1820 <MEXTI_voidConfig+0xce>
        {
        case EXTI0:
            MCUCR &=~(SENSE_MODE_MASK<<ISC00); //clearing bits
    1794:	a5 e5       	ldi	r26, 0x55	; 85
    1796:	b0 e0       	ldi	r27, 0x00	; 0
    1798:	e5 e5       	ldi	r30, 0x55	; 85
    179a:	f0 e0       	ldi	r31, 0x00	; 0
    179c:	80 81       	ld	r24, Z
    179e:	8c 7f       	andi	r24, 0xFC	; 252
    17a0:	8c 93       	st	X, r24
            MCUCR |=(A_u8SenseMode<<ISC00); //puting values
    17a2:	a5 e5       	ldi	r26, 0x55	; 85
    17a4:	b0 e0       	ldi	r27, 0x00	; 0
    17a6:	e5 e5       	ldi	r30, 0x55	; 85
    17a8:	f0 e0       	ldi	r31, 0x00	; 0
    17aa:	90 81       	ld	r25, Z
    17ac:	8a 81       	ldd	r24, Y+2	; 0x02
    17ae:	89 2b       	or	r24, r25
    17b0:	8c 93       	st	X, r24
    17b2:	36 c0       	rjmp	.+108    	; 0x1820 <MEXTI_voidConfig+0xce>
            break;

        case EXTI1:
            MCUCR &=~(SENSE_MODE_MASK<<ISC10); //clearing bits
    17b4:	a5 e5       	ldi	r26, 0x55	; 85
    17b6:	b0 e0       	ldi	r27, 0x00	; 0
    17b8:	e5 e5       	ldi	r30, 0x55	; 85
    17ba:	f0 e0       	ldi	r31, 0x00	; 0
    17bc:	80 81       	ld	r24, Z
    17be:	83 7f       	andi	r24, 0xF3	; 243
    17c0:	8c 93       	st	X, r24
            MCUCR |=(A_u8SenseMode<<ISC10); //puting values
    17c2:	a5 e5       	ldi	r26, 0x55	; 85
    17c4:	b0 e0       	ldi	r27, 0x00	; 0
    17c6:	e5 e5       	ldi	r30, 0x55	; 85
    17c8:	f0 e0       	ldi	r31, 0x00	; 0
    17ca:	80 81       	ld	r24, Z
    17cc:	28 2f       	mov	r18, r24
    17ce:	8a 81       	ldd	r24, Y+2	; 0x02
    17d0:	88 2f       	mov	r24, r24
    17d2:	90 e0       	ldi	r25, 0x00	; 0
    17d4:	88 0f       	add	r24, r24
    17d6:	99 1f       	adc	r25, r25
    17d8:	88 0f       	add	r24, r24
    17da:	99 1f       	adc	r25, r25
    17dc:	82 2b       	or	r24, r18
    17de:	8c 93       	st	X, r24
    17e0:	1f c0       	rjmp	.+62     	; 0x1820 <MEXTI_voidConfig+0xce>
            break;
        
        case EXTI2:
            switch (A_u8SenseMode)
    17e2:	8a 81       	ldd	r24, Y+2	; 0x02
    17e4:	28 2f       	mov	r18, r24
    17e6:	30 e0       	ldi	r19, 0x00	; 0
    17e8:	3c 83       	std	Y+4, r19	; 0x04
    17ea:	2b 83       	std	Y+3, r18	; 0x03
    17ec:	8b 81       	ldd	r24, Y+3	; 0x03
    17ee:	9c 81       	ldd	r25, Y+4	; 0x04
    17f0:	82 30       	cpi	r24, 0x02	; 2
    17f2:	91 05       	cpc	r25, r1
    17f4:	31 f0       	breq	.+12     	; 0x1802 <MEXTI_voidConfig+0xb0>
    17f6:	2b 81       	ldd	r18, Y+3	; 0x03
    17f8:	3c 81       	ldd	r19, Y+4	; 0x04
    17fa:	23 30       	cpi	r18, 0x03	; 3
    17fc:	31 05       	cpc	r19, r1
    17fe:	49 f0       	breq	.+18     	; 0x1812 <MEXTI_voidConfig+0xc0>
    1800:	0f c0       	rjmp	.+30     	; 0x1820 <MEXTI_voidConfig+0xce>
            {
                case FALLING_EDGE:CLR_BIT(MCUCSR,ISC2);
    1802:	a4 e5       	ldi	r26, 0x54	; 84
    1804:	b0 e0       	ldi	r27, 0x00	; 0
    1806:	e4 e5       	ldi	r30, 0x54	; 84
    1808:	f0 e0       	ldi	r31, 0x00	; 0
    180a:	80 81       	ld	r24, Z
    180c:	8f 7b       	andi	r24, 0xBF	; 191
    180e:	8c 93       	st	X, r24
    1810:	07 c0       	rjmp	.+14     	; 0x1820 <MEXTI_voidConfig+0xce>
                break;

                case RISING_EDGE:SET_BIT(MCUCSR,ISC2);
    1812:	a4 e5       	ldi	r26, 0x54	; 84
    1814:	b0 e0       	ldi	r27, 0x00	; 0
    1816:	e4 e5       	ldi	r30, 0x54	; 84
    1818:	f0 e0       	ldi	r31, 0x00	; 0
    181a:	80 81       	ld	r24, Z
    181c:	80 64       	ori	r24, 0x40	; 64
    181e:	8c 93       	st	X, r24
        
        default:
            break;
        }
    }
}
    1820:	26 96       	adiw	r28, 0x06	; 6
    1822:	0f b6       	in	r0, 0x3f	; 63
    1824:	f8 94       	cli
    1826:	de bf       	out	0x3e, r29	; 62
    1828:	0f be       	out	0x3f, r0	; 63
    182a:	cd bf       	out	0x3d, r28	; 61
    182c:	cf 91       	pop	r28
    182e:	df 91       	pop	r29
    1830:	08 95       	ret

00001832 <MEXTI_voidEnable>:

void MEXTI_voidEnable(u8 A_u8EXTI)
{
    1832:	df 93       	push	r29
    1834:	cf 93       	push	r28
    1836:	00 d0       	rcall	.+0      	; 0x1838 <MEXTI_voidEnable+0x6>
    1838:	0f 92       	push	r0
    183a:	cd b7       	in	r28, 0x3d	; 61
    183c:	de b7       	in	r29, 0x3e	; 62
    183e:	89 83       	std	Y+1, r24	; 0x01
    switch(A_u8EXTI)
    1840:	89 81       	ldd	r24, Y+1	; 0x01
    1842:	28 2f       	mov	r18, r24
    1844:	30 e0       	ldi	r19, 0x00	; 0
    1846:	3b 83       	std	Y+3, r19	; 0x03
    1848:	2a 83       	std	Y+2, r18	; 0x02
    184a:	8a 81       	ldd	r24, Y+2	; 0x02
    184c:	9b 81       	ldd	r25, Y+3	; 0x03
    184e:	81 30       	cpi	r24, 0x01	; 1
    1850:	91 05       	cpc	r25, r1
    1852:	89 f0       	breq	.+34     	; 0x1876 <MEXTI_voidEnable+0x44>
    1854:	2a 81       	ldd	r18, Y+2	; 0x02
    1856:	3b 81       	ldd	r19, Y+3	; 0x03
    1858:	22 30       	cpi	r18, 0x02	; 2
    185a:	31 05       	cpc	r19, r1
    185c:	a1 f0       	breq	.+40     	; 0x1886 <MEXTI_voidEnable+0x54>
    185e:	8a 81       	ldd	r24, Y+2	; 0x02
    1860:	9b 81       	ldd	r25, Y+3	; 0x03
    1862:	00 97       	sbiw	r24, 0x00	; 0
    1864:	b9 f4       	brne	.+46     	; 0x1894 <MEXTI_voidEnable+0x62>
    {
        case EXTI0: SET_BIT(GICR,INT0);
    1866:	ab e5       	ldi	r26, 0x5B	; 91
    1868:	b0 e0       	ldi	r27, 0x00	; 0
    186a:	eb e5       	ldi	r30, 0x5B	; 91
    186c:	f0 e0       	ldi	r31, 0x00	; 0
    186e:	80 81       	ld	r24, Z
    1870:	80 64       	ori	r24, 0x40	; 64
    1872:	8c 93       	st	X, r24
    1874:	0f c0       	rjmp	.+30     	; 0x1894 <MEXTI_voidEnable+0x62>
        break;
        case EXTI1: SET_BIT(GICR,INT1);
    1876:	ab e5       	ldi	r26, 0x5B	; 91
    1878:	b0 e0       	ldi	r27, 0x00	; 0
    187a:	eb e5       	ldi	r30, 0x5B	; 91
    187c:	f0 e0       	ldi	r31, 0x00	; 0
    187e:	80 81       	ld	r24, Z
    1880:	80 68       	ori	r24, 0x80	; 128
    1882:	8c 93       	st	X, r24
    1884:	07 c0       	rjmp	.+14     	; 0x1894 <MEXTI_voidEnable+0x62>
        break;
        case EXTI2: SET_BIT(GICR,INT2);
    1886:	ab e5       	ldi	r26, 0x5B	; 91
    1888:	b0 e0       	ldi	r27, 0x00	; 0
    188a:	eb e5       	ldi	r30, 0x5B	; 91
    188c:	f0 e0       	ldi	r31, 0x00	; 0
    188e:	80 81       	ld	r24, Z
    1890:	80 62       	ori	r24, 0x20	; 32
    1892:	8c 93       	st	X, r24
        break;
    }
}
    1894:	0f 90       	pop	r0
    1896:	0f 90       	pop	r0
    1898:	0f 90       	pop	r0
    189a:	cf 91       	pop	r28
    189c:	df 91       	pop	r29
    189e:	08 95       	ret

000018a0 <MEXTI_voidDisable>:

void MEXTI_voidDisable(u8 A_u8EXTI)
{
    18a0:	df 93       	push	r29
    18a2:	cf 93       	push	r28
    18a4:	00 d0       	rcall	.+0      	; 0x18a6 <MEXTI_voidDisable+0x6>
    18a6:	0f 92       	push	r0
    18a8:	cd b7       	in	r28, 0x3d	; 61
    18aa:	de b7       	in	r29, 0x3e	; 62
    18ac:	89 83       	std	Y+1, r24	; 0x01
    switch(A_u8EXTI)
    18ae:	89 81       	ldd	r24, Y+1	; 0x01
    18b0:	28 2f       	mov	r18, r24
    18b2:	30 e0       	ldi	r19, 0x00	; 0
    18b4:	3b 83       	std	Y+3, r19	; 0x03
    18b6:	2a 83       	std	Y+2, r18	; 0x02
    18b8:	8a 81       	ldd	r24, Y+2	; 0x02
    18ba:	9b 81       	ldd	r25, Y+3	; 0x03
    18bc:	81 30       	cpi	r24, 0x01	; 1
    18be:	91 05       	cpc	r25, r1
    18c0:	89 f0       	breq	.+34     	; 0x18e4 <MEXTI_voidDisable+0x44>
    18c2:	2a 81       	ldd	r18, Y+2	; 0x02
    18c4:	3b 81       	ldd	r19, Y+3	; 0x03
    18c6:	22 30       	cpi	r18, 0x02	; 2
    18c8:	31 05       	cpc	r19, r1
    18ca:	a1 f0       	breq	.+40     	; 0x18f4 <MEXTI_voidDisable+0x54>
    18cc:	8a 81       	ldd	r24, Y+2	; 0x02
    18ce:	9b 81       	ldd	r25, Y+3	; 0x03
    18d0:	00 97       	sbiw	r24, 0x00	; 0
    18d2:	b9 f4       	brne	.+46     	; 0x1902 <MEXTI_voidDisable+0x62>
    {
        case EXTI0: CLR_BIT(GICR,INT0);
    18d4:	ab e5       	ldi	r26, 0x5B	; 91
    18d6:	b0 e0       	ldi	r27, 0x00	; 0
    18d8:	eb e5       	ldi	r30, 0x5B	; 91
    18da:	f0 e0       	ldi	r31, 0x00	; 0
    18dc:	80 81       	ld	r24, Z
    18de:	8f 7b       	andi	r24, 0xBF	; 191
    18e0:	8c 93       	st	X, r24
    18e2:	0f c0       	rjmp	.+30     	; 0x1902 <MEXTI_voidDisable+0x62>
        break;
        case EXTI1: CLR_BIT(GICR,INT1);
    18e4:	ab e5       	ldi	r26, 0x5B	; 91
    18e6:	b0 e0       	ldi	r27, 0x00	; 0
    18e8:	eb e5       	ldi	r30, 0x5B	; 91
    18ea:	f0 e0       	ldi	r31, 0x00	; 0
    18ec:	80 81       	ld	r24, Z
    18ee:	8f 77       	andi	r24, 0x7F	; 127
    18f0:	8c 93       	st	X, r24
    18f2:	07 c0       	rjmp	.+14     	; 0x1902 <MEXTI_voidDisable+0x62>
        break;
        case EXTI2: CLR_BIT(GICR,INT2);
    18f4:	ab e5       	ldi	r26, 0x5B	; 91
    18f6:	b0 e0       	ldi	r27, 0x00	; 0
    18f8:	eb e5       	ldi	r30, 0x5B	; 91
    18fa:	f0 e0       	ldi	r31, 0x00	; 0
    18fc:	80 81       	ld	r24, Z
    18fe:	8f 7d       	andi	r24, 0xDF	; 223
    1900:	8c 93       	st	X, r24
        break;
    }
}
    1902:	0f 90       	pop	r0
    1904:	0f 90       	pop	r0
    1906:	0f 90       	pop	r0
    1908:	cf 91       	pop	r28
    190a:	df 91       	pop	r29
    190c:	08 95       	ret

0000190e <MEXTI_voidClearFlag>:

void MEXTI_voidClearFlag(u8 A_u8EXTI)
{
    190e:	df 93       	push	r29
    1910:	cf 93       	push	r28
    1912:	00 d0       	rcall	.+0      	; 0x1914 <MEXTI_voidClearFlag+0x6>
    1914:	0f 92       	push	r0
    1916:	cd b7       	in	r28, 0x3d	; 61
    1918:	de b7       	in	r29, 0x3e	; 62
    191a:	89 83       	std	Y+1, r24	; 0x01
    switch(A_u8EXTI)
    191c:	89 81       	ldd	r24, Y+1	; 0x01
    191e:	28 2f       	mov	r18, r24
    1920:	30 e0       	ldi	r19, 0x00	; 0
    1922:	3b 83       	std	Y+3, r19	; 0x03
    1924:	2a 83       	std	Y+2, r18	; 0x02
    1926:	8a 81       	ldd	r24, Y+2	; 0x02
    1928:	9b 81       	ldd	r25, Y+3	; 0x03
    192a:	81 30       	cpi	r24, 0x01	; 1
    192c:	91 05       	cpc	r25, r1
    192e:	89 f0       	breq	.+34     	; 0x1952 <MEXTI_voidClearFlag+0x44>
    1930:	2a 81       	ldd	r18, Y+2	; 0x02
    1932:	3b 81       	ldd	r19, Y+3	; 0x03
    1934:	22 30       	cpi	r18, 0x02	; 2
    1936:	31 05       	cpc	r19, r1
    1938:	a1 f0       	breq	.+40     	; 0x1962 <MEXTI_voidClearFlag+0x54>
    193a:	8a 81       	ldd	r24, Y+2	; 0x02
    193c:	9b 81       	ldd	r25, Y+3	; 0x03
    193e:	00 97       	sbiw	r24, 0x00	; 0
    1940:	b9 f4       	brne	.+46     	; 0x1970 <MEXTI_voidClearFlag+0x62>
    {
        case EXTI0: SET_BIT(GIFR,INTF0);
    1942:	aa e5       	ldi	r26, 0x5A	; 90
    1944:	b0 e0       	ldi	r27, 0x00	; 0
    1946:	ea e5       	ldi	r30, 0x5A	; 90
    1948:	f0 e0       	ldi	r31, 0x00	; 0
    194a:	80 81       	ld	r24, Z
    194c:	80 64       	ori	r24, 0x40	; 64
    194e:	8c 93       	st	X, r24
    1950:	0f c0       	rjmp	.+30     	; 0x1970 <MEXTI_voidClearFlag+0x62>
        break;
        case EXTI1: SET_BIT(GIFR,INTF1);
    1952:	aa e5       	ldi	r26, 0x5A	; 90
    1954:	b0 e0       	ldi	r27, 0x00	; 0
    1956:	ea e5       	ldi	r30, 0x5A	; 90
    1958:	f0 e0       	ldi	r31, 0x00	; 0
    195a:	80 81       	ld	r24, Z
    195c:	80 68       	ori	r24, 0x80	; 128
    195e:	8c 93       	st	X, r24
    1960:	07 c0       	rjmp	.+14     	; 0x1970 <MEXTI_voidClearFlag+0x62>
        break;
        case EXTI2: SET_BIT(GIFR,INTF2);
    1962:	aa e5       	ldi	r26, 0x5A	; 90
    1964:	b0 e0       	ldi	r27, 0x00	; 0
    1966:	ea e5       	ldi	r30, 0x5A	; 90
    1968:	f0 e0       	ldi	r31, 0x00	; 0
    196a:	80 81       	ld	r24, Z
    196c:	80 62       	ori	r24, 0x20	; 32
    196e:	8c 93       	st	X, r24
        break;
    }
}
    1970:	0f 90       	pop	r0
    1972:	0f 90       	pop	r0
    1974:	0f 90       	pop	r0
    1976:	cf 91       	pop	r28
    1978:	df 91       	pop	r29
    197a:	08 95       	ret

0000197c <MEXTI_voidSetCallBack>:

void MEXTI_voidSetCallBack(u8 A_u8EXTI,void (*ptrToFunc)(void))
{
    197c:	df 93       	push	r29
    197e:	cf 93       	push	r28
    1980:	00 d0       	rcall	.+0      	; 0x1982 <MEXTI_voidSetCallBack+0x6>
    1982:	00 d0       	rcall	.+0      	; 0x1984 <MEXTI_voidSetCallBack+0x8>
    1984:	0f 92       	push	r0
    1986:	cd b7       	in	r28, 0x3d	; 61
    1988:	de b7       	in	r29, 0x3e	; 62
    198a:	89 83       	std	Y+1, r24	; 0x01
    198c:	7b 83       	std	Y+3, r23	; 0x03
    198e:	6a 83       	std	Y+2, r22	; 0x02
    if(ptrToFunc!=NULL)
    1990:	8a 81       	ldd	r24, Y+2	; 0x02
    1992:	9b 81       	ldd	r25, Y+3	; 0x03
    1994:	00 97       	sbiw	r24, 0x00	; 0
    1996:	39 f1       	breq	.+78     	; 0x19e6 <MEXTI_voidSetCallBack+0x6a>
    {
        switch (A_u8EXTI)
    1998:	89 81       	ldd	r24, Y+1	; 0x01
    199a:	28 2f       	mov	r18, r24
    199c:	30 e0       	ldi	r19, 0x00	; 0
    199e:	3d 83       	std	Y+5, r19	; 0x05
    19a0:	2c 83       	std	Y+4, r18	; 0x04
    19a2:	8c 81       	ldd	r24, Y+4	; 0x04
    19a4:	9d 81       	ldd	r25, Y+5	; 0x05
    19a6:	81 30       	cpi	r24, 0x01	; 1
    19a8:	91 05       	cpc	r25, r1
    19aa:	81 f0       	breq	.+32     	; 0x19cc <MEXTI_voidSetCallBack+0x50>
    19ac:	2c 81       	ldd	r18, Y+4	; 0x04
    19ae:	3d 81       	ldd	r19, Y+5	; 0x05
    19b0:	22 30       	cpi	r18, 0x02	; 2
    19b2:	31 05       	cpc	r19, r1
    19b4:	91 f0       	breq	.+36     	; 0x19da <MEXTI_voidSetCallBack+0x5e>
    19b6:	8c 81       	ldd	r24, Y+4	; 0x04
    19b8:	9d 81       	ldd	r25, Y+5	; 0x05
    19ba:	00 97       	sbiw	r24, 0x00	; 0
    19bc:	a1 f4       	brne	.+40     	; 0x19e6 <MEXTI_voidSetCallBack+0x6a>
        {
            case EXTI0:EXTI0_CallBack=ptrToFunc;break;
    19be:	8a 81       	ldd	r24, Y+2	; 0x02
    19c0:	9b 81       	ldd	r25, Y+3	; 0x03
    19c2:	90 93 9f 00 	sts	0x009F, r25
    19c6:	80 93 9e 00 	sts	0x009E, r24
    19ca:	0d c0       	rjmp	.+26     	; 0x19e6 <MEXTI_voidSetCallBack+0x6a>
            case EXTI1:EXTI1_CallBack=ptrToFunc;break;
    19cc:	8a 81       	ldd	r24, Y+2	; 0x02
    19ce:	9b 81       	ldd	r25, Y+3	; 0x03
    19d0:	90 93 a1 00 	sts	0x00A1, r25
    19d4:	80 93 a0 00 	sts	0x00A0, r24
    19d8:	06 c0       	rjmp	.+12     	; 0x19e6 <MEXTI_voidSetCallBack+0x6a>
            case EXTI2:EXTI2_CallBack=ptrToFunc;break;
    19da:	8a 81       	ldd	r24, Y+2	; 0x02
    19dc:	9b 81       	ldd	r25, Y+3	; 0x03
    19de:	90 93 a3 00 	sts	0x00A3, r25
    19e2:	80 93 a2 00 	sts	0x00A2, r24
            default: break;
        }
    }
}
    19e6:	0f 90       	pop	r0
    19e8:	0f 90       	pop	r0
    19ea:	0f 90       	pop	r0
    19ec:	0f 90       	pop	r0
    19ee:	0f 90       	pop	r0
    19f0:	cf 91       	pop	r28
    19f2:	df 91       	pop	r29
    19f4:	08 95       	ret

000019f6 <__vector_1>:
        switch when interrupt happen so we have to make push and pop the shared registers 
        & status register to & from stack
*/

ISR(EXTI0_VECT)
{
    19f6:	1f 92       	push	r1
    19f8:	0f 92       	push	r0
    19fa:	0f b6       	in	r0, 0x3f	; 63
    19fc:	0f 92       	push	r0
    19fe:	11 24       	eor	r1, r1
    1a00:	2f 93       	push	r18
    1a02:	3f 93       	push	r19
    1a04:	4f 93       	push	r20
    1a06:	5f 93       	push	r21
    1a08:	6f 93       	push	r22
    1a0a:	7f 93       	push	r23
    1a0c:	8f 93       	push	r24
    1a0e:	9f 93       	push	r25
    1a10:	af 93       	push	r26
    1a12:	bf 93       	push	r27
    1a14:	ef 93       	push	r30
    1a16:	ff 93       	push	r31
    1a18:	df 93       	push	r29
    1a1a:	cf 93       	push	r28
    1a1c:	cd b7       	in	r28, 0x3d	; 61
    1a1e:	de b7       	in	r29, 0x3e	; 62
    if(EXTI0_CallBack!=NULLPTR) EXTI0_CallBack();
    1a20:	80 91 9e 00 	lds	r24, 0x009E
    1a24:	90 91 9f 00 	lds	r25, 0x009F
    1a28:	00 97       	sbiw	r24, 0x00	; 0
    1a2a:	29 f0       	breq	.+10     	; 0x1a36 <__vector_1+0x40>
    1a2c:	e0 91 9e 00 	lds	r30, 0x009E
    1a30:	f0 91 9f 00 	lds	r31, 0x009F
    1a34:	09 95       	icall
}
    1a36:	cf 91       	pop	r28
    1a38:	df 91       	pop	r29
    1a3a:	ff 91       	pop	r31
    1a3c:	ef 91       	pop	r30
    1a3e:	bf 91       	pop	r27
    1a40:	af 91       	pop	r26
    1a42:	9f 91       	pop	r25
    1a44:	8f 91       	pop	r24
    1a46:	7f 91       	pop	r23
    1a48:	6f 91       	pop	r22
    1a4a:	5f 91       	pop	r21
    1a4c:	4f 91       	pop	r20
    1a4e:	3f 91       	pop	r19
    1a50:	2f 91       	pop	r18
    1a52:	0f 90       	pop	r0
    1a54:	0f be       	out	0x3f, r0	; 63
    1a56:	0f 90       	pop	r0
    1a58:	1f 90       	pop	r1
    1a5a:	18 95       	reti

00001a5c <__vector_2>:

ISR(EXTI1_VECT)
{
    1a5c:	1f 92       	push	r1
    1a5e:	0f 92       	push	r0
    1a60:	0f b6       	in	r0, 0x3f	; 63
    1a62:	0f 92       	push	r0
    1a64:	11 24       	eor	r1, r1
    1a66:	2f 93       	push	r18
    1a68:	3f 93       	push	r19
    1a6a:	4f 93       	push	r20
    1a6c:	5f 93       	push	r21
    1a6e:	6f 93       	push	r22
    1a70:	7f 93       	push	r23
    1a72:	8f 93       	push	r24
    1a74:	9f 93       	push	r25
    1a76:	af 93       	push	r26
    1a78:	bf 93       	push	r27
    1a7a:	ef 93       	push	r30
    1a7c:	ff 93       	push	r31
    1a7e:	df 93       	push	r29
    1a80:	cf 93       	push	r28
    1a82:	cd b7       	in	r28, 0x3d	; 61
    1a84:	de b7       	in	r29, 0x3e	; 62
    if(EXTI1_CallBack!=NULLPTR) EXTI1_CallBack();
    1a86:	80 91 a0 00 	lds	r24, 0x00A0
    1a8a:	90 91 a1 00 	lds	r25, 0x00A1
    1a8e:	00 97       	sbiw	r24, 0x00	; 0
    1a90:	29 f0       	breq	.+10     	; 0x1a9c <__vector_2+0x40>
    1a92:	e0 91 a0 00 	lds	r30, 0x00A0
    1a96:	f0 91 a1 00 	lds	r31, 0x00A1
    1a9a:	09 95       	icall
}
    1a9c:	cf 91       	pop	r28
    1a9e:	df 91       	pop	r29
    1aa0:	ff 91       	pop	r31
    1aa2:	ef 91       	pop	r30
    1aa4:	bf 91       	pop	r27
    1aa6:	af 91       	pop	r26
    1aa8:	9f 91       	pop	r25
    1aaa:	8f 91       	pop	r24
    1aac:	7f 91       	pop	r23
    1aae:	6f 91       	pop	r22
    1ab0:	5f 91       	pop	r21
    1ab2:	4f 91       	pop	r20
    1ab4:	3f 91       	pop	r19
    1ab6:	2f 91       	pop	r18
    1ab8:	0f 90       	pop	r0
    1aba:	0f be       	out	0x3f, r0	; 63
    1abc:	0f 90       	pop	r0
    1abe:	1f 90       	pop	r1
    1ac0:	18 95       	reti

00001ac2 <__vector_3>:

ISR(EXTI2_VECT)
{
    1ac2:	1f 92       	push	r1
    1ac4:	0f 92       	push	r0
    1ac6:	0f b6       	in	r0, 0x3f	; 63
    1ac8:	0f 92       	push	r0
    1aca:	11 24       	eor	r1, r1
    1acc:	2f 93       	push	r18
    1ace:	3f 93       	push	r19
    1ad0:	4f 93       	push	r20
    1ad2:	5f 93       	push	r21
    1ad4:	6f 93       	push	r22
    1ad6:	7f 93       	push	r23
    1ad8:	8f 93       	push	r24
    1ada:	9f 93       	push	r25
    1adc:	af 93       	push	r26
    1ade:	bf 93       	push	r27
    1ae0:	ef 93       	push	r30
    1ae2:	ff 93       	push	r31
    1ae4:	df 93       	push	r29
    1ae6:	cf 93       	push	r28
    1ae8:	cd b7       	in	r28, 0x3d	; 61
    1aea:	de b7       	in	r29, 0x3e	; 62
    if(EXTI2_CallBack!=NULLPTR) EXTI2_CallBack();
    1aec:	80 91 a2 00 	lds	r24, 0x00A2
    1af0:	90 91 a3 00 	lds	r25, 0x00A3
    1af4:	00 97       	sbiw	r24, 0x00	; 0
    1af6:	29 f0       	breq	.+10     	; 0x1b02 <__vector_3+0x40>
    1af8:	e0 91 a2 00 	lds	r30, 0x00A2
    1afc:	f0 91 a3 00 	lds	r31, 0x00A3
    1b00:	09 95       	icall
    1b02:	cf 91       	pop	r28
    1b04:	df 91       	pop	r29
    1b06:	ff 91       	pop	r31
    1b08:	ef 91       	pop	r30
    1b0a:	bf 91       	pop	r27
    1b0c:	af 91       	pop	r26
    1b0e:	9f 91       	pop	r25
    1b10:	8f 91       	pop	r24
    1b12:	7f 91       	pop	r23
    1b14:	6f 91       	pop	r22
    1b16:	5f 91       	pop	r21
    1b18:	4f 91       	pop	r20
    1b1a:	3f 91       	pop	r19
    1b1c:	2f 91       	pop	r18
    1b1e:	0f 90       	pop	r0
    1b20:	0f be       	out	0x3f, r0	; 63
    1b22:	0f 90       	pop	r0
    1b24:	1f 90       	pop	r1
    1b26:	18 95       	reti

00001b28 <MGI_voidEnable>:
#include "../Include/MCAL/GI/GI_Configuration.h"



void MGI_voidEnable()
{
    1b28:	df 93       	push	r29
    1b2a:	cf 93       	push	r28
    1b2c:	cd b7       	in	r28, 0x3d	; 61
    1b2e:	de b7       	in	r29, 0x3e	; 62
    SET_BIT(SREG,I_BIT);
    1b30:	af e5       	ldi	r26, 0x5F	; 95
    1b32:	b0 e0       	ldi	r27, 0x00	; 0
    1b34:	ef e5       	ldi	r30, 0x5F	; 95
    1b36:	f0 e0       	ldi	r31, 0x00	; 0
    1b38:	80 81       	ld	r24, Z
    1b3a:	80 68       	ori	r24, 0x80	; 128
    1b3c:	8c 93       	st	X, r24
}
    1b3e:	cf 91       	pop	r28
    1b40:	df 91       	pop	r29
    1b42:	08 95       	ret

00001b44 <MGI_voidDisable>:

void MGI_voidDisable()
{
    1b44:	df 93       	push	r29
    1b46:	cf 93       	push	r28
    1b48:	cd b7       	in	r28, 0x3d	; 61
    1b4a:	de b7       	in	r29, 0x3e	; 62
    
    CLR_BIT(SREG,I_BIT);
    1b4c:	af e5       	ldi	r26, 0x5F	; 95
    1b4e:	b0 e0       	ldi	r27, 0x00	; 0
    1b50:	ef e5       	ldi	r30, 0x5F	; 95
    1b52:	f0 e0       	ldi	r31, 0x00	; 0
    1b54:	80 81       	ld	r24, Z
    1b56:	8f 77       	andi	r24, 0x7F	; 127
    1b58:	8c 93       	st	X, r24
    1b5a:	cf 91       	pop	r28
    1b5c:	df 91       	pop	r29
    1b5e:	08 95       	ret

00001b60 <HKEYPAD_u8GetPressedKey>:
u8 keypadRow[ROWS_NUMBER]=ROW_PINS;
u8 keypadCol[COLS_NUMBER]=COL_PINS;


u8 HKEYPAD_u8GetPressedKey()
{
    1b60:	df 93       	push	r29
    1b62:	cf 93       	push	r28
    1b64:	cd b7       	in	r28, 0x3d	; 61
    1b66:	de b7       	in	r29, 0x3e	; 62
    1b68:	62 97       	sbiw	r28, 0x12	; 18
    1b6a:	0f b6       	in	r0, 0x3f	; 63
    1b6c:	f8 94       	cli
    1b6e:	de bf       	out	0x3e, r29	; 62
    1b70:	0f be       	out	0x3f, r0	; 63
    1b72:	cd bf       	out	0x3d, r28	; 61
    u8 local_u8RowCounter,local_u8ColCounter,local_u8Flag=FLAG_DOWN,local_u8PressedKey=KEY_NOT_PRESSED;
    1b74:	18 8a       	std	Y+16, r1	; 0x10
    1b76:	8f ef       	ldi	r24, 0xFF	; 255
    1b78:	8f 87       	std	Y+15, r24	; 0x0f
    
    for(local_u8RowCounter=0;local_u8RowCounter<ROWS_NUMBER;local_u8RowCounter++)
    1b7a:	1a 8a       	std	Y+18, r1	; 0x12
    1b7c:	c9 c0       	rjmp	.+402    	; 0x1d10 <HKEYPAD_u8GetPressedKey+0x1b0>
    {
        MDIO_voidSetPinValue(KEYPAD_PORT,keypadRow[local_u8RowCounter],PIN_LOW);
    1b7e:	8a 89       	ldd	r24, Y+18	; 0x12
    1b80:	88 2f       	mov	r24, r24
    1b82:	90 e0       	ldi	r25, 0x00	; 0
    1b84:	fc 01       	movw	r30, r24
    1b86:	e3 58       	subi	r30, 0x83	; 131
    1b88:	ff 4f       	sbci	r31, 0xFF	; 255
    1b8a:	90 81       	ld	r25, Z
    1b8c:	80 e0       	ldi	r24, 0x00	; 0
    1b8e:	69 2f       	mov	r22, r25
    1b90:	40 e0       	ldi	r20, 0x00	; 0
    1b92:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
        for(local_u8ColCounter=0;local_u8ColCounter<COLS_NUMBER;local_u8ColCounter++)
    1b96:	19 8a       	std	Y+17, r1	; 0x11
    1b98:	a5 c0       	rjmp	.+330    	; 0x1ce4 <HKEYPAD_u8GetPressedKey+0x184>
        {
            if (MDIO_u8GetPinValue(KEYPAD_PORT,keypadCol[local_u8ColCounter])==PIN_LOW)
    1b9a:	89 89       	ldd	r24, Y+17	; 0x11
    1b9c:	88 2f       	mov	r24, r24
    1b9e:	90 e0       	ldi	r25, 0x00	; 0
    1ba0:	fc 01       	movw	r30, r24
    1ba2:	ef 57       	subi	r30, 0x7F	; 127
    1ba4:	ff 4f       	sbci	r31, 0xFF	; 255
    1ba6:	90 81       	ld	r25, Z
    1ba8:	80 e0       	ldi	r24, 0x00	; 0
    1baa:	69 2f       	mov	r22, r25
    1bac:	0e 94 47 08 	call	0x108e	; 0x108e <MDIO_u8GetPinValue>
    1bb0:	88 23       	and	r24, r24
    1bb2:	09 f0       	breq	.+2      	; 0x1bb6 <HKEYPAD_u8GetPressedKey+0x56>
    1bb4:	94 c0       	rjmp	.+296    	; 0x1cde <HKEYPAD_u8GetPressedKey+0x17e>
    1bb6:	80 e0       	ldi	r24, 0x00	; 0
    1bb8:	90 e0       	ldi	r25, 0x00	; 0
    1bba:	a6 e1       	ldi	r26, 0x16	; 22
    1bbc:	b3 e4       	ldi	r27, 0x43	; 67
    1bbe:	8b 87       	std	Y+11, r24	; 0x0b
    1bc0:	9c 87       	std	Y+12, r25	; 0x0c
    1bc2:	ad 87       	std	Y+13, r26	; 0x0d
    1bc4:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1bc6:	6b 85       	ldd	r22, Y+11	; 0x0b
    1bc8:	7c 85       	ldd	r23, Y+12	; 0x0c
    1bca:	8d 85       	ldd	r24, Y+13	; 0x0d
    1bcc:	9e 85       	ldd	r25, Y+14	; 0x0e
    1bce:	20 e0       	ldi	r18, 0x00	; 0
    1bd0:	30 e0       	ldi	r19, 0x00	; 0
    1bd2:	4a ef       	ldi	r20, 0xFA	; 250
    1bd4:	54 e4       	ldi	r21, 0x44	; 68
    1bd6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1bda:	dc 01       	movw	r26, r24
    1bdc:	cb 01       	movw	r24, r22
    1bde:	8f 83       	std	Y+7, r24	; 0x07
    1be0:	98 87       	std	Y+8, r25	; 0x08
    1be2:	a9 87       	std	Y+9, r26	; 0x09
    1be4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1be6:	6f 81       	ldd	r22, Y+7	; 0x07
    1be8:	78 85       	ldd	r23, Y+8	; 0x08
    1bea:	89 85       	ldd	r24, Y+9	; 0x09
    1bec:	9a 85       	ldd	r25, Y+10	; 0x0a
    1bee:	20 e0       	ldi	r18, 0x00	; 0
    1bf0:	30 e0       	ldi	r19, 0x00	; 0
    1bf2:	40 e8       	ldi	r20, 0x80	; 128
    1bf4:	5f e3       	ldi	r21, 0x3F	; 63
    1bf6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1bfa:	88 23       	and	r24, r24
    1bfc:	2c f4       	brge	.+10     	; 0x1c08 <HKEYPAD_u8GetPressedKey+0xa8>
		__ticks = 1;
    1bfe:	81 e0       	ldi	r24, 0x01	; 1
    1c00:	90 e0       	ldi	r25, 0x00	; 0
    1c02:	9e 83       	std	Y+6, r25	; 0x06
    1c04:	8d 83       	std	Y+5, r24	; 0x05
    1c06:	3f c0       	rjmp	.+126    	; 0x1c86 <HKEYPAD_u8GetPressedKey+0x126>
	else if (__tmp > 65535)
    1c08:	6f 81       	ldd	r22, Y+7	; 0x07
    1c0a:	78 85       	ldd	r23, Y+8	; 0x08
    1c0c:	89 85       	ldd	r24, Y+9	; 0x09
    1c0e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c10:	20 e0       	ldi	r18, 0x00	; 0
    1c12:	3f ef       	ldi	r19, 0xFF	; 255
    1c14:	4f e7       	ldi	r20, 0x7F	; 127
    1c16:	57 e4       	ldi	r21, 0x47	; 71
    1c18:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1c1c:	18 16       	cp	r1, r24
    1c1e:	4c f5       	brge	.+82     	; 0x1c72 <HKEYPAD_u8GetPressedKey+0x112>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1c20:	6b 85       	ldd	r22, Y+11	; 0x0b
    1c22:	7c 85       	ldd	r23, Y+12	; 0x0c
    1c24:	8d 85       	ldd	r24, Y+13	; 0x0d
    1c26:	9e 85       	ldd	r25, Y+14	; 0x0e
    1c28:	20 e0       	ldi	r18, 0x00	; 0
    1c2a:	30 e0       	ldi	r19, 0x00	; 0
    1c2c:	40 e2       	ldi	r20, 0x20	; 32
    1c2e:	51 e4       	ldi	r21, 0x41	; 65
    1c30:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c34:	dc 01       	movw	r26, r24
    1c36:	cb 01       	movw	r24, r22
    1c38:	bc 01       	movw	r22, r24
    1c3a:	cd 01       	movw	r24, r26
    1c3c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c40:	dc 01       	movw	r26, r24
    1c42:	cb 01       	movw	r24, r22
    1c44:	9e 83       	std	Y+6, r25	; 0x06
    1c46:	8d 83       	std	Y+5, r24	; 0x05
    1c48:	0f c0       	rjmp	.+30     	; 0x1c68 <HKEYPAD_u8GetPressedKey+0x108>
    1c4a:	88 ec       	ldi	r24, 0xC8	; 200
    1c4c:	90 e0       	ldi	r25, 0x00	; 0
    1c4e:	9c 83       	std	Y+4, r25	; 0x04
    1c50:	8b 83       	std	Y+3, r24	; 0x03
    1c52:	8b 81       	ldd	r24, Y+3	; 0x03
    1c54:	9c 81       	ldd	r25, Y+4	; 0x04
    1c56:	01 97       	sbiw	r24, 0x01	; 1
    1c58:	f1 f7       	brne	.-4      	; 0x1c56 <HKEYPAD_u8GetPressedKey+0xf6>
    1c5a:	9c 83       	std	Y+4, r25	; 0x04
    1c5c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1c5e:	8d 81       	ldd	r24, Y+5	; 0x05
    1c60:	9e 81       	ldd	r25, Y+6	; 0x06
    1c62:	01 97       	sbiw	r24, 0x01	; 1
    1c64:	9e 83       	std	Y+6, r25	; 0x06
    1c66:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1c68:	8d 81       	ldd	r24, Y+5	; 0x05
    1c6a:	9e 81       	ldd	r25, Y+6	; 0x06
    1c6c:	00 97       	sbiw	r24, 0x00	; 0
    1c6e:	69 f7       	brne	.-38     	; 0x1c4a <HKEYPAD_u8GetPressedKey+0xea>
    1c70:	14 c0       	rjmp	.+40     	; 0x1c9a <HKEYPAD_u8GetPressedKey+0x13a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1c72:	6f 81       	ldd	r22, Y+7	; 0x07
    1c74:	78 85       	ldd	r23, Y+8	; 0x08
    1c76:	89 85       	ldd	r24, Y+9	; 0x09
    1c78:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c7a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c7e:	dc 01       	movw	r26, r24
    1c80:	cb 01       	movw	r24, r22
    1c82:	9e 83       	std	Y+6, r25	; 0x06
    1c84:	8d 83       	std	Y+5, r24	; 0x05
    1c86:	8d 81       	ldd	r24, Y+5	; 0x05
    1c88:	9e 81       	ldd	r25, Y+6	; 0x06
    1c8a:	9a 83       	std	Y+2, r25	; 0x02
    1c8c:	89 83       	std	Y+1, r24	; 0x01
    1c8e:	89 81       	ldd	r24, Y+1	; 0x01
    1c90:	9a 81       	ldd	r25, Y+2	; 0x02
    1c92:	01 97       	sbiw	r24, 0x01	; 1
    1c94:	f1 f7       	brne	.-4      	; 0x1c92 <HKEYPAD_u8GetPressedKey+0x132>
    1c96:	9a 83       	std	Y+2, r25	; 0x02
    1c98:	89 83       	std	Y+1, r24	; 0x01
            {
                //to avoid "debounce effect"
                _delay_ms(DEBOUNCING_DELAY);
                local_u8Flag=FLAG_UP;
    1c9a:	81 e0       	ldi	r24, 0x01	; 1
    1c9c:	88 8b       	std	Y+16, r24	; 0x10
                //to make sure it will not print the character more than once if the user still press the button
                while(MDIO_u8GetPinValue(KEYPAD_PORT,keypadCol[local_u8ColCounter])==PIN_LOW);
    1c9e:	89 89       	ldd	r24, Y+17	; 0x11
    1ca0:	88 2f       	mov	r24, r24
    1ca2:	90 e0       	ldi	r25, 0x00	; 0
    1ca4:	fc 01       	movw	r30, r24
    1ca6:	ef 57       	subi	r30, 0x7F	; 127
    1ca8:	ff 4f       	sbci	r31, 0xFF	; 255
    1caa:	90 81       	ld	r25, Z
    1cac:	80 e0       	ldi	r24, 0x00	; 0
    1cae:	69 2f       	mov	r22, r25
    1cb0:	0e 94 47 08 	call	0x108e	; 0x108e <MDIO_u8GetPinValue>
    1cb4:	88 23       	and	r24, r24
    1cb6:	99 f3       	breq	.-26     	; 0x1c9e <HKEYPAD_u8GetPressedKey+0x13e>
                local_u8PressedKey=KeypadArr[local_u8RowCounter][local_u8ColCounter];
    1cb8:	8a 89       	ldd	r24, Y+18	; 0x12
    1cba:	48 2f       	mov	r20, r24
    1cbc:	50 e0       	ldi	r21, 0x00	; 0
    1cbe:	89 89       	ldd	r24, Y+17	; 0x11
    1cc0:	28 2f       	mov	r18, r24
    1cc2:	30 e0       	ldi	r19, 0x00	; 0
    1cc4:	ca 01       	movw	r24, r20
    1cc6:	88 0f       	add	r24, r24
    1cc8:	99 1f       	adc	r25, r25
    1cca:	88 0f       	add	r24, r24
    1ccc:	99 1f       	adc	r25, r25
    1cce:	82 0f       	add	r24, r18
    1cd0:	93 1f       	adc	r25, r19
    1cd2:	fc 01       	movw	r30, r24
    1cd4:	e3 59       	subi	r30, 0x93	; 147
    1cd6:	ff 4f       	sbci	r31, 0xFF	; 255
    1cd8:	80 81       	ld	r24, Z
    1cda:	8f 87       	std	Y+15, r24	; 0x0f
    1cdc:	07 c0       	rjmp	.+14     	; 0x1cec <HKEYPAD_u8GetPressedKey+0x18c>
    u8 local_u8RowCounter,local_u8ColCounter,local_u8Flag=FLAG_DOWN,local_u8PressedKey=KEY_NOT_PRESSED;
    
    for(local_u8RowCounter=0;local_u8RowCounter<ROWS_NUMBER;local_u8RowCounter++)
    {
        MDIO_voidSetPinValue(KEYPAD_PORT,keypadRow[local_u8RowCounter],PIN_LOW);
        for(local_u8ColCounter=0;local_u8ColCounter<COLS_NUMBER;local_u8ColCounter++)
    1cde:	89 89       	ldd	r24, Y+17	; 0x11
    1ce0:	8f 5f       	subi	r24, 0xFF	; 255
    1ce2:	89 8b       	std	Y+17, r24	; 0x11
    1ce4:	89 89       	ldd	r24, Y+17	; 0x11
    1ce6:	84 30       	cpi	r24, 0x04	; 4
    1ce8:	08 f4       	brcc	.+2      	; 0x1cec <HKEYPAD_u8GetPressedKey+0x18c>
    1cea:	57 cf       	rjmp	.-338    	; 0x1b9a <HKEYPAD_u8GetPressedKey+0x3a>
                while(MDIO_u8GetPinValue(KEYPAD_PORT,keypadCol[local_u8ColCounter])==PIN_LOW);
                local_u8PressedKey=KeypadArr[local_u8RowCounter][local_u8ColCounter];
                break;
            }
        }
        MDIO_voidSetPinValue(KEYPAD_PORT,keypadRow[local_u8RowCounter],PIN_HIGH);
    1cec:	8a 89       	ldd	r24, Y+18	; 0x12
    1cee:	88 2f       	mov	r24, r24
    1cf0:	90 e0       	ldi	r25, 0x00	; 0
    1cf2:	fc 01       	movw	r30, r24
    1cf4:	e3 58       	subi	r30, 0x83	; 131
    1cf6:	ff 4f       	sbci	r31, 0xFF	; 255
    1cf8:	90 81       	ld	r25, Z
    1cfa:	80 e0       	ldi	r24, 0x00	; 0
    1cfc:	69 2f       	mov	r22, r25
    1cfe:	41 e0       	ldi	r20, 0x01	; 1
    1d00:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
        if(local_u8Flag)
    1d04:	88 89       	ldd	r24, Y+16	; 0x10
    1d06:	88 23       	and	r24, r24
    1d08:	39 f4       	brne	.+14     	; 0x1d18 <HKEYPAD_u8GetPressedKey+0x1b8>

u8 HKEYPAD_u8GetPressedKey()
{
    u8 local_u8RowCounter,local_u8ColCounter,local_u8Flag=FLAG_DOWN,local_u8PressedKey=KEY_NOT_PRESSED;
    
    for(local_u8RowCounter=0;local_u8RowCounter<ROWS_NUMBER;local_u8RowCounter++)
    1d0a:	8a 89       	ldd	r24, Y+18	; 0x12
    1d0c:	8f 5f       	subi	r24, 0xFF	; 255
    1d0e:	8a 8b       	std	Y+18, r24	; 0x12
    1d10:	8a 89       	ldd	r24, Y+18	; 0x12
    1d12:	84 30       	cpi	r24, 0x04	; 4
    1d14:	08 f4       	brcc	.+2      	; 0x1d18 <HKEYPAD_u8GetPressedKey+0x1b8>
    1d16:	33 cf       	rjmp	.-410    	; 0x1b7e <HKEYPAD_u8GetPressedKey+0x1e>
        if(local_u8Flag)
        {
            break;
        }
    }
    return local_u8PressedKey;
    1d18:	8f 85       	ldd	r24, Y+15	; 0x0f
}
    1d1a:	62 96       	adiw	r28, 0x12	; 18
    1d1c:	0f b6       	in	r0, 0x3f	; 63
    1d1e:	f8 94       	cli
    1d20:	de bf       	out	0x3e, r29	; 62
    1d22:	0f be       	out	0x3f, r0	; 63
    1d24:	cd bf       	out	0x3d, r28	; 61
    1d26:	cf 91       	pop	r28
    1d28:	df 91       	pop	r29
    1d2a:	08 95       	ret

00001d2c <HLCD4_voidSendCommand>:


static u8 global_u8Init=0;

void HLCD4_voidSendCommand(u8 A_u8Command)
{
    1d2c:	df 93       	push	r29
    1d2e:	cf 93       	push	r28
    1d30:	cd b7       	in	r28, 0x3d	; 61
    1d32:	de b7       	in	r29, 0x3e	; 62
    1d34:	ab 97       	sbiw	r28, 0x2b	; 43
    1d36:	0f b6       	in	r0, 0x3f	; 63
    1d38:	f8 94       	cli
    1d3a:	de bf       	out	0x3e, r29	; 62
    1d3c:	0f be       	out	0x3f, r0	; 63
    1d3e:	cd bf       	out	0x3d, r28	; 61
    1d40:	8b a7       	std	Y+43, r24	; 0x2b
    //RS=0 RW=0
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,RS_PIN,PIN_LOW);
    1d42:	82 e0       	ldi	r24, 0x02	; 2
    1d44:	60 e0       	ldi	r22, 0x00	; 0
    1d46:	40 e0       	ldi	r20, 0x00	; 0
    1d48:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,RW_PIN,PIN_LOW);
    1d4c:	82 e0       	ldi	r24, 0x02	; 2
    1d4e:	61 e0       	ldi	r22, 0x01	; 1
    1d50:	40 e0       	ldi	r20, 0x00	; 0
    1d52:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>

    //send UPPER Bits (B7 to B4)
    MDIO_voidSetPortValue(LCD_DATA_PORT,A_u8Command);
    1d56:	83 e0       	ldi	r24, 0x03	; 3
    1d58:	6b a5       	ldd	r22, Y+43	; 0x2b
    1d5a:	0e 94 27 0b 	call	0x164e	; 0x164e <MDIO_voidSetPortValue>


    //pulse HIGH to LOW to ENABLE PIN
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_HIGH);
    1d5e:	82 e0       	ldi	r24, 0x02	; 2
    1d60:	62 e0       	ldi	r22, 0x02	; 2
    1d62:	41 e0       	ldi	r20, 0x01	; 1
    1d64:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    1d68:	80 e0       	ldi	r24, 0x00	; 0
    1d6a:	90 e0       	ldi	r25, 0x00	; 0
    1d6c:	a0 e8       	ldi	r26, 0x80	; 128
    1d6e:	bf e3       	ldi	r27, 0x3F	; 63
    1d70:	8f a3       	std	Y+39, r24	; 0x27
    1d72:	98 a7       	std	Y+40, r25	; 0x28
    1d74:	a9 a7       	std	Y+41, r26	; 0x29
    1d76:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1d78:	6f a1       	ldd	r22, Y+39	; 0x27
    1d7a:	78 a5       	ldd	r23, Y+40	; 0x28
    1d7c:	89 a5       	ldd	r24, Y+41	; 0x29
    1d7e:	9a a5       	ldd	r25, Y+42	; 0x2a
    1d80:	20 e0       	ldi	r18, 0x00	; 0
    1d82:	30 e0       	ldi	r19, 0x00	; 0
    1d84:	4a ef       	ldi	r20, 0xFA	; 250
    1d86:	54 e4       	ldi	r21, 0x44	; 68
    1d88:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1d8c:	dc 01       	movw	r26, r24
    1d8e:	cb 01       	movw	r24, r22
    1d90:	8b a3       	std	Y+35, r24	; 0x23
    1d92:	9c a3       	std	Y+36, r25	; 0x24
    1d94:	ad a3       	std	Y+37, r26	; 0x25
    1d96:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1d98:	6b a1       	ldd	r22, Y+35	; 0x23
    1d9a:	7c a1       	ldd	r23, Y+36	; 0x24
    1d9c:	8d a1       	ldd	r24, Y+37	; 0x25
    1d9e:	9e a1       	ldd	r25, Y+38	; 0x26
    1da0:	20 e0       	ldi	r18, 0x00	; 0
    1da2:	30 e0       	ldi	r19, 0x00	; 0
    1da4:	40 e8       	ldi	r20, 0x80	; 128
    1da6:	5f e3       	ldi	r21, 0x3F	; 63
    1da8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1dac:	88 23       	and	r24, r24
    1dae:	2c f4       	brge	.+10     	; 0x1dba <HLCD4_voidSendCommand+0x8e>
		__ticks = 1;
    1db0:	81 e0       	ldi	r24, 0x01	; 1
    1db2:	90 e0       	ldi	r25, 0x00	; 0
    1db4:	9a a3       	std	Y+34, r25	; 0x22
    1db6:	89 a3       	std	Y+33, r24	; 0x21
    1db8:	3f c0       	rjmp	.+126    	; 0x1e38 <HLCD4_voidSendCommand+0x10c>
	else if (__tmp > 65535)
    1dba:	6b a1       	ldd	r22, Y+35	; 0x23
    1dbc:	7c a1       	ldd	r23, Y+36	; 0x24
    1dbe:	8d a1       	ldd	r24, Y+37	; 0x25
    1dc0:	9e a1       	ldd	r25, Y+38	; 0x26
    1dc2:	20 e0       	ldi	r18, 0x00	; 0
    1dc4:	3f ef       	ldi	r19, 0xFF	; 255
    1dc6:	4f e7       	ldi	r20, 0x7F	; 127
    1dc8:	57 e4       	ldi	r21, 0x47	; 71
    1dca:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1dce:	18 16       	cp	r1, r24
    1dd0:	4c f5       	brge	.+82     	; 0x1e24 <HLCD4_voidSendCommand+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1dd2:	6f a1       	ldd	r22, Y+39	; 0x27
    1dd4:	78 a5       	ldd	r23, Y+40	; 0x28
    1dd6:	89 a5       	ldd	r24, Y+41	; 0x29
    1dd8:	9a a5       	ldd	r25, Y+42	; 0x2a
    1dda:	20 e0       	ldi	r18, 0x00	; 0
    1ddc:	30 e0       	ldi	r19, 0x00	; 0
    1dde:	40 e2       	ldi	r20, 0x20	; 32
    1de0:	51 e4       	ldi	r21, 0x41	; 65
    1de2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1de6:	dc 01       	movw	r26, r24
    1de8:	cb 01       	movw	r24, r22
    1dea:	bc 01       	movw	r22, r24
    1dec:	cd 01       	movw	r24, r26
    1dee:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1df2:	dc 01       	movw	r26, r24
    1df4:	cb 01       	movw	r24, r22
    1df6:	9a a3       	std	Y+34, r25	; 0x22
    1df8:	89 a3       	std	Y+33, r24	; 0x21
    1dfa:	0f c0       	rjmp	.+30     	; 0x1e1a <HLCD4_voidSendCommand+0xee>
    1dfc:	88 ec       	ldi	r24, 0xC8	; 200
    1dfe:	90 e0       	ldi	r25, 0x00	; 0
    1e00:	98 a3       	std	Y+32, r25	; 0x20
    1e02:	8f 8f       	std	Y+31, r24	; 0x1f
    1e04:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1e06:	98 a1       	ldd	r25, Y+32	; 0x20
    1e08:	01 97       	sbiw	r24, 0x01	; 1
    1e0a:	f1 f7       	brne	.-4      	; 0x1e08 <HLCD4_voidSendCommand+0xdc>
    1e0c:	98 a3       	std	Y+32, r25	; 0x20
    1e0e:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1e10:	89 a1       	ldd	r24, Y+33	; 0x21
    1e12:	9a a1       	ldd	r25, Y+34	; 0x22
    1e14:	01 97       	sbiw	r24, 0x01	; 1
    1e16:	9a a3       	std	Y+34, r25	; 0x22
    1e18:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e1a:	89 a1       	ldd	r24, Y+33	; 0x21
    1e1c:	9a a1       	ldd	r25, Y+34	; 0x22
    1e1e:	00 97       	sbiw	r24, 0x00	; 0
    1e20:	69 f7       	brne	.-38     	; 0x1dfc <HLCD4_voidSendCommand+0xd0>
    1e22:	14 c0       	rjmp	.+40     	; 0x1e4c <HLCD4_voidSendCommand+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1e24:	6b a1       	ldd	r22, Y+35	; 0x23
    1e26:	7c a1       	ldd	r23, Y+36	; 0x24
    1e28:	8d a1       	ldd	r24, Y+37	; 0x25
    1e2a:	9e a1       	ldd	r25, Y+38	; 0x26
    1e2c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e30:	dc 01       	movw	r26, r24
    1e32:	cb 01       	movw	r24, r22
    1e34:	9a a3       	std	Y+34, r25	; 0x22
    1e36:	89 a3       	std	Y+33, r24	; 0x21
    1e38:	89 a1       	ldd	r24, Y+33	; 0x21
    1e3a:	9a a1       	ldd	r25, Y+34	; 0x22
    1e3c:	9e 8f       	std	Y+30, r25	; 0x1e
    1e3e:	8d 8f       	std	Y+29, r24	; 0x1d
    1e40:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1e42:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1e44:	01 97       	sbiw	r24, 0x01	; 1
    1e46:	f1 f7       	brne	.-4      	; 0x1e44 <HLCD4_voidSendCommand+0x118>
    1e48:	9e 8f       	std	Y+30, r25	; 0x1e
    1e4a:	8d 8f       	std	Y+29, r24	; 0x1d
    _delay_ms(1);
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_LOW);
    1e4c:	82 e0       	ldi	r24, 0x02	; 2
    1e4e:	62 e0       	ldi	r22, 0x02	; 2
    1e50:	40 e0       	ldi	r20, 0x00	; 0
    1e52:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>

    if(global_u8Init)
    1e56:	80 91 a4 00 	lds	r24, 0x00A4
    1e5a:	88 23       	and	r24, r24
    1e5c:	09 f4       	brne	.+2      	; 0x1e60 <HLCD4_voidSendCommand+0x134>
    1e5e:	84 c0       	rjmp	.+264    	; 0x1f68 <HLCD4_voidSendCommand+0x23c>
    {

        //send LOWR Bits (B3 to B0)
        MDIO_voidSetPortValue(LCD_DATA_PORT,A_u8Command<<4);
    1e60:	8b a5       	ldd	r24, Y+43	; 0x2b
    1e62:	98 2f       	mov	r25, r24
    1e64:	92 95       	swap	r25
    1e66:	90 7f       	andi	r25, 0xF0	; 240
    1e68:	83 e0       	ldi	r24, 0x03	; 3
    1e6a:	69 2f       	mov	r22, r25
    1e6c:	0e 94 27 0b 	call	0x164e	; 0x164e <MDIO_voidSetPortValue>

        //pulse HIGH to LOW to ENABLE PIN
        MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_HIGH);
    1e70:	82 e0       	ldi	r24, 0x02	; 2
    1e72:	62 e0       	ldi	r22, 0x02	; 2
    1e74:	41 e0       	ldi	r20, 0x01	; 1
    1e76:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    1e7a:	80 e0       	ldi	r24, 0x00	; 0
    1e7c:	90 e0       	ldi	r25, 0x00	; 0
    1e7e:	a0 e8       	ldi	r26, 0x80	; 128
    1e80:	bf e3       	ldi	r27, 0x3F	; 63
    1e82:	89 8f       	std	Y+25, r24	; 0x19
    1e84:	9a 8f       	std	Y+26, r25	; 0x1a
    1e86:	ab 8f       	std	Y+27, r26	; 0x1b
    1e88:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1e8a:	69 8d       	ldd	r22, Y+25	; 0x19
    1e8c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1e8e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1e90:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1e92:	20 e0       	ldi	r18, 0x00	; 0
    1e94:	30 e0       	ldi	r19, 0x00	; 0
    1e96:	4a ef       	ldi	r20, 0xFA	; 250
    1e98:	54 e4       	ldi	r21, 0x44	; 68
    1e9a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1e9e:	dc 01       	movw	r26, r24
    1ea0:	cb 01       	movw	r24, r22
    1ea2:	8d 8b       	std	Y+21, r24	; 0x15
    1ea4:	9e 8b       	std	Y+22, r25	; 0x16
    1ea6:	af 8b       	std	Y+23, r26	; 0x17
    1ea8:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1eaa:	6d 89       	ldd	r22, Y+21	; 0x15
    1eac:	7e 89       	ldd	r23, Y+22	; 0x16
    1eae:	8f 89       	ldd	r24, Y+23	; 0x17
    1eb0:	98 8d       	ldd	r25, Y+24	; 0x18
    1eb2:	20 e0       	ldi	r18, 0x00	; 0
    1eb4:	30 e0       	ldi	r19, 0x00	; 0
    1eb6:	40 e8       	ldi	r20, 0x80	; 128
    1eb8:	5f e3       	ldi	r21, 0x3F	; 63
    1eba:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1ebe:	88 23       	and	r24, r24
    1ec0:	2c f4       	brge	.+10     	; 0x1ecc <HLCD4_voidSendCommand+0x1a0>
		__ticks = 1;
    1ec2:	81 e0       	ldi	r24, 0x01	; 1
    1ec4:	90 e0       	ldi	r25, 0x00	; 0
    1ec6:	9c 8b       	std	Y+20, r25	; 0x14
    1ec8:	8b 8b       	std	Y+19, r24	; 0x13
    1eca:	3f c0       	rjmp	.+126    	; 0x1f4a <HLCD4_voidSendCommand+0x21e>
	else if (__tmp > 65535)
    1ecc:	6d 89       	ldd	r22, Y+21	; 0x15
    1ece:	7e 89       	ldd	r23, Y+22	; 0x16
    1ed0:	8f 89       	ldd	r24, Y+23	; 0x17
    1ed2:	98 8d       	ldd	r25, Y+24	; 0x18
    1ed4:	20 e0       	ldi	r18, 0x00	; 0
    1ed6:	3f ef       	ldi	r19, 0xFF	; 255
    1ed8:	4f e7       	ldi	r20, 0x7F	; 127
    1eda:	57 e4       	ldi	r21, 0x47	; 71
    1edc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1ee0:	18 16       	cp	r1, r24
    1ee2:	4c f5       	brge	.+82     	; 0x1f36 <HLCD4_voidSendCommand+0x20a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1ee4:	69 8d       	ldd	r22, Y+25	; 0x19
    1ee6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1ee8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1eea:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1eec:	20 e0       	ldi	r18, 0x00	; 0
    1eee:	30 e0       	ldi	r19, 0x00	; 0
    1ef0:	40 e2       	ldi	r20, 0x20	; 32
    1ef2:	51 e4       	ldi	r21, 0x41	; 65
    1ef4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ef8:	dc 01       	movw	r26, r24
    1efa:	cb 01       	movw	r24, r22
    1efc:	bc 01       	movw	r22, r24
    1efe:	cd 01       	movw	r24, r26
    1f00:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f04:	dc 01       	movw	r26, r24
    1f06:	cb 01       	movw	r24, r22
    1f08:	9c 8b       	std	Y+20, r25	; 0x14
    1f0a:	8b 8b       	std	Y+19, r24	; 0x13
    1f0c:	0f c0       	rjmp	.+30     	; 0x1f2c <HLCD4_voidSendCommand+0x200>
    1f0e:	88 ec       	ldi	r24, 0xC8	; 200
    1f10:	90 e0       	ldi	r25, 0x00	; 0
    1f12:	9a 8b       	std	Y+18, r25	; 0x12
    1f14:	89 8b       	std	Y+17, r24	; 0x11
    1f16:	89 89       	ldd	r24, Y+17	; 0x11
    1f18:	9a 89       	ldd	r25, Y+18	; 0x12
    1f1a:	01 97       	sbiw	r24, 0x01	; 1
    1f1c:	f1 f7       	brne	.-4      	; 0x1f1a <HLCD4_voidSendCommand+0x1ee>
    1f1e:	9a 8b       	std	Y+18, r25	; 0x12
    1f20:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1f22:	8b 89       	ldd	r24, Y+19	; 0x13
    1f24:	9c 89       	ldd	r25, Y+20	; 0x14
    1f26:	01 97       	sbiw	r24, 0x01	; 1
    1f28:	9c 8b       	std	Y+20, r25	; 0x14
    1f2a:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1f2c:	8b 89       	ldd	r24, Y+19	; 0x13
    1f2e:	9c 89       	ldd	r25, Y+20	; 0x14
    1f30:	00 97       	sbiw	r24, 0x00	; 0
    1f32:	69 f7       	brne	.-38     	; 0x1f0e <HLCD4_voidSendCommand+0x1e2>
    1f34:	14 c0       	rjmp	.+40     	; 0x1f5e <HLCD4_voidSendCommand+0x232>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1f36:	6d 89       	ldd	r22, Y+21	; 0x15
    1f38:	7e 89       	ldd	r23, Y+22	; 0x16
    1f3a:	8f 89       	ldd	r24, Y+23	; 0x17
    1f3c:	98 8d       	ldd	r25, Y+24	; 0x18
    1f3e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f42:	dc 01       	movw	r26, r24
    1f44:	cb 01       	movw	r24, r22
    1f46:	9c 8b       	std	Y+20, r25	; 0x14
    1f48:	8b 8b       	std	Y+19, r24	; 0x13
    1f4a:	8b 89       	ldd	r24, Y+19	; 0x13
    1f4c:	9c 89       	ldd	r25, Y+20	; 0x14
    1f4e:	98 8b       	std	Y+16, r25	; 0x10
    1f50:	8f 87       	std	Y+15, r24	; 0x0f
    1f52:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f54:	98 89       	ldd	r25, Y+16	; 0x10
    1f56:	01 97       	sbiw	r24, 0x01	; 1
    1f58:	f1 f7       	brne	.-4      	; 0x1f56 <HLCD4_voidSendCommand+0x22a>
    1f5a:	98 8b       	std	Y+16, r25	; 0x10
    1f5c:	8f 87       	std	Y+15, r24	; 0x0f
        _delay_ms(1);
        MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_LOW);
    1f5e:	82 e0       	ldi	r24, 0x02	; 2
    1f60:	62 e0       	ldi	r22, 0x02	; 2
    1f62:	40 e0       	ldi	r20, 0x00	; 0
    1f64:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    1f68:	80 e0       	ldi	r24, 0x00	; 0
    1f6a:	90 e0       	ldi	r25, 0x00	; 0
    1f6c:	a0 e0       	ldi	r26, 0x00	; 0
    1f6e:	b0 e4       	ldi	r27, 0x40	; 64
    1f70:	8b 87       	std	Y+11, r24	; 0x0b
    1f72:	9c 87       	std	Y+12, r25	; 0x0c
    1f74:	ad 87       	std	Y+13, r26	; 0x0d
    1f76:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1f78:	6b 85       	ldd	r22, Y+11	; 0x0b
    1f7a:	7c 85       	ldd	r23, Y+12	; 0x0c
    1f7c:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f7e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f80:	20 e0       	ldi	r18, 0x00	; 0
    1f82:	30 e0       	ldi	r19, 0x00	; 0
    1f84:	4a ef       	ldi	r20, 0xFA	; 250
    1f86:	54 e4       	ldi	r21, 0x44	; 68
    1f88:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f8c:	dc 01       	movw	r26, r24
    1f8e:	cb 01       	movw	r24, r22
    1f90:	8f 83       	std	Y+7, r24	; 0x07
    1f92:	98 87       	std	Y+8, r25	; 0x08
    1f94:	a9 87       	std	Y+9, r26	; 0x09
    1f96:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1f98:	6f 81       	ldd	r22, Y+7	; 0x07
    1f9a:	78 85       	ldd	r23, Y+8	; 0x08
    1f9c:	89 85       	ldd	r24, Y+9	; 0x09
    1f9e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1fa0:	20 e0       	ldi	r18, 0x00	; 0
    1fa2:	30 e0       	ldi	r19, 0x00	; 0
    1fa4:	40 e8       	ldi	r20, 0x80	; 128
    1fa6:	5f e3       	ldi	r21, 0x3F	; 63
    1fa8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1fac:	88 23       	and	r24, r24
    1fae:	2c f4       	brge	.+10     	; 0x1fba <HLCD4_voidSendCommand+0x28e>
		__ticks = 1;
    1fb0:	81 e0       	ldi	r24, 0x01	; 1
    1fb2:	90 e0       	ldi	r25, 0x00	; 0
    1fb4:	9e 83       	std	Y+6, r25	; 0x06
    1fb6:	8d 83       	std	Y+5, r24	; 0x05
    1fb8:	3f c0       	rjmp	.+126    	; 0x2038 <HLCD4_voidSendCommand+0x30c>
	else if (__tmp > 65535)
    1fba:	6f 81       	ldd	r22, Y+7	; 0x07
    1fbc:	78 85       	ldd	r23, Y+8	; 0x08
    1fbe:	89 85       	ldd	r24, Y+9	; 0x09
    1fc0:	9a 85       	ldd	r25, Y+10	; 0x0a
    1fc2:	20 e0       	ldi	r18, 0x00	; 0
    1fc4:	3f ef       	ldi	r19, 0xFF	; 255
    1fc6:	4f e7       	ldi	r20, 0x7F	; 127
    1fc8:	57 e4       	ldi	r21, 0x47	; 71
    1fca:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1fce:	18 16       	cp	r1, r24
    1fd0:	4c f5       	brge	.+82     	; 0x2024 <HLCD4_voidSendCommand+0x2f8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1fd2:	6b 85       	ldd	r22, Y+11	; 0x0b
    1fd4:	7c 85       	ldd	r23, Y+12	; 0x0c
    1fd6:	8d 85       	ldd	r24, Y+13	; 0x0d
    1fd8:	9e 85       	ldd	r25, Y+14	; 0x0e
    1fda:	20 e0       	ldi	r18, 0x00	; 0
    1fdc:	30 e0       	ldi	r19, 0x00	; 0
    1fde:	40 e2       	ldi	r20, 0x20	; 32
    1fe0:	51 e4       	ldi	r21, 0x41	; 65
    1fe2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1fe6:	dc 01       	movw	r26, r24
    1fe8:	cb 01       	movw	r24, r22
    1fea:	bc 01       	movw	r22, r24
    1fec:	cd 01       	movw	r24, r26
    1fee:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ff2:	dc 01       	movw	r26, r24
    1ff4:	cb 01       	movw	r24, r22
    1ff6:	9e 83       	std	Y+6, r25	; 0x06
    1ff8:	8d 83       	std	Y+5, r24	; 0x05
    1ffa:	0f c0       	rjmp	.+30     	; 0x201a <HLCD4_voidSendCommand+0x2ee>
    1ffc:	88 ec       	ldi	r24, 0xC8	; 200
    1ffe:	90 e0       	ldi	r25, 0x00	; 0
    2000:	9c 83       	std	Y+4, r25	; 0x04
    2002:	8b 83       	std	Y+3, r24	; 0x03
    2004:	8b 81       	ldd	r24, Y+3	; 0x03
    2006:	9c 81       	ldd	r25, Y+4	; 0x04
    2008:	01 97       	sbiw	r24, 0x01	; 1
    200a:	f1 f7       	brne	.-4      	; 0x2008 <HLCD4_voidSendCommand+0x2dc>
    200c:	9c 83       	std	Y+4, r25	; 0x04
    200e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2010:	8d 81       	ldd	r24, Y+5	; 0x05
    2012:	9e 81       	ldd	r25, Y+6	; 0x06
    2014:	01 97       	sbiw	r24, 0x01	; 1
    2016:	9e 83       	std	Y+6, r25	; 0x06
    2018:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    201a:	8d 81       	ldd	r24, Y+5	; 0x05
    201c:	9e 81       	ldd	r25, Y+6	; 0x06
    201e:	00 97       	sbiw	r24, 0x00	; 0
    2020:	69 f7       	brne	.-38     	; 0x1ffc <HLCD4_voidSendCommand+0x2d0>
    2022:	14 c0       	rjmp	.+40     	; 0x204c <HLCD4_voidSendCommand+0x320>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2024:	6f 81       	ldd	r22, Y+7	; 0x07
    2026:	78 85       	ldd	r23, Y+8	; 0x08
    2028:	89 85       	ldd	r24, Y+9	; 0x09
    202a:	9a 85       	ldd	r25, Y+10	; 0x0a
    202c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2030:	dc 01       	movw	r26, r24
    2032:	cb 01       	movw	r24, r22
    2034:	9e 83       	std	Y+6, r25	; 0x06
    2036:	8d 83       	std	Y+5, r24	; 0x05
    2038:	8d 81       	ldd	r24, Y+5	; 0x05
    203a:	9e 81       	ldd	r25, Y+6	; 0x06
    203c:	9a 83       	std	Y+2, r25	; 0x02
    203e:	89 83       	std	Y+1, r24	; 0x01
    2040:	89 81       	ldd	r24, Y+1	; 0x01
    2042:	9a 81       	ldd	r25, Y+2	; 0x02
    2044:	01 97       	sbiw	r24, 0x01	; 1
    2046:	f1 f7       	brne	.-4      	; 0x2044 <HLCD4_voidSendCommand+0x318>
    2048:	9a 83       	std	Y+2, r25	; 0x02
    204a:	89 83       	std	Y+1, r24	; 0x01
    }
    _delay_ms(2);
}
    204c:	ab 96       	adiw	r28, 0x2b	; 43
    204e:	0f b6       	in	r0, 0x3f	; 63
    2050:	f8 94       	cli
    2052:	de bf       	out	0x3e, r29	; 62
    2054:	0f be       	out	0x3f, r0	; 63
    2056:	cd bf       	out	0x3d, r28	; 61
    2058:	cf 91       	pop	r28
    205a:	df 91       	pop	r29
    205c:	08 95       	ret

0000205e <HLCD4_voidSendData>:


void HLCD4_voidSendData(u8 A_u8Data)
{
    205e:	df 93       	push	r29
    2060:	cf 93       	push	r28
    2062:	cd b7       	in	r28, 0x3d	; 61
    2064:	de b7       	in	r29, 0x3e	; 62
    2066:	ab 97       	sbiw	r28, 0x2b	; 43
    2068:	0f b6       	in	r0, 0x3f	; 63
    206a:	f8 94       	cli
    206c:	de bf       	out	0x3e, r29	; 62
    206e:	0f be       	out	0x3f, r0	; 63
    2070:	cd bf       	out	0x3d, r28	; 61
    2072:	8b a7       	std	Y+43, r24	; 0x2b
    //RS=1 RW=0
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,RS_PIN,PIN_HIGH);
    2074:	82 e0       	ldi	r24, 0x02	; 2
    2076:	60 e0       	ldi	r22, 0x00	; 0
    2078:	41 e0       	ldi	r20, 0x01	; 1
    207a:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,RW_PIN,PIN_LOW);
    207e:	82 e0       	ldi	r24, 0x02	; 2
    2080:	61 e0       	ldi	r22, 0x01	; 1
    2082:	40 e0       	ldi	r20, 0x00	; 0
    2084:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>

	MDIO_voidSetPortValue(LCD_DATA_PORT,A_u8Data);
    2088:	83 e0       	ldi	r24, 0x03	; 3
    208a:	6b a5       	ldd	r22, Y+43	; 0x2b
    208c:	0e 94 27 0b 	call	0x164e	; 0x164e <MDIO_voidSetPortValue>


    MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_HIGH);
    2090:	82 e0       	ldi	r24, 0x02	; 2
    2092:	62 e0       	ldi	r22, 0x02	; 2
    2094:	41 e0       	ldi	r20, 0x01	; 1
    2096:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    209a:	80 e0       	ldi	r24, 0x00	; 0
    209c:	90 e0       	ldi	r25, 0x00	; 0
    209e:	a0 e8       	ldi	r26, 0x80	; 128
    20a0:	bf e3       	ldi	r27, 0x3F	; 63
    20a2:	8f a3       	std	Y+39, r24	; 0x27
    20a4:	98 a7       	std	Y+40, r25	; 0x28
    20a6:	a9 a7       	std	Y+41, r26	; 0x29
    20a8:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    20aa:	6f a1       	ldd	r22, Y+39	; 0x27
    20ac:	78 a5       	ldd	r23, Y+40	; 0x28
    20ae:	89 a5       	ldd	r24, Y+41	; 0x29
    20b0:	9a a5       	ldd	r25, Y+42	; 0x2a
    20b2:	20 e0       	ldi	r18, 0x00	; 0
    20b4:	30 e0       	ldi	r19, 0x00	; 0
    20b6:	4a ef       	ldi	r20, 0xFA	; 250
    20b8:	54 e4       	ldi	r21, 0x44	; 68
    20ba:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    20be:	dc 01       	movw	r26, r24
    20c0:	cb 01       	movw	r24, r22
    20c2:	8b a3       	std	Y+35, r24	; 0x23
    20c4:	9c a3       	std	Y+36, r25	; 0x24
    20c6:	ad a3       	std	Y+37, r26	; 0x25
    20c8:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    20ca:	6b a1       	ldd	r22, Y+35	; 0x23
    20cc:	7c a1       	ldd	r23, Y+36	; 0x24
    20ce:	8d a1       	ldd	r24, Y+37	; 0x25
    20d0:	9e a1       	ldd	r25, Y+38	; 0x26
    20d2:	20 e0       	ldi	r18, 0x00	; 0
    20d4:	30 e0       	ldi	r19, 0x00	; 0
    20d6:	40 e8       	ldi	r20, 0x80	; 128
    20d8:	5f e3       	ldi	r21, 0x3F	; 63
    20da:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    20de:	88 23       	and	r24, r24
    20e0:	2c f4       	brge	.+10     	; 0x20ec <HLCD4_voidSendData+0x8e>
		__ticks = 1;
    20e2:	81 e0       	ldi	r24, 0x01	; 1
    20e4:	90 e0       	ldi	r25, 0x00	; 0
    20e6:	9a a3       	std	Y+34, r25	; 0x22
    20e8:	89 a3       	std	Y+33, r24	; 0x21
    20ea:	3f c0       	rjmp	.+126    	; 0x216a <HLCD4_voidSendData+0x10c>
	else if (__tmp > 65535)
    20ec:	6b a1       	ldd	r22, Y+35	; 0x23
    20ee:	7c a1       	ldd	r23, Y+36	; 0x24
    20f0:	8d a1       	ldd	r24, Y+37	; 0x25
    20f2:	9e a1       	ldd	r25, Y+38	; 0x26
    20f4:	20 e0       	ldi	r18, 0x00	; 0
    20f6:	3f ef       	ldi	r19, 0xFF	; 255
    20f8:	4f e7       	ldi	r20, 0x7F	; 127
    20fa:	57 e4       	ldi	r21, 0x47	; 71
    20fc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2100:	18 16       	cp	r1, r24
    2102:	4c f5       	brge	.+82     	; 0x2156 <HLCD4_voidSendData+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2104:	6f a1       	ldd	r22, Y+39	; 0x27
    2106:	78 a5       	ldd	r23, Y+40	; 0x28
    2108:	89 a5       	ldd	r24, Y+41	; 0x29
    210a:	9a a5       	ldd	r25, Y+42	; 0x2a
    210c:	20 e0       	ldi	r18, 0x00	; 0
    210e:	30 e0       	ldi	r19, 0x00	; 0
    2110:	40 e2       	ldi	r20, 0x20	; 32
    2112:	51 e4       	ldi	r21, 0x41	; 65
    2114:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2118:	dc 01       	movw	r26, r24
    211a:	cb 01       	movw	r24, r22
    211c:	bc 01       	movw	r22, r24
    211e:	cd 01       	movw	r24, r26
    2120:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2124:	dc 01       	movw	r26, r24
    2126:	cb 01       	movw	r24, r22
    2128:	9a a3       	std	Y+34, r25	; 0x22
    212a:	89 a3       	std	Y+33, r24	; 0x21
    212c:	0f c0       	rjmp	.+30     	; 0x214c <HLCD4_voidSendData+0xee>
    212e:	88 ec       	ldi	r24, 0xC8	; 200
    2130:	90 e0       	ldi	r25, 0x00	; 0
    2132:	98 a3       	std	Y+32, r25	; 0x20
    2134:	8f 8f       	std	Y+31, r24	; 0x1f
    2136:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2138:	98 a1       	ldd	r25, Y+32	; 0x20
    213a:	01 97       	sbiw	r24, 0x01	; 1
    213c:	f1 f7       	brne	.-4      	; 0x213a <HLCD4_voidSendData+0xdc>
    213e:	98 a3       	std	Y+32, r25	; 0x20
    2140:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2142:	89 a1       	ldd	r24, Y+33	; 0x21
    2144:	9a a1       	ldd	r25, Y+34	; 0x22
    2146:	01 97       	sbiw	r24, 0x01	; 1
    2148:	9a a3       	std	Y+34, r25	; 0x22
    214a:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    214c:	89 a1       	ldd	r24, Y+33	; 0x21
    214e:	9a a1       	ldd	r25, Y+34	; 0x22
    2150:	00 97       	sbiw	r24, 0x00	; 0
    2152:	69 f7       	brne	.-38     	; 0x212e <HLCD4_voidSendData+0xd0>
    2154:	14 c0       	rjmp	.+40     	; 0x217e <HLCD4_voidSendData+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2156:	6b a1       	ldd	r22, Y+35	; 0x23
    2158:	7c a1       	ldd	r23, Y+36	; 0x24
    215a:	8d a1       	ldd	r24, Y+37	; 0x25
    215c:	9e a1       	ldd	r25, Y+38	; 0x26
    215e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2162:	dc 01       	movw	r26, r24
    2164:	cb 01       	movw	r24, r22
    2166:	9a a3       	std	Y+34, r25	; 0x22
    2168:	89 a3       	std	Y+33, r24	; 0x21
    216a:	89 a1       	ldd	r24, Y+33	; 0x21
    216c:	9a a1       	ldd	r25, Y+34	; 0x22
    216e:	9e 8f       	std	Y+30, r25	; 0x1e
    2170:	8d 8f       	std	Y+29, r24	; 0x1d
    2172:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2174:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2176:	01 97       	sbiw	r24, 0x01	; 1
    2178:	f1 f7       	brne	.-4      	; 0x2176 <HLCD4_voidSendData+0x118>
    217a:	9e 8f       	std	Y+30, r25	; 0x1e
    217c:	8d 8f       	std	Y+29, r24	; 0x1d
    _delay_ms(1);
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_LOW);
    217e:	82 e0       	ldi	r24, 0x02	; 2
    2180:	62 e0       	ldi	r22, 0x02	; 2
    2182:	40 e0       	ldi	r20, 0x00	; 0
    2184:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>

    MDIO_voidSetPortValue(LCD_DATA_PORT,A_u8Data<<4);
    2188:	8b a5       	ldd	r24, Y+43	; 0x2b
    218a:	98 2f       	mov	r25, r24
    218c:	92 95       	swap	r25
    218e:	90 7f       	andi	r25, 0xF0	; 240
    2190:	83 e0       	ldi	r24, 0x03	; 3
    2192:	69 2f       	mov	r22, r25
    2194:	0e 94 27 0b 	call	0x164e	; 0x164e <MDIO_voidSetPortValue>


    MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_HIGH);
    2198:	82 e0       	ldi	r24, 0x02	; 2
    219a:	62 e0       	ldi	r22, 0x02	; 2
    219c:	41 e0       	ldi	r20, 0x01	; 1
    219e:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    21a2:	80 e0       	ldi	r24, 0x00	; 0
    21a4:	90 e0       	ldi	r25, 0x00	; 0
    21a6:	a0 e8       	ldi	r26, 0x80	; 128
    21a8:	bf e3       	ldi	r27, 0x3F	; 63
    21aa:	89 8f       	std	Y+25, r24	; 0x19
    21ac:	9a 8f       	std	Y+26, r25	; 0x1a
    21ae:	ab 8f       	std	Y+27, r26	; 0x1b
    21b0:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    21b2:	69 8d       	ldd	r22, Y+25	; 0x19
    21b4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    21b6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    21b8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    21ba:	20 e0       	ldi	r18, 0x00	; 0
    21bc:	30 e0       	ldi	r19, 0x00	; 0
    21be:	4a ef       	ldi	r20, 0xFA	; 250
    21c0:	54 e4       	ldi	r21, 0x44	; 68
    21c2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21c6:	dc 01       	movw	r26, r24
    21c8:	cb 01       	movw	r24, r22
    21ca:	8d 8b       	std	Y+21, r24	; 0x15
    21cc:	9e 8b       	std	Y+22, r25	; 0x16
    21ce:	af 8b       	std	Y+23, r26	; 0x17
    21d0:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    21d2:	6d 89       	ldd	r22, Y+21	; 0x15
    21d4:	7e 89       	ldd	r23, Y+22	; 0x16
    21d6:	8f 89       	ldd	r24, Y+23	; 0x17
    21d8:	98 8d       	ldd	r25, Y+24	; 0x18
    21da:	20 e0       	ldi	r18, 0x00	; 0
    21dc:	30 e0       	ldi	r19, 0x00	; 0
    21de:	40 e8       	ldi	r20, 0x80	; 128
    21e0:	5f e3       	ldi	r21, 0x3F	; 63
    21e2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    21e6:	88 23       	and	r24, r24
    21e8:	2c f4       	brge	.+10     	; 0x21f4 <HLCD4_voidSendData+0x196>
		__ticks = 1;
    21ea:	81 e0       	ldi	r24, 0x01	; 1
    21ec:	90 e0       	ldi	r25, 0x00	; 0
    21ee:	9c 8b       	std	Y+20, r25	; 0x14
    21f0:	8b 8b       	std	Y+19, r24	; 0x13
    21f2:	3f c0       	rjmp	.+126    	; 0x2272 <HLCD4_voidSendData+0x214>
	else if (__tmp > 65535)
    21f4:	6d 89       	ldd	r22, Y+21	; 0x15
    21f6:	7e 89       	ldd	r23, Y+22	; 0x16
    21f8:	8f 89       	ldd	r24, Y+23	; 0x17
    21fa:	98 8d       	ldd	r25, Y+24	; 0x18
    21fc:	20 e0       	ldi	r18, 0x00	; 0
    21fe:	3f ef       	ldi	r19, 0xFF	; 255
    2200:	4f e7       	ldi	r20, 0x7F	; 127
    2202:	57 e4       	ldi	r21, 0x47	; 71
    2204:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2208:	18 16       	cp	r1, r24
    220a:	4c f5       	brge	.+82     	; 0x225e <HLCD4_voidSendData+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    220c:	69 8d       	ldd	r22, Y+25	; 0x19
    220e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2210:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2212:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2214:	20 e0       	ldi	r18, 0x00	; 0
    2216:	30 e0       	ldi	r19, 0x00	; 0
    2218:	40 e2       	ldi	r20, 0x20	; 32
    221a:	51 e4       	ldi	r21, 0x41	; 65
    221c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2220:	dc 01       	movw	r26, r24
    2222:	cb 01       	movw	r24, r22
    2224:	bc 01       	movw	r22, r24
    2226:	cd 01       	movw	r24, r26
    2228:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    222c:	dc 01       	movw	r26, r24
    222e:	cb 01       	movw	r24, r22
    2230:	9c 8b       	std	Y+20, r25	; 0x14
    2232:	8b 8b       	std	Y+19, r24	; 0x13
    2234:	0f c0       	rjmp	.+30     	; 0x2254 <HLCD4_voidSendData+0x1f6>
    2236:	88 ec       	ldi	r24, 0xC8	; 200
    2238:	90 e0       	ldi	r25, 0x00	; 0
    223a:	9a 8b       	std	Y+18, r25	; 0x12
    223c:	89 8b       	std	Y+17, r24	; 0x11
    223e:	89 89       	ldd	r24, Y+17	; 0x11
    2240:	9a 89       	ldd	r25, Y+18	; 0x12
    2242:	01 97       	sbiw	r24, 0x01	; 1
    2244:	f1 f7       	brne	.-4      	; 0x2242 <HLCD4_voidSendData+0x1e4>
    2246:	9a 8b       	std	Y+18, r25	; 0x12
    2248:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    224a:	8b 89       	ldd	r24, Y+19	; 0x13
    224c:	9c 89       	ldd	r25, Y+20	; 0x14
    224e:	01 97       	sbiw	r24, 0x01	; 1
    2250:	9c 8b       	std	Y+20, r25	; 0x14
    2252:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2254:	8b 89       	ldd	r24, Y+19	; 0x13
    2256:	9c 89       	ldd	r25, Y+20	; 0x14
    2258:	00 97       	sbiw	r24, 0x00	; 0
    225a:	69 f7       	brne	.-38     	; 0x2236 <HLCD4_voidSendData+0x1d8>
    225c:	14 c0       	rjmp	.+40     	; 0x2286 <HLCD4_voidSendData+0x228>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    225e:	6d 89       	ldd	r22, Y+21	; 0x15
    2260:	7e 89       	ldd	r23, Y+22	; 0x16
    2262:	8f 89       	ldd	r24, Y+23	; 0x17
    2264:	98 8d       	ldd	r25, Y+24	; 0x18
    2266:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    226a:	dc 01       	movw	r26, r24
    226c:	cb 01       	movw	r24, r22
    226e:	9c 8b       	std	Y+20, r25	; 0x14
    2270:	8b 8b       	std	Y+19, r24	; 0x13
    2272:	8b 89       	ldd	r24, Y+19	; 0x13
    2274:	9c 89       	ldd	r25, Y+20	; 0x14
    2276:	98 8b       	std	Y+16, r25	; 0x10
    2278:	8f 87       	std	Y+15, r24	; 0x0f
    227a:	8f 85       	ldd	r24, Y+15	; 0x0f
    227c:	98 89       	ldd	r25, Y+16	; 0x10
    227e:	01 97       	sbiw	r24, 0x01	; 1
    2280:	f1 f7       	brne	.-4      	; 0x227e <HLCD4_voidSendData+0x220>
    2282:	98 8b       	std	Y+16, r25	; 0x10
    2284:	8f 87       	std	Y+15, r24	; 0x0f
    _delay_ms(1);
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_LOW);
    2286:	82 e0       	ldi	r24, 0x02	; 2
    2288:	62 e0       	ldi	r22, 0x02	; 2
    228a:	40 e0       	ldi	r20, 0x00	; 0
    228c:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    2290:	80 e0       	ldi	r24, 0x00	; 0
    2292:	90 e0       	ldi	r25, 0x00	; 0
    2294:	a0 e0       	ldi	r26, 0x00	; 0
    2296:	b0 e4       	ldi	r27, 0x40	; 64
    2298:	8b 87       	std	Y+11, r24	; 0x0b
    229a:	9c 87       	std	Y+12, r25	; 0x0c
    229c:	ad 87       	std	Y+13, r26	; 0x0d
    229e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    22a0:	6b 85       	ldd	r22, Y+11	; 0x0b
    22a2:	7c 85       	ldd	r23, Y+12	; 0x0c
    22a4:	8d 85       	ldd	r24, Y+13	; 0x0d
    22a6:	9e 85       	ldd	r25, Y+14	; 0x0e
    22a8:	20 e0       	ldi	r18, 0x00	; 0
    22aa:	30 e0       	ldi	r19, 0x00	; 0
    22ac:	4a ef       	ldi	r20, 0xFA	; 250
    22ae:	54 e4       	ldi	r21, 0x44	; 68
    22b0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    22b4:	dc 01       	movw	r26, r24
    22b6:	cb 01       	movw	r24, r22
    22b8:	8f 83       	std	Y+7, r24	; 0x07
    22ba:	98 87       	std	Y+8, r25	; 0x08
    22bc:	a9 87       	std	Y+9, r26	; 0x09
    22be:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    22c0:	6f 81       	ldd	r22, Y+7	; 0x07
    22c2:	78 85       	ldd	r23, Y+8	; 0x08
    22c4:	89 85       	ldd	r24, Y+9	; 0x09
    22c6:	9a 85       	ldd	r25, Y+10	; 0x0a
    22c8:	20 e0       	ldi	r18, 0x00	; 0
    22ca:	30 e0       	ldi	r19, 0x00	; 0
    22cc:	40 e8       	ldi	r20, 0x80	; 128
    22ce:	5f e3       	ldi	r21, 0x3F	; 63
    22d0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    22d4:	88 23       	and	r24, r24
    22d6:	2c f4       	brge	.+10     	; 0x22e2 <HLCD4_voidSendData+0x284>
		__ticks = 1;
    22d8:	81 e0       	ldi	r24, 0x01	; 1
    22da:	90 e0       	ldi	r25, 0x00	; 0
    22dc:	9e 83       	std	Y+6, r25	; 0x06
    22de:	8d 83       	std	Y+5, r24	; 0x05
    22e0:	3f c0       	rjmp	.+126    	; 0x2360 <HLCD4_voidSendData+0x302>
	else if (__tmp > 65535)
    22e2:	6f 81       	ldd	r22, Y+7	; 0x07
    22e4:	78 85       	ldd	r23, Y+8	; 0x08
    22e6:	89 85       	ldd	r24, Y+9	; 0x09
    22e8:	9a 85       	ldd	r25, Y+10	; 0x0a
    22ea:	20 e0       	ldi	r18, 0x00	; 0
    22ec:	3f ef       	ldi	r19, 0xFF	; 255
    22ee:	4f e7       	ldi	r20, 0x7F	; 127
    22f0:	57 e4       	ldi	r21, 0x47	; 71
    22f2:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    22f6:	18 16       	cp	r1, r24
    22f8:	4c f5       	brge	.+82     	; 0x234c <HLCD4_voidSendData+0x2ee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    22fa:	6b 85       	ldd	r22, Y+11	; 0x0b
    22fc:	7c 85       	ldd	r23, Y+12	; 0x0c
    22fe:	8d 85       	ldd	r24, Y+13	; 0x0d
    2300:	9e 85       	ldd	r25, Y+14	; 0x0e
    2302:	20 e0       	ldi	r18, 0x00	; 0
    2304:	30 e0       	ldi	r19, 0x00	; 0
    2306:	40 e2       	ldi	r20, 0x20	; 32
    2308:	51 e4       	ldi	r21, 0x41	; 65
    230a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    230e:	dc 01       	movw	r26, r24
    2310:	cb 01       	movw	r24, r22
    2312:	bc 01       	movw	r22, r24
    2314:	cd 01       	movw	r24, r26
    2316:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    231a:	dc 01       	movw	r26, r24
    231c:	cb 01       	movw	r24, r22
    231e:	9e 83       	std	Y+6, r25	; 0x06
    2320:	8d 83       	std	Y+5, r24	; 0x05
    2322:	0f c0       	rjmp	.+30     	; 0x2342 <HLCD4_voidSendData+0x2e4>
    2324:	88 ec       	ldi	r24, 0xC8	; 200
    2326:	90 e0       	ldi	r25, 0x00	; 0
    2328:	9c 83       	std	Y+4, r25	; 0x04
    232a:	8b 83       	std	Y+3, r24	; 0x03
    232c:	8b 81       	ldd	r24, Y+3	; 0x03
    232e:	9c 81       	ldd	r25, Y+4	; 0x04
    2330:	01 97       	sbiw	r24, 0x01	; 1
    2332:	f1 f7       	brne	.-4      	; 0x2330 <HLCD4_voidSendData+0x2d2>
    2334:	9c 83       	std	Y+4, r25	; 0x04
    2336:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2338:	8d 81       	ldd	r24, Y+5	; 0x05
    233a:	9e 81       	ldd	r25, Y+6	; 0x06
    233c:	01 97       	sbiw	r24, 0x01	; 1
    233e:	9e 83       	std	Y+6, r25	; 0x06
    2340:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2342:	8d 81       	ldd	r24, Y+5	; 0x05
    2344:	9e 81       	ldd	r25, Y+6	; 0x06
    2346:	00 97       	sbiw	r24, 0x00	; 0
    2348:	69 f7       	brne	.-38     	; 0x2324 <HLCD4_voidSendData+0x2c6>
    234a:	14 c0       	rjmp	.+40     	; 0x2374 <HLCD4_voidSendData+0x316>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    234c:	6f 81       	ldd	r22, Y+7	; 0x07
    234e:	78 85       	ldd	r23, Y+8	; 0x08
    2350:	89 85       	ldd	r24, Y+9	; 0x09
    2352:	9a 85       	ldd	r25, Y+10	; 0x0a
    2354:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2358:	dc 01       	movw	r26, r24
    235a:	cb 01       	movw	r24, r22
    235c:	9e 83       	std	Y+6, r25	; 0x06
    235e:	8d 83       	std	Y+5, r24	; 0x05
    2360:	8d 81       	ldd	r24, Y+5	; 0x05
    2362:	9e 81       	ldd	r25, Y+6	; 0x06
    2364:	9a 83       	std	Y+2, r25	; 0x02
    2366:	89 83       	std	Y+1, r24	; 0x01
    2368:	89 81       	ldd	r24, Y+1	; 0x01
    236a:	9a 81       	ldd	r25, Y+2	; 0x02
    236c:	01 97       	sbiw	r24, 0x01	; 1
    236e:	f1 f7       	brne	.-4      	; 0x236c <HLCD4_voidSendData+0x30e>
    2370:	9a 83       	std	Y+2, r25	; 0x02
    2372:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(2);
}
    2374:	ab 96       	adiw	r28, 0x2b	; 43
    2376:	0f b6       	in	r0, 0x3f	; 63
    2378:	f8 94       	cli
    237a:	de bf       	out	0x3e, r29	; 62
    237c:	0f be       	out	0x3f, r0	; 63
    237e:	cd bf       	out	0x3d, r28	; 61
    2380:	cf 91       	pop	r28
    2382:	df 91       	pop	r29
    2384:	08 95       	ret

00002386 <HLCD4_voidInit>:



void HLCD4_voidInit()
{
    2386:	0f 93       	push	r16
    2388:	1f 93       	push	r17
    238a:	df 93       	push	r29
    238c:	cf 93       	push	r28
    238e:	cd b7       	in	r28, 0x3d	; 61
    2390:	de b7       	in	r29, 0x3e	; 62
    2392:	cc 54       	subi	r28, 0x4C	; 76
    2394:	d0 40       	sbci	r29, 0x00	; 0
    2396:	0f b6       	in	r0, 0x3f	; 63
    2398:	f8 94       	cli
    239a:	de bf       	out	0x3e, r29	; 62
    239c:	0f be       	out	0x3f, r0	; 63
    239e:	cd bf       	out	0x3d, r28	; 61
    23a0:	fe 01       	movw	r30, r28
    23a2:	e7 5b       	subi	r30, 0xB7	; 183
    23a4:	ff 4f       	sbci	r31, 0xFF	; 255
    23a6:	80 e0       	ldi	r24, 0x00	; 0
    23a8:	90 e0       	ldi	r25, 0x00	; 0
    23aa:	a0 ef       	ldi	r26, 0xF0	; 240
    23ac:	b1 e4       	ldi	r27, 0x41	; 65
    23ae:	80 83       	st	Z, r24
    23b0:	91 83       	std	Z+1, r25	; 0x01
    23b2:	a2 83       	std	Z+2, r26	; 0x02
    23b4:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    23b6:	8e 01       	movw	r16, r28
    23b8:	0b 5b       	subi	r16, 0xBB	; 187
    23ba:	1f 4f       	sbci	r17, 0xFF	; 255
    23bc:	fe 01       	movw	r30, r28
    23be:	e7 5b       	subi	r30, 0xB7	; 183
    23c0:	ff 4f       	sbci	r31, 0xFF	; 255
    23c2:	60 81       	ld	r22, Z
    23c4:	71 81       	ldd	r23, Z+1	; 0x01
    23c6:	82 81       	ldd	r24, Z+2	; 0x02
    23c8:	93 81       	ldd	r25, Z+3	; 0x03
    23ca:	20 e0       	ldi	r18, 0x00	; 0
    23cc:	30 e0       	ldi	r19, 0x00	; 0
    23ce:	4a ef       	ldi	r20, 0xFA	; 250
    23d0:	54 e4       	ldi	r21, 0x44	; 68
    23d2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    23d6:	dc 01       	movw	r26, r24
    23d8:	cb 01       	movw	r24, r22
    23da:	f8 01       	movw	r30, r16
    23dc:	80 83       	st	Z, r24
    23de:	91 83       	std	Z+1, r25	; 0x01
    23e0:	a2 83       	std	Z+2, r26	; 0x02
    23e2:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    23e4:	fe 01       	movw	r30, r28
    23e6:	eb 5b       	subi	r30, 0xBB	; 187
    23e8:	ff 4f       	sbci	r31, 0xFF	; 255
    23ea:	60 81       	ld	r22, Z
    23ec:	71 81       	ldd	r23, Z+1	; 0x01
    23ee:	82 81       	ldd	r24, Z+2	; 0x02
    23f0:	93 81       	ldd	r25, Z+3	; 0x03
    23f2:	20 e0       	ldi	r18, 0x00	; 0
    23f4:	30 e0       	ldi	r19, 0x00	; 0
    23f6:	40 e8       	ldi	r20, 0x80	; 128
    23f8:	5f e3       	ldi	r21, 0x3F	; 63
    23fa:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    23fe:	88 23       	and	r24, r24
    2400:	44 f4       	brge	.+16     	; 0x2412 <HLCD4_voidInit+0x8c>
		__ticks = 1;
    2402:	fe 01       	movw	r30, r28
    2404:	ed 5b       	subi	r30, 0xBD	; 189
    2406:	ff 4f       	sbci	r31, 0xFF	; 255
    2408:	81 e0       	ldi	r24, 0x01	; 1
    240a:	90 e0       	ldi	r25, 0x00	; 0
    240c:	91 83       	std	Z+1, r25	; 0x01
    240e:	80 83       	st	Z, r24
    2410:	64 c0       	rjmp	.+200    	; 0x24da <HLCD4_voidInit+0x154>
	else if (__tmp > 65535)
    2412:	fe 01       	movw	r30, r28
    2414:	eb 5b       	subi	r30, 0xBB	; 187
    2416:	ff 4f       	sbci	r31, 0xFF	; 255
    2418:	60 81       	ld	r22, Z
    241a:	71 81       	ldd	r23, Z+1	; 0x01
    241c:	82 81       	ldd	r24, Z+2	; 0x02
    241e:	93 81       	ldd	r25, Z+3	; 0x03
    2420:	20 e0       	ldi	r18, 0x00	; 0
    2422:	3f ef       	ldi	r19, 0xFF	; 255
    2424:	4f e7       	ldi	r20, 0x7F	; 127
    2426:	57 e4       	ldi	r21, 0x47	; 71
    2428:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    242c:	18 16       	cp	r1, r24
    242e:	0c f0       	brlt	.+2      	; 0x2432 <HLCD4_voidInit+0xac>
    2430:	43 c0       	rjmp	.+134    	; 0x24b8 <HLCD4_voidInit+0x132>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2432:	fe 01       	movw	r30, r28
    2434:	e7 5b       	subi	r30, 0xB7	; 183
    2436:	ff 4f       	sbci	r31, 0xFF	; 255
    2438:	60 81       	ld	r22, Z
    243a:	71 81       	ldd	r23, Z+1	; 0x01
    243c:	82 81       	ldd	r24, Z+2	; 0x02
    243e:	93 81       	ldd	r25, Z+3	; 0x03
    2440:	20 e0       	ldi	r18, 0x00	; 0
    2442:	30 e0       	ldi	r19, 0x00	; 0
    2444:	40 e2       	ldi	r20, 0x20	; 32
    2446:	51 e4       	ldi	r21, 0x41	; 65
    2448:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    244c:	dc 01       	movw	r26, r24
    244e:	cb 01       	movw	r24, r22
    2450:	8e 01       	movw	r16, r28
    2452:	0d 5b       	subi	r16, 0xBD	; 189
    2454:	1f 4f       	sbci	r17, 0xFF	; 255
    2456:	bc 01       	movw	r22, r24
    2458:	cd 01       	movw	r24, r26
    245a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    245e:	dc 01       	movw	r26, r24
    2460:	cb 01       	movw	r24, r22
    2462:	f8 01       	movw	r30, r16
    2464:	91 83       	std	Z+1, r25	; 0x01
    2466:	80 83       	st	Z, r24
    2468:	1f c0       	rjmp	.+62     	; 0x24a8 <HLCD4_voidInit+0x122>
    246a:	fe 01       	movw	r30, r28
    246c:	ef 5b       	subi	r30, 0xBF	; 191
    246e:	ff 4f       	sbci	r31, 0xFF	; 255
    2470:	88 ec       	ldi	r24, 0xC8	; 200
    2472:	90 e0       	ldi	r25, 0x00	; 0
    2474:	91 83       	std	Z+1, r25	; 0x01
    2476:	80 83       	st	Z, r24
    2478:	fe 01       	movw	r30, r28
    247a:	ef 5b       	subi	r30, 0xBF	; 191
    247c:	ff 4f       	sbci	r31, 0xFF	; 255
    247e:	80 81       	ld	r24, Z
    2480:	91 81       	ldd	r25, Z+1	; 0x01
    2482:	01 97       	sbiw	r24, 0x01	; 1
    2484:	f1 f7       	brne	.-4      	; 0x2482 <HLCD4_voidInit+0xfc>
    2486:	fe 01       	movw	r30, r28
    2488:	ef 5b       	subi	r30, 0xBF	; 191
    248a:	ff 4f       	sbci	r31, 0xFF	; 255
    248c:	91 83       	std	Z+1, r25	; 0x01
    248e:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2490:	de 01       	movw	r26, r28
    2492:	ad 5b       	subi	r26, 0xBD	; 189
    2494:	bf 4f       	sbci	r27, 0xFF	; 255
    2496:	fe 01       	movw	r30, r28
    2498:	ed 5b       	subi	r30, 0xBD	; 189
    249a:	ff 4f       	sbci	r31, 0xFF	; 255
    249c:	80 81       	ld	r24, Z
    249e:	91 81       	ldd	r25, Z+1	; 0x01
    24a0:	01 97       	sbiw	r24, 0x01	; 1
    24a2:	11 96       	adiw	r26, 0x01	; 1
    24a4:	9c 93       	st	X, r25
    24a6:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    24a8:	fe 01       	movw	r30, r28
    24aa:	ed 5b       	subi	r30, 0xBD	; 189
    24ac:	ff 4f       	sbci	r31, 0xFF	; 255
    24ae:	80 81       	ld	r24, Z
    24b0:	91 81       	ldd	r25, Z+1	; 0x01
    24b2:	00 97       	sbiw	r24, 0x00	; 0
    24b4:	d1 f6       	brne	.-76     	; 0x246a <HLCD4_voidInit+0xe4>
    24b6:	24 c0       	rjmp	.+72     	; 0x2500 <HLCD4_voidInit+0x17a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    24b8:	8e 01       	movw	r16, r28
    24ba:	0d 5b       	subi	r16, 0xBD	; 189
    24bc:	1f 4f       	sbci	r17, 0xFF	; 255
    24be:	fe 01       	movw	r30, r28
    24c0:	eb 5b       	subi	r30, 0xBB	; 187
    24c2:	ff 4f       	sbci	r31, 0xFF	; 255
    24c4:	60 81       	ld	r22, Z
    24c6:	71 81       	ldd	r23, Z+1	; 0x01
    24c8:	82 81       	ldd	r24, Z+2	; 0x02
    24ca:	93 81       	ldd	r25, Z+3	; 0x03
    24cc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    24d0:	dc 01       	movw	r26, r24
    24d2:	cb 01       	movw	r24, r22
    24d4:	f8 01       	movw	r30, r16
    24d6:	91 83       	std	Z+1, r25	; 0x01
    24d8:	80 83       	st	Z, r24
    24da:	fe 01       	movw	r30, r28
    24dc:	ed 5b       	subi	r30, 0xBD	; 189
    24de:	ff 4f       	sbci	r31, 0xFF	; 255
    24e0:	80 81       	ld	r24, Z
    24e2:	91 81       	ldd	r25, Z+1	; 0x01
    24e4:	fe 01       	movw	r30, r28
    24e6:	ff 96       	adiw	r30, 0x3f	; 63
    24e8:	91 83       	std	Z+1, r25	; 0x01
    24ea:	80 83       	st	Z, r24
    24ec:	fe 01       	movw	r30, r28
    24ee:	ff 96       	adiw	r30, 0x3f	; 63
    24f0:	80 81       	ld	r24, Z
    24f2:	91 81       	ldd	r25, Z+1	; 0x01
    24f4:	01 97       	sbiw	r24, 0x01	; 1
    24f6:	f1 f7       	brne	.-4      	; 0x24f4 <HLCD4_voidInit+0x16e>
    24f8:	fe 01       	movw	r30, r28
    24fa:	ff 96       	adiw	r30, 0x3f	; 63
    24fc:	91 83       	std	Z+1, r25	; 0x01
    24fe:	80 83       	st	Z, r24
    _delay_ms(30);
    HLCD4_voidSendCommand(FUNCTION_SET1);
    2500:	80 e2       	ldi	r24, 0x20	; 32
    2502:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <HLCD4_voidSendCommand>
    HLCD4_voidSendCommand(FUNCTION_SET2);
    2506:	80 e2       	ldi	r24, 0x20	; 32
    2508:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <HLCD4_voidSendCommand>
    HLCD4_voidSendCommand(FUNCTION_SET3);
    250c:	80 e8       	ldi	r24, 0x80	; 128
    250e:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <HLCD4_voidSendCommand>
    2512:	80 e0       	ldi	r24, 0x00	; 0
    2514:	90 e0       	ldi	r25, 0x00	; 0
    2516:	a0 e2       	ldi	r26, 0x20	; 32
    2518:	b2 e4       	ldi	r27, 0x42	; 66
    251a:	8b af       	std	Y+59, r24	; 0x3b
    251c:	9c af       	std	Y+60, r25	; 0x3c
    251e:	ad af       	std	Y+61, r26	; 0x3d
    2520:	be af       	std	Y+62, r27	; 0x3e
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    2522:	6b ad       	ldd	r22, Y+59	; 0x3b
    2524:	7c ad       	ldd	r23, Y+60	; 0x3c
    2526:	8d ad       	ldd	r24, Y+61	; 0x3d
    2528:	9e ad       	ldd	r25, Y+62	; 0x3e
    252a:	2b ea       	ldi	r18, 0xAB	; 171
    252c:	3a ea       	ldi	r19, 0xAA	; 170
    252e:	4a e2       	ldi	r20, 0x2A	; 42
    2530:	50 e4       	ldi	r21, 0x40	; 64
    2532:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2536:	dc 01       	movw	r26, r24
    2538:	cb 01       	movw	r24, r22
    253a:	8f ab       	std	Y+55, r24	; 0x37
    253c:	98 af       	std	Y+56, r25	; 0x38
    253e:	a9 af       	std	Y+57, r26	; 0x39
    2540:	ba af       	std	Y+58, r27	; 0x3a
	if (__tmp < 1.0)
    2542:	6f a9       	ldd	r22, Y+55	; 0x37
    2544:	78 ad       	ldd	r23, Y+56	; 0x38
    2546:	89 ad       	ldd	r24, Y+57	; 0x39
    2548:	9a ad       	ldd	r25, Y+58	; 0x3a
    254a:	20 e0       	ldi	r18, 0x00	; 0
    254c:	30 e0       	ldi	r19, 0x00	; 0
    254e:	40 e8       	ldi	r20, 0x80	; 128
    2550:	5f e3       	ldi	r21, 0x3F	; 63
    2552:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2556:	88 23       	and	r24, r24
    2558:	1c f4       	brge	.+6      	; 0x2560 <HLCD4_voidInit+0x1da>
		__ticks = 1;
    255a:	81 e0       	ldi	r24, 0x01	; 1
    255c:	8e ab       	std	Y+54, r24	; 0x36
    255e:	91 c0       	rjmp	.+290    	; 0x2682 <HLCD4_voidInit+0x2fc>
	else if (__tmp > 255)
    2560:	6f a9       	ldd	r22, Y+55	; 0x37
    2562:	78 ad       	ldd	r23, Y+56	; 0x38
    2564:	89 ad       	ldd	r24, Y+57	; 0x39
    2566:	9a ad       	ldd	r25, Y+58	; 0x3a
    2568:	20 e0       	ldi	r18, 0x00	; 0
    256a:	30 e0       	ldi	r19, 0x00	; 0
    256c:	4f e7       	ldi	r20, 0x7F	; 127
    256e:	53 e4       	ldi	r21, 0x43	; 67
    2570:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2574:	18 16       	cp	r1, r24
    2576:	0c f0       	brlt	.+2      	; 0x257a <HLCD4_voidInit+0x1f4>
    2578:	7b c0       	rjmp	.+246    	; 0x2670 <HLCD4_voidInit+0x2ea>
	{
		_delay_ms(__us / 1000.0);
    257a:	6b ad       	ldd	r22, Y+59	; 0x3b
    257c:	7c ad       	ldd	r23, Y+60	; 0x3c
    257e:	8d ad       	ldd	r24, Y+61	; 0x3d
    2580:	9e ad       	ldd	r25, Y+62	; 0x3e
    2582:	20 e0       	ldi	r18, 0x00	; 0
    2584:	30 e0       	ldi	r19, 0x00	; 0
    2586:	4a e7       	ldi	r20, 0x7A	; 122
    2588:	54 e4       	ldi	r21, 0x44	; 68
    258a:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    258e:	dc 01       	movw	r26, r24
    2590:	cb 01       	movw	r24, r22
    2592:	8a ab       	std	Y+50, r24	; 0x32
    2594:	9b ab       	std	Y+51, r25	; 0x33
    2596:	ac ab       	std	Y+52, r26	; 0x34
    2598:	bd ab       	std	Y+53, r27	; 0x35
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    259a:	6a a9       	ldd	r22, Y+50	; 0x32
    259c:	7b a9       	ldd	r23, Y+51	; 0x33
    259e:	8c a9       	ldd	r24, Y+52	; 0x34
    25a0:	9d a9       	ldd	r25, Y+53	; 0x35
    25a2:	20 e0       	ldi	r18, 0x00	; 0
    25a4:	30 e0       	ldi	r19, 0x00	; 0
    25a6:	4a ef       	ldi	r20, 0xFA	; 250
    25a8:	54 e4       	ldi	r21, 0x44	; 68
    25aa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    25ae:	dc 01       	movw	r26, r24
    25b0:	cb 01       	movw	r24, r22
    25b2:	8e a7       	std	Y+46, r24	; 0x2e
    25b4:	9f a7       	std	Y+47, r25	; 0x2f
    25b6:	a8 ab       	std	Y+48, r26	; 0x30
    25b8:	b9 ab       	std	Y+49, r27	; 0x31
	if (__tmp < 1.0)
    25ba:	6e a5       	ldd	r22, Y+46	; 0x2e
    25bc:	7f a5       	ldd	r23, Y+47	; 0x2f
    25be:	88 a9       	ldd	r24, Y+48	; 0x30
    25c0:	99 a9       	ldd	r25, Y+49	; 0x31
    25c2:	20 e0       	ldi	r18, 0x00	; 0
    25c4:	30 e0       	ldi	r19, 0x00	; 0
    25c6:	40 e8       	ldi	r20, 0x80	; 128
    25c8:	5f e3       	ldi	r21, 0x3F	; 63
    25ca:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    25ce:	88 23       	and	r24, r24
    25d0:	2c f4       	brge	.+10     	; 0x25dc <HLCD4_voidInit+0x256>
		__ticks = 1;
    25d2:	81 e0       	ldi	r24, 0x01	; 1
    25d4:	90 e0       	ldi	r25, 0x00	; 0
    25d6:	9d a7       	std	Y+45, r25	; 0x2d
    25d8:	8c a7       	std	Y+44, r24	; 0x2c
    25da:	3f c0       	rjmp	.+126    	; 0x265a <HLCD4_voidInit+0x2d4>
	else if (__tmp > 65535)
    25dc:	6e a5       	ldd	r22, Y+46	; 0x2e
    25de:	7f a5       	ldd	r23, Y+47	; 0x2f
    25e0:	88 a9       	ldd	r24, Y+48	; 0x30
    25e2:	99 a9       	ldd	r25, Y+49	; 0x31
    25e4:	20 e0       	ldi	r18, 0x00	; 0
    25e6:	3f ef       	ldi	r19, 0xFF	; 255
    25e8:	4f e7       	ldi	r20, 0x7F	; 127
    25ea:	57 e4       	ldi	r21, 0x47	; 71
    25ec:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    25f0:	18 16       	cp	r1, r24
    25f2:	4c f5       	brge	.+82     	; 0x2646 <HLCD4_voidInit+0x2c0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    25f4:	6a a9       	ldd	r22, Y+50	; 0x32
    25f6:	7b a9       	ldd	r23, Y+51	; 0x33
    25f8:	8c a9       	ldd	r24, Y+52	; 0x34
    25fa:	9d a9       	ldd	r25, Y+53	; 0x35
    25fc:	20 e0       	ldi	r18, 0x00	; 0
    25fe:	30 e0       	ldi	r19, 0x00	; 0
    2600:	40 e2       	ldi	r20, 0x20	; 32
    2602:	51 e4       	ldi	r21, 0x41	; 65
    2604:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2608:	dc 01       	movw	r26, r24
    260a:	cb 01       	movw	r24, r22
    260c:	bc 01       	movw	r22, r24
    260e:	cd 01       	movw	r24, r26
    2610:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2614:	dc 01       	movw	r26, r24
    2616:	cb 01       	movw	r24, r22
    2618:	9d a7       	std	Y+45, r25	; 0x2d
    261a:	8c a7       	std	Y+44, r24	; 0x2c
    261c:	0f c0       	rjmp	.+30     	; 0x263c <HLCD4_voidInit+0x2b6>
    261e:	88 ec       	ldi	r24, 0xC8	; 200
    2620:	90 e0       	ldi	r25, 0x00	; 0
    2622:	9b a7       	std	Y+43, r25	; 0x2b
    2624:	8a a7       	std	Y+42, r24	; 0x2a
    2626:	8a a5       	ldd	r24, Y+42	; 0x2a
    2628:	9b a5       	ldd	r25, Y+43	; 0x2b
    262a:	01 97       	sbiw	r24, 0x01	; 1
    262c:	f1 f7       	brne	.-4      	; 0x262a <HLCD4_voidInit+0x2a4>
    262e:	9b a7       	std	Y+43, r25	; 0x2b
    2630:	8a a7       	std	Y+42, r24	; 0x2a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2632:	8c a5       	ldd	r24, Y+44	; 0x2c
    2634:	9d a5       	ldd	r25, Y+45	; 0x2d
    2636:	01 97       	sbiw	r24, 0x01	; 1
    2638:	9d a7       	std	Y+45, r25	; 0x2d
    263a:	8c a7       	std	Y+44, r24	; 0x2c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    263c:	8c a5       	ldd	r24, Y+44	; 0x2c
    263e:	9d a5       	ldd	r25, Y+45	; 0x2d
    2640:	00 97       	sbiw	r24, 0x00	; 0
    2642:	69 f7       	brne	.-38     	; 0x261e <HLCD4_voidInit+0x298>
    2644:	24 c0       	rjmp	.+72     	; 0x268e <HLCD4_voidInit+0x308>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2646:	6e a5       	ldd	r22, Y+46	; 0x2e
    2648:	7f a5       	ldd	r23, Y+47	; 0x2f
    264a:	88 a9       	ldd	r24, Y+48	; 0x30
    264c:	99 a9       	ldd	r25, Y+49	; 0x31
    264e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2652:	dc 01       	movw	r26, r24
    2654:	cb 01       	movw	r24, r22
    2656:	9d a7       	std	Y+45, r25	; 0x2d
    2658:	8c a7       	std	Y+44, r24	; 0x2c
    265a:	8c a5       	ldd	r24, Y+44	; 0x2c
    265c:	9d a5       	ldd	r25, Y+45	; 0x2d
    265e:	99 a7       	std	Y+41, r25	; 0x29
    2660:	88 a7       	std	Y+40, r24	; 0x28
    2662:	88 a5       	ldd	r24, Y+40	; 0x28
    2664:	99 a5       	ldd	r25, Y+41	; 0x29
    2666:	01 97       	sbiw	r24, 0x01	; 1
    2668:	f1 f7       	brne	.-4      	; 0x2666 <HLCD4_voidInit+0x2e0>
    266a:	99 a7       	std	Y+41, r25	; 0x29
    266c:	88 a7       	std	Y+40, r24	; 0x28
    266e:	0f c0       	rjmp	.+30     	; 0x268e <HLCD4_voidInit+0x308>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    2670:	6f a9       	ldd	r22, Y+55	; 0x37
    2672:	78 ad       	ldd	r23, Y+56	; 0x38
    2674:	89 ad       	ldd	r24, Y+57	; 0x39
    2676:	9a ad       	ldd	r25, Y+58	; 0x3a
    2678:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    267c:	dc 01       	movw	r26, r24
    267e:	cb 01       	movw	r24, r22
    2680:	8e ab       	std	Y+54, r24	; 0x36
    2682:	8e a9       	ldd	r24, Y+54	; 0x36
    2684:	8f a3       	std	Y+39, r24	; 0x27
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2686:	8f a1       	ldd	r24, Y+39	; 0x27
    2688:	8a 95       	dec	r24
    268a:	f1 f7       	brne	.-4      	; 0x2688 <HLCD4_voidInit+0x302>
    268c:	8f a3       	std	Y+39, r24	; 0x27
    _delay_us(40);
    HLCD4_voidSendCommand(ON_OFF_CONTROL1);
    268e:	80 e0       	ldi	r24, 0x00	; 0
    2690:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <HLCD4_voidSendCommand>
    HLCD4_voidSendCommand(ON_OFF_CONTROL2);
    2694:	80 ec       	ldi	r24, 0xC0	; 192
    2696:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <HLCD4_voidSendCommand>
    269a:	80 e0       	ldi	r24, 0x00	; 0
    269c:	90 e0       	ldi	r25, 0x00	; 0
    269e:	a0 e2       	ldi	r26, 0x20	; 32
    26a0:	b2 e4       	ldi	r27, 0x42	; 66
    26a2:	8b a3       	std	Y+35, r24	; 0x23
    26a4:	9c a3       	std	Y+36, r25	; 0x24
    26a6:	ad a3       	std	Y+37, r26	; 0x25
    26a8:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    26aa:	6b a1       	ldd	r22, Y+35	; 0x23
    26ac:	7c a1       	ldd	r23, Y+36	; 0x24
    26ae:	8d a1       	ldd	r24, Y+37	; 0x25
    26b0:	9e a1       	ldd	r25, Y+38	; 0x26
    26b2:	2b ea       	ldi	r18, 0xAB	; 171
    26b4:	3a ea       	ldi	r19, 0xAA	; 170
    26b6:	4a e2       	ldi	r20, 0x2A	; 42
    26b8:	50 e4       	ldi	r21, 0x40	; 64
    26ba:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    26be:	dc 01       	movw	r26, r24
    26c0:	cb 01       	movw	r24, r22
    26c2:	8f 8f       	std	Y+31, r24	; 0x1f
    26c4:	98 a3       	std	Y+32, r25	; 0x20
    26c6:	a9 a3       	std	Y+33, r26	; 0x21
    26c8:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    26ca:	6f 8d       	ldd	r22, Y+31	; 0x1f
    26cc:	78 a1       	ldd	r23, Y+32	; 0x20
    26ce:	89 a1       	ldd	r24, Y+33	; 0x21
    26d0:	9a a1       	ldd	r25, Y+34	; 0x22
    26d2:	20 e0       	ldi	r18, 0x00	; 0
    26d4:	30 e0       	ldi	r19, 0x00	; 0
    26d6:	40 e8       	ldi	r20, 0x80	; 128
    26d8:	5f e3       	ldi	r21, 0x3F	; 63
    26da:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    26de:	88 23       	and	r24, r24
    26e0:	1c f4       	brge	.+6      	; 0x26e8 <HLCD4_voidInit+0x362>
		__ticks = 1;
    26e2:	81 e0       	ldi	r24, 0x01	; 1
    26e4:	8e 8f       	std	Y+30, r24	; 0x1e
    26e6:	91 c0       	rjmp	.+290    	; 0x280a <HLCD4_voidInit+0x484>
	else if (__tmp > 255)
    26e8:	6f 8d       	ldd	r22, Y+31	; 0x1f
    26ea:	78 a1       	ldd	r23, Y+32	; 0x20
    26ec:	89 a1       	ldd	r24, Y+33	; 0x21
    26ee:	9a a1       	ldd	r25, Y+34	; 0x22
    26f0:	20 e0       	ldi	r18, 0x00	; 0
    26f2:	30 e0       	ldi	r19, 0x00	; 0
    26f4:	4f e7       	ldi	r20, 0x7F	; 127
    26f6:	53 e4       	ldi	r21, 0x43	; 67
    26f8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    26fc:	18 16       	cp	r1, r24
    26fe:	0c f0       	brlt	.+2      	; 0x2702 <HLCD4_voidInit+0x37c>
    2700:	7b c0       	rjmp	.+246    	; 0x27f8 <HLCD4_voidInit+0x472>
	{
		_delay_ms(__us / 1000.0);
    2702:	6b a1       	ldd	r22, Y+35	; 0x23
    2704:	7c a1       	ldd	r23, Y+36	; 0x24
    2706:	8d a1       	ldd	r24, Y+37	; 0x25
    2708:	9e a1       	ldd	r25, Y+38	; 0x26
    270a:	20 e0       	ldi	r18, 0x00	; 0
    270c:	30 e0       	ldi	r19, 0x00	; 0
    270e:	4a e7       	ldi	r20, 0x7A	; 122
    2710:	54 e4       	ldi	r21, 0x44	; 68
    2712:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    2716:	dc 01       	movw	r26, r24
    2718:	cb 01       	movw	r24, r22
    271a:	8a 8f       	std	Y+26, r24	; 0x1a
    271c:	9b 8f       	std	Y+27, r25	; 0x1b
    271e:	ac 8f       	std	Y+28, r26	; 0x1c
    2720:	bd 8f       	std	Y+29, r27	; 0x1d
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2722:	6a 8d       	ldd	r22, Y+26	; 0x1a
    2724:	7b 8d       	ldd	r23, Y+27	; 0x1b
    2726:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2728:	9d 8d       	ldd	r25, Y+29	; 0x1d
    272a:	20 e0       	ldi	r18, 0x00	; 0
    272c:	30 e0       	ldi	r19, 0x00	; 0
    272e:	4a ef       	ldi	r20, 0xFA	; 250
    2730:	54 e4       	ldi	r21, 0x44	; 68
    2732:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2736:	dc 01       	movw	r26, r24
    2738:	cb 01       	movw	r24, r22
    273a:	8e 8b       	std	Y+22, r24	; 0x16
    273c:	9f 8b       	std	Y+23, r25	; 0x17
    273e:	a8 8f       	std	Y+24, r26	; 0x18
    2740:	b9 8f       	std	Y+25, r27	; 0x19
	if (__tmp < 1.0)
    2742:	6e 89       	ldd	r22, Y+22	; 0x16
    2744:	7f 89       	ldd	r23, Y+23	; 0x17
    2746:	88 8d       	ldd	r24, Y+24	; 0x18
    2748:	99 8d       	ldd	r25, Y+25	; 0x19
    274a:	20 e0       	ldi	r18, 0x00	; 0
    274c:	30 e0       	ldi	r19, 0x00	; 0
    274e:	40 e8       	ldi	r20, 0x80	; 128
    2750:	5f e3       	ldi	r21, 0x3F	; 63
    2752:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2756:	88 23       	and	r24, r24
    2758:	2c f4       	brge	.+10     	; 0x2764 <HLCD4_voidInit+0x3de>
		__ticks = 1;
    275a:	81 e0       	ldi	r24, 0x01	; 1
    275c:	90 e0       	ldi	r25, 0x00	; 0
    275e:	9d 8b       	std	Y+21, r25	; 0x15
    2760:	8c 8b       	std	Y+20, r24	; 0x14
    2762:	3f c0       	rjmp	.+126    	; 0x27e2 <HLCD4_voidInit+0x45c>
	else if (__tmp > 65535)
    2764:	6e 89       	ldd	r22, Y+22	; 0x16
    2766:	7f 89       	ldd	r23, Y+23	; 0x17
    2768:	88 8d       	ldd	r24, Y+24	; 0x18
    276a:	99 8d       	ldd	r25, Y+25	; 0x19
    276c:	20 e0       	ldi	r18, 0x00	; 0
    276e:	3f ef       	ldi	r19, 0xFF	; 255
    2770:	4f e7       	ldi	r20, 0x7F	; 127
    2772:	57 e4       	ldi	r21, 0x47	; 71
    2774:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2778:	18 16       	cp	r1, r24
    277a:	4c f5       	brge	.+82     	; 0x27ce <HLCD4_voidInit+0x448>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    277c:	6a 8d       	ldd	r22, Y+26	; 0x1a
    277e:	7b 8d       	ldd	r23, Y+27	; 0x1b
    2780:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2782:	9d 8d       	ldd	r25, Y+29	; 0x1d
    2784:	20 e0       	ldi	r18, 0x00	; 0
    2786:	30 e0       	ldi	r19, 0x00	; 0
    2788:	40 e2       	ldi	r20, 0x20	; 32
    278a:	51 e4       	ldi	r21, 0x41	; 65
    278c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2790:	dc 01       	movw	r26, r24
    2792:	cb 01       	movw	r24, r22
    2794:	bc 01       	movw	r22, r24
    2796:	cd 01       	movw	r24, r26
    2798:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    279c:	dc 01       	movw	r26, r24
    279e:	cb 01       	movw	r24, r22
    27a0:	9d 8b       	std	Y+21, r25	; 0x15
    27a2:	8c 8b       	std	Y+20, r24	; 0x14
    27a4:	0f c0       	rjmp	.+30     	; 0x27c4 <HLCD4_voidInit+0x43e>
    27a6:	88 ec       	ldi	r24, 0xC8	; 200
    27a8:	90 e0       	ldi	r25, 0x00	; 0
    27aa:	9b 8b       	std	Y+19, r25	; 0x13
    27ac:	8a 8b       	std	Y+18, r24	; 0x12
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    27ae:	8a 89       	ldd	r24, Y+18	; 0x12
    27b0:	9b 89       	ldd	r25, Y+19	; 0x13
    27b2:	01 97       	sbiw	r24, 0x01	; 1
    27b4:	f1 f7       	brne	.-4      	; 0x27b2 <HLCD4_voidInit+0x42c>
    27b6:	9b 8b       	std	Y+19, r25	; 0x13
    27b8:	8a 8b       	std	Y+18, r24	; 0x12
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    27ba:	8c 89       	ldd	r24, Y+20	; 0x14
    27bc:	9d 89       	ldd	r25, Y+21	; 0x15
    27be:	01 97       	sbiw	r24, 0x01	; 1
    27c0:	9d 8b       	std	Y+21, r25	; 0x15
    27c2:	8c 8b       	std	Y+20, r24	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    27c4:	8c 89       	ldd	r24, Y+20	; 0x14
    27c6:	9d 89       	ldd	r25, Y+21	; 0x15
    27c8:	00 97       	sbiw	r24, 0x00	; 0
    27ca:	69 f7       	brne	.-38     	; 0x27a6 <HLCD4_voidInit+0x420>
    27cc:	24 c0       	rjmp	.+72     	; 0x2816 <HLCD4_voidInit+0x490>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    27ce:	6e 89       	ldd	r22, Y+22	; 0x16
    27d0:	7f 89       	ldd	r23, Y+23	; 0x17
    27d2:	88 8d       	ldd	r24, Y+24	; 0x18
    27d4:	99 8d       	ldd	r25, Y+25	; 0x19
    27d6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    27da:	dc 01       	movw	r26, r24
    27dc:	cb 01       	movw	r24, r22
    27de:	9d 8b       	std	Y+21, r25	; 0x15
    27e0:	8c 8b       	std	Y+20, r24	; 0x14
    27e2:	8c 89       	ldd	r24, Y+20	; 0x14
    27e4:	9d 89       	ldd	r25, Y+21	; 0x15
    27e6:	99 8b       	std	Y+17, r25	; 0x11
    27e8:	88 8b       	std	Y+16, r24	; 0x10
    27ea:	88 89       	ldd	r24, Y+16	; 0x10
    27ec:	99 89       	ldd	r25, Y+17	; 0x11
    27ee:	01 97       	sbiw	r24, 0x01	; 1
    27f0:	f1 f7       	brne	.-4      	; 0x27ee <HLCD4_voidInit+0x468>
    27f2:	99 8b       	std	Y+17, r25	; 0x11
    27f4:	88 8b       	std	Y+16, r24	; 0x10
    27f6:	0f c0       	rjmp	.+30     	; 0x2816 <HLCD4_voidInit+0x490>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    27f8:	6f 8d       	ldd	r22, Y+31	; 0x1f
    27fa:	78 a1       	ldd	r23, Y+32	; 0x20
    27fc:	89 a1       	ldd	r24, Y+33	; 0x21
    27fe:	9a a1       	ldd	r25, Y+34	; 0x22
    2800:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2804:	dc 01       	movw	r26, r24
    2806:	cb 01       	movw	r24, r22
    2808:	8e 8f       	std	Y+30, r24	; 0x1e
    280a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    280c:	8f 87       	std	Y+15, r24	; 0x0f
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    280e:	8f 85       	ldd	r24, Y+15	; 0x0f
    2810:	8a 95       	dec	r24
    2812:	f1 f7       	brne	.-4      	; 0x2810 <HLCD4_voidInit+0x48a>
    2814:	8f 87       	std	Y+15, r24	; 0x0f
    _delay_us(40);
    HLCD4_voidSendCommand(DISPLAY_CLEAR1);
    2816:	80 e0       	ldi	r24, 0x00	; 0
    2818:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <HLCD4_voidSendCommand>
    HLCD4_voidSendCommand(DISPLAY_CLEAR2);
    281c:	80 e1       	ldi	r24, 0x10	; 16
    281e:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <HLCD4_voidSendCommand>
    2822:	80 e0       	ldi	r24, 0x00	; 0
    2824:	90 e0       	ldi	r25, 0x00	; 0
    2826:	a0 e0       	ldi	r26, 0x00	; 0
    2828:	b0 e4       	ldi	r27, 0x40	; 64
    282a:	8b 87       	std	Y+11, r24	; 0x0b
    282c:	9c 87       	std	Y+12, r25	; 0x0c
    282e:	ad 87       	std	Y+13, r26	; 0x0d
    2830:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2832:	6b 85       	ldd	r22, Y+11	; 0x0b
    2834:	7c 85       	ldd	r23, Y+12	; 0x0c
    2836:	8d 85       	ldd	r24, Y+13	; 0x0d
    2838:	9e 85       	ldd	r25, Y+14	; 0x0e
    283a:	20 e0       	ldi	r18, 0x00	; 0
    283c:	30 e0       	ldi	r19, 0x00	; 0
    283e:	4a ef       	ldi	r20, 0xFA	; 250
    2840:	54 e4       	ldi	r21, 0x44	; 68
    2842:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2846:	dc 01       	movw	r26, r24
    2848:	cb 01       	movw	r24, r22
    284a:	8f 83       	std	Y+7, r24	; 0x07
    284c:	98 87       	std	Y+8, r25	; 0x08
    284e:	a9 87       	std	Y+9, r26	; 0x09
    2850:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2852:	6f 81       	ldd	r22, Y+7	; 0x07
    2854:	78 85       	ldd	r23, Y+8	; 0x08
    2856:	89 85       	ldd	r24, Y+9	; 0x09
    2858:	9a 85       	ldd	r25, Y+10	; 0x0a
    285a:	20 e0       	ldi	r18, 0x00	; 0
    285c:	30 e0       	ldi	r19, 0x00	; 0
    285e:	40 e8       	ldi	r20, 0x80	; 128
    2860:	5f e3       	ldi	r21, 0x3F	; 63
    2862:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2866:	88 23       	and	r24, r24
    2868:	2c f4       	brge	.+10     	; 0x2874 <HLCD4_voidInit+0x4ee>
		__ticks = 1;
    286a:	81 e0       	ldi	r24, 0x01	; 1
    286c:	90 e0       	ldi	r25, 0x00	; 0
    286e:	9e 83       	std	Y+6, r25	; 0x06
    2870:	8d 83       	std	Y+5, r24	; 0x05
    2872:	3f c0       	rjmp	.+126    	; 0x28f2 <HLCD4_voidInit+0x56c>
	else if (__tmp > 65535)
    2874:	6f 81       	ldd	r22, Y+7	; 0x07
    2876:	78 85       	ldd	r23, Y+8	; 0x08
    2878:	89 85       	ldd	r24, Y+9	; 0x09
    287a:	9a 85       	ldd	r25, Y+10	; 0x0a
    287c:	20 e0       	ldi	r18, 0x00	; 0
    287e:	3f ef       	ldi	r19, 0xFF	; 255
    2880:	4f e7       	ldi	r20, 0x7F	; 127
    2882:	57 e4       	ldi	r21, 0x47	; 71
    2884:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2888:	18 16       	cp	r1, r24
    288a:	4c f5       	brge	.+82     	; 0x28de <HLCD4_voidInit+0x558>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    288c:	6b 85       	ldd	r22, Y+11	; 0x0b
    288e:	7c 85       	ldd	r23, Y+12	; 0x0c
    2890:	8d 85       	ldd	r24, Y+13	; 0x0d
    2892:	9e 85       	ldd	r25, Y+14	; 0x0e
    2894:	20 e0       	ldi	r18, 0x00	; 0
    2896:	30 e0       	ldi	r19, 0x00	; 0
    2898:	40 e2       	ldi	r20, 0x20	; 32
    289a:	51 e4       	ldi	r21, 0x41	; 65
    289c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    28a0:	dc 01       	movw	r26, r24
    28a2:	cb 01       	movw	r24, r22
    28a4:	bc 01       	movw	r22, r24
    28a6:	cd 01       	movw	r24, r26
    28a8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    28ac:	dc 01       	movw	r26, r24
    28ae:	cb 01       	movw	r24, r22
    28b0:	9e 83       	std	Y+6, r25	; 0x06
    28b2:	8d 83       	std	Y+5, r24	; 0x05
    28b4:	0f c0       	rjmp	.+30     	; 0x28d4 <HLCD4_voidInit+0x54e>
    28b6:	88 ec       	ldi	r24, 0xC8	; 200
    28b8:	90 e0       	ldi	r25, 0x00	; 0
    28ba:	9c 83       	std	Y+4, r25	; 0x04
    28bc:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    28be:	8b 81       	ldd	r24, Y+3	; 0x03
    28c0:	9c 81       	ldd	r25, Y+4	; 0x04
    28c2:	01 97       	sbiw	r24, 0x01	; 1
    28c4:	f1 f7       	brne	.-4      	; 0x28c2 <HLCD4_voidInit+0x53c>
    28c6:	9c 83       	std	Y+4, r25	; 0x04
    28c8:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    28ca:	8d 81       	ldd	r24, Y+5	; 0x05
    28cc:	9e 81       	ldd	r25, Y+6	; 0x06
    28ce:	01 97       	sbiw	r24, 0x01	; 1
    28d0:	9e 83       	std	Y+6, r25	; 0x06
    28d2:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    28d4:	8d 81       	ldd	r24, Y+5	; 0x05
    28d6:	9e 81       	ldd	r25, Y+6	; 0x06
    28d8:	00 97       	sbiw	r24, 0x00	; 0
    28da:	69 f7       	brne	.-38     	; 0x28b6 <HLCD4_voidInit+0x530>
    28dc:	14 c0       	rjmp	.+40     	; 0x2906 <HLCD4_voidInit+0x580>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    28de:	6f 81       	ldd	r22, Y+7	; 0x07
    28e0:	78 85       	ldd	r23, Y+8	; 0x08
    28e2:	89 85       	ldd	r24, Y+9	; 0x09
    28e4:	9a 85       	ldd	r25, Y+10	; 0x0a
    28e6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    28ea:	dc 01       	movw	r26, r24
    28ec:	cb 01       	movw	r24, r22
    28ee:	9e 83       	std	Y+6, r25	; 0x06
    28f0:	8d 83       	std	Y+5, r24	; 0x05
    28f2:	8d 81       	ldd	r24, Y+5	; 0x05
    28f4:	9e 81       	ldd	r25, Y+6	; 0x06
    28f6:	9a 83       	std	Y+2, r25	; 0x02
    28f8:	89 83       	std	Y+1, r24	; 0x01
    28fa:	89 81       	ldd	r24, Y+1	; 0x01
    28fc:	9a 81       	ldd	r25, Y+2	; 0x02
    28fe:	01 97       	sbiw	r24, 0x01	; 1
    2900:	f1 f7       	brne	.-4      	; 0x28fe <HLCD4_voidInit+0x578>
    2902:	9a 83       	std	Y+2, r25	; 0x02
    2904:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(2);
    HLCD4_voidSendCommand(ENTRY_MODE_SET1);
    2906:	80 e0       	ldi	r24, 0x00	; 0
    2908:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <HLCD4_voidSendCommand>
    HLCD4_voidSendCommand(ENTRY_MODE_SET2);
    290c:	80 e6       	ldi	r24, 0x60	; 96
    290e:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <HLCD4_voidSendCommand>
    global_u8Init=1;
    2912:	81 e0       	ldi	r24, 0x01	; 1
    2914:	80 93 a4 00 	sts	0x00A4, r24
} 
    2918:	c4 5b       	subi	r28, 0xB4	; 180
    291a:	df 4f       	sbci	r29, 0xFF	; 255
    291c:	0f b6       	in	r0, 0x3f	; 63
    291e:	f8 94       	cli
    2920:	de bf       	out	0x3e, r29	; 62
    2922:	0f be       	out	0x3f, r0	; 63
    2924:	cd bf       	out	0x3d, r28	; 61
    2926:	cf 91       	pop	r28
    2928:	df 91       	pop	r29
    292a:	1f 91       	pop	r17
    292c:	0f 91       	pop	r16
    292e:	08 95       	ret

00002930 <HLCD4_voidClearDisplay>:

void HLCD4_voidClearDisplay(void)
{
    2930:	df 93       	push	r29
    2932:	cf 93       	push	r28
    2934:	cd b7       	in	r28, 0x3d	; 61
    2936:	de b7       	in	r29, 0x3e	; 62
    2938:	2e 97       	sbiw	r28, 0x0e	; 14
    293a:	0f b6       	in	r0, 0x3f	; 63
    293c:	f8 94       	cli
    293e:	de bf       	out	0x3e, r29	; 62
    2940:	0f be       	out	0x3f, r0	; 63
    2942:	cd bf       	out	0x3d, r28	; 61
    HLCD4_voidSendCommand(DISPLAY_CLEAR);
    2944:	81 e0       	ldi	r24, 0x01	; 1
    2946:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <HLCD4_voidSendCommand>
    294a:	80 e0       	ldi	r24, 0x00	; 0
    294c:	90 e0       	ldi	r25, 0x00	; 0
    294e:	a0 e0       	ldi	r26, 0x00	; 0
    2950:	b0 e4       	ldi	r27, 0x40	; 64
    2952:	8b 87       	std	Y+11, r24	; 0x0b
    2954:	9c 87       	std	Y+12, r25	; 0x0c
    2956:	ad 87       	std	Y+13, r26	; 0x0d
    2958:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    295a:	6b 85       	ldd	r22, Y+11	; 0x0b
    295c:	7c 85       	ldd	r23, Y+12	; 0x0c
    295e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2960:	9e 85       	ldd	r25, Y+14	; 0x0e
    2962:	20 e0       	ldi	r18, 0x00	; 0
    2964:	30 e0       	ldi	r19, 0x00	; 0
    2966:	4a ef       	ldi	r20, 0xFA	; 250
    2968:	54 e4       	ldi	r21, 0x44	; 68
    296a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    296e:	dc 01       	movw	r26, r24
    2970:	cb 01       	movw	r24, r22
    2972:	8f 83       	std	Y+7, r24	; 0x07
    2974:	98 87       	std	Y+8, r25	; 0x08
    2976:	a9 87       	std	Y+9, r26	; 0x09
    2978:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    297a:	6f 81       	ldd	r22, Y+7	; 0x07
    297c:	78 85       	ldd	r23, Y+8	; 0x08
    297e:	89 85       	ldd	r24, Y+9	; 0x09
    2980:	9a 85       	ldd	r25, Y+10	; 0x0a
    2982:	20 e0       	ldi	r18, 0x00	; 0
    2984:	30 e0       	ldi	r19, 0x00	; 0
    2986:	40 e8       	ldi	r20, 0x80	; 128
    2988:	5f e3       	ldi	r21, 0x3F	; 63
    298a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    298e:	88 23       	and	r24, r24
    2990:	2c f4       	brge	.+10     	; 0x299c <HLCD4_voidClearDisplay+0x6c>
		__ticks = 1;
    2992:	81 e0       	ldi	r24, 0x01	; 1
    2994:	90 e0       	ldi	r25, 0x00	; 0
    2996:	9e 83       	std	Y+6, r25	; 0x06
    2998:	8d 83       	std	Y+5, r24	; 0x05
    299a:	3f c0       	rjmp	.+126    	; 0x2a1a <HLCD4_voidClearDisplay+0xea>
	else if (__tmp > 65535)
    299c:	6f 81       	ldd	r22, Y+7	; 0x07
    299e:	78 85       	ldd	r23, Y+8	; 0x08
    29a0:	89 85       	ldd	r24, Y+9	; 0x09
    29a2:	9a 85       	ldd	r25, Y+10	; 0x0a
    29a4:	20 e0       	ldi	r18, 0x00	; 0
    29a6:	3f ef       	ldi	r19, 0xFF	; 255
    29a8:	4f e7       	ldi	r20, 0x7F	; 127
    29aa:	57 e4       	ldi	r21, 0x47	; 71
    29ac:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    29b0:	18 16       	cp	r1, r24
    29b2:	4c f5       	brge	.+82     	; 0x2a06 <HLCD4_voidClearDisplay+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    29b4:	6b 85       	ldd	r22, Y+11	; 0x0b
    29b6:	7c 85       	ldd	r23, Y+12	; 0x0c
    29b8:	8d 85       	ldd	r24, Y+13	; 0x0d
    29ba:	9e 85       	ldd	r25, Y+14	; 0x0e
    29bc:	20 e0       	ldi	r18, 0x00	; 0
    29be:	30 e0       	ldi	r19, 0x00	; 0
    29c0:	40 e2       	ldi	r20, 0x20	; 32
    29c2:	51 e4       	ldi	r21, 0x41	; 65
    29c4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    29c8:	dc 01       	movw	r26, r24
    29ca:	cb 01       	movw	r24, r22
    29cc:	bc 01       	movw	r22, r24
    29ce:	cd 01       	movw	r24, r26
    29d0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    29d4:	dc 01       	movw	r26, r24
    29d6:	cb 01       	movw	r24, r22
    29d8:	9e 83       	std	Y+6, r25	; 0x06
    29da:	8d 83       	std	Y+5, r24	; 0x05
    29dc:	0f c0       	rjmp	.+30     	; 0x29fc <HLCD4_voidClearDisplay+0xcc>
    29de:	88 ec       	ldi	r24, 0xC8	; 200
    29e0:	90 e0       	ldi	r25, 0x00	; 0
    29e2:	9c 83       	std	Y+4, r25	; 0x04
    29e4:	8b 83       	std	Y+3, r24	; 0x03
    29e6:	8b 81       	ldd	r24, Y+3	; 0x03
    29e8:	9c 81       	ldd	r25, Y+4	; 0x04
    29ea:	01 97       	sbiw	r24, 0x01	; 1
    29ec:	f1 f7       	brne	.-4      	; 0x29ea <HLCD4_voidClearDisplay+0xba>
    29ee:	9c 83       	std	Y+4, r25	; 0x04
    29f0:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    29f2:	8d 81       	ldd	r24, Y+5	; 0x05
    29f4:	9e 81       	ldd	r25, Y+6	; 0x06
    29f6:	01 97       	sbiw	r24, 0x01	; 1
    29f8:	9e 83       	std	Y+6, r25	; 0x06
    29fa:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    29fc:	8d 81       	ldd	r24, Y+5	; 0x05
    29fe:	9e 81       	ldd	r25, Y+6	; 0x06
    2a00:	00 97       	sbiw	r24, 0x00	; 0
    2a02:	69 f7       	brne	.-38     	; 0x29de <HLCD4_voidClearDisplay+0xae>
    2a04:	14 c0       	rjmp	.+40     	; 0x2a2e <HLCD4_voidClearDisplay+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2a06:	6f 81       	ldd	r22, Y+7	; 0x07
    2a08:	78 85       	ldd	r23, Y+8	; 0x08
    2a0a:	89 85       	ldd	r24, Y+9	; 0x09
    2a0c:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a0e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2a12:	dc 01       	movw	r26, r24
    2a14:	cb 01       	movw	r24, r22
    2a16:	9e 83       	std	Y+6, r25	; 0x06
    2a18:	8d 83       	std	Y+5, r24	; 0x05
    2a1a:	8d 81       	ldd	r24, Y+5	; 0x05
    2a1c:	9e 81       	ldd	r25, Y+6	; 0x06
    2a1e:	9a 83       	std	Y+2, r25	; 0x02
    2a20:	89 83       	std	Y+1, r24	; 0x01
    2a22:	89 81       	ldd	r24, Y+1	; 0x01
    2a24:	9a 81       	ldd	r25, Y+2	; 0x02
    2a26:	01 97       	sbiw	r24, 0x01	; 1
    2a28:	f1 f7       	brne	.-4      	; 0x2a26 <HLCD4_voidClearDisplay+0xf6>
    2a2a:	9a 83       	std	Y+2, r25	; 0x02
    2a2c:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(2);
}
    2a2e:	2e 96       	adiw	r28, 0x0e	; 14
    2a30:	0f b6       	in	r0, 0x3f	; 63
    2a32:	f8 94       	cli
    2a34:	de bf       	out	0x3e, r29	; 62
    2a36:	0f be       	out	0x3f, r0	; 63
    2a38:	cd bf       	out	0x3d, r28	; 61
    2a3a:	cf 91       	pop	r28
    2a3c:	df 91       	pop	r29
    2a3e:	08 95       	ret

00002a40 <HLCD4_voidSendString>:

void HLCD4_voidSendString(u8 * A_Pu8String)
{
    2a40:	df 93       	push	r29
    2a42:	cf 93       	push	r28
    2a44:	00 d0       	rcall	.+0      	; 0x2a46 <HLCD4_voidSendString+0x6>
    2a46:	0f 92       	push	r0
    2a48:	cd b7       	in	r28, 0x3d	; 61
    2a4a:	de b7       	in	r29, 0x3e	; 62
    2a4c:	9b 83       	std	Y+3, r25	; 0x03
    2a4e:	8a 83       	std	Y+2, r24	; 0x02
    u8 local_u8Couter=0;
    2a50:	19 82       	std	Y+1, r1	; 0x01
    2a52:	0e c0       	rjmp	.+28     	; 0x2a70 <HLCD4_voidSendString+0x30>
    while (A_Pu8String[local_u8Couter]!='\0')
    {
        HLCD4_voidSendData(A_Pu8String[local_u8Couter]);
    2a54:	89 81       	ldd	r24, Y+1	; 0x01
    2a56:	28 2f       	mov	r18, r24
    2a58:	30 e0       	ldi	r19, 0x00	; 0
    2a5a:	8a 81       	ldd	r24, Y+2	; 0x02
    2a5c:	9b 81       	ldd	r25, Y+3	; 0x03
    2a5e:	fc 01       	movw	r30, r24
    2a60:	e2 0f       	add	r30, r18
    2a62:	f3 1f       	adc	r31, r19
    2a64:	80 81       	ld	r24, Z
    2a66:	0e 94 2f 10 	call	0x205e	; 0x205e <HLCD4_voidSendData>
        local_u8Couter++;
    2a6a:	89 81       	ldd	r24, Y+1	; 0x01
    2a6c:	8f 5f       	subi	r24, 0xFF	; 255
    2a6e:	89 83       	std	Y+1, r24	; 0x01
}

void HLCD4_voidSendString(u8 * A_Pu8String)
{
    u8 local_u8Couter=0;
    while (A_Pu8String[local_u8Couter]!='\0')
    2a70:	89 81       	ldd	r24, Y+1	; 0x01
    2a72:	28 2f       	mov	r18, r24
    2a74:	30 e0       	ldi	r19, 0x00	; 0
    2a76:	8a 81       	ldd	r24, Y+2	; 0x02
    2a78:	9b 81       	ldd	r25, Y+3	; 0x03
    2a7a:	fc 01       	movw	r30, r24
    2a7c:	e2 0f       	add	r30, r18
    2a7e:	f3 1f       	adc	r31, r19
    2a80:	80 81       	ld	r24, Z
    2a82:	88 23       	and	r24, r24
    2a84:	39 f7       	brne	.-50     	; 0x2a54 <HLCD4_voidSendString+0x14>
    {
        HLCD4_voidSendData(A_Pu8String[local_u8Couter]);
        local_u8Couter++;
    }
    
}
    2a86:	0f 90       	pop	r0
    2a88:	0f 90       	pop	r0
    2a8a:	0f 90       	pop	r0
    2a8c:	cf 91       	pop	r28
    2a8e:	df 91       	pop	r29
    2a90:	08 95       	ret

00002a92 <HLCD4_voidGoToPos>:

void HLCD4_voidGoToPos(u8 A_u8RowNum,u8 A_u8ColNum)
{
    2a92:	df 93       	push	r29
    2a94:	cf 93       	push	r28
    2a96:	cd b7       	in	r28, 0x3d	; 61
    2a98:	de b7       	in	r29, 0x3e	; 62
    2a9a:	63 97       	sbiw	r28, 0x13	; 19
    2a9c:	0f b6       	in	r0, 0x3f	; 63
    2a9e:	f8 94       	cli
    2aa0:	de bf       	out	0x3e, r29	; 62
    2aa2:	0f be       	out	0x3f, r0	; 63
    2aa4:	cd bf       	out	0x3d, r28	; 61
    2aa6:	88 8b       	std	Y+16, r24	; 0x10
    2aa8:	69 8b       	std	Y+17, r22	; 0x11
    // _delay_ms(1);

    //*******************************//
    //Second method
	u8 local_u8Address;
    switch(A_u8RowNum)
    2aaa:	88 89       	ldd	r24, Y+16	; 0x10
    2aac:	28 2f       	mov	r18, r24
    2aae:	30 e0       	ldi	r19, 0x00	; 0
    2ab0:	3b 8b       	std	Y+19, r19	; 0x13
    2ab2:	2a 8b       	std	Y+18, r18	; 0x12
    2ab4:	8a 89       	ldd	r24, Y+18	; 0x12
    2ab6:	9b 89       	ldd	r25, Y+19	; 0x13
    2ab8:	81 30       	cpi	r24, 0x01	; 1
    2aba:	91 05       	cpc	r25, r1
    2abc:	31 f0       	breq	.+12     	; 0x2aca <HLCD4_voidGoToPos+0x38>
    2abe:	2a 89       	ldd	r18, Y+18	; 0x12
    2ac0:	3b 89       	ldd	r19, Y+19	; 0x13
    2ac2:	22 30       	cpi	r18, 0x02	; 2
    2ac4:	31 05       	cpc	r19, r1
    2ac6:	59 f0       	breq	.+22     	; 0x2ade <HLCD4_voidGoToPos+0x4c>
    2ac8:	13 c0       	rjmp	.+38     	; 0x2af0 <HLCD4_voidGoToPos+0x5e>
    {
        case LCD_ROW_ONE:
        local_u8Address=FIRST_ROW_ADDRESS + A_u8ColNum -1;
    2aca:	89 89       	ldd	r24, Y+17	; 0x11
    2acc:	81 50       	subi	r24, 0x01	; 1
    2ace:	8f 87       	std	Y+15, r24	; 0x0f
        SET_BIT(local_u8Address,PIN7);
    2ad0:	8f 85       	ldd	r24, Y+15	; 0x0f
    2ad2:	80 68       	ori	r24, 0x80	; 128
    2ad4:	8f 87       	std	Y+15, r24	; 0x0f
        HLCD4_voidSendCommand(local_u8Address);
    2ad6:	8f 85       	ldd	r24, Y+15	; 0x0f
    2ad8:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <HLCD4_voidSendCommand>
    2adc:	09 c0       	rjmp	.+18     	; 0x2af0 <HLCD4_voidGoToPos+0x5e>
        break;

        case LCD_ROW_TWO:
        local_u8Address=SECOND_ROW_ADDRESS + A_u8ColNum;
    2ade:	89 89       	ldd	r24, Y+17	; 0x11
    2ae0:	81 5c       	subi	r24, 0xC1	; 193
    2ae2:	8f 87       	std	Y+15, r24	; 0x0f
        SET_BIT(local_u8Address,PIN7);
    2ae4:	8f 85       	ldd	r24, Y+15	; 0x0f
    2ae6:	80 68       	ori	r24, 0x80	; 128
    2ae8:	8f 87       	std	Y+15, r24	; 0x0f
        HLCD4_voidSendCommand(local_u8Address);
    2aea:	8f 85       	ldd	r24, Y+15	; 0x0f
    2aec:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <HLCD4_voidSendCommand>
    2af0:	80 e0       	ldi	r24, 0x00	; 0
    2af2:	90 e0       	ldi	r25, 0x00	; 0
    2af4:	a0 e8       	ldi	r26, 0x80	; 128
    2af6:	bf e3       	ldi	r27, 0x3F	; 63
    2af8:	8b 87       	std	Y+11, r24	; 0x0b
    2afa:	9c 87       	std	Y+12, r25	; 0x0c
    2afc:	ad 87       	std	Y+13, r26	; 0x0d
    2afe:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2b00:	6b 85       	ldd	r22, Y+11	; 0x0b
    2b02:	7c 85       	ldd	r23, Y+12	; 0x0c
    2b04:	8d 85       	ldd	r24, Y+13	; 0x0d
    2b06:	9e 85       	ldd	r25, Y+14	; 0x0e
    2b08:	20 e0       	ldi	r18, 0x00	; 0
    2b0a:	30 e0       	ldi	r19, 0x00	; 0
    2b0c:	4a ef       	ldi	r20, 0xFA	; 250
    2b0e:	54 e4       	ldi	r21, 0x44	; 68
    2b10:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2b14:	dc 01       	movw	r26, r24
    2b16:	cb 01       	movw	r24, r22
    2b18:	8f 83       	std	Y+7, r24	; 0x07
    2b1a:	98 87       	std	Y+8, r25	; 0x08
    2b1c:	a9 87       	std	Y+9, r26	; 0x09
    2b1e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2b20:	6f 81       	ldd	r22, Y+7	; 0x07
    2b22:	78 85       	ldd	r23, Y+8	; 0x08
    2b24:	89 85       	ldd	r24, Y+9	; 0x09
    2b26:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b28:	20 e0       	ldi	r18, 0x00	; 0
    2b2a:	30 e0       	ldi	r19, 0x00	; 0
    2b2c:	40 e8       	ldi	r20, 0x80	; 128
    2b2e:	5f e3       	ldi	r21, 0x3F	; 63
    2b30:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2b34:	88 23       	and	r24, r24
    2b36:	2c f4       	brge	.+10     	; 0x2b42 <HLCD4_voidGoToPos+0xb0>
		__ticks = 1;
    2b38:	81 e0       	ldi	r24, 0x01	; 1
    2b3a:	90 e0       	ldi	r25, 0x00	; 0
    2b3c:	9e 83       	std	Y+6, r25	; 0x06
    2b3e:	8d 83       	std	Y+5, r24	; 0x05
    2b40:	3f c0       	rjmp	.+126    	; 0x2bc0 <HLCD4_voidGoToPos+0x12e>
	else if (__tmp > 65535)
    2b42:	6f 81       	ldd	r22, Y+7	; 0x07
    2b44:	78 85       	ldd	r23, Y+8	; 0x08
    2b46:	89 85       	ldd	r24, Y+9	; 0x09
    2b48:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b4a:	20 e0       	ldi	r18, 0x00	; 0
    2b4c:	3f ef       	ldi	r19, 0xFF	; 255
    2b4e:	4f e7       	ldi	r20, 0x7F	; 127
    2b50:	57 e4       	ldi	r21, 0x47	; 71
    2b52:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2b56:	18 16       	cp	r1, r24
    2b58:	4c f5       	brge	.+82     	; 0x2bac <HLCD4_voidGoToPos+0x11a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2b5a:	6b 85       	ldd	r22, Y+11	; 0x0b
    2b5c:	7c 85       	ldd	r23, Y+12	; 0x0c
    2b5e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2b60:	9e 85       	ldd	r25, Y+14	; 0x0e
    2b62:	20 e0       	ldi	r18, 0x00	; 0
    2b64:	30 e0       	ldi	r19, 0x00	; 0
    2b66:	40 e2       	ldi	r20, 0x20	; 32
    2b68:	51 e4       	ldi	r21, 0x41	; 65
    2b6a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2b6e:	dc 01       	movw	r26, r24
    2b70:	cb 01       	movw	r24, r22
    2b72:	bc 01       	movw	r22, r24
    2b74:	cd 01       	movw	r24, r26
    2b76:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2b7a:	dc 01       	movw	r26, r24
    2b7c:	cb 01       	movw	r24, r22
    2b7e:	9e 83       	std	Y+6, r25	; 0x06
    2b80:	8d 83       	std	Y+5, r24	; 0x05
    2b82:	0f c0       	rjmp	.+30     	; 0x2ba2 <HLCD4_voidGoToPos+0x110>
    2b84:	88 ec       	ldi	r24, 0xC8	; 200
    2b86:	90 e0       	ldi	r25, 0x00	; 0
    2b88:	9c 83       	std	Y+4, r25	; 0x04
    2b8a:	8b 83       	std	Y+3, r24	; 0x03
    2b8c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b8e:	9c 81       	ldd	r25, Y+4	; 0x04
    2b90:	01 97       	sbiw	r24, 0x01	; 1
    2b92:	f1 f7       	brne	.-4      	; 0x2b90 <HLCD4_voidGoToPos+0xfe>
    2b94:	9c 83       	std	Y+4, r25	; 0x04
    2b96:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2b98:	8d 81       	ldd	r24, Y+5	; 0x05
    2b9a:	9e 81       	ldd	r25, Y+6	; 0x06
    2b9c:	01 97       	sbiw	r24, 0x01	; 1
    2b9e:	9e 83       	std	Y+6, r25	; 0x06
    2ba0:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2ba2:	8d 81       	ldd	r24, Y+5	; 0x05
    2ba4:	9e 81       	ldd	r25, Y+6	; 0x06
    2ba6:	00 97       	sbiw	r24, 0x00	; 0
    2ba8:	69 f7       	brne	.-38     	; 0x2b84 <HLCD4_voidGoToPos+0xf2>
    2baa:	14 c0       	rjmp	.+40     	; 0x2bd4 <HLCD4_voidGoToPos+0x142>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2bac:	6f 81       	ldd	r22, Y+7	; 0x07
    2bae:	78 85       	ldd	r23, Y+8	; 0x08
    2bb0:	89 85       	ldd	r24, Y+9	; 0x09
    2bb2:	9a 85       	ldd	r25, Y+10	; 0x0a
    2bb4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2bb8:	dc 01       	movw	r26, r24
    2bba:	cb 01       	movw	r24, r22
    2bbc:	9e 83       	std	Y+6, r25	; 0x06
    2bbe:	8d 83       	std	Y+5, r24	; 0x05
    2bc0:	8d 81       	ldd	r24, Y+5	; 0x05
    2bc2:	9e 81       	ldd	r25, Y+6	; 0x06
    2bc4:	9a 83       	std	Y+2, r25	; 0x02
    2bc6:	89 83       	std	Y+1, r24	; 0x01
    2bc8:	89 81       	ldd	r24, Y+1	; 0x01
    2bca:	9a 81       	ldd	r25, Y+2	; 0x02
    2bcc:	01 97       	sbiw	r24, 0x01	; 1
    2bce:	f1 f7       	brne	.-4      	; 0x2bcc <HLCD4_voidGoToPos+0x13a>
    2bd0:	9a 83       	std	Y+2, r25	; 0x02
    2bd2:	89 83       	std	Y+1, r24	; 0x01
        break;

    }
    _delay_ms(1);

}
    2bd4:	63 96       	adiw	r28, 0x13	; 19
    2bd6:	0f b6       	in	r0, 0x3f	; 63
    2bd8:	f8 94       	cli
    2bda:	de bf       	out	0x3e, r29	; 62
    2bdc:	0f be       	out	0x3f, r0	; 63
    2bde:	cd bf       	out	0x3d, r28	; 61
    2be0:	cf 91       	pop	r28
    2be2:	df 91       	pop	r29
    2be4:	08 95       	ret

00002be6 <HLCD4_voidDisplayNumber>:

void HLCD4_voidDisplayNumber(u32 A_u32Number)
{
    2be6:	df 93       	push	r29
    2be8:	cf 93       	push	r28
    2bea:	00 d0       	rcall	.+0      	; 0x2bec <HLCD4_voidDisplayNumber+0x6>
    2bec:	00 d0       	rcall	.+0      	; 0x2bee <HLCD4_voidDisplayNumber+0x8>
    2bee:	cd b7       	in	r28, 0x3d	; 61
    2bf0:	de b7       	in	r29, 0x3e	; 62
    2bf2:	9c 83       	std	Y+4, r25	; 0x04
    2bf4:	8b 83       	std	Y+3, r24	; 0x03
    // u8 local_u8NumToStr[100];
    // itoa(A_u32Number,local_u8NumToStr,10);
    // HLCD4_voidSendString(local_u8NumToStr);
    //****************************************************//
    //third method: it will deal with zero unlike the first method so it's not problem here
    u32 local_u32Number=1;
    2bf6:	81 e0       	ldi	r24, 0x01	; 1
    2bf8:	90 e0       	ldi	r25, 0x00	; 0
    2bfa:	9a 83       	std	Y+2, r25	; 0x02
    2bfc:	89 83       	std	Y+1, r24	; 0x01
    if(A_u32Number==0)
    2bfe:	8b 81       	ldd	r24, Y+3	; 0x03
    2c00:	9c 81       	ldd	r25, Y+4	; 0x04
    2c02:	00 97       	sbiw	r24, 0x00	; 0
    2c04:	31 f5       	brne	.+76     	; 0x2c52 <HLCD4_voidDisplayNumber+0x6c>
    {
        HLCD4_voidSendData('0');
    2c06:	80 e3       	ldi	r24, 0x30	; 48
    2c08:	0e 94 2f 10 	call	0x205e	; 0x205e <HLCD4_voidSendData>
    2c0c:	22 c0       	rjmp	.+68     	; 0x2c52 <HLCD4_voidDisplayNumber+0x6c>
    }   
    while(A_u32Number !=0)
    {
            local_u32Number=((local_u32Number * 10)+(A_u32Number%10));
    2c0e:	89 81       	ldd	r24, Y+1	; 0x01
    2c10:	9a 81       	ldd	r25, Y+2	; 0x02
    2c12:	9c 01       	movw	r18, r24
    2c14:	22 0f       	add	r18, r18
    2c16:	33 1f       	adc	r19, r19
    2c18:	c9 01       	movw	r24, r18
    2c1a:	88 0f       	add	r24, r24
    2c1c:	99 1f       	adc	r25, r25
    2c1e:	88 0f       	add	r24, r24
    2c20:	99 1f       	adc	r25, r25
    2c22:	f9 01       	movw	r30, r18
    2c24:	e8 0f       	add	r30, r24
    2c26:	f9 1f       	adc	r31, r25
    2c28:	8b 81       	ldd	r24, Y+3	; 0x03
    2c2a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c2c:	2a e0       	ldi	r18, 0x0A	; 10
    2c2e:	30 e0       	ldi	r19, 0x00	; 0
    2c30:	b9 01       	movw	r22, r18
    2c32:	0e 94 16 3a 	call	0x742c	; 0x742c <__udivmodhi4>
    2c36:	8e 0f       	add	r24, r30
    2c38:	9f 1f       	adc	r25, r31
    2c3a:	9a 83       	std	Y+2, r25	; 0x02
    2c3c:	89 83       	std	Y+1, r24	; 0x01
            A_u32Number=A_u32Number/10;
    2c3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c40:	9c 81       	ldd	r25, Y+4	; 0x04
    2c42:	2a e0       	ldi	r18, 0x0A	; 10
    2c44:	30 e0       	ldi	r19, 0x00	; 0
    2c46:	b9 01       	movw	r22, r18
    2c48:	0e 94 16 3a 	call	0x742c	; 0x742c <__udivmodhi4>
    2c4c:	cb 01       	movw	r24, r22
    2c4e:	9c 83       	std	Y+4, r25	; 0x04
    2c50:	8b 83       	std	Y+3, r24	; 0x03
    u32 local_u32Number=1;
    if(A_u32Number==0)
    {
        HLCD4_voidSendData('0');
    }   
    while(A_u32Number !=0)
    2c52:	8b 81       	ldd	r24, Y+3	; 0x03
    2c54:	9c 81       	ldd	r25, Y+4	; 0x04
    2c56:	00 97       	sbiw	r24, 0x00	; 0
    2c58:	d1 f6       	brne	.-76     	; 0x2c0e <HLCD4_voidDisplayNumber+0x28>
    2c5a:	14 c0       	rjmp	.+40     	; 0x2c84 <HLCD4_voidDisplayNumber+0x9e>
            A_u32Number=A_u32Number/10;

    }
    while (local_u32Number!=1)
    {
        HLCD4_voidSendData((local_u32Number%10)+48);
    2c5c:	89 81       	ldd	r24, Y+1	; 0x01
    2c5e:	9a 81       	ldd	r25, Y+2	; 0x02
    2c60:	2a e0       	ldi	r18, 0x0A	; 10
    2c62:	30 e0       	ldi	r19, 0x00	; 0
    2c64:	b9 01       	movw	r22, r18
    2c66:	0e 94 16 3a 	call	0x742c	; 0x742c <__udivmodhi4>
    2c6a:	80 5d       	subi	r24, 0xD0	; 208
    2c6c:	0e 94 2f 10 	call	0x205e	; 0x205e <HLCD4_voidSendData>
        local_u32Number=local_u32Number/10;
    2c70:	89 81       	ldd	r24, Y+1	; 0x01
    2c72:	9a 81       	ldd	r25, Y+2	; 0x02
    2c74:	2a e0       	ldi	r18, 0x0A	; 10
    2c76:	30 e0       	ldi	r19, 0x00	; 0
    2c78:	b9 01       	movw	r22, r18
    2c7a:	0e 94 16 3a 	call	0x742c	; 0x742c <__udivmodhi4>
    2c7e:	cb 01       	movw	r24, r22
    2c80:	9a 83       	std	Y+2, r25	; 0x02
    2c82:	89 83       	std	Y+1, r24	; 0x01
    {
            local_u32Number=((local_u32Number * 10)+(A_u32Number%10));
            A_u32Number=A_u32Number/10;

    }
    while (local_u32Number!=1)
    2c84:	89 81       	ldd	r24, Y+1	; 0x01
    2c86:	9a 81       	ldd	r25, Y+2	; 0x02
    2c88:	81 30       	cpi	r24, 0x01	; 1
    2c8a:	91 05       	cpc	r25, r1
    2c8c:	39 f7       	brne	.-50     	; 0x2c5c <HLCD4_voidDisplayNumber+0x76>
    {
        HLCD4_voidSendData((local_u32Number%10)+48);
        local_u32Number=local_u32Number/10;
    }
}
    2c8e:	0f 90       	pop	r0
    2c90:	0f 90       	pop	r0
    2c92:	0f 90       	pop	r0
    2c94:	0f 90       	pop	r0
    2c96:	cf 91       	pop	r28
    2c98:	df 91       	pop	r29
    2c9a:	08 95       	ret

00002c9c <HLCD4_voidStoreCustomChar>:

void HLCD4_voidStoreCustomChar(u8 * A_u8Pattern,u8 A_u8CGRAMIndex)
{
    2c9c:	df 93       	push	r29
    2c9e:	cf 93       	push	r28
    2ca0:	cd b7       	in	r28, 0x3d	; 61
    2ca2:	de b7       	in	r29, 0x3e	; 62
    2ca4:	ab 97       	sbiw	r28, 0x2b	; 43
    2ca6:	0f b6       	in	r0, 0x3f	; 63
    2ca8:	f8 94       	cli
    2caa:	de bf       	out	0x3e, r29	; 62
    2cac:	0f be       	out	0x3f, r0	; 63
    2cae:	cd bf       	out	0x3d, r28	; 61
    2cb0:	9a a7       	std	Y+42, r25	; 0x2a
    2cb2:	89 a7       	std	Y+41, r24	; 0x29
    2cb4:	6b a7       	std	Y+43, r22	; 0x2b
    u8 local_u8Address;
    if(A_u8CGRAMIndex<8)
    2cb6:	8b a5       	ldd	r24, Y+43	; 0x2b
    2cb8:	88 30       	cpi	r24, 0x08	; 8
    2cba:	08 f0       	brcs	.+2      	; 0x2cbe <HLCD4_voidStoreCustomChar+0x22>
    2cbc:	e5 c0       	rjmp	.+458    	; 0x2e88 <HLCD4_voidStoreCustomChar+0x1ec>
    {
        A_u8CGRAMIndex=A_u8CGRAMIndex*8;
    2cbe:	8b a5       	ldd	r24, Y+43	; 0x2b
    2cc0:	88 2f       	mov	r24, r24
    2cc2:	90 e0       	ldi	r25, 0x00	; 0
    2cc4:	88 0f       	add	r24, r24
    2cc6:	99 1f       	adc	r25, r25
    2cc8:	88 0f       	add	r24, r24
    2cca:	99 1f       	adc	r25, r25
    2ccc:	88 0f       	add	r24, r24
    2cce:	99 1f       	adc	r25, r25
    2cd0:	8b a7       	std	Y+43, r24	; 0x2b
        SET_BIT(A_u8CGRAMIndex,PIN6);
    2cd2:	8b a5       	ldd	r24, Y+43	; 0x2b
    2cd4:	80 64       	ori	r24, 0x40	; 64
    2cd6:	8b a7       	std	Y+43, r24	; 0x2b
        CLR_BIT(A_u8CGRAMIndex,PIN7);
    2cd8:	8b a5       	ldd	r24, Y+43	; 0x2b
    2cda:	8f 77       	andi	r24, 0x7F	; 127
    2cdc:	8b a7       	std	Y+43, r24	; 0x2b
        HLCD4_voidSendCommand(A_u8CGRAMIndex);
    2cde:	8b a5       	ldd	r24, Y+43	; 0x2b
    2ce0:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <HLCD4_voidSendCommand>
        for(u8 i=0;i<8;i++)
    2ce4:	1f a2       	std	Y+39, r1	; 0x27
    2ce6:	cc c0       	rjmp	.+408    	; 0x2e80 <HLCD4_voidStoreCustomChar+0x1e4>
        {
            HLCD4_voidSendData(A_u8Pattern[i]);
    2ce8:	8f a1       	ldd	r24, Y+39	; 0x27
    2cea:	28 2f       	mov	r18, r24
    2cec:	30 e0       	ldi	r19, 0x00	; 0
    2cee:	89 a5       	ldd	r24, Y+41	; 0x29
    2cf0:	9a a5       	ldd	r25, Y+42	; 0x2a
    2cf2:	fc 01       	movw	r30, r24
    2cf4:	e2 0f       	add	r30, r18
    2cf6:	f3 1f       	adc	r31, r19
    2cf8:	80 81       	ld	r24, Z
    2cfa:	0e 94 2f 10 	call	0x205e	; 0x205e <HLCD4_voidSendData>
    2cfe:	80 e0       	ldi	r24, 0x00	; 0
    2d00:	90 e0       	ldi	r25, 0x00	; 0
    2d02:	a0 e7       	ldi	r26, 0x70	; 112
    2d04:	b2 e4       	ldi	r27, 0x42	; 66
    2d06:	8b a3       	std	Y+35, r24	; 0x23
    2d08:	9c a3       	std	Y+36, r25	; 0x24
    2d0a:	ad a3       	std	Y+37, r26	; 0x25
    2d0c:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    2d0e:	6b a1       	ldd	r22, Y+35	; 0x23
    2d10:	7c a1       	ldd	r23, Y+36	; 0x24
    2d12:	8d a1       	ldd	r24, Y+37	; 0x25
    2d14:	9e a1       	ldd	r25, Y+38	; 0x26
    2d16:	2b ea       	ldi	r18, 0xAB	; 171
    2d18:	3a ea       	ldi	r19, 0xAA	; 170
    2d1a:	4a e2       	ldi	r20, 0x2A	; 42
    2d1c:	50 e4       	ldi	r21, 0x40	; 64
    2d1e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2d22:	dc 01       	movw	r26, r24
    2d24:	cb 01       	movw	r24, r22
    2d26:	8f 8f       	std	Y+31, r24	; 0x1f
    2d28:	98 a3       	std	Y+32, r25	; 0x20
    2d2a:	a9 a3       	std	Y+33, r26	; 0x21
    2d2c:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    2d2e:	6f 8d       	ldd	r22, Y+31	; 0x1f
    2d30:	78 a1       	ldd	r23, Y+32	; 0x20
    2d32:	89 a1       	ldd	r24, Y+33	; 0x21
    2d34:	9a a1       	ldd	r25, Y+34	; 0x22
    2d36:	20 e0       	ldi	r18, 0x00	; 0
    2d38:	30 e0       	ldi	r19, 0x00	; 0
    2d3a:	40 e8       	ldi	r20, 0x80	; 128
    2d3c:	5f e3       	ldi	r21, 0x3F	; 63
    2d3e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2d42:	88 23       	and	r24, r24
    2d44:	1c f4       	brge	.+6      	; 0x2d4c <HLCD4_voidStoreCustomChar+0xb0>
		__ticks = 1;
    2d46:	81 e0       	ldi	r24, 0x01	; 1
    2d48:	8e 8f       	std	Y+30, r24	; 0x1e
    2d4a:	91 c0       	rjmp	.+290    	; 0x2e6e <HLCD4_voidStoreCustomChar+0x1d2>
	else if (__tmp > 255)
    2d4c:	6f 8d       	ldd	r22, Y+31	; 0x1f
    2d4e:	78 a1       	ldd	r23, Y+32	; 0x20
    2d50:	89 a1       	ldd	r24, Y+33	; 0x21
    2d52:	9a a1       	ldd	r25, Y+34	; 0x22
    2d54:	20 e0       	ldi	r18, 0x00	; 0
    2d56:	30 e0       	ldi	r19, 0x00	; 0
    2d58:	4f e7       	ldi	r20, 0x7F	; 127
    2d5a:	53 e4       	ldi	r21, 0x43	; 67
    2d5c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2d60:	18 16       	cp	r1, r24
    2d62:	0c f0       	brlt	.+2      	; 0x2d66 <HLCD4_voidStoreCustomChar+0xca>
    2d64:	7b c0       	rjmp	.+246    	; 0x2e5c <HLCD4_voidStoreCustomChar+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    2d66:	6b a1       	ldd	r22, Y+35	; 0x23
    2d68:	7c a1       	ldd	r23, Y+36	; 0x24
    2d6a:	8d a1       	ldd	r24, Y+37	; 0x25
    2d6c:	9e a1       	ldd	r25, Y+38	; 0x26
    2d6e:	20 e0       	ldi	r18, 0x00	; 0
    2d70:	30 e0       	ldi	r19, 0x00	; 0
    2d72:	4a e7       	ldi	r20, 0x7A	; 122
    2d74:	54 e4       	ldi	r21, 0x44	; 68
    2d76:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    2d7a:	dc 01       	movw	r26, r24
    2d7c:	cb 01       	movw	r24, r22
    2d7e:	8a 8f       	std	Y+26, r24	; 0x1a
    2d80:	9b 8f       	std	Y+27, r25	; 0x1b
    2d82:	ac 8f       	std	Y+28, r26	; 0x1c
    2d84:	bd 8f       	std	Y+29, r27	; 0x1d
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2d86:	6a 8d       	ldd	r22, Y+26	; 0x1a
    2d88:	7b 8d       	ldd	r23, Y+27	; 0x1b
    2d8a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2d8c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    2d8e:	20 e0       	ldi	r18, 0x00	; 0
    2d90:	30 e0       	ldi	r19, 0x00	; 0
    2d92:	4a ef       	ldi	r20, 0xFA	; 250
    2d94:	54 e4       	ldi	r21, 0x44	; 68
    2d96:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2d9a:	dc 01       	movw	r26, r24
    2d9c:	cb 01       	movw	r24, r22
    2d9e:	8e 8b       	std	Y+22, r24	; 0x16
    2da0:	9f 8b       	std	Y+23, r25	; 0x17
    2da2:	a8 8f       	std	Y+24, r26	; 0x18
    2da4:	b9 8f       	std	Y+25, r27	; 0x19
	if (__tmp < 1.0)
    2da6:	6e 89       	ldd	r22, Y+22	; 0x16
    2da8:	7f 89       	ldd	r23, Y+23	; 0x17
    2daa:	88 8d       	ldd	r24, Y+24	; 0x18
    2dac:	99 8d       	ldd	r25, Y+25	; 0x19
    2dae:	20 e0       	ldi	r18, 0x00	; 0
    2db0:	30 e0       	ldi	r19, 0x00	; 0
    2db2:	40 e8       	ldi	r20, 0x80	; 128
    2db4:	5f e3       	ldi	r21, 0x3F	; 63
    2db6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2dba:	88 23       	and	r24, r24
    2dbc:	2c f4       	brge	.+10     	; 0x2dc8 <HLCD4_voidStoreCustomChar+0x12c>
		__ticks = 1;
    2dbe:	81 e0       	ldi	r24, 0x01	; 1
    2dc0:	90 e0       	ldi	r25, 0x00	; 0
    2dc2:	9d 8b       	std	Y+21, r25	; 0x15
    2dc4:	8c 8b       	std	Y+20, r24	; 0x14
    2dc6:	3f c0       	rjmp	.+126    	; 0x2e46 <HLCD4_voidStoreCustomChar+0x1aa>
	else if (__tmp > 65535)
    2dc8:	6e 89       	ldd	r22, Y+22	; 0x16
    2dca:	7f 89       	ldd	r23, Y+23	; 0x17
    2dcc:	88 8d       	ldd	r24, Y+24	; 0x18
    2dce:	99 8d       	ldd	r25, Y+25	; 0x19
    2dd0:	20 e0       	ldi	r18, 0x00	; 0
    2dd2:	3f ef       	ldi	r19, 0xFF	; 255
    2dd4:	4f e7       	ldi	r20, 0x7F	; 127
    2dd6:	57 e4       	ldi	r21, 0x47	; 71
    2dd8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2ddc:	18 16       	cp	r1, r24
    2dde:	4c f5       	brge	.+82     	; 0x2e32 <HLCD4_voidStoreCustomChar+0x196>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2de0:	6a 8d       	ldd	r22, Y+26	; 0x1a
    2de2:	7b 8d       	ldd	r23, Y+27	; 0x1b
    2de4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2de6:	9d 8d       	ldd	r25, Y+29	; 0x1d
    2de8:	20 e0       	ldi	r18, 0x00	; 0
    2dea:	30 e0       	ldi	r19, 0x00	; 0
    2dec:	40 e2       	ldi	r20, 0x20	; 32
    2dee:	51 e4       	ldi	r21, 0x41	; 65
    2df0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2df4:	dc 01       	movw	r26, r24
    2df6:	cb 01       	movw	r24, r22
    2df8:	bc 01       	movw	r22, r24
    2dfa:	cd 01       	movw	r24, r26
    2dfc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2e00:	dc 01       	movw	r26, r24
    2e02:	cb 01       	movw	r24, r22
    2e04:	9d 8b       	std	Y+21, r25	; 0x15
    2e06:	8c 8b       	std	Y+20, r24	; 0x14
    2e08:	0f c0       	rjmp	.+30     	; 0x2e28 <HLCD4_voidStoreCustomChar+0x18c>
    2e0a:	88 ec       	ldi	r24, 0xC8	; 200
    2e0c:	90 e0       	ldi	r25, 0x00	; 0
    2e0e:	9b 8b       	std	Y+19, r25	; 0x13
    2e10:	8a 8b       	std	Y+18, r24	; 0x12
    2e12:	8a 89       	ldd	r24, Y+18	; 0x12
    2e14:	9b 89       	ldd	r25, Y+19	; 0x13
    2e16:	01 97       	sbiw	r24, 0x01	; 1
    2e18:	f1 f7       	brne	.-4      	; 0x2e16 <HLCD4_voidStoreCustomChar+0x17a>
    2e1a:	9b 8b       	std	Y+19, r25	; 0x13
    2e1c:	8a 8b       	std	Y+18, r24	; 0x12
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2e1e:	8c 89       	ldd	r24, Y+20	; 0x14
    2e20:	9d 89       	ldd	r25, Y+21	; 0x15
    2e22:	01 97       	sbiw	r24, 0x01	; 1
    2e24:	9d 8b       	std	Y+21, r25	; 0x15
    2e26:	8c 8b       	std	Y+20, r24	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2e28:	8c 89       	ldd	r24, Y+20	; 0x14
    2e2a:	9d 89       	ldd	r25, Y+21	; 0x15
    2e2c:	00 97       	sbiw	r24, 0x00	; 0
    2e2e:	69 f7       	brne	.-38     	; 0x2e0a <HLCD4_voidStoreCustomChar+0x16e>
    2e30:	24 c0       	rjmp	.+72     	; 0x2e7a <HLCD4_voidStoreCustomChar+0x1de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2e32:	6e 89       	ldd	r22, Y+22	; 0x16
    2e34:	7f 89       	ldd	r23, Y+23	; 0x17
    2e36:	88 8d       	ldd	r24, Y+24	; 0x18
    2e38:	99 8d       	ldd	r25, Y+25	; 0x19
    2e3a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2e3e:	dc 01       	movw	r26, r24
    2e40:	cb 01       	movw	r24, r22
    2e42:	9d 8b       	std	Y+21, r25	; 0x15
    2e44:	8c 8b       	std	Y+20, r24	; 0x14
    2e46:	8c 89       	ldd	r24, Y+20	; 0x14
    2e48:	9d 89       	ldd	r25, Y+21	; 0x15
    2e4a:	99 8b       	std	Y+17, r25	; 0x11
    2e4c:	88 8b       	std	Y+16, r24	; 0x10
    2e4e:	88 89       	ldd	r24, Y+16	; 0x10
    2e50:	99 89       	ldd	r25, Y+17	; 0x11
    2e52:	01 97       	sbiw	r24, 0x01	; 1
    2e54:	f1 f7       	brne	.-4      	; 0x2e52 <HLCD4_voidStoreCustomChar+0x1b6>
    2e56:	99 8b       	std	Y+17, r25	; 0x11
    2e58:	88 8b       	std	Y+16, r24	; 0x10
    2e5a:	0f c0       	rjmp	.+30     	; 0x2e7a <HLCD4_voidStoreCustomChar+0x1de>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    2e5c:	6f 8d       	ldd	r22, Y+31	; 0x1f
    2e5e:	78 a1       	ldd	r23, Y+32	; 0x20
    2e60:	89 a1       	ldd	r24, Y+33	; 0x21
    2e62:	9a a1       	ldd	r25, Y+34	; 0x22
    2e64:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2e68:	dc 01       	movw	r26, r24
    2e6a:	cb 01       	movw	r24, r22
    2e6c:	8e 8f       	std	Y+30, r24	; 0x1e
    2e6e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2e70:	8f 87       	std	Y+15, r24	; 0x0f
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2e72:	8f 85       	ldd	r24, Y+15	; 0x0f
    2e74:	8a 95       	dec	r24
    2e76:	f1 f7       	brne	.-4      	; 0x2e74 <HLCD4_voidStoreCustomChar+0x1d8>
    2e78:	8f 87       	std	Y+15, r24	; 0x0f
    {
        A_u8CGRAMIndex=A_u8CGRAMIndex*8;
        SET_BIT(A_u8CGRAMIndex,PIN6);
        CLR_BIT(A_u8CGRAMIndex,PIN7);
        HLCD4_voidSendCommand(A_u8CGRAMIndex);
        for(u8 i=0;i<8;i++)
    2e7a:	8f a1       	ldd	r24, Y+39	; 0x27
    2e7c:	8f 5f       	subi	r24, 0xFF	; 255
    2e7e:	8f a3       	std	Y+39, r24	; 0x27
    2e80:	8f a1       	ldd	r24, Y+39	; 0x27
    2e82:	88 30       	cpi	r24, 0x08	; 8
    2e84:	08 f4       	brcc	.+2      	; 0x2e88 <HLCD4_voidStoreCustomChar+0x1ec>
    2e86:	30 cf       	rjmp	.-416    	; 0x2ce8 <HLCD4_voidStoreCustomChar+0x4c>
        {
            HLCD4_voidSendData(A_u8Pattern[i]);
            _delay_us(60);
        }
    }
    HLCD4_voidSendCommand(RETURN_HOME);
    2e88:	82 e0       	ldi	r24, 0x02	; 2
    2e8a:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <HLCD4_voidSendCommand>
    2e8e:	80 e0       	ldi	r24, 0x00	; 0
    2e90:	90 e0       	ldi	r25, 0x00	; 0
    2e92:	a0 e0       	ldi	r26, 0x00	; 0
    2e94:	b0 e4       	ldi	r27, 0x40	; 64
    2e96:	8b 87       	std	Y+11, r24	; 0x0b
    2e98:	9c 87       	std	Y+12, r25	; 0x0c
    2e9a:	ad 87       	std	Y+13, r26	; 0x0d
    2e9c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2e9e:	6b 85       	ldd	r22, Y+11	; 0x0b
    2ea0:	7c 85       	ldd	r23, Y+12	; 0x0c
    2ea2:	8d 85       	ldd	r24, Y+13	; 0x0d
    2ea4:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ea6:	20 e0       	ldi	r18, 0x00	; 0
    2ea8:	30 e0       	ldi	r19, 0x00	; 0
    2eaa:	4a ef       	ldi	r20, 0xFA	; 250
    2eac:	54 e4       	ldi	r21, 0x44	; 68
    2eae:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2eb2:	dc 01       	movw	r26, r24
    2eb4:	cb 01       	movw	r24, r22
    2eb6:	8f 83       	std	Y+7, r24	; 0x07
    2eb8:	98 87       	std	Y+8, r25	; 0x08
    2eba:	a9 87       	std	Y+9, r26	; 0x09
    2ebc:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2ebe:	6f 81       	ldd	r22, Y+7	; 0x07
    2ec0:	78 85       	ldd	r23, Y+8	; 0x08
    2ec2:	89 85       	ldd	r24, Y+9	; 0x09
    2ec4:	9a 85       	ldd	r25, Y+10	; 0x0a
    2ec6:	20 e0       	ldi	r18, 0x00	; 0
    2ec8:	30 e0       	ldi	r19, 0x00	; 0
    2eca:	40 e8       	ldi	r20, 0x80	; 128
    2ecc:	5f e3       	ldi	r21, 0x3F	; 63
    2ece:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2ed2:	88 23       	and	r24, r24
    2ed4:	2c f4       	brge	.+10     	; 0x2ee0 <HLCD4_voidStoreCustomChar+0x244>
		__ticks = 1;
    2ed6:	81 e0       	ldi	r24, 0x01	; 1
    2ed8:	90 e0       	ldi	r25, 0x00	; 0
    2eda:	9e 83       	std	Y+6, r25	; 0x06
    2edc:	8d 83       	std	Y+5, r24	; 0x05
    2ede:	3f c0       	rjmp	.+126    	; 0x2f5e <HLCD4_voidStoreCustomChar+0x2c2>
	else if (__tmp > 65535)
    2ee0:	6f 81       	ldd	r22, Y+7	; 0x07
    2ee2:	78 85       	ldd	r23, Y+8	; 0x08
    2ee4:	89 85       	ldd	r24, Y+9	; 0x09
    2ee6:	9a 85       	ldd	r25, Y+10	; 0x0a
    2ee8:	20 e0       	ldi	r18, 0x00	; 0
    2eea:	3f ef       	ldi	r19, 0xFF	; 255
    2eec:	4f e7       	ldi	r20, 0x7F	; 127
    2eee:	57 e4       	ldi	r21, 0x47	; 71
    2ef0:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2ef4:	18 16       	cp	r1, r24
    2ef6:	4c f5       	brge	.+82     	; 0x2f4a <HLCD4_voidStoreCustomChar+0x2ae>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2ef8:	6b 85       	ldd	r22, Y+11	; 0x0b
    2efa:	7c 85       	ldd	r23, Y+12	; 0x0c
    2efc:	8d 85       	ldd	r24, Y+13	; 0x0d
    2efe:	9e 85       	ldd	r25, Y+14	; 0x0e
    2f00:	20 e0       	ldi	r18, 0x00	; 0
    2f02:	30 e0       	ldi	r19, 0x00	; 0
    2f04:	40 e2       	ldi	r20, 0x20	; 32
    2f06:	51 e4       	ldi	r21, 0x41	; 65
    2f08:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2f0c:	dc 01       	movw	r26, r24
    2f0e:	cb 01       	movw	r24, r22
    2f10:	bc 01       	movw	r22, r24
    2f12:	cd 01       	movw	r24, r26
    2f14:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2f18:	dc 01       	movw	r26, r24
    2f1a:	cb 01       	movw	r24, r22
    2f1c:	9e 83       	std	Y+6, r25	; 0x06
    2f1e:	8d 83       	std	Y+5, r24	; 0x05
    2f20:	0f c0       	rjmp	.+30     	; 0x2f40 <HLCD4_voidStoreCustomChar+0x2a4>
    2f22:	88 ec       	ldi	r24, 0xC8	; 200
    2f24:	90 e0       	ldi	r25, 0x00	; 0
    2f26:	9c 83       	std	Y+4, r25	; 0x04
    2f28:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2f2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f2e:	01 97       	sbiw	r24, 0x01	; 1
    2f30:	f1 f7       	brne	.-4      	; 0x2f2e <HLCD4_voidStoreCustomChar+0x292>
    2f32:	9c 83       	std	Y+4, r25	; 0x04
    2f34:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2f36:	8d 81       	ldd	r24, Y+5	; 0x05
    2f38:	9e 81       	ldd	r25, Y+6	; 0x06
    2f3a:	01 97       	sbiw	r24, 0x01	; 1
    2f3c:	9e 83       	std	Y+6, r25	; 0x06
    2f3e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2f40:	8d 81       	ldd	r24, Y+5	; 0x05
    2f42:	9e 81       	ldd	r25, Y+6	; 0x06
    2f44:	00 97       	sbiw	r24, 0x00	; 0
    2f46:	69 f7       	brne	.-38     	; 0x2f22 <HLCD4_voidStoreCustomChar+0x286>
    2f48:	14 c0       	rjmp	.+40     	; 0x2f72 <HLCD4_voidStoreCustomChar+0x2d6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2f4a:	6f 81       	ldd	r22, Y+7	; 0x07
    2f4c:	78 85       	ldd	r23, Y+8	; 0x08
    2f4e:	89 85       	ldd	r24, Y+9	; 0x09
    2f50:	9a 85       	ldd	r25, Y+10	; 0x0a
    2f52:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2f56:	dc 01       	movw	r26, r24
    2f58:	cb 01       	movw	r24, r22
    2f5a:	9e 83       	std	Y+6, r25	; 0x06
    2f5c:	8d 83       	std	Y+5, r24	; 0x05
    2f5e:	8d 81       	ldd	r24, Y+5	; 0x05
    2f60:	9e 81       	ldd	r25, Y+6	; 0x06
    2f62:	9a 83       	std	Y+2, r25	; 0x02
    2f64:	89 83       	std	Y+1, r24	; 0x01
    2f66:	89 81       	ldd	r24, Y+1	; 0x01
    2f68:	9a 81       	ldd	r25, Y+2	; 0x02
    2f6a:	01 97       	sbiw	r24, 0x01	; 1
    2f6c:	f1 f7       	brne	.-4      	; 0x2f6a <HLCD4_voidStoreCustomChar+0x2ce>
    2f6e:	9a 83       	std	Y+2, r25	; 0x02
    2f70:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(2);

}
    2f72:	ab 96       	adiw	r28, 0x2b	; 43
    2f74:	0f b6       	in	r0, 0x3f	; 63
    2f76:	f8 94       	cli
    2f78:	de bf       	out	0x3e, r29	; 62
    2f7a:	0f be       	out	0x3f, r0	; 63
    2f7c:	cd bf       	out	0x3d, r28	; 61
    2f7e:	cf 91       	pop	r28
    2f80:	df 91       	pop	r29
    2f82:	08 95       	ret

00002f84 <HLCD4_voidDisplayCustomChar>:

void HLCD4_voidDisplayCustomChar(u8 A_u8CGRAMIndex,u8 A_u8Row,u8 A_u8Col)
{
    2f84:	df 93       	push	r29
    2f86:	cf 93       	push	r28
    2f88:	00 d0       	rcall	.+0      	; 0x2f8a <HLCD4_voidDisplayCustomChar+0x6>
    2f8a:	0f 92       	push	r0
    2f8c:	cd b7       	in	r28, 0x3d	; 61
    2f8e:	de b7       	in	r29, 0x3e	; 62
    2f90:	89 83       	std	Y+1, r24	; 0x01
    2f92:	6a 83       	std	Y+2, r22	; 0x02
    2f94:	4b 83       	std	Y+3, r20	; 0x03
    HLCD4_voidGoToPos(A_u8Row,A_u8Col);
    2f96:	8a 81       	ldd	r24, Y+2	; 0x02
    2f98:	6b 81       	ldd	r22, Y+3	; 0x03
    2f9a:	0e 94 49 15 	call	0x2a92	; 0x2a92 <HLCD4_voidGoToPos>
    HLCD4_voidSendData(A_u8CGRAMIndex);
    2f9e:	89 81       	ldd	r24, Y+1	; 0x01
    2fa0:	0e 94 2f 10 	call	0x205e	; 0x205e <HLCD4_voidSendData>
    2fa4:	0f 90       	pop	r0
    2fa6:	0f 90       	pop	r0
    2fa8:	0f 90       	pop	r0
    2faa:	cf 91       	pop	r28
    2fac:	df 91       	pop	r29
    2fae:	08 95       	ret

00002fb0 <HLCD8_voidSendCommand>:
#define F_CPU 8000000UL
#include <math.h>
#include <stdlib.h>

void HLCD8_voidSendCommand(u8 A_u8Command)
{
    2fb0:	df 93       	push	r29
    2fb2:	cf 93       	push	r28
    2fb4:	cd b7       	in	r28, 0x3d	; 61
    2fb6:	de b7       	in	r29, 0x3e	; 62
    2fb8:	2f 97       	sbiw	r28, 0x0f	; 15
    2fba:	0f b6       	in	r0, 0x3f	; 63
    2fbc:	f8 94       	cli
    2fbe:	de bf       	out	0x3e, r29	; 62
    2fc0:	0f be       	out	0x3f, r0	; 63
    2fc2:	cd bf       	out	0x3d, r28	; 61
    2fc4:	8f 87       	std	Y+15, r24	; 0x0f
    //RS=0 RW=0
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,RS_PIN,PIN_LOW);
    2fc6:	82 e0       	ldi	r24, 0x02	; 2
    2fc8:	60 e0       	ldi	r22, 0x00	; 0
    2fca:	40 e0       	ldi	r20, 0x00	; 0
    2fcc:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,RW_PIN,PIN_LOW);
    2fd0:	82 e0       	ldi	r24, 0x02	; 2
    2fd2:	61 e0       	ldi	r22, 0x01	; 1
    2fd4:	40 e0       	ldi	r20, 0x00	; 0
    2fd6:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>

    MDIO_voidSetPortValue(LCD_DATA_PORT,A_u8Command);
    2fda:	83 e0       	ldi	r24, 0x03	; 3
    2fdc:	6f 85       	ldd	r22, Y+15	; 0x0f
    2fde:	0e 94 27 0b 	call	0x164e	; 0x164e <MDIO_voidSetPortValue>
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_HIGH);
    2fe2:	82 e0       	ldi	r24, 0x02	; 2
    2fe4:	62 e0       	ldi	r22, 0x02	; 2
    2fe6:	41 e0       	ldi	r20, 0x01	; 1
    2fe8:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    2fec:	80 e0       	ldi	r24, 0x00	; 0
    2fee:	90 e0       	ldi	r25, 0x00	; 0
    2ff0:	a0 e0       	ldi	r26, 0x00	; 0
    2ff2:	b0 e4       	ldi	r27, 0x40	; 64
    2ff4:	8b 87       	std	Y+11, r24	; 0x0b
    2ff6:	9c 87       	std	Y+12, r25	; 0x0c
    2ff8:	ad 87       	std	Y+13, r26	; 0x0d
    2ffa:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2ffc:	6b 85       	ldd	r22, Y+11	; 0x0b
    2ffe:	7c 85       	ldd	r23, Y+12	; 0x0c
    3000:	8d 85       	ldd	r24, Y+13	; 0x0d
    3002:	9e 85       	ldd	r25, Y+14	; 0x0e
    3004:	20 e0       	ldi	r18, 0x00	; 0
    3006:	30 e0       	ldi	r19, 0x00	; 0
    3008:	4a ef       	ldi	r20, 0xFA	; 250
    300a:	54 e4       	ldi	r21, 0x44	; 68
    300c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3010:	dc 01       	movw	r26, r24
    3012:	cb 01       	movw	r24, r22
    3014:	8f 83       	std	Y+7, r24	; 0x07
    3016:	98 87       	std	Y+8, r25	; 0x08
    3018:	a9 87       	std	Y+9, r26	; 0x09
    301a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    301c:	6f 81       	ldd	r22, Y+7	; 0x07
    301e:	78 85       	ldd	r23, Y+8	; 0x08
    3020:	89 85       	ldd	r24, Y+9	; 0x09
    3022:	9a 85       	ldd	r25, Y+10	; 0x0a
    3024:	20 e0       	ldi	r18, 0x00	; 0
    3026:	30 e0       	ldi	r19, 0x00	; 0
    3028:	40 e8       	ldi	r20, 0x80	; 128
    302a:	5f e3       	ldi	r21, 0x3F	; 63
    302c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3030:	88 23       	and	r24, r24
    3032:	2c f4       	brge	.+10     	; 0x303e <HLCD8_voidSendCommand+0x8e>
		__ticks = 1;
    3034:	81 e0       	ldi	r24, 0x01	; 1
    3036:	90 e0       	ldi	r25, 0x00	; 0
    3038:	9e 83       	std	Y+6, r25	; 0x06
    303a:	8d 83       	std	Y+5, r24	; 0x05
    303c:	3f c0       	rjmp	.+126    	; 0x30bc <HLCD8_voidSendCommand+0x10c>
	else if (__tmp > 65535)
    303e:	6f 81       	ldd	r22, Y+7	; 0x07
    3040:	78 85       	ldd	r23, Y+8	; 0x08
    3042:	89 85       	ldd	r24, Y+9	; 0x09
    3044:	9a 85       	ldd	r25, Y+10	; 0x0a
    3046:	20 e0       	ldi	r18, 0x00	; 0
    3048:	3f ef       	ldi	r19, 0xFF	; 255
    304a:	4f e7       	ldi	r20, 0x7F	; 127
    304c:	57 e4       	ldi	r21, 0x47	; 71
    304e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3052:	18 16       	cp	r1, r24
    3054:	4c f5       	brge	.+82     	; 0x30a8 <HLCD8_voidSendCommand+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3056:	6b 85       	ldd	r22, Y+11	; 0x0b
    3058:	7c 85       	ldd	r23, Y+12	; 0x0c
    305a:	8d 85       	ldd	r24, Y+13	; 0x0d
    305c:	9e 85       	ldd	r25, Y+14	; 0x0e
    305e:	20 e0       	ldi	r18, 0x00	; 0
    3060:	30 e0       	ldi	r19, 0x00	; 0
    3062:	40 e2       	ldi	r20, 0x20	; 32
    3064:	51 e4       	ldi	r21, 0x41	; 65
    3066:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    306a:	dc 01       	movw	r26, r24
    306c:	cb 01       	movw	r24, r22
    306e:	bc 01       	movw	r22, r24
    3070:	cd 01       	movw	r24, r26
    3072:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3076:	dc 01       	movw	r26, r24
    3078:	cb 01       	movw	r24, r22
    307a:	9e 83       	std	Y+6, r25	; 0x06
    307c:	8d 83       	std	Y+5, r24	; 0x05
    307e:	0f c0       	rjmp	.+30     	; 0x309e <HLCD8_voidSendCommand+0xee>
    3080:	88 ec       	ldi	r24, 0xC8	; 200
    3082:	90 e0       	ldi	r25, 0x00	; 0
    3084:	9c 83       	std	Y+4, r25	; 0x04
    3086:	8b 83       	std	Y+3, r24	; 0x03
    3088:	8b 81       	ldd	r24, Y+3	; 0x03
    308a:	9c 81       	ldd	r25, Y+4	; 0x04
    308c:	01 97       	sbiw	r24, 0x01	; 1
    308e:	f1 f7       	brne	.-4      	; 0x308c <HLCD8_voidSendCommand+0xdc>
    3090:	9c 83       	std	Y+4, r25	; 0x04
    3092:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3094:	8d 81       	ldd	r24, Y+5	; 0x05
    3096:	9e 81       	ldd	r25, Y+6	; 0x06
    3098:	01 97       	sbiw	r24, 0x01	; 1
    309a:	9e 83       	std	Y+6, r25	; 0x06
    309c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    309e:	8d 81       	ldd	r24, Y+5	; 0x05
    30a0:	9e 81       	ldd	r25, Y+6	; 0x06
    30a2:	00 97       	sbiw	r24, 0x00	; 0
    30a4:	69 f7       	brne	.-38     	; 0x3080 <HLCD8_voidSendCommand+0xd0>
    30a6:	14 c0       	rjmp	.+40     	; 0x30d0 <HLCD8_voidSendCommand+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    30a8:	6f 81       	ldd	r22, Y+7	; 0x07
    30aa:	78 85       	ldd	r23, Y+8	; 0x08
    30ac:	89 85       	ldd	r24, Y+9	; 0x09
    30ae:	9a 85       	ldd	r25, Y+10	; 0x0a
    30b0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    30b4:	dc 01       	movw	r26, r24
    30b6:	cb 01       	movw	r24, r22
    30b8:	9e 83       	std	Y+6, r25	; 0x06
    30ba:	8d 83       	std	Y+5, r24	; 0x05
    30bc:	8d 81       	ldd	r24, Y+5	; 0x05
    30be:	9e 81       	ldd	r25, Y+6	; 0x06
    30c0:	9a 83       	std	Y+2, r25	; 0x02
    30c2:	89 83       	std	Y+1, r24	; 0x01
    30c4:	89 81       	ldd	r24, Y+1	; 0x01
    30c6:	9a 81       	ldd	r25, Y+2	; 0x02
    30c8:	01 97       	sbiw	r24, 0x01	; 1
    30ca:	f1 f7       	brne	.-4      	; 0x30c8 <HLCD8_voidSendCommand+0x118>
    30cc:	9a 83       	std	Y+2, r25	; 0x02
    30ce:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(2);
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_LOW);
    30d0:	82 e0       	ldi	r24, 0x02	; 2
    30d2:	62 e0       	ldi	r22, 0x02	; 2
    30d4:	40 e0       	ldi	r20, 0x00	; 0
    30d6:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
}
    30da:	2f 96       	adiw	r28, 0x0f	; 15
    30dc:	0f b6       	in	r0, 0x3f	; 63
    30de:	f8 94       	cli
    30e0:	de bf       	out	0x3e, r29	; 62
    30e2:	0f be       	out	0x3f, r0	; 63
    30e4:	cd bf       	out	0x3d, r28	; 61
    30e6:	cf 91       	pop	r28
    30e8:	df 91       	pop	r29
    30ea:	08 95       	ret

000030ec <HLCD8_voidSendData>:


void HLCD8_voidSendData(u8 A_u8Data)
{
    30ec:	df 93       	push	r29
    30ee:	cf 93       	push	r28
    30f0:	cd b7       	in	r28, 0x3d	; 61
    30f2:	de b7       	in	r29, 0x3e	; 62
    30f4:	2f 97       	sbiw	r28, 0x0f	; 15
    30f6:	0f b6       	in	r0, 0x3f	; 63
    30f8:	f8 94       	cli
    30fa:	de bf       	out	0x3e, r29	; 62
    30fc:	0f be       	out	0x3f, r0	; 63
    30fe:	cd bf       	out	0x3d, r28	; 61
    3100:	8f 87       	std	Y+15, r24	; 0x0f
    //RS=1 RW=0
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,RS_PIN,PIN_HIGH);
    3102:	82 e0       	ldi	r24, 0x02	; 2
    3104:	60 e0       	ldi	r22, 0x00	; 0
    3106:	41 e0       	ldi	r20, 0x01	; 1
    3108:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,RW_PIN,PIN_LOW);
    310c:	82 e0       	ldi	r24, 0x02	; 2
    310e:	61 e0       	ldi	r22, 0x01	; 1
    3110:	40 e0       	ldi	r20, 0x00	; 0
    3112:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>

    MDIO_voidSetPortValue(LCD_DATA_PORT,A_u8Data);
    3116:	83 e0       	ldi	r24, 0x03	; 3
    3118:	6f 85       	ldd	r22, Y+15	; 0x0f
    311a:	0e 94 27 0b 	call	0x164e	; 0x164e <MDIO_voidSetPortValue>

    MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_HIGH);
    311e:	82 e0       	ldi	r24, 0x02	; 2
    3120:	62 e0       	ldi	r22, 0x02	; 2
    3122:	41 e0       	ldi	r20, 0x01	; 1
    3124:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    3128:	80 e0       	ldi	r24, 0x00	; 0
    312a:	90 e0       	ldi	r25, 0x00	; 0
    312c:	a0 e0       	ldi	r26, 0x00	; 0
    312e:	b0 e4       	ldi	r27, 0x40	; 64
    3130:	8b 87       	std	Y+11, r24	; 0x0b
    3132:	9c 87       	std	Y+12, r25	; 0x0c
    3134:	ad 87       	std	Y+13, r26	; 0x0d
    3136:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3138:	6b 85       	ldd	r22, Y+11	; 0x0b
    313a:	7c 85       	ldd	r23, Y+12	; 0x0c
    313c:	8d 85       	ldd	r24, Y+13	; 0x0d
    313e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3140:	20 e0       	ldi	r18, 0x00	; 0
    3142:	30 e0       	ldi	r19, 0x00	; 0
    3144:	4a ef       	ldi	r20, 0xFA	; 250
    3146:	54 e4       	ldi	r21, 0x44	; 68
    3148:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    314c:	dc 01       	movw	r26, r24
    314e:	cb 01       	movw	r24, r22
    3150:	8f 83       	std	Y+7, r24	; 0x07
    3152:	98 87       	std	Y+8, r25	; 0x08
    3154:	a9 87       	std	Y+9, r26	; 0x09
    3156:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3158:	6f 81       	ldd	r22, Y+7	; 0x07
    315a:	78 85       	ldd	r23, Y+8	; 0x08
    315c:	89 85       	ldd	r24, Y+9	; 0x09
    315e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3160:	20 e0       	ldi	r18, 0x00	; 0
    3162:	30 e0       	ldi	r19, 0x00	; 0
    3164:	40 e8       	ldi	r20, 0x80	; 128
    3166:	5f e3       	ldi	r21, 0x3F	; 63
    3168:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    316c:	88 23       	and	r24, r24
    316e:	2c f4       	brge	.+10     	; 0x317a <HLCD8_voidSendData+0x8e>
		__ticks = 1;
    3170:	81 e0       	ldi	r24, 0x01	; 1
    3172:	90 e0       	ldi	r25, 0x00	; 0
    3174:	9e 83       	std	Y+6, r25	; 0x06
    3176:	8d 83       	std	Y+5, r24	; 0x05
    3178:	3f c0       	rjmp	.+126    	; 0x31f8 <HLCD8_voidSendData+0x10c>
	else if (__tmp > 65535)
    317a:	6f 81       	ldd	r22, Y+7	; 0x07
    317c:	78 85       	ldd	r23, Y+8	; 0x08
    317e:	89 85       	ldd	r24, Y+9	; 0x09
    3180:	9a 85       	ldd	r25, Y+10	; 0x0a
    3182:	20 e0       	ldi	r18, 0x00	; 0
    3184:	3f ef       	ldi	r19, 0xFF	; 255
    3186:	4f e7       	ldi	r20, 0x7F	; 127
    3188:	57 e4       	ldi	r21, 0x47	; 71
    318a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    318e:	18 16       	cp	r1, r24
    3190:	4c f5       	brge	.+82     	; 0x31e4 <HLCD8_voidSendData+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3192:	6b 85       	ldd	r22, Y+11	; 0x0b
    3194:	7c 85       	ldd	r23, Y+12	; 0x0c
    3196:	8d 85       	ldd	r24, Y+13	; 0x0d
    3198:	9e 85       	ldd	r25, Y+14	; 0x0e
    319a:	20 e0       	ldi	r18, 0x00	; 0
    319c:	30 e0       	ldi	r19, 0x00	; 0
    319e:	40 e2       	ldi	r20, 0x20	; 32
    31a0:	51 e4       	ldi	r21, 0x41	; 65
    31a2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    31a6:	dc 01       	movw	r26, r24
    31a8:	cb 01       	movw	r24, r22
    31aa:	bc 01       	movw	r22, r24
    31ac:	cd 01       	movw	r24, r26
    31ae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    31b2:	dc 01       	movw	r26, r24
    31b4:	cb 01       	movw	r24, r22
    31b6:	9e 83       	std	Y+6, r25	; 0x06
    31b8:	8d 83       	std	Y+5, r24	; 0x05
    31ba:	0f c0       	rjmp	.+30     	; 0x31da <HLCD8_voidSendData+0xee>
    31bc:	88 ec       	ldi	r24, 0xC8	; 200
    31be:	90 e0       	ldi	r25, 0x00	; 0
    31c0:	9c 83       	std	Y+4, r25	; 0x04
    31c2:	8b 83       	std	Y+3, r24	; 0x03
    31c4:	8b 81       	ldd	r24, Y+3	; 0x03
    31c6:	9c 81       	ldd	r25, Y+4	; 0x04
    31c8:	01 97       	sbiw	r24, 0x01	; 1
    31ca:	f1 f7       	brne	.-4      	; 0x31c8 <HLCD8_voidSendData+0xdc>
    31cc:	9c 83       	std	Y+4, r25	; 0x04
    31ce:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    31d0:	8d 81       	ldd	r24, Y+5	; 0x05
    31d2:	9e 81       	ldd	r25, Y+6	; 0x06
    31d4:	01 97       	sbiw	r24, 0x01	; 1
    31d6:	9e 83       	std	Y+6, r25	; 0x06
    31d8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    31da:	8d 81       	ldd	r24, Y+5	; 0x05
    31dc:	9e 81       	ldd	r25, Y+6	; 0x06
    31de:	00 97       	sbiw	r24, 0x00	; 0
    31e0:	69 f7       	brne	.-38     	; 0x31bc <HLCD8_voidSendData+0xd0>
    31e2:	14 c0       	rjmp	.+40     	; 0x320c <HLCD8_voidSendData+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    31e4:	6f 81       	ldd	r22, Y+7	; 0x07
    31e6:	78 85       	ldd	r23, Y+8	; 0x08
    31e8:	89 85       	ldd	r24, Y+9	; 0x09
    31ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    31ec:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    31f0:	dc 01       	movw	r26, r24
    31f2:	cb 01       	movw	r24, r22
    31f4:	9e 83       	std	Y+6, r25	; 0x06
    31f6:	8d 83       	std	Y+5, r24	; 0x05
    31f8:	8d 81       	ldd	r24, Y+5	; 0x05
    31fa:	9e 81       	ldd	r25, Y+6	; 0x06
    31fc:	9a 83       	std	Y+2, r25	; 0x02
    31fe:	89 83       	std	Y+1, r24	; 0x01
    3200:	89 81       	ldd	r24, Y+1	; 0x01
    3202:	9a 81       	ldd	r25, Y+2	; 0x02
    3204:	01 97       	sbiw	r24, 0x01	; 1
    3206:	f1 f7       	brne	.-4      	; 0x3204 <HLCD8_voidSendData+0x118>
    3208:	9a 83       	std	Y+2, r25	; 0x02
    320a:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(2);
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_LOW);
    320c:	82 e0       	ldi	r24, 0x02	; 2
    320e:	62 e0       	ldi	r22, 0x02	; 2
    3210:	40 e0       	ldi	r20, 0x00	; 0
    3212:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
}
    3216:	2f 96       	adiw	r28, 0x0f	; 15
    3218:	0f b6       	in	r0, 0x3f	; 63
    321a:	f8 94       	cli
    321c:	de bf       	out	0x3e, r29	; 62
    321e:	0f be       	out	0x3f, r0	; 63
    3220:	cd bf       	out	0x3d, r28	; 61
    3222:	cf 91       	pop	r28
    3224:	df 91       	pop	r29
    3226:	08 95       	ret

00003228 <HLCD8_voidInit>:


void HLCD8_voidInit()
{
    3228:	df 93       	push	r29
    322a:	cf 93       	push	r28
    322c:	cd b7       	in	r28, 0x3d	; 61
    322e:	de b7       	in	r29, 0x3e	; 62
    3230:	e8 97       	sbiw	r28, 0x38	; 56
    3232:	0f b6       	in	r0, 0x3f	; 63
    3234:	f8 94       	cli
    3236:	de bf       	out	0x3e, r29	; 62
    3238:	0f be       	out	0x3f, r0	; 63
    323a:	cd bf       	out	0x3d, r28	; 61
    323c:	80 e0       	ldi	r24, 0x00	; 0
    323e:	90 e0       	ldi	r25, 0x00	; 0
    3240:	a0 ef       	ldi	r26, 0xF0	; 240
    3242:	b1 e4       	ldi	r27, 0x41	; 65
    3244:	8d ab       	std	Y+53, r24	; 0x35
    3246:	9e ab       	std	Y+54, r25	; 0x36
    3248:	af ab       	std	Y+55, r26	; 0x37
    324a:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    324c:	6d a9       	ldd	r22, Y+53	; 0x35
    324e:	7e a9       	ldd	r23, Y+54	; 0x36
    3250:	8f a9       	ldd	r24, Y+55	; 0x37
    3252:	98 ad       	ldd	r25, Y+56	; 0x38
    3254:	20 e0       	ldi	r18, 0x00	; 0
    3256:	30 e0       	ldi	r19, 0x00	; 0
    3258:	4a ef       	ldi	r20, 0xFA	; 250
    325a:	54 e4       	ldi	r21, 0x44	; 68
    325c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3260:	dc 01       	movw	r26, r24
    3262:	cb 01       	movw	r24, r22
    3264:	89 ab       	std	Y+49, r24	; 0x31
    3266:	9a ab       	std	Y+50, r25	; 0x32
    3268:	ab ab       	std	Y+51, r26	; 0x33
    326a:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    326c:	69 a9       	ldd	r22, Y+49	; 0x31
    326e:	7a a9       	ldd	r23, Y+50	; 0x32
    3270:	8b a9       	ldd	r24, Y+51	; 0x33
    3272:	9c a9       	ldd	r25, Y+52	; 0x34
    3274:	20 e0       	ldi	r18, 0x00	; 0
    3276:	30 e0       	ldi	r19, 0x00	; 0
    3278:	40 e8       	ldi	r20, 0x80	; 128
    327a:	5f e3       	ldi	r21, 0x3F	; 63
    327c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3280:	88 23       	and	r24, r24
    3282:	2c f4       	brge	.+10     	; 0x328e <HLCD8_voidInit+0x66>
		__ticks = 1;
    3284:	81 e0       	ldi	r24, 0x01	; 1
    3286:	90 e0       	ldi	r25, 0x00	; 0
    3288:	98 ab       	std	Y+48, r25	; 0x30
    328a:	8f a7       	std	Y+47, r24	; 0x2f
    328c:	3f c0       	rjmp	.+126    	; 0x330c <HLCD8_voidInit+0xe4>
	else if (__tmp > 65535)
    328e:	69 a9       	ldd	r22, Y+49	; 0x31
    3290:	7a a9       	ldd	r23, Y+50	; 0x32
    3292:	8b a9       	ldd	r24, Y+51	; 0x33
    3294:	9c a9       	ldd	r25, Y+52	; 0x34
    3296:	20 e0       	ldi	r18, 0x00	; 0
    3298:	3f ef       	ldi	r19, 0xFF	; 255
    329a:	4f e7       	ldi	r20, 0x7F	; 127
    329c:	57 e4       	ldi	r21, 0x47	; 71
    329e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    32a2:	18 16       	cp	r1, r24
    32a4:	4c f5       	brge	.+82     	; 0x32f8 <HLCD8_voidInit+0xd0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    32a6:	6d a9       	ldd	r22, Y+53	; 0x35
    32a8:	7e a9       	ldd	r23, Y+54	; 0x36
    32aa:	8f a9       	ldd	r24, Y+55	; 0x37
    32ac:	98 ad       	ldd	r25, Y+56	; 0x38
    32ae:	20 e0       	ldi	r18, 0x00	; 0
    32b0:	30 e0       	ldi	r19, 0x00	; 0
    32b2:	40 e2       	ldi	r20, 0x20	; 32
    32b4:	51 e4       	ldi	r21, 0x41	; 65
    32b6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    32ba:	dc 01       	movw	r26, r24
    32bc:	cb 01       	movw	r24, r22
    32be:	bc 01       	movw	r22, r24
    32c0:	cd 01       	movw	r24, r26
    32c2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    32c6:	dc 01       	movw	r26, r24
    32c8:	cb 01       	movw	r24, r22
    32ca:	98 ab       	std	Y+48, r25	; 0x30
    32cc:	8f a7       	std	Y+47, r24	; 0x2f
    32ce:	0f c0       	rjmp	.+30     	; 0x32ee <HLCD8_voidInit+0xc6>
    32d0:	88 ec       	ldi	r24, 0xC8	; 200
    32d2:	90 e0       	ldi	r25, 0x00	; 0
    32d4:	9e a7       	std	Y+46, r25	; 0x2e
    32d6:	8d a7       	std	Y+45, r24	; 0x2d
    32d8:	8d a5       	ldd	r24, Y+45	; 0x2d
    32da:	9e a5       	ldd	r25, Y+46	; 0x2e
    32dc:	01 97       	sbiw	r24, 0x01	; 1
    32de:	f1 f7       	brne	.-4      	; 0x32dc <HLCD8_voidInit+0xb4>
    32e0:	9e a7       	std	Y+46, r25	; 0x2e
    32e2:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    32e4:	8f a5       	ldd	r24, Y+47	; 0x2f
    32e6:	98 a9       	ldd	r25, Y+48	; 0x30
    32e8:	01 97       	sbiw	r24, 0x01	; 1
    32ea:	98 ab       	std	Y+48, r25	; 0x30
    32ec:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    32ee:	8f a5       	ldd	r24, Y+47	; 0x2f
    32f0:	98 a9       	ldd	r25, Y+48	; 0x30
    32f2:	00 97       	sbiw	r24, 0x00	; 0
    32f4:	69 f7       	brne	.-38     	; 0x32d0 <HLCD8_voidInit+0xa8>
    32f6:	14 c0       	rjmp	.+40     	; 0x3320 <HLCD8_voidInit+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    32f8:	69 a9       	ldd	r22, Y+49	; 0x31
    32fa:	7a a9       	ldd	r23, Y+50	; 0x32
    32fc:	8b a9       	ldd	r24, Y+51	; 0x33
    32fe:	9c a9       	ldd	r25, Y+52	; 0x34
    3300:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3304:	dc 01       	movw	r26, r24
    3306:	cb 01       	movw	r24, r22
    3308:	98 ab       	std	Y+48, r25	; 0x30
    330a:	8f a7       	std	Y+47, r24	; 0x2f
    330c:	8f a5       	ldd	r24, Y+47	; 0x2f
    330e:	98 a9       	ldd	r25, Y+48	; 0x30
    3310:	9c a7       	std	Y+44, r25	; 0x2c
    3312:	8b a7       	std	Y+43, r24	; 0x2b
    3314:	8b a5       	ldd	r24, Y+43	; 0x2b
    3316:	9c a5       	ldd	r25, Y+44	; 0x2c
    3318:	01 97       	sbiw	r24, 0x01	; 1
    331a:	f1 f7       	brne	.-4      	; 0x3318 <HLCD8_voidInit+0xf0>
    331c:	9c a7       	std	Y+44, r25	; 0x2c
    331e:	8b a7       	std	Y+43, r24	; 0x2b
    _delay_ms(30);
    HLCD8_voidSendCommand(FUNCTION_SET);
    3320:	88 e3       	ldi	r24, 0x38	; 56
    3322:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <HLCD8_voidSendCommand>
    3326:	80 e0       	ldi	r24, 0x00	; 0
    3328:	90 e0       	ldi	r25, 0x00	; 0
    332a:	a0 e8       	ldi	r26, 0x80	; 128
    332c:	bf e3       	ldi	r27, 0x3F	; 63
    332e:	8f a3       	std	Y+39, r24	; 0x27
    3330:	98 a7       	std	Y+40, r25	; 0x28
    3332:	a9 a7       	std	Y+41, r26	; 0x29
    3334:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3336:	6f a1       	ldd	r22, Y+39	; 0x27
    3338:	78 a5       	ldd	r23, Y+40	; 0x28
    333a:	89 a5       	ldd	r24, Y+41	; 0x29
    333c:	9a a5       	ldd	r25, Y+42	; 0x2a
    333e:	20 e0       	ldi	r18, 0x00	; 0
    3340:	30 e0       	ldi	r19, 0x00	; 0
    3342:	4a ef       	ldi	r20, 0xFA	; 250
    3344:	54 e4       	ldi	r21, 0x44	; 68
    3346:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    334a:	dc 01       	movw	r26, r24
    334c:	cb 01       	movw	r24, r22
    334e:	8b a3       	std	Y+35, r24	; 0x23
    3350:	9c a3       	std	Y+36, r25	; 0x24
    3352:	ad a3       	std	Y+37, r26	; 0x25
    3354:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    3356:	6b a1       	ldd	r22, Y+35	; 0x23
    3358:	7c a1       	ldd	r23, Y+36	; 0x24
    335a:	8d a1       	ldd	r24, Y+37	; 0x25
    335c:	9e a1       	ldd	r25, Y+38	; 0x26
    335e:	20 e0       	ldi	r18, 0x00	; 0
    3360:	30 e0       	ldi	r19, 0x00	; 0
    3362:	40 e8       	ldi	r20, 0x80	; 128
    3364:	5f e3       	ldi	r21, 0x3F	; 63
    3366:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    336a:	88 23       	and	r24, r24
    336c:	2c f4       	brge	.+10     	; 0x3378 <HLCD8_voidInit+0x150>
		__ticks = 1;
    336e:	81 e0       	ldi	r24, 0x01	; 1
    3370:	90 e0       	ldi	r25, 0x00	; 0
    3372:	9a a3       	std	Y+34, r25	; 0x22
    3374:	89 a3       	std	Y+33, r24	; 0x21
    3376:	3f c0       	rjmp	.+126    	; 0x33f6 <HLCD8_voidInit+0x1ce>
	else if (__tmp > 65535)
    3378:	6b a1       	ldd	r22, Y+35	; 0x23
    337a:	7c a1       	ldd	r23, Y+36	; 0x24
    337c:	8d a1       	ldd	r24, Y+37	; 0x25
    337e:	9e a1       	ldd	r25, Y+38	; 0x26
    3380:	20 e0       	ldi	r18, 0x00	; 0
    3382:	3f ef       	ldi	r19, 0xFF	; 255
    3384:	4f e7       	ldi	r20, 0x7F	; 127
    3386:	57 e4       	ldi	r21, 0x47	; 71
    3388:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    338c:	18 16       	cp	r1, r24
    338e:	4c f5       	brge	.+82     	; 0x33e2 <HLCD8_voidInit+0x1ba>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3390:	6f a1       	ldd	r22, Y+39	; 0x27
    3392:	78 a5       	ldd	r23, Y+40	; 0x28
    3394:	89 a5       	ldd	r24, Y+41	; 0x29
    3396:	9a a5       	ldd	r25, Y+42	; 0x2a
    3398:	20 e0       	ldi	r18, 0x00	; 0
    339a:	30 e0       	ldi	r19, 0x00	; 0
    339c:	40 e2       	ldi	r20, 0x20	; 32
    339e:	51 e4       	ldi	r21, 0x41	; 65
    33a0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    33a4:	dc 01       	movw	r26, r24
    33a6:	cb 01       	movw	r24, r22
    33a8:	bc 01       	movw	r22, r24
    33aa:	cd 01       	movw	r24, r26
    33ac:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    33b0:	dc 01       	movw	r26, r24
    33b2:	cb 01       	movw	r24, r22
    33b4:	9a a3       	std	Y+34, r25	; 0x22
    33b6:	89 a3       	std	Y+33, r24	; 0x21
    33b8:	0f c0       	rjmp	.+30     	; 0x33d8 <HLCD8_voidInit+0x1b0>
    33ba:	88 ec       	ldi	r24, 0xC8	; 200
    33bc:	90 e0       	ldi	r25, 0x00	; 0
    33be:	98 a3       	std	Y+32, r25	; 0x20
    33c0:	8f 8f       	std	Y+31, r24	; 0x1f
    33c2:	8f 8d       	ldd	r24, Y+31	; 0x1f
    33c4:	98 a1       	ldd	r25, Y+32	; 0x20
    33c6:	01 97       	sbiw	r24, 0x01	; 1
    33c8:	f1 f7       	brne	.-4      	; 0x33c6 <HLCD8_voidInit+0x19e>
    33ca:	98 a3       	std	Y+32, r25	; 0x20
    33cc:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    33ce:	89 a1       	ldd	r24, Y+33	; 0x21
    33d0:	9a a1       	ldd	r25, Y+34	; 0x22
    33d2:	01 97       	sbiw	r24, 0x01	; 1
    33d4:	9a a3       	std	Y+34, r25	; 0x22
    33d6:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    33d8:	89 a1       	ldd	r24, Y+33	; 0x21
    33da:	9a a1       	ldd	r25, Y+34	; 0x22
    33dc:	00 97       	sbiw	r24, 0x00	; 0
    33de:	69 f7       	brne	.-38     	; 0x33ba <HLCD8_voidInit+0x192>
    33e0:	14 c0       	rjmp	.+40     	; 0x340a <HLCD8_voidInit+0x1e2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    33e2:	6b a1       	ldd	r22, Y+35	; 0x23
    33e4:	7c a1       	ldd	r23, Y+36	; 0x24
    33e6:	8d a1       	ldd	r24, Y+37	; 0x25
    33e8:	9e a1       	ldd	r25, Y+38	; 0x26
    33ea:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    33ee:	dc 01       	movw	r26, r24
    33f0:	cb 01       	movw	r24, r22
    33f2:	9a a3       	std	Y+34, r25	; 0x22
    33f4:	89 a3       	std	Y+33, r24	; 0x21
    33f6:	89 a1       	ldd	r24, Y+33	; 0x21
    33f8:	9a a1       	ldd	r25, Y+34	; 0x22
    33fa:	9e 8f       	std	Y+30, r25	; 0x1e
    33fc:	8d 8f       	std	Y+29, r24	; 0x1d
    33fe:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3400:	9e 8d       	ldd	r25, Y+30	; 0x1e
    3402:	01 97       	sbiw	r24, 0x01	; 1
    3404:	f1 f7       	brne	.-4      	; 0x3402 <HLCD8_voidInit+0x1da>
    3406:	9e 8f       	std	Y+30, r25	; 0x1e
    3408:	8d 8f       	std	Y+29, r24	; 0x1d
    _delay_ms(1);
    HLCD8_voidSendCommand(ON_OFF_CONTROL);
    340a:	8c e0       	ldi	r24, 0x0C	; 12
    340c:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <HLCD8_voidSendCommand>
    3410:	80 e0       	ldi	r24, 0x00	; 0
    3412:	90 e0       	ldi	r25, 0x00	; 0
    3414:	a0 e8       	ldi	r26, 0x80	; 128
    3416:	bf e3       	ldi	r27, 0x3F	; 63
    3418:	89 8f       	std	Y+25, r24	; 0x19
    341a:	9a 8f       	std	Y+26, r25	; 0x1a
    341c:	ab 8f       	std	Y+27, r26	; 0x1b
    341e:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3420:	69 8d       	ldd	r22, Y+25	; 0x19
    3422:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3424:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3426:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3428:	20 e0       	ldi	r18, 0x00	; 0
    342a:	30 e0       	ldi	r19, 0x00	; 0
    342c:	4a ef       	ldi	r20, 0xFA	; 250
    342e:	54 e4       	ldi	r21, 0x44	; 68
    3430:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3434:	dc 01       	movw	r26, r24
    3436:	cb 01       	movw	r24, r22
    3438:	8d 8b       	std	Y+21, r24	; 0x15
    343a:	9e 8b       	std	Y+22, r25	; 0x16
    343c:	af 8b       	std	Y+23, r26	; 0x17
    343e:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    3440:	6d 89       	ldd	r22, Y+21	; 0x15
    3442:	7e 89       	ldd	r23, Y+22	; 0x16
    3444:	8f 89       	ldd	r24, Y+23	; 0x17
    3446:	98 8d       	ldd	r25, Y+24	; 0x18
    3448:	20 e0       	ldi	r18, 0x00	; 0
    344a:	30 e0       	ldi	r19, 0x00	; 0
    344c:	40 e8       	ldi	r20, 0x80	; 128
    344e:	5f e3       	ldi	r21, 0x3F	; 63
    3450:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3454:	88 23       	and	r24, r24
    3456:	2c f4       	brge	.+10     	; 0x3462 <HLCD8_voidInit+0x23a>
		__ticks = 1;
    3458:	81 e0       	ldi	r24, 0x01	; 1
    345a:	90 e0       	ldi	r25, 0x00	; 0
    345c:	9c 8b       	std	Y+20, r25	; 0x14
    345e:	8b 8b       	std	Y+19, r24	; 0x13
    3460:	3f c0       	rjmp	.+126    	; 0x34e0 <HLCD8_voidInit+0x2b8>
	else if (__tmp > 65535)
    3462:	6d 89       	ldd	r22, Y+21	; 0x15
    3464:	7e 89       	ldd	r23, Y+22	; 0x16
    3466:	8f 89       	ldd	r24, Y+23	; 0x17
    3468:	98 8d       	ldd	r25, Y+24	; 0x18
    346a:	20 e0       	ldi	r18, 0x00	; 0
    346c:	3f ef       	ldi	r19, 0xFF	; 255
    346e:	4f e7       	ldi	r20, 0x7F	; 127
    3470:	57 e4       	ldi	r21, 0x47	; 71
    3472:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3476:	18 16       	cp	r1, r24
    3478:	4c f5       	brge	.+82     	; 0x34cc <HLCD8_voidInit+0x2a4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    347a:	69 8d       	ldd	r22, Y+25	; 0x19
    347c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    347e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3480:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3482:	20 e0       	ldi	r18, 0x00	; 0
    3484:	30 e0       	ldi	r19, 0x00	; 0
    3486:	40 e2       	ldi	r20, 0x20	; 32
    3488:	51 e4       	ldi	r21, 0x41	; 65
    348a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    348e:	dc 01       	movw	r26, r24
    3490:	cb 01       	movw	r24, r22
    3492:	bc 01       	movw	r22, r24
    3494:	cd 01       	movw	r24, r26
    3496:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    349a:	dc 01       	movw	r26, r24
    349c:	cb 01       	movw	r24, r22
    349e:	9c 8b       	std	Y+20, r25	; 0x14
    34a0:	8b 8b       	std	Y+19, r24	; 0x13
    34a2:	0f c0       	rjmp	.+30     	; 0x34c2 <HLCD8_voidInit+0x29a>
    34a4:	88 ec       	ldi	r24, 0xC8	; 200
    34a6:	90 e0       	ldi	r25, 0x00	; 0
    34a8:	9a 8b       	std	Y+18, r25	; 0x12
    34aa:	89 8b       	std	Y+17, r24	; 0x11
    34ac:	89 89       	ldd	r24, Y+17	; 0x11
    34ae:	9a 89       	ldd	r25, Y+18	; 0x12
    34b0:	01 97       	sbiw	r24, 0x01	; 1
    34b2:	f1 f7       	brne	.-4      	; 0x34b0 <HLCD8_voidInit+0x288>
    34b4:	9a 8b       	std	Y+18, r25	; 0x12
    34b6:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    34b8:	8b 89       	ldd	r24, Y+19	; 0x13
    34ba:	9c 89       	ldd	r25, Y+20	; 0x14
    34bc:	01 97       	sbiw	r24, 0x01	; 1
    34be:	9c 8b       	std	Y+20, r25	; 0x14
    34c0:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    34c2:	8b 89       	ldd	r24, Y+19	; 0x13
    34c4:	9c 89       	ldd	r25, Y+20	; 0x14
    34c6:	00 97       	sbiw	r24, 0x00	; 0
    34c8:	69 f7       	brne	.-38     	; 0x34a4 <HLCD8_voidInit+0x27c>
    34ca:	14 c0       	rjmp	.+40     	; 0x34f4 <HLCD8_voidInit+0x2cc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    34cc:	6d 89       	ldd	r22, Y+21	; 0x15
    34ce:	7e 89       	ldd	r23, Y+22	; 0x16
    34d0:	8f 89       	ldd	r24, Y+23	; 0x17
    34d2:	98 8d       	ldd	r25, Y+24	; 0x18
    34d4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    34d8:	dc 01       	movw	r26, r24
    34da:	cb 01       	movw	r24, r22
    34dc:	9c 8b       	std	Y+20, r25	; 0x14
    34de:	8b 8b       	std	Y+19, r24	; 0x13
    34e0:	8b 89       	ldd	r24, Y+19	; 0x13
    34e2:	9c 89       	ldd	r25, Y+20	; 0x14
    34e4:	98 8b       	std	Y+16, r25	; 0x10
    34e6:	8f 87       	std	Y+15, r24	; 0x0f
    34e8:	8f 85       	ldd	r24, Y+15	; 0x0f
    34ea:	98 89       	ldd	r25, Y+16	; 0x10
    34ec:	01 97       	sbiw	r24, 0x01	; 1
    34ee:	f1 f7       	brne	.-4      	; 0x34ec <HLCD8_voidInit+0x2c4>
    34f0:	98 8b       	std	Y+16, r25	; 0x10
    34f2:	8f 87       	std	Y+15, r24	; 0x0f
    _delay_ms(1);
    HLCD8_voidSendCommand(DISPLAY_CLEAR);
    34f4:	81 e0       	ldi	r24, 0x01	; 1
    34f6:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <HLCD8_voidSendCommand>
    34fa:	80 e0       	ldi	r24, 0x00	; 0
    34fc:	90 e0       	ldi	r25, 0x00	; 0
    34fe:	a0 e0       	ldi	r26, 0x00	; 0
    3500:	b0 e4       	ldi	r27, 0x40	; 64
    3502:	8b 87       	std	Y+11, r24	; 0x0b
    3504:	9c 87       	std	Y+12, r25	; 0x0c
    3506:	ad 87       	std	Y+13, r26	; 0x0d
    3508:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    350a:	6b 85       	ldd	r22, Y+11	; 0x0b
    350c:	7c 85       	ldd	r23, Y+12	; 0x0c
    350e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3510:	9e 85       	ldd	r25, Y+14	; 0x0e
    3512:	20 e0       	ldi	r18, 0x00	; 0
    3514:	30 e0       	ldi	r19, 0x00	; 0
    3516:	4a ef       	ldi	r20, 0xFA	; 250
    3518:	54 e4       	ldi	r21, 0x44	; 68
    351a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    351e:	dc 01       	movw	r26, r24
    3520:	cb 01       	movw	r24, r22
    3522:	8f 83       	std	Y+7, r24	; 0x07
    3524:	98 87       	std	Y+8, r25	; 0x08
    3526:	a9 87       	std	Y+9, r26	; 0x09
    3528:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    352a:	6f 81       	ldd	r22, Y+7	; 0x07
    352c:	78 85       	ldd	r23, Y+8	; 0x08
    352e:	89 85       	ldd	r24, Y+9	; 0x09
    3530:	9a 85       	ldd	r25, Y+10	; 0x0a
    3532:	20 e0       	ldi	r18, 0x00	; 0
    3534:	30 e0       	ldi	r19, 0x00	; 0
    3536:	40 e8       	ldi	r20, 0x80	; 128
    3538:	5f e3       	ldi	r21, 0x3F	; 63
    353a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    353e:	88 23       	and	r24, r24
    3540:	2c f4       	brge	.+10     	; 0x354c <HLCD8_voidInit+0x324>
		__ticks = 1;
    3542:	81 e0       	ldi	r24, 0x01	; 1
    3544:	90 e0       	ldi	r25, 0x00	; 0
    3546:	9e 83       	std	Y+6, r25	; 0x06
    3548:	8d 83       	std	Y+5, r24	; 0x05
    354a:	3f c0       	rjmp	.+126    	; 0x35ca <HLCD8_voidInit+0x3a2>
	else if (__tmp > 65535)
    354c:	6f 81       	ldd	r22, Y+7	; 0x07
    354e:	78 85       	ldd	r23, Y+8	; 0x08
    3550:	89 85       	ldd	r24, Y+9	; 0x09
    3552:	9a 85       	ldd	r25, Y+10	; 0x0a
    3554:	20 e0       	ldi	r18, 0x00	; 0
    3556:	3f ef       	ldi	r19, 0xFF	; 255
    3558:	4f e7       	ldi	r20, 0x7F	; 127
    355a:	57 e4       	ldi	r21, 0x47	; 71
    355c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3560:	18 16       	cp	r1, r24
    3562:	4c f5       	brge	.+82     	; 0x35b6 <HLCD8_voidInit+0x38e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3564:	6b 85       	ldd	r22, Y+11	; 0x0b
    3566:	7c 85       	ldd	r23, Y+12	; 0x0c
    3568:	8d 85       	ldd	r24, Y+13	; 0x0d
    356a:	9e 85       	ldd	r25, Y+14	; 0x0e
    356c:	20 e0       	ldi	r18, 0x00	; 0
    356e:	30 e0       	ldi	r19, 0x00	; 0
    3570:	40 e2       	ldi	r20, 0x20	; 32
    3572:	51 e4       	ldi	r21, 0x41	; 65
    3574:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3578:	dc 01       	movw	r26, r24
    357a:	cb 01       	movw	r24, r22
    357c:	bc 01       	movw	r22, r24
    357e:	cd 01       	movw	r24, r26
    3580:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3584:	dc 01       	movw	r26, r24
    3586:	cb 01       	movw	r24, r22
    3588:	9e 83       	std	Y+6, r25	; 0x06
    358a:	8d 83       	std	Y+5, r24	; 0x05
    358c:	0f c0       	rjmp	.+30     	; 0x35ac <HLCD8_voidInit+0x384>
    358e:	88 ec       	ldi	r24, 0xC8	; 200
    3590:	90 e0       	ldi	r25, 0x00	; 0
    3592:	9c 83       	std	Y+4, r25	; 0x04
    3594:	8b 83       	std	Y+3, r24	; 0x03
    3596:	8b 81       	ldd	r24, Y+3	; 0x03
    3598:	9c 81       	ldd	r25, Y+4	; 0x04
    359a:	01 97       	sbiw	r24, 0x01	; 1
    359c:	f1 f7       	brne	.-4      	; 0x359a <HLCD8_voidInit+0x372>
    359e:	9c 83       	std	Y+4, r25	; 0x04
    35a0:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    35a2:	8d 81       	ldd	r24, Y+5	; 0x05
    35a4:	9e 81       	ldd	r25, Y+6	; 0x06
    35a6:	01 97       	sbiw	r24, 0x01	; 1
    35a8:	9e 83       	std	Y+6, r25	; 0x06
    35aa:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    35ac:	8d 81       	ldd	r24, Y+5	; 0x05
    35ae:	9e 81       	ldd	r25, Y+6	; 0x06
    35b0:	00 97       	sbiw	r24, 0x00	; 0
    35b2:	69 f7       	brne	.-38     	; 0x358e <HLCD8_voidInit+0x366>
    35b4:	14 c0       	rjmp	.+40     	; 0x35de <HLCD8_voidInit+0x3b6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    35b6:	6f 81       	ldd	r22, Y+7	; 0x07
    35b8:	78 85       	ldd	r23, Y+8	; 0x08
    35ba:	89 85       	ldd	r24, Y+9	; 0x09
    35bc:	9a 85       	ldd	r25, Y+10	; 0x0a
    35be:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    35c2:	dc 01       	movw	r26, r24
    35c4:	cb 01       	movw	r24, r22
    35c6:	9e 83       	std	Y+6, r25	; 0x06
    35c8:	8d 83       	std	Y+5, r24	; 0x05
    35ca:	8d 81       	ldd	r24, Y+5	; 0x05
    35cc:	9e 81       	ldd	r25, Y+6	; 0x06
    35ce:	9a 83       	std	Y+2, r25	; 0x02
    35d0:	89 83       	std	Y+1, r24	; 0x01
    35d2:	89 81       	ldd	r24, Y+1	; 0x01
    35d4:	9a 81       	ldd	r25, Y+2	; 0x02
    35d6:	01 97       	sbiw	r24, 0x01	; 1
    35d8:	f1 f7       	brne	.-4      	; 0x35d6 <HLCD8_voidInit+0x3ae>
    35da:	9a 83       	std	Y+2, r25	; 0x02
    35dc:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(2);
    HLCD8_voidSendCommand(ENTRY_MODE_SET);
    35de:	86 e0       	ldi	r24, 0x06	; 6
    35e0:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <HLCD8_voidSendCommand>
}
    35e4:	e8 96       	adiw	r28, 0x38	; 56
    35e6:	0f b6       	in	r0, 0x3f	; 63
    35e8:	f8 94       	cli
    35ea:	de bf       	out	0x3e, r29	; 62
    35ec:	0f be       	out	0x3f, r0	; 63
    35ee:	cd bf       	out	0x3d, r28	; 61
    35f0:	cf 91       	pop	r28
    35f2:	df 91       	pop	r29
    35f4:	08 95       	ret

000035f6 <HLCD8_voidClearDisplay>:

void HLCD8_voidClearDisplay(void)
{
    35f6:	df 93       	push	r29
    35f8:	cf 93       	push	r28
    35fa:	cd b7       	in	r28, 0x3d	; 61
    35fc:	de b7       	in	r29, 0x3e	; 62
    35fe:	2e 97       	sbiw	r28, 0x0e	; 14
    3600:	0f b6       	in	r0, 0x3f	; 63
    3602:	f8 94       	cli
    3604:	de bf       	out	0x3e, r29	; 62
    3606:	0f be       	out	0x3f, r0	; 63
    3608:	cd bf       	out	0x3d, r28	; 61
    HLCD8_voidSendCommand(DISPLAY_CLEAR);
    360a:	81 e0       	ldi	r24, 0x01	; 1
    360c:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <HLCD8_voidSendCommand>
    3610:	80 e0       	ldi	r24, 0x00	; 0
    3612:	90 e0       	ldi	r25, 0x00	; 0
    3614:	a0 e0       	ldi	r26, 0x00	; 0
    3616:	b0 e4       	ldi	r27, 0x40	; 64
    3618:	8b 87       	std	Y+11, r24	; 0x0b
    361a:	9c 87       	std	Y+12, r25	; 0x0c
    361c:	ad 87       	std	Y+13, r26	; 0x0d
    361e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3620:	6b 85       	ldd	r22, Y+11	; 0x0b
    3622:	7c 85       	ldd	r23, Y+12	; 0x0c
    3624:	8d 85       	ldd	r24, Y+13	; 0x0d
    3626:	9e 85       	ldd	r25, Y+14	; 0x0e
    3628:	20 e0       	ldi	r18, 0x00	; 0
    362a:	30 e0       	ldi	r19, 0x00	; 0
    362c:	4a ef       	ldi	r20, 0xFA	; 250
    362e:	54 e4       	ldi	r21, 0x44	; 68
    3630:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3634:	dc 01       	movw	r26, r24
    3636:	cb 01       	movw	r24, r22
    3638:	8f 83       	std	Y+7, r24	; 0x07
    363a:	98 87       	std	Y+8, r25	; 0x08
    363c:	a9 87       	std	Y+9, r26	; 0x09
    363e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3640:	6f 81       	ldd	r22, Y+7	; 0x07
    3642:	78 85       	ldd	r23, Y+8	; 0x08
    3644:	89 85       	ldd	r24, Y+9	; 0x09
    3646:	9a 85       	ldd	r25, Y+10	; 0x0a
    3648:	20 e0       	ldi	r18, 0x00	; 0
    364a:	30 e0       	ldi	r19, 0x00	; 0
    364c:	40 e8       	ldi	r20, 0x80	; 128
    364e:	5f e3       	ldi	r21, 0x3F	; 63
    3650:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3654:	88 23       	and	r24, r24
    3656:	2c f4       	brge	.+10     	; 0x3662 <HLCD8_voidClearDisplay+0x6c>
		__ticks = 1;
    3658:	81 e0       	ldi	r24, 0x01	; 1
    365a:	90 e0       	ldi	r25, 0x00	; 0
    365c:	9e 83       	std	Y+6, r25	; 0x06
    365e:	8d 83       	std	Y+5, r24	; 0x05
    3660:	3f c0       	rjmp	.+126    	; 0x36e0 <HLCD8_voidClearDisplay+0xea>
	else if (__tmp > 65535)
    3662:	6f 81       	ldd	r22, Y+7	; 0x07
    3664:	78 85       	ldd	r23, Y+8	; 0x08
    3666:	89 85       	ldd	r24, Y+9	; 0x09
    3668:	9a 85       	ldd	r25, Y+10	; 0x0a
    366a:	20 e0       	ldi	r18, 0x00	; 0
    366c:	3f ef       	ldi	r19, 0xFF	; 255
    366e:	4f e7       	ldi	r20, 0x7F	; 127
    3670:	57 e4       	ldi	r21, 0x47	; 71
    3672:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3676:	18 16       	cp	r1, r24
    3678:	4c f5       	brge	.+82     	; 0x36cc <HLCD8_voidClearDisplay+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    367a:	6b 85       	ldd	r22, Y+11	; 0x0b
    367c:	7c 85       	ldd	r23, Y+12	; 0x0c
    367e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3680:	9e 85       	ldd	r25, Y+14	; 0x0e
    3682:	20 e0       	ldi	r18, 0x00	; 0
    3684:	30 e0       	ldi	r19, 0x00	; 0
    3686:	40 e2       	ldi	r20, 0x20	; 32
    3688:	51 e4       	ldi	r21, 0x41	; 65
    368a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    368e:	dc 01       	movw	r26, r24
    3690:	cb 01       	movw	r24, r22
    3692:	bc 01       	movw	r22, r24
    3694:	cd 01       	movw	r24, r26
    3696:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    369a:	dc 01       	movw	r26, r24
    369c:	cb 01       	movw	r24, r22
    369e:	9e 83       	std	Y+6, r25	; 0x06
    36a0:	8d 83       	std	Y+5, r24	; 0x05
    36a2:	0f c0       	rjmp	.+30     	; 0x36c2 <HLCD8_voidClearDisplay+0xcc>
    36a4:	88 ec       	ldi	r24, 0xC8	; 200
    36a6:	90 e0       	ldi	r25, 0x00	; 0
    36a8:	9c 83       	std	Y+4, r25	; 0x04
    36aa:	8b 83       	std	Y+3, r24	; 0x03
    36ac:	8b 81       	ldd	r24, Y+3	; 0x03
    36ae:	9c 81       	ldd	r25, Y+4	; 0x04
    36b0:	01 97       	sbiw	r24, 0x01	; 1
    36b2:	f1 f7       	brne	.-4      	; 0x36b0 <HLCD8_voidClearDisplay+0xba>
    36b4:	9c 83       	std	Y+4, r25	; 0x04
    36b6:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    36b8:	8d 81       	ldd	r24, Y+5	; 0x05
    36ba:	9e 81       	ldd	r25, Y+6	; 0x06
    36bc:	01 97       	sbiw	r24, 0x01	; 1
    36be:	9e 83       	std	Y+6, r25	; 0x06
    36c0:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    36c2:	8d 81       	ldd	r24, Y+5	; 0x05
    36c4:	9e 81       	ldd	r25, Y+6	; 0x06
    36c6:	00 97       	sbiw	r24, 0x00	; 0
    36c8:	69 f7       	brne	.-38     	; 0x36a4 <HLCD8_voidClearDisplay+0xae>
    36ca:	14 c0       	rjmp	.+40     	; 0x36f4 <HLCD8_voidClearDisplay+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    36cc:	6f 81       	ldd	r22, Y+7	; 0x07
    36ce:	78 85       	ldd	r23, Y+8	; 0x08
    36d0:	89 85       	ldd	r24, Y+9	; 0x09
    36d2:	9a 85       	ldd	r25, Y+10	; 0x0a
    36d4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    36d8:	dc 01       	movw	r26, r24
    36da:	cb 01       	movw	r24, r22
    36dc:	9e 83       	std	Y+6, r25	; 0x06
    36de:	8d 83       	std	Y+5, r24	; 0x05
    36e0:	8d 81       	ldd	r24, Y+5	; 0x05
    36e2:	9e 81       	ldd	r25, Y+6	; 0x06
    36e4:	9a 83       	std	Y+2, r25	; 0x02
    36e6:	89 83       	std	Y+1, r24	; 0x01
    36e8:	89 81       	ldd	r24, Y+1	; 0x01
    36ea:	9a 81       	ldd	r25, Y+2	; 0x02
    36ec:	01 97       	sbiw	r24, 0x01	; 1
    36ee:	f1 f7       	brne	.-4      	; 0x36ec <HLCD8_voidClearDisplay+0xf6>
    36f0:	9a 83       	std	Y+2, r25	; 0x02
    36f2:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(2);
}
    36f4:	2e 96       	adiw	r28, 0x0e	; 14
    36f6:	0f b6       	in	r0, 0x3f	; 63
    36f8:	f8 94       	cli
    36fa:	de bf       	out	0x3e, r29	; 62
    36fc:	0f be       	out	0x3f, r0	; 63
    36fe:	cd bf       	out	0x3d, r28	; 61
    3700:	cf 91       	pop	r28
    3702:	df 91       	pop	r29
    3704:	08 95       	ret

00003706 <HLCD8_voidSendString>:


void HLCD8_voidSendString(u8 * A_Pu8String)
{
    3706:	df 93       	push	r29
    3708:	cf 93       	push	r28
    370a:	00 d0       	rcall	.+0      	; 0x370c <HLCD8_voidSendString+0x6>
    370c:	0f 92       	push	r0
    370e:	cd b7       	in	r28, 0x3d	; 61
    3710:	de b7       	in	r29, 0x3e	; 62
    3712:	9b 83       	std	Y+3, r25	; 0x03
    3714:	8a 83       	std	Y+2, r24	; 0x02
    u8 local_u8Couter=0;
    3716:	19 82       	std	Y+1, r1	; 0x01
    3718:	0e c0       	rjmp	.+28     	; 0x3736 <HLCD8_voidSendString+0x30>
    while (A_Pu8String[local_u8Couter]!='\0')
    {
        HLCD8_voidSendData(A_Pu8String[local_u8Couter]);
    371a:	89 81       	ldd	r24, Y+1	; 0x01
    371c:	28 2f       	mov	r18, r24
    371e:	30 e0       	ldi	r19, 0x00	; 0
    3720:	8a 81       	ldd	r24, Y+2	; 0x02
    3722:	9b 81       	ldd	r25, Y+3	; 0x03
    3724:	fc 01       	movw	r30, r24
    3726:	e2 0f       	add	r30, r18
    3728:	f3 1f       	adc	r31, r19
    372a:	80 81       	ld	r24, Z
    372c:	0e 94 76 18 	call	0x30ec	; 0x30ec <HLCD8_voidSendData>
        local_u8Couter++;
    3730:	89 81       	ldd	r24, Y+1	; 0x01
    3732:	8f 5f       	subi	r24, 0xFF	; 255
    3734:	89 83       	std	Y+1, r24	; 0x01


void HLCD8_voidSendString(u8 * A_Pu8String)
{
    u8 local_u8Couter=0;
    while (A_Pu8String[local_u8Couter]!='\0')
    3736:	89 81       	ldd	r24, Y+1	; 0x01
    3738:	28 2f       	mov	r18, r24
    373a:	30 e0       	ldi	r19, 0x00	; 0
    373c:	8a 81       	ldd	r24, Y+2	; 0x02
    373e:	9b 81       	ldd	r25, Y+3	; 0x03
    3740:	fc 01       	movw	r30, r24
    3742:	e2 0f       	add	r30, r18
    3744:	f3 1f       	adc	r31, r19
    3746:	80 81       	ld	r24, Z
    3748:	88 23       	and	r24, r24
    374a:	39 f7       	brne	.-50     	; 0x371a <HLCD8_voidSendString+0x14>
    {
        HLCD8_voidSendData(A_Pu8String[local_u8Couter]);
        local_u8Couter++;
    }
    
}
    374c:	0f 90       	pop	r0
    374e:	0f 90       	pop	r0
    3750:	0f 90       	pop	r0
    3752:	cf 91       	pop	r28
    3754:	df 91       	pop	r29
    3756:	08 95       	ret

00003758 <HLCD8_voidGoToPos>:

void HLCD8_voidGoToPos(u8 A_u8RowNum,u8 A_u8ColNum)
{
    3758:	df 93       	push	r29
    375a:	cf 93       	push	r28
    375c:	cd b7       	in	r28, 0x3d	; 61
    375e:	de b7       	in	r29, 0x3e	; 62
    3760:	63 97       	sbiw	r28, 0x13	; 19
    3762:	0f b6       	in	r0, 0x3f	; 63
    3764:	f8 94       	cli
    3766:	de bf       	out	0x3e, r29	; 62
    3768:	0f be       	out	0x3f, r0	; 63
    376a:	cd bf       	out	0x3d, r28	; 61
    376c:	88 8b       	std	Y+16, r24	; 0x10
    376e:	69 8b       	std	Y+17, r22	; 0x11
    // }
    // _delay_ms(1);
    /************************************************************/ 
    //Second method
	u8 local_u8Address;
    switch(A_u8RowNum)
    3770:	88 89       	ldd	r24, Y+16	; 0x10
    3772:	28 2f       	mov	r18, r24
    3774:	30 e0       	ldi	r19, 0x00	; 0
    3776:	3b 8b       	std	Y+19, r19	; 0x13
    3778:	2a 8b       	std	Y+18, r18	; 0x12
    377a:	8a 89       	ldd	r24, Y+18	; 0x12
    377c:	9b 89       	ldd	r25, Y+19	; 0x13
    377e:	81 30       	cpi	r24, 0x01	; 1
    3780:	91 05       	cpc	r25, r1
    3782:	31 f0       	breq	.+12     	; 0x3790 <HLCD8_voidGoToPos+0x38>
    3784:	2a 89       	ldd	r18, Y+18	; 0x12
    3786:	3b 89       	ldd	r19, Y+19	; 0x13
    3788:	22 30       	cpi	r18, 0x02	; 2
    378a:	31 05       	cpc	r19, r1
    378c:	59 f0       	breq	.+22     	; 0x37a4 <HLCD8_voidGoToPos+0x4c>
    378e:	13 c0       	rjmp	.+38     	; 0x37b6 <HLCD8_voidGoToPos+0x5e>
    {
        case LCD_ROW_ONE:
        local_u8Address=FIRST_ROW_ADDRESS + A_u8ColNum -1;
    3790:	89 89       	ldd	r24, Y+17	; 0x11
    3792:	81 50       	subi	r24, 0x01	; 1
    3794:	8f 87       	std	Y+15, r24	; 0x0f
        SET_BIT(local_u8Address,PIN7);
    3796:	8f 85       	ldd	r24, Y+15	; 0x0f
    3798:	80 68       	ori	r24, 0x80	; 128
    379a:	8f 87       	std	Y+15, r24	; 0x0f
        HLCD8_voidSendCommand(local_u8Address);
    379c:	8f 85       	ldd	r24, Y+15	; 0x0f
    379e:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <HLCD8_voidSendCommand>
    37a2:	09 c0       	rjmp	.+18     	; 0x37b6 <HLCD8_voidGoToPos+0x5e>
        break;

        case LCD_ROW_TWO:
        local_u8Address=SECOND_ROW_ADDRESS + A_u8ColNum;
    37a4:	89 89       	ldd	r24, Y+17	; 0x11
    37a6:	81 5c       	subi	r24, 0xC1	; 193
    37a8:	8f 87       	std	Y+15, r24	; 0x0f
        SET_BIT(local_u8Address,PIN7);
    37aa:	8f 85       	ldd	r24, Y+15	; 0x0f
    37ac:	80 68       	ori	r24, 0x80	; 128
    37ae:	8f 87       	std	Y+15, r24	; 0x0f
        HLCD8_voidSendCommand(local_u8Address);
    37b0:	8f 85       	ldd	r24, Y+15	; 0x0f
    37b2:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <HLCD8_voidSendCommand>
    37b6:	80 e0       	ldi	r24, 0x00	; 0
    37b8:	90 e0       	ldi	r25, 0x00	; 0
    37ba:	a0 e8       	ldi	r26, 0x80	; 128
    37bc:	bf e3       	ldi	r27, 0x3F	; 63
    37be:	8b 87       	std	Y+11, r24	; 0x0b
    37c0:	9c 87       	std	Y+12, r25	; 0x0c
    37c2:	ad 87       	std	Y+13, r26	; 0x0d
    37c4:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    37c6:	6b 85       	ldd	r22, Y+11	; 0x0b
    37c8:	7c 85       	ldd	r23, Y+12	; 0x0c
    37ca:	8d 85       	ldd	r24, Y+13	; 0x0d
    37cc:	9e 85       	ldd	r25, Y+14	; 0x0e
    37ce:	20 e0       	ldi	r18, 0x00	; 0
    37d0:	30 e0       	ldi	r19, 0x00	; 0
    37d2:	4a ef       	ldi	r20, 0xFA	; 250
    37d4:	54 e4       	ldi	r21, 0x44	; 68
    37d6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    37da:	dc 01       	movw	r26, r24
    37dc:	cb 01       	movw	r24, r22
    37de:	8f 83       	std	Y+7, r24	; 0x07
    37e0:	98 87       	std	Y+8, r25	; 0x08
    37e2:	a9 87       	std	Y+9, r26	; 0x09
    37e4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    37e6:	6f 81       	ldd	r22, Y+7	; 0x07
    37e8:	78 85       	ldd	r23, Y+8	; 0x08
    37ea:	89 85       	ldd	r24, Y+9	; 0x09
    37ec:	9a 85       	ldd	r25, Y+10	; 0x0a
    37ee:	20 e0       	ldi	r18, 0x00	; 0
    37f0:	30 e0       	ldi	r19, 0x00	; 0
    37f2:	40 e8       	ldi	r20, 0x80	; 128
    37f4:	5f e3       	ldi	r21, 0x3F	; 63
    37f6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    37fa:	88 23       	and	r24, r24
    37fc:	2c f4       	brge	.+10     	; 0x3808 <HLCD8_voidGoToPos+0xb0>
		__ticks = 1;
    37fe:	81 e0       	ldi	r24, 0x01	; 1
    3800:	90 e0       	ldi	r25, 0x00	; 0
    3802:	9e 83       	std	Y+6, r25	; 0x06
    3804:	8d 83       	std	Y+5, r24	; 0x05
    3806:	3f c0       	rjmp	.+126    	; 0x3886 <HLCD8_voidGoToPos+0x12e>
	else if (__tmp > 65535)
    3808:	6f 81       	ldd	r22, Y+7	; 0x07
    380a:	78 85       	ldd	r23, Y+8	; 0x08
    380c:	89 85       	ldd	r24, Y+9	; 0x09
    380e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3810:	20 e0       	ldi	r18, 0x00	; 0
    3812:	3f ef       	ldi	r19, 0xFF	; 255
    3814:	4f e7       	ldi	r20, 0x7F	; 127
    3816:	57 e4       	ldi	r21, 0x47	; 71
    3818:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    381c:	18 16       	cp	r1, r24
    381e:	4c f5       	brge	.+82     	; 0x3872 <HLCD8_voidGoToPos+0x11a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3820:	6b 85       	ldd	r22, Y+11	; 0x0b
    3822:	7c 85       	ldd	r23, Y+12	; 0x0c
    3824:	8d 85       	ldd	r24, Y+13	; 0x0d
    3826:	9e 85       	ldd	r25, Y+14	; 0x0e
    3828:	20 e0       	ldi	r18, 0x00	; 0
    382a:	30 e0       	ldi	r19, 0x00	; 0
    382c:	40 e2       	ldi	r20, 0x20	; 32
    382e:	51 e4       	ldi	r21, 0x41	; 65
    3830:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3834:	dc 01       	movw	r26, r24
    3836:	cb 01       	movw	r24, r22
    3838:	bc 01       	movw	r22, r24
    383a:	cd 01       	movw	r24, r26
    383c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3840:	dc 01       	movw	r26, r24
    3842:	cb 01       	movw	r24, r22
    3844:	9e 83       	std	Y+6, r25	; 0x06
    3846:	8d 83       	std	Y+5, r24	; 0x05
    3848:	0f c0       	rjmp	.+30     	; 0x3868 <HLCD8_voidGoToPos+0x110>
    384a:	88 ec       	ldi	r24, 0xC8	; 200
    384c:	90 e0       	ldi	r25, 0x00	; 0
    384e:	9c 83       	std	Y+4, r25	; 0x04
    3850:	8b 83       	std	Y+3, r24	; 0x03
    3852:	8b 81       	ldd	r24, Y+3	; 0x03
    3854:	9c 81       	ldd	r25, Y+4	; 0x04
    3856:	01 97       	sbiw	r24, 0x01	; 1
    3858:	f1 f7       	brne	.-4      	; 0x3856 <HLCD8_voidGoToPos+0xfe>
    385a:	9c 83       	std	Y+4, r25	; 0x04
    385c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    385e:	8d 81       	ldd	r24, Y+5	; 0x05
    3860:	9e 81       	ldd	r25, Y+6	; 0x06
    3862:	01 97       	sbiw	r24, 0x01	; 1
    3864:	9e 83       	std	Y+6, r25	; 0x06
    3866:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3868:	8d 81       	ldd	r24, Y+5	; 0x05
    386a:	9e 81       	ldd	r25, Y+6	; 0x06
    386c:	00 97       	sbiw	r24, 0x00	; 0
    386e:	69 f7       	brne	.-38     	; 0x384a <HLCD8_voidGoToPos+0xf2>
    3870:	14 c0       	rjmp	.+40     	; 0x389a <HLCD8_voidGoToPos+0x142>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3872:	6f 81       	ldd	r22, Y+7	; 0x07
    3874:	78 85       	ldd	r23, Y+8	; 0x08
    3876:	89 85       	ldd	r24, Y+9	; 0x09
    3878:	9a 85       	ldd	r25, Y+10	; 0x0a
    387a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    387e:	dc 01       	movw	r26, r24
    3880:	cb 01       	movw	r24, r22
    3882:	9e 83       	std	Y+6, r25	; 0x06
    3884:	8d 83       	std	Y+5, r24	; 0x05
    3886:	8d 81       	ldd	r24, Y+5	; 0x05
    3888:	9e 81       	ldd	r25, Y+6	; 0x06
    388a:	9a 83       	std	Y+2, r25	; 0x02
    388c:	89 83       	std	Y+1, r24	; 0x01
    388e:	89 81       	ldd	r24, Y+1	; 0x01
    3890:	9a 81       	ldd	r25, Y+2	; 0x02
    3892:	01 97       	sbiw	r24, 0x01	; 1
    3894:	f1 f7       	brne	.-4      	; 0x3892 <HLCD8_voidGoToPos+0x13a>
    3896:	9a 83       	std	Y+2, r25	; 0x02
    3898:	89 83       	std	Y+1, r24	; 0x01
        break;

    }
    _delay_ms(1);

}
    389a:	63 96       	adiw	r28, 0x13	; 19
    389c:	0f b6       	in	r0, 0x3f	; 63
    389e:	f8 94       	cli
    38a0:	de bf       	out	0x3e, r29	; 62
    38a2:	0f be       	out	0x3f, r0	; 63
    38a4:	cd bf       	out	0x3d, r28	; 61
    38a6:	cf 91       	pop	r28
    38a8:	df 91       	pop	r29
    38aa:	08 95       	ret

000038ac <HLCD8_voidDisplayNumber>:

void HLCD8_voidDisplayNumber(u32 A_u32Number)
{
    38ac:	df 93       	push	r29
    38ae:	cf 93       	push	r28
    38b0:	00 d0       	rcall	.+0      	; 0x38b2 <HLCD8_voidDisplayNumber+0x6>
    38b2:	00 d0       	rcall	.+0      	; 0x38b4 <HLCD8_voidDisplayNumber+0x8>
    38b4:	cd b7       	in	r28, 0x3d	; 61
    38b6:	de b7       	in	r29, 0x3e	; 62
    38b8:	9c 83       	std	Y+4, r25	; 0x04
    38ba:	8b 83       	std	Y+3, r24	; 0x03
    // u8 local_u8NumToStr[100];
    // itoa(A_u32Number,local_u8NumToStr,10);
    // HLCD8_voidSendString(local_u8NumToStr);
    //****************************************************//
    //third method: it will deal with zero unlike the first method so it's not problem here
    u32 local_u32Number=1;
    38bc:	81 e0       	ldi	r24, 0x01	; 1
    38be:	90 e0       	ldi	r25, 0x00	; 0
    38c0:	9a 83       	std	Y+2, r25	; 0x02
    38c2:	89 83       	std	Y+1, r24	; 0x01
    if(A_u32Number==0)
    38c4:	8b 81       	ldd	r24, Y+3	; 0x03
    38c6:	9c 81       	ldd	r25, Y+4	; 0x04
    38c8:	00 97       	sbiw	r24, 0x00	; 0
    38ca:	31 f5       	brne	.+76     	; 0x3918 <HLCD8_voidDisplayNumber+0x6c>
    {
        HLCD8_voidSendData('0');
    38cc:	80 e3       	ldi	r24, 0x30	; 48
    38ce:	0e 94 76 18 	call	0x30ec	; 0x30ec <HLCD8_voidSendData>
    38d2:	22 c0       	rjmp	.+68     	; 0x3918 <HLCD8_voidDisplayNumber+0x6c>
    }   
    while(A_u32Number !=0)
    {
        local_u32Number=((local_u32Number * 10)+(A_u32Number%10));
    38d4:	89 81       	ldd	r24, Y+1	; 0x01
    38d6:	9a 81       	ldd	r25, Y+2	; 0x02
    38d8:	9c 01       	movw	r18, r24
    38da:	22 0f       	add	r18, r18
    38dc:	33 1f       	adc	r19, r19
    38de:	c9 01       	movw	r24, r18
    38e0:	88 0f       	add	r24, r24
    38e2:	99 1f       	adc	r25, r25
    38e4:	88 0f       	add	r24, r24
    38e6:	99 1f       	adc	r25, r25
    38e8:	f9 01       	movw	r30, r18
    38ea:	e8 0f       	add	r30, r24
    38ec:	f9 1f       	adc	r31, r25
    38ee:	8b 81       	ldd	r24, Y+3	; 0x03
    38f0:	9c 81       	ldd	r25, Y+4	; 0x04
    38f2:	2a e0       	ldi	r18, 0x0A	; 10
    38f4:	30 e0       	ldi	r19, 0x00	; 0
    38f6:	b9 01       	movw	r22, r18
    38f8:	0e 94 16 3a 	call	0x742c	; 0x742c <__udivmodhi4>
    38fc:	8e 0f       	add	r24, r30
    38fe:	9f 1f       	adc	r25, r31
    3900:	9a 83       	std	Y+2, r25	; 0x02
    3902:	89 83       	std	Y+1, r24	; 0x01
        A_u32Number=A_u32Number/10;
    3904:	8b 81       	ldd	r24, Y+3	; 0x03
    3906:	9c 81       	ldd	r25, Y+4	; 0x04
    3908:	2a e0       	ldi	r18, 0x0A	; 10
    390a:	30 e0       	ldi	r19, 0x00	; 0
    390c:	b9 01       	movw	r22, r18
    390e:	0e 94 16 3a 	call	0x742c	; 0x742c <__udivmodhi4>
    3912:	cb 01       	movw	r24, r22
    3914:	9c 83       	std	Y+4, r25	; 0x04
    3916:	8b 83       	std	Y+3, r24	; 0x03
    u32 local_u32Number=1;
    if(A_u32Number==0)
    {
        HLCD8_voidSendData('0');
    }   
    while(A_u32Number !=0)
    3918:	8b 81       	ldd	r24, Y+3	; 0x03
    391a:	9c 81       	ldd	r25, Y+4	; 0x04
    391c:	00 97       	sbiw	r24, 0x00	; 0
    391e:	d1 f6       	brne	.-76     	; 0x38d4 <HLCD8_voidDisplayNumber+0x28>
    3920:	14 c0       	rjmp	.+40     	; 0x394a <HLCD8_voidDisplayNumber+0x9e>
        A_u32Number=A_u32Number/10;

    }
    while (local_u32Number!=1)
    {
        HLCD8_voidSendData((local_u32Number%10)+48);
    3922:	89 81       	ldd	r24, Y+1	; 0x01
    3924:	9a 81       	ldd	r25, Y+2	; 0x02
    3926:	2a e0       	ldi	r18, 0x0A	; 10
    3928:	30 e0       	ldi	r19, 0x00	; 0
    392a:	b9 01       	movw	r22, r18
    392c:	0e 94 16 3a 	call	0x742c	; 0x742c <__udivmodhi4>
    3930:	80 5d       	subi	r24, 0xD0	; 208
    3932:	0e 94 76 18 	call	0x30ec	; 0x30ec <HLCD8_voidSendData>
        local_u32Number=local_u32Number/10;
    3936:	89 81       	ldd	r24, Y+1	; 0x01
    3938:	9a 81       	ldd	r25, Y+2	; 0x02
    393a:	2a e0       	ldi	r18, 0x0A	; 10
    393c:	30 e0       	ldi	r19, 0x00	; 0
    393e:	b9 01       	movw	r22, r18
    3940:	0e 94 16 3a 	call	0x742c	; 0x742c <__udivmodhi4>
    3944:	cb 01       	movw	r24, r22
    3946:	9a 83       	std	Y+2, r25	; 0x02
    3948:	89 83       	std	Y+1, r24	; 0x01
    {
        local_u32Number=((local_u32Number * 10)+(A_u32Number%10));
        A_u32Number=A_u32Number/10;

    }
    while (local_u32Number!=1)
    394a:	89 81       	ldd	r24, Y+1	; 0x01
    394c:	9a 81       	ldd	r25, Y+2	; 0x02
    394e:	81 30       	cpi	r24, 0x01	; 1
    3950:	91 05       	cpc	r25, r1
    3952:	39 f7       	brne	.-50     	; 0x3922 <HLCD8_voidDisplayNumber+0x76>
    {
        HLCD8_voidSendData((local_u32Number%10)+48);
        local_u32Number=local_u32Number/10;
    }
}
    3954:	0f 90       	pop	r0
    3956:	0f 90       	pop	r0
    3958:	0f 90       	pop	r0
    395a:	0f 90       	pop	r0
    395c:	cf 91       	pop	r28
    395e:	df 91       	pop	r29
    3960:	08 95       	ret

00003962 <HLCD8_voidStoreCustomChar>:

void HLCD8_voidStoreCustomChar(u8 * A_u8Pattern,u8 A_u8CGRAMIndex)
{
    3962:	df 93       	push	r29
    3964:	cf 93       	push	r28
    3966:	cd b7       	in	r28, 0x3d	; 61
    3968:	de b7       	in	r29, 0x3e	; 62
    396a:	ab 97       	sbiw	r28, 0x2b	; 43
    396c:	0f b6       	in	r0, 0x3f	; 63
    396e:	f8 94       	cli
    3970:	de bf       	out	0x3e, r29	; 62
    3972:	0f be       	out	0x3f, r0	; 63
    3974:	cd bf       	out	0x3d, r28	; 61
    3976:	9a a7       	std	Y+42, r25	; 0x2a
    3978:	89 a7       	std	Y+41, r24	; 0x29
    397a:	6b a7       	std	Y+43, r22	; 0x2b
    u8 local_u8Address;
    if(A_u8CGRAMIndex<8)
    397c:	8b a5       	ldd	r24, Y+43	; 0x2b
    397e:	88 30       	cpi	r24, 0x08	; 8
    3980:	08 f0       	brcs	.+2      	; 0x3984 <HLCD8_voidStoreCustomChar+0x22>
    3982:	e5 c0       	rjmp	.+458    	; 0x3b4e <HLCD8_voidStoreCustomChar+0x1ec>
    {
        A_u8CGRAMIndex=A_u8CGRAMIndex*8;
    3984:	8b a5       	ldd	r24, Y+43	; 0x2b
    3986:	88 2f       	mov	r24, r24
    3988:	90 e0       	ldi	r25, 0x00	; 0
    398a:	88 0f       	add	r24, r24
    398c:	99 1f       	adc	r25, r25
    398e:	88 0f       	add	r24, r24
    3990:	99 1f       	adc	r25, r25
    3992:	88 0f       	add	r24, r24
    3994:	99 1f       	adc	r25, r25
    3996:	8b a7       	std	Y+43, r24	; 0x2b
        SET_BIT(A_u8CGRAMIndex,PIN6);
    3998:	8b a5       	ldd	r24, Y+43	; 0x2b
    399a:	80 64       	ori	r24, 0x40	; 64
    399c:	8b a7       	std	Y+43, r24	; 0x2b
        CLR_BIT(A_u8CGRAMIndex,PIN7);
    399e:	8b a5       	ldd	r24, Y+43	; 0x2b
    39a0:	8f 77       	andi	r24, 0x7F	; 127
    39a2:	8b a7       	std	Y+43, r24	; 0x2b
        HLCD8_voidSendCommand(A_u8CGRAMIndex);
    39a4:	8b a5       	ldd	r24, Y+43	; 0x2b
    39a6:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <HLCD8_voidSendCommand>
        for(u8 i=0;i<8;i++)
    39aa:	1f a2       	std	Y+39, r1	; 0x27
    39ac:	cc c0       	rjmp	.+408    	; 0x3b46 <HLCD8_voidStoreCustomChar+0x1e4>
        {
            HLCD8_voidSendData(A_u8Pattern[i]);
    39ae:	8f a1       	ldd	r24, Y+39	; 0x27
    39b0:	28 2f       	mov	r18, r24
    39b2:	30 e0       	ldi	r19, 0x00	; 0
    39b4:	89 a5       	ldd	r24, Y+41	; 0x29
    39b6:	9a a5       	ldd	r25, Y+42	; 0x2a
    39b8:	fc 01       	movw	r30, r24
    39ba:	e2 0f       	add	r30, r18
    39bc:	f3 1f       	adc	r31, r19
    39be:	80 81       	ld	r24, Z
    39c0:	0e 94 76 18 	call	0x30ec	; 0x30ec <HLCD8_voidSendData>
    39c4:	80 e0       	ldi	r24, 0x00	; 0
    39c6:	90 e0       	ldi	r25, 0x00	; 0
    39c8:	a0 e7       	ldi	r26, 0x70	; 112
    39ca:	b2 e4       	ldi	r27, 0x42	; 66
    39cc:	8b a3       	std	Y+35, r24	; 0x23
    39ce:	9c a3       	std	Y+36, r25	; 0x24
    39d0:	ad a3       	std	Y+37, r26	; 0x25
    39d2:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    39d4:	6b a1       	ldd	r22, Y+35	; 0x23
    39d6:	7c a1       	ldd	r23, Y+36	; 0x24
    39d8:	8d a1       	ldd	r24, Y+37	; 0x25
    39da:	9e a1       	ldd	r25, Y+38	; 0x26
    39dc:	2b ea       	ldi	r18, 0xAB	; 171
    39de:	3a ea       	ldi	r19, 0xAA	; 170
    39e0:	4a e2       	ldi	r20, 0x2A	; 42
    39e2:	50 e4       	ldi	r21, 0x40	; 64
    39e4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    39e8:	dc 01       	movw	r26, r24
    39ea:	cb 01       	movw	r24, r22
    39ec:	8f 8f       	std	Y+31, r24	; 0x1f
    39ee:	98 a3       	std	Y+32, r25	; 0x20
    39f0:	a9 a3       	std	Y+33, r26	; 0x21
    39f2:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    39f4:	6f 8d       	ldd	r22, Y+31	; 0x1f
    39f6:	78 a1       	ldd	r23, Y+32	; 0x20
    39f8:	89 a1       	ldd	r24, Y+33	; 0x21
    39fa:	9a a1       	ldd	r25, Y+34	; 0x22
    39fc:	20 e0       	ldi	r18, 0x00	; 0
    39fe:	30 e0       	ldi	r19, 0x00	; 0
    3a00:	40 e8       	ldi	r20, 0x80	; 128
    3a02:	5f e3       	ldi	r21, 0x3F	; 63
    3a04:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3a08:	88 23       	and	r24, r24
    3a0a:	1c f4       	brge	.+6      	; 0x3a12 <HLCD8_voidStoreCustomChar+0xb0>
		__ticks = 1;
    3a0c:	81 e0       	ldi	r24, 0x01	; 1
    3a0e:	8e 8f       	std	Y+30, r24	; 0x1e
    3a10:	91 c0       	rjmp	.+290    	; 0x3b34 <HLCD8_voidStoreCustomChar+0x1d2>
	else if (__tmp > 255)
    3a12:	6f 8d       	ldd	r22, Y+31	; 0x1f
    3a14:	78 a1       	ldd	r23, Y+32	; 0x20
    3a16:	89 a1       	ldd	r24, Y+33	; 0x21
    3a18:	9a a1       	ldd	r25, Y+34	; 0x22
    3a1a:	20 e0       	ldi	r18, 0x00	; 0
    3a1c:	30 e0       	ldi	r19, 0x00	; 0
    3a1e:	4f e7       	ldi	r20, 0x7F	; 127
    3a20:	53 e4       	ldi	r21, 0x43	; 67
    3a22:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3a26:	18 16       	cp	r1, r24
    3a28:	0c f0       	brlt	.+2      	; 0x3a2c <HLCD8_voidStoreCustomChar+0xca>
    3a2a:	7b c0       	rjmp	.+246    	; 0x3b22 <HLCD8_voidStoreCustomChar+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    3a2c:	6b a1       	ldd	r22, Y+35	; 0x23
    3a2e:	7c a1       	ldd	r23, Y+36	; 0x24
    3a30:	8d a1       	ldd	r24, Y+37	; 0x25
    3a32:	9e a1       	ldd	r25, Y+38	; 0x26
    3a34:	20 e0       	ldi	r18, 0x00	; 0
    3a36:	30 e0       	ldi	r19, 0x00	; 0
    3a38:	4a e7       	ldi	r20, 0x7A	; 122
    3a3a:	54 e4       	ldi	r21, 0x44	; 68
    3a3c:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    3a40:	dc 01       	movw	r26, r24
    3a42:	cb 01       	movw	r24, r22
    3a44:	8a 8f       	std	Y+26, r24	; 0x1a
    3a46:	9b 8f       	std	Y+27, r25	; 0x1b
    3a48:	ac 8f       	std	Y+28, r26	; 0x1c
    3a4a:	bd 8f       	std	Y+29, r27	; 0x1d
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3a4c:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3a4e:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3a50:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3a52:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3a54:	20 e0       	ldi	r18, 0x00	; 0
    3a56:	30 e0       	ldi	r19, 0x00	; 0
    3a58:	4a ef       	ldi	r20, 0xFA	; 250
    3a5a:	54 e4       	ldi	r21, 0x44	; 68
    3a5c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3a60:	dc 01       	movw	r26, r24
    3a62:	cb 01       	movw	r24, r22
    3a64:	8e 8b       	std	Y+22, r24	; 0x16
    3a66:	9f 8b       	std	Y+23, r25	; 0x17
    3a68:	a8 8f       	std	Y+24, r26	; 0x18
    3a6a:	b9 8f       	std	Y+25, r27	; 0x19
	if (__tmp < 1.0)
    3a6c:	6e 89       	ldd	r22, Y+22	; 0x16
    3a6e:	7f 89       	ldd	r23, Y+23	; 0x17
    3a70:	88 8d       	ldd	r24, Y+24	; 0x18
    3a72:	99 8d       	ldd	r25, Y+25	; 0x19
    3a74:	20 e0       	ldi	r18, 0x00	; 0
    3a76:	30 e0       	ldi	r19, 0x00	; 0
    3a78:	40 e8       	ldi	r20, 0x80	; 128
    3a7a:	5f e3       	ldi	r21, 0x3F	; 63
    3a7c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3a80:	88 23       	and	r24, r24
    3a82:	2c f4       	brge	.+10     	; 0x3a8e <HLCD8_voidStoreCustomChar+0x12c>
		__ticks = 1;
    3a84:	81 e0       	ldi	r24, 0x01	; 1
    3a86:	90 e0       	ldi	r25, 0x00	; 0
    3a88:	9d 8b       	std	Y+21, r25	; 0x15
    3a8a:	8c 8b       	std	Y+20, r24	; 0x14
    3a8c:	3f c0       	rjmp	.+126    	; 0x3b0c <HLCD8_voidStoreCustomChar+0x1aa>
	else if (__tmp > 65535)
    3a8e:	6e 89       	ldd	r22, Y+22	; 0x16
    3a90:	7f 89       	ldd	r23, Y+23	; 0x17
    3a92:	88 8d       	ldd	r24, Y+24	; 0x18
    3a94:	99 8d       	ldd	r25, Y+25	; 0x19
    3a96:	20 e0       	ldi	r18, 0x00	; 0
    3a98:	3f ef       	ldi	r19, 0xFF	; 255
    3a9a:	4f e7       	ldi	r20, 0x7F	; 127
    3a9c:	57 e4       	ldi	r21, 0x47	; 71
    3a9e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3aa2:	18 16       	cp	r1, r24
    3aa4:	4c f5       	brge	.+82     	; 0x3af8 <HLCD8_voidStoreCustomChar+0x196>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3aa6:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3aa8:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3aaa:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3aac:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3aae:	20 e0       	ldi	r18, 0x00	; 0
    3ab0:	30 e0       	ldi	r19, 0x00	; 0
    3ab2:	40 e2       	ldi	r20, 0x20	; 32
    3ab4:	51 e4       	ldi	r21, 0x41	; 65
    3ab6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3aba:	dc 01       	movw	r26, r24
    3abc:	cb 01       	movw	r24, r22
    3abe:	bc 01       	movw	r22, r24
    3ac0:	cd 01       	movw	r24, r26
    3ac2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3ac6:	dc 01       	movw	r26, r24
    3ac8:	cb 01       	movw	r24, r22
    3aca:	9d 8b       	std	Y+21, r25	; 0x15
    3acc:	8c 8b       	std	Y+20, r24	; 0x14
    3ace:	0f c0       	rjmp	.+30     	; 0x3aee <HLCD8_voidStoreCustomChar+0x18c>
    3ad0:	88 ec       	ldi	r24, 0xC8	; 200
    3ad2:	90 e0       	ldi	r25, 0x00	; 0
    3ad4:	9b 8b       	std	Y+19, r25	; 0x13
    3ad6:	8a 8b       	std	Y+18, r24	; 0x12
    3ad8:	8a 89       	ldd	r24, Y+18	; 0x12
    3ada:	9b 89       	ldd	r25, Y+19	; 0x13
    3adc:	01 97       	sbiw	r24, 0x01	; 1
    3ade:	f1 f7       	brne	.-4      	; 0x3adc <HLCD8_voidStoreCustomChar+0x17a>
    3ae0:	9b 8b       	std	Y+19, r25	; 0x13
    3ae2:	8a 8b       	std	Y+18, r24	; 0x12
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3ae4:	8c 89       	ldd	r24, Y+20	; 0x14
    3ae6:	9d 89       	ldd	r25, Y+21	; 0x15
    3ae8:	01 97       	sbiw	r24, 0x01	; 1
    3aea:	9d 8b       	std	Y+21, r25	; 0x15
    3aec:	8c 8b       	std	Y+20, r24	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3aee:	8c 89       	ldd	r24, Y+20	; 0x14
    3af0:	9d 89       	ldd	r25, Y+21	; 0x15
    3af2:	00 97       	sbiw	r24, 0x00	; 0
    3af4:	69 f7       	brne	.-38     	; 0x3ad0 <HLCD8_voidStoreCustomChar+0x16e>
    3af6:	24 c0       	rjmp	.+72     	; 0x3b40 <HLCD8_voidStoreCustomChar+0x1de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3af8:	6e 89       	ldd	r22, Y+22	; 0x16
    3afa:	7f 89       	ldd	r23, Y+23	; 0x17
    3afc:	88 8d       	ldd	r24, Y+24	; 0x18
    3afe:	99 8d       	ldd	r25, Y+25	; 0x19
    3b00:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3b04:	dc 01       	movw	r26, r24
    3b06:	cb 01       	movw	r24, r22
    3b08:	9d 8b       	std	Y+21, r25	; 0x15
    3b0a:	8c 8b       	std	Y+20, r24	; 0x14
    3b0c:	8c 89       	ldd	r24, Y+20	; 0x14
    3b0e:	9d 89       	ldd	r25, Y+21	; 0x15
    3b10:	99 8b       	std	Y+17, r25	; 0x11
    3b12:	88 8b       	std	Y+16, r24	; 0x10
    3b14:	88 89       	ldd	r24, Y+16	; 0x10
    3b16:	99 89       	ldd	r25, Y+17	; 0x11
    3b18:	01 97       	sbiw	r24, 0x01	; 1
    3b1a:	f1 f7       	brne	.-4      	; 0x3b18 <HLCD8_voidStoreCustomChar+0x1b6>
    3b1c:	99 8b       	std	Y+17, r25	; 0x11
    3b1e:	88 8b       	std	Y+16, r24	; 0x10
    3b20:	0f c0       	rjmp	.+30     	; 0x3b40 <HLCD8_voidStoreCustomChar+0x1de>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3b22:	6f 8d       	ldd	r22, Y+31	; 0x1f
    3b24:	78 a1       	ldd	r23, Y+32	; 0x20
    3b26:	89 a1       	ldd	r24, Y+33	; 0x21
    3b28:	9a a1       	ldd	r25, Y+34	; 0x22
    3b2a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3b2e:	dc 01       	movw	r26, r24
    3b30:	cb 01       	movw	r24, r22
    3b32:	8e 8f       	std	Y+30, r24	; 0x1e
    3b34:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3b36:	8f 87       	std	Y+15, r24	; 0x0f
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3b38:	8f 85       	ldd	r24, Y+15	; 0x0f
    3b3a:	8a 95       	dec	r24
    3b3c:	f1 f7       	brne	.-4      	; 0x3b3a <HLCD8_voidStoreCustomChar+0x1d8>
    3b3e:	8f 87       	std	Y+15, r24	; 0x0f
    {
        A_u8CGRAMIndex=A_u8CGRAMIndex*8;
        SET_BIT(A_u8CGRAMIndex,PIN6);
        CLR_BIT(A_u8CGRAMIndex,PIN7);
        HLCD8_voidSendCommand(A_u8CGRAMIndex);
        for(u8 i=0;i<8;i++)
    3b40:	8f a1       	ldd	r24, Y+39	; 0x27
    3b42:	8f 5f       	subi	r24, 0xFF	; 255
    3b44:	8f a3       	std	Y+39, r24	; 0x27
    3b46:	8f a1       	ldd	r24, Y+39	; 0x27
    3b48:	88 30       	cpi	r24, 0x08	; 8
    3b4a:	08 f4       	brcc	.+2      	; 0x3b4e <HLCD8_voidStoreCustomChar+0x1ec>
    3b4c:	30 cf       	rjmp	.-416    	; 0x39ae <HLCD8_voidStoreCustomChar+0x4c>
        {
            HLCD8_voidSendData(A_u8Pattern[i]);
            _delay_us(60);
        }
    }
    HLCD8_voidSendCommand(RETURN_HOME);
    3b4e:	82 e0       	ldi	r24, 0x02	; 2
    3b50:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <HLCD8_voidSendCommand>
    3b54:	80 e0       	ldi	r24, 0x00	; 0
    3b56:	90 e0       	ldi	r25, 0x00	; 0
    3b58:	a0 e0       	ldi	r26, 0x00	; 0
    3b5a:	b0 e4       	ldi	r27, 0x40	; 64
    3b5c:	8b 87       	std	Y+11, r24	; 0x0b
    3b5e:	9c 87       	std	Y+12, r25	; 0x0c
    3b60:	ad 87       	std	Y+13, r26	; 0x0d
    3b62:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3b64:	6b 85       	ldd	r22, Y+11	; 0x0b
    3b66:	7c 85       	ldd	r23, Y+12	; 0x0c
    3b68:	8d 85       	ldd	r24, Y+13	; 0x0d
    3b6a:	9e 85       	ldd	r25, Y+14	; 0x0e
    3b6c:	20 e0       	ldi	r18, 0x00	; 0
    3b6e:	30 e0       	ldi	r19, 0x00	; 0
    3b70:	4a ef       	ldi	r20, 0xFA	; 250
    3b72:	54 e4       	ldi	r21, 0x44	; 68
    3b74:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3b78:	dc 01       	movw	r26, r24
    3b7a:	cb 01       	movw	r24, r22
    3b7c:	8f 83       	std	Y+7, r24	; 0x07
    3b7e:	98 87       	std	Y+8, r25	; 0x08
    3b80:	a9 87       	std	Y+9, r26	; 0x09
    3b82:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3b84:	6f 81       	ldd	r22, Y+7	; 0x07
    3b86:	78 85       	ldd	r23, Y+8	; 0x08
    3b88:	89 85       	ldd	r24, Y+9	; 0x09
    3b8a:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b8c:	20 e0       	ldi	r18, 0x00	; 0
    3b8e:	30 e0       	ldi	r19, 0x00	; 0
    3b90:	40 e8       	ldi	r20, 0x80	; 128
    3b92:	5f e3       	ldi	r21, 0x3F	; 63
    3b94:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3b98:	88 23       	and	r24, r24
    3b9a:	2c f4       	brge	.+10     	; 0x3ba6 <HLCD8_voidStoreCustomChar+0x244>
		__ticks = 1;
    3b9c:	81 e0       	ldi	r24, 0x01	; 1
    3b9e:	90 e0       	ldi	r25, 0x00	; 0
    3ba0:	9e 83       	std	Y+6, r25	; 0x06
    3ba2:	8d 83       	std	Y+5, r24	; 0x05
    3ba4:	3f c0       	rjmp	.+126    	; 0x3c24 <HLCD8_voidStoreCustomChar+0x2c2>
	else if (__tmp > 65535)
    3ba6:	6f 81       	ldd	r22, Y+7	; 0x07
    3ba8:	78 85       	ldd	r23, Y+8	; 0x08
    3baa:	89 85       	ldd	r24, Y+9	; 0x09
    3bac:	9a 85       	ldd	r25, Y+10	; 0x0a
    3bae:	20 e0       	ldi	r18, 0x00	; 0
    3bb0:	3f ef       	ldi	r19, 0xFF	; 255
    3bb2:	4f e7       	ldi	r20, 0x7F	; 127
    3bb4:	57 e4       	ldi	r21, 0x47	; 71
    3bb6:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3bba:	18 16       	cp	r1, r24
    3bbc:	4c f5       	brge	.+82     	; 0x3c10 <HLCD8_voidStoreCustomChar+0x2ae>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3bbe:	6b 85       	ldd	r22, Y+11	; 0x0b
    3bc0:	7c 85       	ldd	r23, Y+12	; 0x0c
    3bc2:	8d 85       	ldd	r24, Y+13	; 0x0d
    3bc4:	9e 85       	ldd	r25, Y+14	; 0x0e
    3bc6:	20 e0       	ldi	r18, 0x00	; 0
    3bc8:	30 e0       	ldi	r19, 0x00	; 0
    3bca:	40 e2       	ldi	r20, 0x20	; 32
    3bcc:	51 e4       	ldi	r21, 0x41	; 65
    3bce:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3bd2:	dc 01       	movw	r26, r24
    3bd4:	cb 01       	movw	r24, r22
    3bd6:	bc 01       	movw	r22, r24
    3bd8:	cd 01       	movw	r24, r26
    3bda:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3bde:	dc 01       	movw	r26, r24
    3be0:	cb 01       	movw	r24, r22
    3be2:	9e 83       	std	Y+6, r25	; 0x06
    3be4:	8d 83       	std	Y+5, r24	; 0x05
    3be6:	0f c0       	rjmp	.+30     	; 0x3c06 <HLCD8_voidStoreCustomChar+0x2a4>
    3be8:	88 ec       	ldi	r24, 0xC8	; 200
    3bea:	90 e0       	ldi	r25, 0x00	; 0
    3bec:	9c 83       	std	Y+4, r25	; 0x04
    3bee:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3bf0:	8b 81       	ldd	r24, Y+3	; 0x03
    3bf2:	9c 81       	ldd	r25, Y+4	; 0x04
    3bf4:	01 97       	sbiw	r24, 0x01	; 1
    3bf6:	f1 f7       	brne	.-4      	; 0x3bf4 <HLCD8_voidStoreCustomChar+0x292>
    3bf8:	9c 83       	std	Y+4, r25	; 0x04
    3bfa:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3bfc:	8d 81       	ldd	r24, Y+5	; 0x05
    3bfe:	9e 81       	ldd	r25, Y+6	; 0x06
    3c00:	01 97       	sbiw	r24, 0x01	; 1
    3c02:	9e 83       	std	Y+6, r25	; 0x06
    3c04:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3c06:	8d 81       	ldd	r24, Y+5	; 0x05
    3c08:	9e 81       	ldd	r25, Y+6	; 0x06
    3c0a:	00 97       	sbiw	r24, 0x00	; 0
    3c0c:	69 f7       	brne	.-38     	; 0x3be8 <HLCD8_voidStoreCustomChar+0x286>
    3c0e:	14 c0       	rjmp	.+40     	; 0x3c38 <HLCD8_voidStoreCustomChar+0x2d6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3c10:	6f 81       	ldd	r22, Y+7	; 0x07
    3c12:	78 85       	ldd	r23, Y+8	; 0x08
    3c14:	89 85       	ldd	r24, Y+9	; 0x09
    3c16:	9a 85       	ldd	r25, Y+10	; 0x0a
    3c18:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3c1c:	dc 01       	movw	r26, r24
    3c1e:	cb 01       	movw	r24, r22
    3c20:	9e 83       	std	Y+6, r25	; 0x06
    3c22:	8d 83       	std	Y+5, r24	; 0x05
    3c24:	8d 81       	ldd	r24, Y+5	; 0x05
    3c26:	9e 81       	ldd	r25, Y+6	; 0x06
    3c28:	9a 83       	std	Y+2, r25	; 0x02
    3c2a:	89 83       	std	Y+1, r24	; 0x01
    3c2c:	89 81       	ldd	r24, Y+1	; 0x01
    3c2e:	9a 81       	ldd	r25, Y+2	; 0x02
    3c30:	01 97       	sbiw	r24, 0x01	; 1
    3c32:	f1 f7       	brne	.-4      	; 0x3c30 <HLCD8_voidStoreCustomChar+0x2ce>
    3c34:	9a 83       	std	Y+2, r25	; 0x02
    3c36:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(2);

}
    3c38:	ab 96       	adiw	r28, 0x2b	; 43
    3c3a:	0f b6       	in	r0, 0x3f	; 63
    3c3c:	f8 94       	cli
    3c3e:	de bf       	out	0x3e, r29	; 62
    3c40:	0f be       	out	0x3f, r0	; 63
    3c42:	cd bf       	out	0x3d, r28	; 61
    3c44:	cf 91       	pop	r28
    3c46:	df 91       	pop	r29
    3c48:	08 95       	ret

00003c4a <HLCD8_voidDisplayCustomChar>:

void HLCD8_voidDisplayCustomChar(u8 A_u8CGRAMIndex,u8 A_u8Row,u8 A_u8Col)
{
    3c4a:	df 93       	push	r29
    3c4c:	cf 93       	push	r28
    3c4e:	00 d0       	rcall	.+0      	; 0x3c50 <HLCD8_voidDisplayCustomChar+0x6>
    3c50:	0f 92       	push	r0
    3c52:	cd b7       	in	r28, 0x3d	; 61
    3c54:	de b7       	in	r29, 0x3e	; 62
    3c56:	89 83       	std	Y+1, r24	; 0x01
    3c58:	6a 83       	std	Y+2, r22	; 0x02
    3c5a:	4b 83       	std	Y+3, r20	; 0x03
    HLCD8_voidGoToPos(A_u8Row,A_u8Col);
    3c5c:	8a 81       	ldd	r24, Y+2	; 0x02
    3c5e:	6b 81       	ldd	r22, Y+3	; 0x03
    3c60:	0e 94 ac 1b 	call	0x3758	; 0x3758 <HLCD8_voidGoToPos>
    HLCD8_voidSendData(A_u8CGRAMIndex);
    3c64:	89 81       	ldd	r24, Y+1	; 0x01
    3c66:	0e 94 76 18 	call	0x30ec	; 0x30ec <HLCD8_voidSendData>
    3c6a:	0f 90       	pop	r0
    3c6c:	0f 90       	pop	r0
    3c6e:	0f 90       	pop	r0
    3c70:	cf 91       	pop	r28
    3c72:	df 91       	pop	r29
    3c74:	08 95       	ret

00003c76 <RTOS_voidInit>:


RTOS_TCB RTOS_AOfTasks[RTOS_MAX_NUMBER_OF_TASKS];

void RTOS_voidInit(void)
{
    3c76:	df 93       	push	r29
    3c78:	cf 93       	push	r28
    3c7a:	cd b7       	in	r28, 0x3d	; 61
    3c7c:	de b7       	in	r29, 0x3e	; 62
    //set callback function for timer0 ctc mode
    MTIMER0_voidSetCallBackCTC(RTOS_voidScheduler);
    3c7e:	8d eb       	ldi	r24, 0xBD	; 189
    3c80:	9e e1       	ldi	r25, 0x1E	; 30
    3c82:	0e 94 12 26 	call	0x4c24	; 0x4c24 <MTIMER0_voidSetCallBackCTC>
    MTIMER0_voidInit();
    3c86:	0e 94 c0 25 	call	0x4b80	; 0x4b80 <MTIMER0_voidInit>
}
    3c8a:	cf 91       	pop	r28
    3c8c:	df 91       	pop	r29
    3c8e:	08 95       	ret

00003c90 <RTOS_voidInitArrayFunctions>:

void RTOS_voidInitArrayFunctions()
{
    3c90:	df 93       	push	r29
    3c92:	cf 93       	push	r28
    3c94:	0f 92       	push	r0
    3c96:	cd b7       	in	r28, 0x3d	; 61
    3c98:	de b7       	in	r29, 0x3e	; 62
    u8 local_u8Counter=0;   
    3c9a:	19 82       	std	Y+1, r1	; 0x01
    3c9c:	12 c0       	rjmp	.+36     	; 0x3cc2 <RTOS_voidInitArrayFunctions+0x32>
    for(;local_u8Counter<RTOS_MAX_NUMBER_OF_TASKS;local_u8Counter++)
    {
        RTOS_AOfTasks[local_u8Counter].pf=NULL;
    3c9e:	89 81       	ldd	r24, Y+1	; 0x01
    3ca0:	28 2f       	mov	r18, r24
    3ca2:	30 e0       	ldi	r19, 0x00	; 0
    3ca4:	c9 01       	movw	r24, r18
    3ca6:	88 0f       	add	r24, r24
    3ca8:	99 1f       	adc	r25, r25
    3caa:	82 0f       	add	r24, r18
    3cac:	93 1f       	adc	r25, r19
    3cae:	88 0f       	add	r24, r24
    3cb0:	99 1f       	adc	r25, r25
    3cb2:	fc 01       	movw	r30, r24
    3cb4:	e5 5d       	subi	r30, 0xD5	; 213
    3cb6:	f8 4f       	sbci	r31, 0xF8	; 248
    3cb8:	11 82       	std	Z+1, r1	; 0x01
    3cba:	10 82       	st	Z, r1
}

void RTOS_voidInitArrayFunctions()
{
    u8 local_u8Counter=0;   
    for(;local_u8Counter<RTOS_MAX_NUMBER_OF_TASKS;local_u8Counter++)
    3cbc:	89 81       	ldd	r24, Y+1	; 0x01
    3cbe:	8f 5f       	subi	r24, 0xFF	; 255
    3cc0:	89 83       	std	Y+1, r24	; 0x01
    3cc2:	89 81       	ldd	r24, Y+1	; 0x01
    3cc4:	83 30       	cpi	r24, 0x03	; 3
    3cc6:	58 f3       	brcs	.-42     	; 0x3c9e <RTOS_voidInitArrayFunctions+0xe>
    {
        RTOS_AOfTasks[local_u8Counter].pf=NULL;
    }
}
    3cc8:	0f 90       	pop	r0
    3cca:	cf 91       	pop	r28
    3ccc:	df 91       	pop	r29
    3cce:	08 95       	ret

00003cd0 <RTOS_voidCreateTask>:

void RTOS_voidCreateTask(u8 A_u8Priority,u16 A_u16Periodicty,u16 A_u16FirstDelay,void(*pf)(void))
{
    3cd0:	df 93       	push	r29
    3cd2:	cf 93       	push	r28
    3cd4:	cd b7       	in	r28, 0x3d	; 61
    3cd6:	de b7       	in	r29, 0x3e	; 62
    3cd8:	27 97       	sbiw	r28, 0x07	; 7
    3cda:	0f b6       	in	r0, 0x3f	; 63
    3cdc:	f8 94       	cli
    3cde:	de bf       	out	0x3e, r29	; 62
    3ce0:	0f be       	out	0x3f, r0	; 63
    3ce2:	cd bf       	out	0x3d, r28	; 61
    3ce4:	89 83       	std	Y+1, r24	; 0x01
    3ce6:	7b 83       	std	Y+3, r23	; 0x03
    3ce8:	6a 83       	std	Y+2, r22	; 0x02
    3cea:	5d 83       	std	Y+5, r21	; 0x05
    3cec:	4c 83       	std	Y+4, r20	; 0x04
    3cee:	3f 83       	std	Y+7, r19	; 0x07
    3cf0:	2e 83       	std	Y+6, r18	; 0x06
    if(A_u8Priority<RTOS_MAX_NUMBER_OF_TASKS && pf!=NULL)
    3cf2:	89 81       	ldd	r24, Y+1	; 0x01
    3cf4:	83 30       	cpi	r24, 0x03	; 3
    3cf6:	c0 f5       	brcc	.+112    	; 0x3d68 <RTOS_voidCreateTask+0x98>
    3cf8:	8e 81       	ldd	r24, Y+6	; 0x06
    3cfa:	9f 81       	ldd	r25, Y+7	; 0x07
    3cfc:	00 97       	sbiw	r24, 0x00	; 0
    3cfe:	a1 f1       	breq	.+104    	; 0x3d68 <RTOS_voidCreateTask+0x98>
    {
        RTOS_AOfTasks[A_u8Priority].FirstDelay=A_u16FirstDelay;
    3d00:	89 81       	ldd	r24, Y+1	; 0x01
    3d02:	28 2f       	mov	r18, r24
    3d04:	30 e0       	ldi	r19, 0x00	; 0
    3d06:	c9 01       	movw	r24, r18
    3d08:	88 0f       	add	r24, r24
    3d0a:	99 1f       	adc	r25, r25
    3d0c:	82 0f       	add	r24, r18
    3d0e:	93 1f       	adc	r25, r19
    3d10:	88 0f       	add	r24, r24
    3d12:	99 1f       	adc	r25, r25
    3d14:	fc 01       	movw	r30, r24
    3d16:	e9 5d       	subi	r30, 0xD9	; 217
    3d18:	f8 4f       	sbci	r31, 0xF8	; 248
    3d1a:	8c 81       	ldd	r24, Y+4	; 0x04
    3d1c:	9d 81       	ldd	r25, Y+5	; 0x05
    3d1e:	91 83       	std	Z+1, r25	; 0x01
    3d20:	80 83       	st	Z, r24
        RTOS_AOfTasks[A_u8Priority].Periodicty=A_u16Periodicty;
    3d22:	89 81       	ldd	r24, Y+1	; 0x01
    3d24:	28 2f       	mov	r18, r24
    3d26:	30 e0       	ldi	r19, 0x00	; 0
    3d28:	c9 01       	movw	r24, r18
    3d2a:	88 0f       	add	r24, r24
    3d2c:	99 1f       	adc	r25, r25
    3d2e:	82 0f       	add	r24, r18
    3d30:	93 1f       	adc	r25, r19
    3d32:	01 96       	adiw	r24, 0x01	; 1
    3d34:	88 0f       	add	r24, r24
    3d36:	99 1f       	adc	r25, r25
    3d38:	fc 01       	movw	r30, r24
    3d3a:	e9 5d       	subi	r30, 0xD9	; 217
    3d3c:	f8 4f       	sbci	r31, 0xF8	; 248
    3d3e:	8a 81       	ldd	r24, Y+2	; 0x02
    3d40:	9b 81       	ldd	r25, Y+3	; 0x03
    3d42:	91 83       	std	Z+1, r25	; 0x01
    3d44:	80 83       	st	Z, r24
        RTOS_AOfTasks[A_u8Priority].pf=pf;
    3d46:	89 81       	ldd	r24, Y+1	; 0x01
    3d48:	28 2f       	mov	r18, r24
    3d4a:	30 e0       	ldi	r19, 0x00	; 0
    3d4c:	c9 01       	movw	r24, r18
    3d4e:	88 0f       	add	r24, r24
    3d50:	99 1f       	adc	r25, r25
    3d52:	82 0f       	add	r24, r18
    3d54:	93 1f       	adc	r25, r19
    3d56:	88 0f       	add	r24, r24
    3d58:	99 1f       	adc	r25, r25
    3d5a:	fc 01       	movw	r30, r24
    3d5c:	e5 5d       	subi	r30, 0xD5	; 213
    3d5e:	f8 4f       	sbci	r31, 0xF8	; 248
    3d60:	8e 81       	ldd	r24, Y+6	; 0x06
    3d62:	9f 81       	ldd	r25, Y+7	; 0x07
    3d64:	91 83       	std	Z+1, r25	; 0x01
    3d66:	80 83       	st	Z, r24
    }
}
    3d68:	27 96       	adiw	r28, 0x07	; 7
    3d6a:	0f b6       	in	r0, 0x3f	; 63
    3d6c:	f8 94       	cli
    3d6e:	de bf       	out	0x3e, r29	; 62
    3d70:	0f be       	out	0x3f, r0	; 63
    3d72:	cd bf       	out	0x3d, r28	; 61
    3d74:	cf 91       	pop	r28
    3d76:	df 91       	pop	r29
    3d78:	08 95       	ret

00003d7a <RTOS_voidScheduler>:



void RTOS_voidScheduler(void)
{
    3d7a:	df 93       	push	r29
    3d7c:	cf 93       	push	r28
    3d7e:	0f 92       	push	r0
    3d80:	cd b7       	in	r28, 0x3d	; 61
    3d82:	de b7       	in	r29, 0x3e	; 62
    u8 local_u8TaskCounter=0;
    3d84:	19 82       	std	Y+1, r1	; 0x01
    3d86:	78 c0       	rjmp	.+240    	; 0x3e78 <RTOS_voidScheduler+0xfe>
    for(;local_u8TaskCounter<RTOS_MAX_NUMBER_OF_TASKS;local_u8TaskCounter++)
    {
        if(RTOS_AOfTasks[local_u8TaskCounter].FirstDelay == 0)
    3d88:	89 81       	ldd	r24, Y+1	; 0x01
    3d8a:	28 2f       	mov	r18, r24
    3d8c:	30 e0       	ldi	r19, 0x00	; 0
    3d8e:	c9 01       	movw	r24, r18
    3d90:	88 0f       	add	r24, r24
    3d92:	99 1f       	adc	r25, r25
    3d94:	82 0f       	add	r24, r18
    3d96:	93 1f       	adc	r25, r19
    3d98:	88 0f       	add	r24, r24
    3d9a:	99 1f       	adc	r25, r25
    3d9c:	fc 01       	movw	r30, r24
    3d9e:	e9 5d       	subi	r30, 0xD9	; 217
    3da0:	f8 4f       	sbci	r31, 0xF8	; 248
    3da2:	80 81       	ld	r24, Z
    3da4:	91 81       	ldd	r25, Z+1	; 0x01
    3da6:	00 97       	sbiw	r24, 0x00	; 0
    3da8:	09 f0       	breq	.+2      	; 0x3dac <RTOS_voidScheduler+0x32>
    3daa:	45 c0       	rjmp	.+138    	; 0x3e36 <RTOS_voidScheduler+0xbc>
        {
            if(RTOS_AOfTasks[local_u8TaskCounter].pf !=NULL)
    3dac:	89 81       	ldd	r24, Y+1	; 0x01
    3dae:	28 2f       	mov	r18, r24
    3db0:	30 e0       	ldi	r19, 0x00	; 0
    3db2:	c9 01       	movw	r24, r18
    3db4:	88 0f       	add	r24, r24
    3db6:	99 1f       	adc	r25, r25
    3db8:	82 0f       	add	r24, r18
    3dba:	93 1f       	adc	r25, r19
    3dbc:	88 0f       	add	r24, r24
    3dbe:	99 1f       	adc	r25, r25
    3dc0:	fc 01       	movw	r30, r24
    3dc2:	e5 5d       	subi	r30, 0xD5	; 213
    3dc4:	f8 4f       	sbci	r31, 0xF8	; 248
    3dc6:	80 81       	ld	r24, Z
    3dc8:	91 81       	ldd	r25, Z+1	; 0x01
    3dca:	00 97       	sbiw	r24, 0x00	; 0
    3dcc:	89 f0       	breq	.+34     	; 0x3df0 <RTOS_voidScheduler+0x76>
            {
                RTOS_AOfTasks[local_u8TaskCounter].pf();
    3dce:	89 81       	ldd	r24, Y+1	; 0x01
    3dd0:	28 2f       	mov	r18, r24
    3dd2:	30 e0       	ldi	r19, 0x00	; 0
    3dd4:	c9 01       	movw	r24, r18
    3dd6:	88 0f       	add	r24, r24
    3dd8:	99 1f       	adc	r25, r25
    3dda:	82 0f       	add	r24, r18
    3ddc:	93 1f       	adc	r25, r19
    3dde:	88 0f       	add	r24, r24
    3de0:	99 1f       	adc	r25, r25
    3de2:	fc 01       	movw	r30, r24
    3de4:	e5 5d       	subi	r30, 0xD5	; 213
    3de6:	f8 4f       	sbci	r31, 0xF8	; 248
    3de8:	01 90       	ld	r0, Z+
    3dea:	f0 81       	ld	r31, Z
    3dec:	e0 2d       	mov	r30, r0
    3dee:	09 95       	icall
            }
            RTOS_AOfTasks[local_u8TaskCounter].FirstDelay = RTOS_AOfTasks[local_u8TaskCounter].Periodicty-1;
    3df0:	89 81       	ldd	r24, Y+1	; 0x01
    3df2:	48 2f       	mov	r20, r24
    3df4:	50 e0       	ldi	r21, 0x00	; 0
    3df6:	89 81       	ldd	r24, Y+1	; 0x01
    3df8:	28 2f       	mov	r18, r24
    3dfa:	30 e0       	ldi	r19, 0x00	; 0
    3dfc:	c9 01       	movw	r24, r18
    3dfe:	88 0f       	add	r24, r24
    3e00:	99 1f       	adc	r25, r25
    3e02:	82 0f       	add	r24, r18
    3e04:	93 1f       	adc	r25, r19
    3e06:	01 96       	adiw	r24, 0x01	; 1
    3e08:	88 0f       	add	r24, r24
    3e0a:	99 1f       	adc	r25, r25
    3e0c:	fc 01       	movw	r30, r24
    3e0e:	e9 5d       	subi	r30, 0xD9	; 217
    3e10:	f8 4f       	sbci	r31, 0xF8	; 248
    3e12:	80 81       	ld	r24, Z
    3e14:	91 81       	ldd	r25, Z+1	; 0x01
    3e16:	9c 01       	movw	r18, r24
    3e18:	21 50       	subi	r18, 0x01	; 1
    3e1a:	30 40       	sbci	r19, 0x00	; 0
    3e1c:	ca 01       	movw	r24, r20
    3e1e:	88 0f       	add	r24, r24
    3e20:	99 1f       	adc	r25, r25
    3e22:	84 0f       	add	r24, r20
    3e24:	95 1f       	adc	r25, r21
    3e26:	88 0f       	add	r24, r24
    3e28:	99 1f       	adc	r25, r25
    3e2a:	fc 01       	movw	r30, r24
    3e2c:	e9 5d       	subi	r30, 0xD9	; 217
    3e2e:	f8 4f       	sbci	r31, 0xF8	; 248
    3e30:	31 83       	std	Z+1, r19	; 0x01
    3e32:	20 83       	st	Z, r18
    3e34:	1e c0       	rjmp	.+60     	; 0x3e72 <RTOS_voidScheduler+0xf8>
        }
        else
        {
            RTOS_AOfTasks[local_u8TaskCounter].FirstDelay--;
    3e36:	89 81       	ldd	r24, Y+1	; 0x01
    3e38:	28 2f       	mov	r18, r24
    3e3a:	30 e0       	ldi	r19, 0x00	; 0
    3e3c:	c9 01       	movw	r24, r18
    3e3e:	88 0f       	add	r24, r24
    3e40:	99 1f       	adc	r25, r25
    3e42:	82 0f       	add	r24, r18
    3e44:	93 1f       	adc	r25, r19
    3e46:	88 0f       	add	r24, r24
    3e48:	99 1f       	adc	r25, r25
    3e4a:	fc 01       	movw	r30, r24
    3e4c:	e9 5d       	subi	r30, 0xD9	; 217
    3e4e:	f8 4f       	sbci	r31, 0xF8	; 248
    3e50:	80 81       	ld	r24, Z
    3e52:	91 81       	ldd	r25, Z+1	; 0x01
    3e54:	ac 01       	movw	r20, r24
    3e56:	41 50       	subi	r20, 0x01	; 1
    3e58:	50 40       	sbci	r21, 0x00	; 0
    3e5a:	c9 01       	movw	r24, r18
    3e5c:	88 0f       	add	r24, r24
    3e5e:	99 1f       	adc	r25, r25
    3e60:	82 0f       	add	r24, r18
    3e62:	93 1f       	adc	r25, r19
    3e64:	88 0f       	add	r24, r24
    3e66:	99 1f       	adc	r25, r25
    3e68:	fc 01       	movw	r30, r24
    3e6a:	e9 5d       	subi	r30, 0xD9	; 217
    3e6c:	f8 4f       	sbci	r31, 0xF8	; 248
    3e6e:	51 83       	std	Z+1, r21	; 0x01
    3e70:	40 83       	st	Z, r20


void RTOS_voidScheduler(void)
{
    u8 local_u8TaskCounter=0;
    for(;local_u8TaskCounter<RTOS_MAX_NUMBER_OF_TASKS;local_u8TaskCounter++)
    3e72:	89 81       	ldd	r24, Y+1	; 0x01
    3e74:	8f 5f       	subi	r24, 0xFF	; 255
    3e76:	89 83       	std	Y+1, r24	; 0x01
    3e78:	89 81       	ldd	r24, Y+1	; 0x01
    3e7a:	83 30       	cpi	r24, 0x03	; 3
    3e7c:	08 f4       	brcc	.+2      	; 0x3e80 <RTOS_voidScheduler+0x106>
    3e7e:	84 cf       	rjmp	.-248    	; 0x3d88 <RTOS_voidScheduler+0xe>
        else
        {
            RTOS_AOfTasks[local_u8TaskCounter].FirstDelay--;
        }
    }
}
    3e80:	0f 90       	pop	r0
    3e82:	cf 91       	pop	r28
    3e84:	df 91       	pop	r29
    3e86:	08 95       	ret

00003e88 <HSSD_voidDisplay>:
#include "../Include/HAL/SSD/SSD_Private.h"
#include "../Include/HAL/SSD/SSD_Configuration.h"

#include <util/delay.h>
void HSSD_voidDisplay(u8 A_u8Number,u8 A_u8PortId)
{
    3e88:	df 93       	push	r29
    3e8a:	cf 93       	push	r28
    3e8c:	00 d0       	rcall	.+0      	; 0x3e8e <HSSD_voidDisplay+0x6>
    3e8e:	00 d0       	rcall	.+0      	; 0x3e90 <HSSD_voidDisplay+0x8>
    3e90:	cd b7       	in	r28, 0x3d	; 61
    3e92:	de b7       	in	r29, 0x3e	; 62
    3e94:	89 83       	std	Y+1, r24	; 0x01
    3e96:	6a 83       	std	Y+2, r22	; 0x02
	switch(A_u8Number)
    3e98:	89 81       	ldd	r24, Y+1	; 0x01
    3e9a:	28 2f       	mov	r18, r24
    3e9c:	30 e0       	ldi	r19, 0x00	; 0
    3e9e:	3c 83       	std	Y+4, r19	; 0x04
    3ea0:	2b 83       	std	Y+3, r18	; 0x03
    3ea2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ea4:	9c 81       	ldd	r25, Y+4	; 0x04
    3ea6:	8b 35       	cpi	r24, 0x5B	; 91
    3ea8:	91 05       	cpc	r25, r1
    3eaa:	09 f4       	brne	.+2      	; 0x3eae <HSSD_voidDisplay+0x26>
    3eac:	4c c0       	rjmp	.+152    	; 0x3f46 <HSSD_voidDisplay+0xbe>
    3eae:	2b 81       	ldd	r18, Y+3	; 0x03
    3eb0:	3c 81       	ldd	r19, Y+4	; 0x04
    3eb2:	2c 35       	cpi	r18, 0x5C	; 92
    3eb4:	31 05       	cpc	r19, r1
    3eb6:	e4 f4       	brge	.+56     	; 0x3ef0 <HSSD_voidDisplay+0x68>
    3eb8:	8b 81       	ldd	r24, Y+3	; 0x03
    3eba:	9c 81       	ldd	r25, Y+4	; 0x04
    3ebc:	87 30       	cpi	r24, 0x07	; 7
    3ebe:	91 05       	cpc	r25, r1
    3ec0:	09 f4       	brne	.+2      	; 0x3ec4 <HSSD_voidDisplay+0x3c>
    3ec2:	5a c0       	rjmp	.+180    	; 0x3f78 <HSSD_voidDisplay+0xf0>
    3ec4:	2b 81       	ldd	r18, Y+3	; 0x03
    3ec6:	3c 81       	ldd	r19, Y+4	; 0x04
    3ec8:	28 30       	cpi	r18, 0x08	; 8
    3eca:	31 05       	cpc	r19, r1
    3ecc:	34 f4       	brge	.+12     	; 0x3eda <HSSD_voidDisplay+0x52>
    3ece:	8b 81       	ldd	r24, Y+3	; 0x03
    3ed0:	9c 81       	ldd	r25, Y+4	; 0x04
    3ed2:	86 30       	cpi	r24, 0x06	; 6
    3ed4:	91 05       	cpc	r25, r1
    3ed6:	91 f1       	breq	.+100    	; 0x3f3c <HSSD_voidDisplay+0xb4>
    3ed8:	5d c0       	rjmp	.+186    	; 0x3f94 <HSSD_voidDisplay+0x10c>
    3eda:	2b 81       	ldd	r18, Y+3	; 0x03
    3edc:	3c 81       	ldd	r19, Y+4	; 0x04
    3ede:	2f 33       	cpi	r18, 0x3F	; 63
    3ee0:	31 05       	cpc	r19, r1
    3ee2:	39 f1       	breq	.+78     	; 0x3f32 <HSSD_voidDisplay+0xaa>
    3ee4:	8b 81       	ldd	r24, Y+3	; 0x03
    3ee6:	9c 81       	ldd	r25, Y+4	; 0x04
    3ee8:	8f 34       	cpi	r24, 0x4F	; 79
    3eea:	91 05       	cpc	r25, r1
    3eec:	89 f1       	breq	.+98     	; 0x3f50 <HSSD_voidDisplay+0xc8>
    3eee:	52 c0       	rjmp	.+164    	; 0x3f94 <HSSD_voidDisplay+0x10c>
    3ef0:	2b 81       	ldd	r18, Y+3	; 0x03
    3ef2:	3c 81       	ldd	r19, Y+4	; 0x04
    3ef4:	2f 36       	cpi	r18, 0x6F	; 111
    3ef6:	31 05       	cpc	r19, r1
    3ef8:	09 f4       	brne	.+2      	; 0x3efc <HSSD_voidDisplay+0x74>
    3efa:	48 c0       	rjmp	.+144    	; 0x3f8c <HSSD_voidDisplay+0x104>
    3efc:	8b 81       	ldd	r24, Y+3	; 0x03
    3efe:	9c 81       	ldd	r25, Y+4	; 0x04
    3f00:	80 37       	cpi	r24, 0x70	; 112
    3f02:	91 05       	cpc	r25, r1
    3f04:	5c f4       	brge	.+22     	; 0x3f1c <HSSD_voidDisplay+0x94>
    3f06:	2b 81       	ldd	r18, Y+3	; 0x03
    3f08:	3c 81       	ldd	r19, Y+4	; 0x04
    3f0a:	26 36       	cpi	r18, 0x66	; 102
    3f0c:	31 05       	cpc	r19, r1
    3f0e:	29 f1       	breq	.+74     	; 0x3f5a <HSSD_voidDisplay+0xd2>
    3f10:	8b 81       	ldd	r24, Y+3	; 0x03
    3f12:	9c 81       	ldd	r25, Y+4	; 0x04
    3f14:	8d 36       	cpi	r24, 0x6D	; 109
    3f16:	91 05       	cpc	r25, r1
    3f18:	29 f1       	breq	.+74     	; 0x3f64 <HSSD_voidDisplay+0xdc>
    3f1a:	3c c0       	rjmp	.+120    	; 0x3f94 <HSSD_voidDisplay+0x10c>
    3f1c:	2b 81       	ldd	r18, Y+3	; 0x03
    3f1e:	3c 81       	ldd	r19, Y+4	; 0x04
    3f20:	2d 37       	cpi	r18, 0x7D	; 125
    3f22:	31 05       	cpc	r19, r1
    3f24:	21 f1       	breq	.+72     	; 0x3f6e <HSSD_voidDisplay+0xe6>
    3f26:	8b 81       	ldd	r24, Y+3	; 0x03
    3f28:	9c 81       	ldd	r25, Y+4	; 0x04
    3f2a:	8f 37       	cpi	r24, 0x7F	; 127
    3f2c:	91 05       	cpc	r25, r1
    3f2e:	49 f1       	breq	.+82     	; 0x3f82 <HSSD_voidDisplay+0xfa>
    3f30:	31 c0       	rjmp	.+98     	; 0x3f94 <HSSD_voidDisplay+0x10c>
	{
	case ZERO:
		MDIO_voidSetPortValue(A_u8PortId,ZERO);
    3f32:	8a 81       	ldd	r24, Y+2	; 0x02
    3f34:	6f e3       	ldi	r22, 0x3F	; 63
    3f36:	0e 94 27 0b 	call	0x164e	; 0x164e <MDIO_voidSetPortValue>
    3f3a:	2c c0       	rjmp	.+88     	; 0x3f94 <HSSD_voidDisplay+0x10c>
		break;
	case ONE:
		MDIO_voidSetPortValue(A_u8PortId,ONE);
    3f3c:	8a 81       	ldd	r24, Y+2	; 0x02
    3f3e:	66 e0       	ldi	r22, 0x06	; 6
    3f40:	0e 94 27 0b 	call	0x164e	; 0x164e <MDIO_voidSetPortValue>
    3f44:	27 c0       	rjmp	.+78     	; 0x3f94 <HSSD_voidDisplay+0x10c>
		break;
	case TWO:
		MDIO_voidSetPortValue(A_u8PortId,TWO);
    3f46:	8a 81       	ldd	r24, Y+2	; 0x02
    3f48:	6b e5       	ldi	r22, 0x5B	; 91
    3f4a:	0e 94 27 0b 	call	0x164e	; 0x164e <MDIO_voidSetPortValue>
    3f4e:	22 c0       	rjmp	.+68     	; 0x3f94 <HSSD_voidDisplay+0x10c>
		break;
	case THREE:
		MDIO_voidSetPortValue(A_u8PortId,THREE);
    3f50:	8a 81       	ldd	r24, Y+2	; 0x02
    3f52:	6f e4       	ldi	r22, 0x4F	; 79
    3f54:	0e 94 27 0b 	call	0x164e	; 0x164e <MDIO_voidSetPortValue>
    3f58:	1d c0       	rjmp	.+58     	; 0x3f94 <HSSD_voidDisplay+0x10c>
		break;
	case FOUR:
		MDIO_voidSetPortValue(A_u8PortId,FOUR);
    3f5a:	8a 81       	ldd	r24, Y+2	; 0x02
    3f5c:	66 e6       	ldi	r22, 0x66	; 102
    3f5e:	0e 94 27 0b 	call	0x164e	; 0x164e <MDIO_voidSetPortValue>
    3f62:	18 c0       	rjmp	.+48     	; 0x3f94 <HSSD_voidDisplay+0x10c>
		break;
	case FIVE:
		MDIO_voidSetPortValue(A_u8PortId,FIVE);
    3f64:	8a 81       	ldd	r24, Y+2	; 0x02
    3f66:	6d e6       	ldi	r22, 0x6D	; 109
    3f68:	0e 94 27 0b 	call	0x164e	; 0x164e <MDIO_voidSetPortValue>
    3f6c:	13 c0       	rjmp	.+38     	; 0x3f94 <HSSD_voidDisplay+0x10c>
		break;
	case SIX:
		MDIO_voidSetPortValue(A_u8PortId,SIX);
    3f6e:	8a 81       	ldd	r24, Y+2	; 0x02
    3f70:	6d e7       	ldi	r22, 0x7D	; 125
    3f72:	0e 94 27 0b 	call	0x164e	; 0x164e <MDIO_voidSetPortValue>
    3f76:	0e c0       	rjmp	.+28     	; 0x3f94 <HSSD_voidDisplay+0x10c>
		break;
	case SEVEN:
		MDIO_voidSetPortValue(A_u8PortId,SEVEN);
    3f78:	8a 81       	ldd	r24, Y+2	; 0x02
    3f7a:	67 e0       	ldi	r22, 0x07	; 7
    3f7c:	0e 94 27 0b 	call	0x164e	; 0x164e <MDIO_voidSetPortValue>
    3f80:	09 c0       	rjmp	.+18     	; 0x3f94 <HSSD_voidDisplay+0x10c>
		break;
	case EIGHT:
		MDIO_voidSetPortValue(A_u8PortId,EIGHT);
    3f82:	8a 81       	ldd	r24, Y+2	; 0x02
    3f84:	6f e7       	ldi	r22, 0x7F	; 127
    3f86:	0e 94 27 0b 	call	0x164e	; 0x164e <MDIO_voidSetPortValue>
    3f8a:	04 c0       	rjmp	.+8      	; 0x3f94 <HSSD_voidDisplay+0x10c>
		break;
	case NINE:
		MDIO_voidSetPortValue(A_u8PortId,NINE);
    3f8c:	8a 81       	ldd	r24, Y+2	; 0x02
    3f8e:	6f e6       	ldi	r22, 0x6F	; 111
    3f90:	0e 94 27 0b 	call	0x164e	; 0x164e <MDIO_voidSetPortValue>
		break;
	}
}
    3f94:	0f 90       	pop	r0
    3f96:	0f 90       	pop	r0
    3f98:	0f 90       	pop	r0
    3f9a:	0f 90       	pop	r0
    3f9c:	cf 91       	pop	r28
    3f9e:	df 91       	pop	r29
    3fa0:	08 95       	ret

00003fa2 <HSSD_voidDisplayAscending>:

void HSSD_voidDisplayAscending(u8 A_u8PortId)
{
    3fa2:	df 93       	push	r29
    3fa4:	cf 93       	push	r28
    3fa6:	cd b7       	in	r28, 0x3d	; 61
    3fa8:	de b7       	in	r29, 0x3e	; 62
    3faa:	6f 97       	sbiw	r28, 0x1f	; 31
    3fac:	0f b6       	in	r0, 0x3f	; 63
    3fae:	f8 94       	cli
    3fb0:	de bf       	out	0x3e, r29	; 62
    3fb2:	0f be       	out	0x3f, r0	; 63
    3fb4:	cd bf       	out	0x3d, r28	; 61
    3fb6:	8a 8f       	std	Y+26, r24	; 0x1a
u8 arr[]={ZERO,ONE,TWO,THREE,FOUR,FIVE,SIX,SEVEN,EIGHT,NINE};
    3fb8:	ce 01       	movw	r24, r28
    3fba:	40 96       	adiw	r24, 0x10	; 16
    3fbc:	9c 8f       	std	Y+28, r25	; 0x1c
    3fbe:	8b 8f       	std	Y+27, r24	; 0x1b
    3fc0:	e7 e8       	ldi	r30, 0x87	; 135
    3fc2:	f0 e0       	ldi	r31, 0x00	; 0
    3fc4:	fe 8f       	std	Y+30, r31	; 0x1e
    3fc6:	ed 8f       	std	Y+29, r30	; 0x1d
    3fc8:	fa e0       	ldi	r31, 0x0A	; 10
    3fca:	ff 8f       	std	Y+31, r31	; 0x1f
    3fcc:	ed 8d       	ldd	r30, Y+29	; 0x1d
    3fce:	fe 8d       	ldd	r31, Y+30	; 0x1e
    3fd0:	00 80       	ld	r0, Z
    3fd2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3fd4:	9e 8d       	ldd	r25, Y+30	; 0x1e
    3fd6:	01 96       	adiw	r24, 0x01	; 1
    3fd8:	9e 8f       	std	Y+30, r25	; 0x1e
    3fda:	8d 8f       	std	Y+29, r24	; 0x1d
    3fdc:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3fde:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3fe0:	00 82       	st	Z, r0
    3fe2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3fe4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3fe6:	01 96       	adiw	r24, 0x01	; 1
    3fe8:	9c 8f       	std	Y+28, r25	; 0x1c
    3fea:	8b 8f       	std	Y+27, r24	; 0x1b
    3fec:	9f 8d       	ldd	r25, Y+31	; 0x1f
    3fee:	91 50       	subi	r25, 0x01	; 1
    3ff0:	9f 8f       	std	Y+31, r25	; 0x1f
    3ff2:	ef 8d       	ldd	r30, Y+31	; 0x1f
    3ff4:	ee 23       	and	r30, r30
    3ff6:	51 f7       	brne	.-44     	; 0x3fcc <HSSD_voidDisplayAscending+0x2a>
	for(u8 i=0;i<10;i++)
    3ff8:	1f 86       	std	Y+15, r1	; 0x0f
    3ffa:	81 c0       	rjmp	.+258    	; 0x40fe <HSSD_voidDisplayAscending+0x15c>
	{
		HSSD_voidDisplay(arr[i],A_u8PortId);
    3ffc:	8f 85       	ldd	r24, Y+15	; 0x0f
    3ffe:	28 2f       	mov	r18, r24
    4000:	30 e0       	ldi	r19, 0x00	; 0
    4002:	ce 01       	movw	r24, r28
    4004:	40 96       	adiw	r24, 0x10	; 16
    4006:	fc 01       	movw	r30, r24
    4008:	e2 0f       	add	r30, r18
    400a:	f3 1f       	adc	r31, r19
    400c:	80 81       	ld	r24, Z
    400e:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4010:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <HSSD_voidDisplay>
    4014:	80 e0       	ldi	r24, 0x00	; 0
    4016:	90 e0       	ldi	r25, 0x00	; 0
    4018:	aa e7       	ldi	r26, 0x7A	; 122
    401a:	b4 e4       	ldi	r27, 0x44	; 68
    401c:	8b 87       	std	Y+11, r24	; 0x0b
    401e:	9c 87       	std	Y+12, r25	; 0x0c
    4020:	ad 87       	std	Y+13, r26	; 0x0d
    4022:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4024:	6b 85       	ldd	r22, Y+11	; 0x0b
    4026:	7c 85       	ldd	r23, Y+12	; 0x0c
    4028:	8d 85       	ldd	r24, Y+13	; 0x0d
    402a:	9e 85       	ldd	r25, Y+14	; 0x0e
    402c:	20 e0       	ldi	r18, 0x00	; 0
    402e:	30 e0       	ldi	r19, 0x00	; 0
    4030:	4a ef       	ldi	r20, 0xFA	; 250
    4032:	54 e4       	ldi	r21, 0x44	; 68
    4034:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4038:	dc 01       	movw	r26, r24
    403a:	cb 01       	movw	r24, r22
    403c:	8f 83       	std	Y+7, r24	; 0x07
    403e:	98 87       	std	Y+8, r25	; 0x08
    4040:	a9 87       	std	Y+9, r26	; 0x09
    4042:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4044:	6f 81       	ldd	r22, Y+7	; 0x07
    4046:	78 85       	ldd	r23, Y+8	; 0x08
    4048:	89 85       	ldd	r24, Y+9	; 0x09
    404a:	9a 85       	ldd	r25, Y+10	; 0x0a
    404c:	20 e0       	ldi	r18, 0x00	; 0
    404e:	30 e0       	ldi	r19, 0x00	; 0
    4050:	40 e8       	ldi	r20, 0x80	; 128
    4052:	5f e3       	ldi	r21, 0x3F	; 63
    4054:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4058:	88 23       	and	r24, r24
    405a:	2c f4       	brge	.+10     	; 0x4066 <HSSD_voidDisplayAscending+0xc4>
		__ticks = 1;
    405c:	81 e0       	ldi	r24, 0x01	; 1
    405e:	90 e0       	ldi	r25, 0x00	; 0
    4060:	9e 83       	std	Y+6, r25	; 0x06
    4062:	8d 83       	std	Y+5, r24	; 0x05
    4064:	3f c0       	rjmp	.+126    	; 0x40e4 <HSSD_voidDisplayAscending+0x142>
	else if (__tmp > 65535)
    4066:	6f 81       	ldd	r22, Y+7	; 0x07
    4068:	78 85       	ldd	r23, Y+8	; 0x08
    406a:	89 85       	ldd	r24, Y+9	; 0x09
    406c:	9a 85       	ldd	r25, Y+10	; 0x0a
    406e:	20 e0       	ldi	r18, 0x00	; 0
    4070:	3f ef       	ldi	r19, 0xFF	; 255
    4072:	4f e7       	ldi	r20, 0x7F	; 127
    4074:	57 e4       	ldi	r21, 0x47	; 71
    4076:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    407a:	18 16       	cp	r1, r24
    407c:	4c f5       	brge	.+82     	; 0x40d0 <HSSD_voidDisplayAscending+0x12e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    407e:	6b 85       	ldd	r22, Y+11	; 0x0b
    4080:	7c 85       	ldd	r23, Y+12	; 0x0c
    4082:	8d 85       	ldd	r24, Y+13	; 0x0d
    4084:	9e 85       	ldd	r25, Y+14	; 0x0e
    4086:	20 e0       	ldi	r18, 0x00	; 0
    4088:	30 e0       	ldi	r19, 0x00	; 0
    408a:	40 e2       	ldi	r20, 0x20	; 32
    408c:	51 e4       	ldi	r21, 0x41	; 65
    408e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4092:	dc 01       	movw	r26, r24
    4094:	cb 01       	movw	r24, r22
    4096:	bc 01       	movw	r22, r24
    4098:	cd 01       	movw	r24, r26
    409a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    409e:	dc 01       	movw	r26, r24
    40a0:	cb 01       	movw	r24, r22
    40a2:	9e 83       	std	Y+6, r25	; 0x06
    40a4:	8d 83       	std	Y+5, r24	; 0x05
    40a6:	0f c0       	rjmp	.+30     	; 0x40c6 <HSSD_voidDisplayAscending+0x124>
    40a8:	88 ec       	ldi	r24, 0xC8	; 200
    40aa:	90 e0       	ldi	r25, 0x00	; 0
    40ac:	9c 83       	std	Y+4, r25	; 0x04
    40ae:	8b 83       	std	Y+3, r24	; 0x03
    40b0:	8b 81       	ldd	r24, Y+3	; 0x03
    40b2:	9c 81       	ldd	r25, Y+4	; 0x04
    40b4:	01 97       	sbiw	r24, 0x01	; 1
    40b6:	f1 f7       	brne	.-4      	; 0x40b4 <HSSD_voidDisplayAscending+0x112>
    40b8:	9c 83       	std	Y+4, r25	; 0x04
    40ba:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    40bc:	8d 81       	ldd	r24, Y+5	; 0x05
    40be:	9e 81       	ldd	r25, Y+6	; 0x06
    40c0:	01 97       	sbiw	r24, 0x01	; 1
    40c2:	9e 83       	std	Y+6, r25	; 0x06
    40c4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    40c6:	8d 81       	ldd	r24, Y+5	; 0x05
    40c8:	9e 81       	ldd	r25, Y+6	; 0x06
    40ca:	00 97       	sbiw	r24, 0x00	; 0
    40cc:	69 f7       	brne	.-38     	; 0x40a8 <HSSD_voidDisplayAscending+0x106>
    40ce:	14 c0       	rjmp	.+40     	; 0x40f8 <HSSD_voidDisplayAscending+0x156>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    40d0:	6f 81       	ldd	r22, Y+7	; 0x07
    40d2:	78 85       	ldd	r23, Y+8	; 0x08
    40d4:	89 85       	ldd	r24, Y+9	; 0x09
    40d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    40d8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    40dc:	dc 01       	movw	r26, r24
    40de:	cb 01       	movw	r24, r22
    40e0:	9e 83       	std	Y+6, r25	; 0x06
    40e2:	8d 83       	std	Y+5, r24	; 0x05
    40e4:	8d 81       	ldd	r24, Y+5	; 0x05
    40e6:	9e 81       	ldd	r25, Y+6	; 0x06
    40e8:	9a 83       	std	Y+2, r25	; 0x02
    40ea:	89 83       	std	Y+1, r24	; 0x01
    40ec:	89 81       	ldd	r24, Y+1	; 0x01
    40ee:	9a 81       	ldd	r25, Y+2	; 0x02
    40f0:	01 97       	sbiw	r24, 0x01	; 1
    40f2:	f1 f7       	brne	.-4      	; 0x40f0 <HSSD_voidDisplayAscending+0x14e>
    40f4:	9a 83       	std	Y+2, r25	; 0x02
    40f6:	89 83       	std	Y+1, r24	; 0x01
}

void HSSD_voidDisplayAscending(u8 A_u8PortId)
{
u8 arr[]={ZERO,ONE,TWO,THREE,FOUR,FIVE,SIX,SEVEN,EIGHT,NINE};
	for(u8 i=0;i<10;i++)
    40f8:	8f 85       	ldd	r24, Y+15	; 0x0f
    40fa:	8f 5f       	subi	r24, 0xFF	; 255
    40fc:	8f 87       	std	Y+15, r24	; 0x0f
    40fe:	8f 85       	ldd	r24, Y+15	; 0x0f
    4100:	8a 30       	cpi	r24, 0x0A	; 10
    4102:	08 f4       	brcc	.+2      	; 0x4106 <HSSD_voidDisplayAscending+0x164>
    4104:	7b cf       	rjmp	.-266    	; 0x3ffc <HSSD_voidDisplayAscending+0x5a>
	{
		HSSD_voidDisplay(arr[i],A_u8PortId);
		_delay_ms(SSD_DELAY);
	}
}
    4106:	6f 96       	adiw	r28, 0x1f	; 31
    4108:	0f b6       	in	r0, 0x3f	; 63
    410a:	f8 94       	cli
    410c:	de bf       	out	0x3e, r29	; 62
    410e:	0f be       	out	0x3f, r0	; 63
    4110:	cd bf       	out	0x3d, r28	; 61
    4112:	cf 91       	pop	r28
    4114:	df 91       	pop	r29
    4116:	08 95       	ret

00004118 <HSSD_voidDisplayDescending>:

void HSSD_voidDisplayDescending(u8 A_u8PortId)
{
    4118:	df 93       	push	r29
    411a:	cf 93       	push	r28
    411c:	cd b7       	in	r28, 0x3d	; 61
    411e:	de b7       	in	r29, 0x3e	; 62
    4120:	6f 97       	sbiw	r28, 0x1f	; 31
    4122:	0f b6       	in	r0, 0x3f	; 63
    4124:	f8 94       	cli
    4126:	de bf       	out	0x3e, r29	; 62
    4128:	0f be       	out	0x3f, r0	; 63
    412a:	cd bf       	out	0x3d, r28	; 61
    412c:	8a 8f       	std	Y+26, r24	; 0x1a
u8 arr[]={ZERO,ONE,TWO,THREE,FOUR,FIVE,SIX,SEVEN,EIGHT,NINE};
    412e:	ce 01       	movw	r24, r28
    4130:	40 96       	adiw	r24, 0x10	; 16
    4132:	9c 8f       	std	Y+28, r25	; 0x1c
    4134:	8b 8f       	std	Y+27, r24	; 0x1b
    4136:	e1 e9       	ldi	r30, 0x91	; 145
    4138:	f0 e0       	ldi	r31, 0x00	; 0
    413a:	fe 8f       	std	Y+30, r31	; 0x1e
    413c:	ed 8f       	std	Y+29, r30	; 0x1d
    413e:	fa e0       	ldi	r31, 0x0A	; 10
    4140:	ff 8f       	std	Y+31, r31	; 0x1f
    4142:	ed 8d       	ldd	r30, Y+29	; 0x1d
    4144:	fe 8d       	ldd	r31, Y+30	; 0x1e
    4146:	00 80       	ld	r0, Z
    4148:	8d 8d       	ldd	r24, Y+29	; 0x1d
    414a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    414c:	01 96       	adiw	r24, 0x01	; 1
    414e:	9e 8f       	std	Y+30, r25	; 0x1e
    4150:	8d 8f       	std	Y+29, r24	; 0x1d
    4152:	eb 8d       	ldd	r30, Y+27	; 0x1b
    4154:	fc 8d       	ldd	r31, Y+28	; 0x1c
    4156:	00 82       	st	Z, r0
    4158:	8b 8d       	ldd	r24, Y+27	; 0x1b
    415a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    415c:	01 96       	adiw	r24, 0x01	; 1
    415e:	9c 8f       	std	Y+28, r25	; 0x1c
    4160:	8b 8f       	std	Y+27, r24	; 0x1b
    4162:	9f 8d       	ldd	r25, Y+31	; 0x1f
    4164:	91 50       	subi	r25, 0x01	; 1
    4166:	9f 8f       	std	Y+31, r25	; 0x1f
    4168:	ef 8d       	ldd	r30, Y+31	; 0x1f
    416a:	ee 23       	and	r30, r30
    416c:	51 f7       	brne	.-44     	; 0x4142 <HSSD_voidDisplayDescending+0x2a>
	for(u8 j=9;j>=0;j--)
    416e:	89 e0       	ldi	r24, 0x09	; 9
    4170:	8f 87       	std	Y+15, r24	; 0x0f
	{
		HSSD_voidDisplay(arr[j],A_u8PortId);
    4172:	8f 85       	ldd	r24, Y+15	; 0x0f
    4174:	28 2f       	mov	r18, r24
    4176:	30 e0       	ldi	r19, 0x00	; 0
    4178:	ce 01       	movw	r24, r28
    417a:	40 96       	adiw	r24, 0x10	; 16
    417c:	fc 01       	movw	r30, r24
    417e:	e2 0f       	add	r30, r18
    4180:	f3 1f       	adc	r31, r19
    4182:	80 81       	ld	r24, Z
    4184:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4186:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <HSSD_voidDisplay>
    418a:	80 e0       	ldi	r24, 0x00	; 0
    418c:	90 e0       	ldi	r25, 0x00	; 0
    418e:	aa e7       	ldi	r26, 0x7A	; 122
    4190:	b4 e4       	ldi	r27, 0x44	; 68
    4192:	8b 87       	std	Y+11, r24	; 0x0b
    4194:	9c 87       	std	Y+12, r25	; 0x0c
    4196:	ad 87       	std	Y+13, r26	; 0x0d
    4198:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    419a:	6b 85       	ldd	r22, Y+11	; 0x0b
    419c:	7c 85       	ldd	r23, Y+12	; 0x0c
    419e:	8d 85       	ldd	r24, Y+13	; 0x0d
    41a0:	9e 85       	ldd	r25, Y+14	; 0x0e
    41a2:	20 e0       	ldi	r18, 0x00	; 0
    41a4:	30 e0       	ldi	r19, 0x00	; 0
    41a6:	4a ef       	ldi	r20, 0xFA	; 250
    41a8:	54 e4       	ldi	r21, 0x44	; 68
    41aa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    41ae:	dc 01       	movw	r26, r24
    41b0:	cb 01       	movw	r24, r22
    41b2:	8f 83       	std	Y+7, r24	; 0x07
    41b4:	98 87       	std	Y+8, r25	; 0x08
    41b6:	a9 87       	std	Y+9, r26	; 0x09
    41b8:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    41ba:	6f 81       	ldd	r22, Y+7	; 0x07
    41bc:	78 85       	ldd	r23, Y+8	; 0x08
    41be:	89 85       	ldd	r24, Y+9	; 0x09
    41c0:	9a 85       	ldd	r25, Y+10	; 0x0a
    41c2:	20 e0       	ldi	r18, 0x00	; 0
    41c4:	30 e0       	ldi	r19, 0x00	; 0
    41c6:	40 e8       	ldi	r20, 0x80	; 128
    41c8:	5f e3       	ldi	r21, 0x3F	; 63
    41ca:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    41ce:	88 23       	and	r24, r24
    41d0:	2c f4       	brge	.+10     	; 0x41dc <HSSD_voidDisplayDescending+0xc4>
		__ticks = 1;
    41d2:	81 e0       	ldi	r24, 0x01	; 1
    41d4:	90 e0       	ldi	r25, 0x00	; 0
    41d6:	9e 83       	std	Y+6, r25	; 0x06
    41d8:	8d 83       	std	Y+5, r24	; 0x05
    41da:	3f c0       	rjmp	.+126    	; 0x425a <HSSD_voidDisplayDescending+0x142>
	else if (__tmp > 65535)
    41dc:	6f 81       	ldd	r22, Y+7	; 0x07
    41de:	78 85       	ldd	r23, Y+8	; 0x08
    41e0:	89 85       	ldd	r24, Y+9	; 0x09
    41e2:	9a 85       	ldd	r25, Y+10	; 0x0a
    41e4:	20 e0       	ldi	r18, 0x00	; 0
    41e6:	3f ef       	ldi	r19, 0xFF	; 255
    41e8:	4f e7       	ldi	r20, 0x7F	; 127
    41ea:	57 e4       	ldi	r21, 0x47	; 71
    41ec:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    41f0:	18 16       	cp	r1, r24
    41f2:	4c f5       	brge	.+82     	; 0x4246 <HSSD_voidDisplayDescending+0x12e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    41f4:	6b 85       	ldd	r22, Y+11	; 0x0b
    41f6:	7c 85       	ldd	r23, Y+12	; 0x0c
    41f8:	8d 85       	ldd	r24, Y+13	; 0x0d
    41fa:	9e 85       	ldd	r25, Y+14	; 0x0e
    41fc:	20 e0       	ldi	r18, 0x00	; 0
    41fe:	30 e0       	ldi	r19, 0x00	; 0
    4200:	40 e2       	ldi	r20, 0x20	; 32
    4202:	51 e4       	ldi	r21, 0x41	; 65
    4204:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4208:	dc 01       	movw	r26, r24
    420a:	cb 01       	movw	r24, r22
    420c:	bc 01       	movw	r22, r24
    420e:	cd 01       	movw	r24, r26
    4210:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4214:	dc 01       	movw	r26, r24
    4216:	cb 01       	movw	r24, r22
    4218:	9e 83       	std	Y+6, r25	; 0x06
    421a:	8d 83       	std	Y+5, r24	; 0x05
    421c:	0f c0       	rjmp	.+30     	; 0x423c <HSSD_voidDisplayDescending+0x124>
    421e:	88 ec       	ldi	r24, 0xC8	; 200
    4220:	90 e0       	ldi	r25, 0x00	; 0
    4222:	9c 83       	std	Y+4, r25	; 0x04
    4224:	8b 83       	std	Y+3, r24	; 0x03
    4226:	8b 81       	ldd	r24, Y+3	; 0x03
    4228:	9c 81       	ldd	r25, Y+4	; 0x04
    422a:	01 97       	sbiw	r24, 0x01	; 1
    422c:	f1 f7       	brne	.-4      	; 0x422a <HSSD_voidDisplayDescending+0x112>
    422e:	9c 83       	std	Y+4, r25	; 0x04
    4230:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4232:	8d 81       	ldd	r24, Y+5	; 0x05
    4234:	9e 81       	ldd	r25, Y+6	; 0x06
    4236:	01 97       	sbiw	r24, 0x01	; 1
    4238:	9e 83       	std	Y+6, r25	; 0x06
    423a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    423c:	8d 81       	ldd	r24, Y+5	; 0x05
    423e:	9e 81       	ldd	r25, Y+6	; 0x06
    4240:	00 97       	sbiw	r24, 0x00	; 0
    4242:	69 f7       	brne	.-38     	; 0x421e <HSSD_voidDisplayDescending+0x106>
    4244:	14 c0       	rjmp	.+40     	; 0x426e <HSSD_voidDisplayDescending+0x156>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4246:	6f 81       	ldd	r22, Y+7	; 0x07
    4248:	78 85       	ldd	r23, Y+8	; 0x08
    424a:	89 85       	ldd	r24, Y+9	; 0x09
    424c:	9a 85       	ldd	r25, Y+10	; 0x0a
    424e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4252:	dc 01       	movw	r26, r24
    4254:	cb 01       	movw	r24, r22
    4256:	9e 83       	std	Y+6, r25	; 0x06
    4258:	8d 83       	std	Y+5, r24	; 0x05
    425a:	8d 81       	ldd	r24, Y+5	; 0x05
    425c:	9e 81       	ldd	r25, Y+6	; 0x06
    425e:	9a 83       	std	Y+2, r25	; 0x02
    4260:	89 83       	std	Y+1, r24	; 0x01
    4262:	89 81       	ldd	r24, Y+1	; 0x01
    4264:	9a 81       	ldd	r25, Y+2	; 0x02
    4266:	01 97       	sbiw	r24, 0x01	; 1
    4268:	f1 f7       	brne	.-4      	; 0x4266 <HSSD_voidDisplayDescending+0x14e>
    426a:	9a 83       	std	Y+2, r25	; 0x02
    426c:	89 83       	std	Y+1, r24	; 0x01
}

void HSSD_voidDisplayDescending(u8 A_u8PortId)
{
u8 arr[]={ZERO,ONE,TWO,THREE,FOUR,FIVE,SIX,SEVEN,EIGHT,NINE};
	for(u8 j=9;j>=0;j--)
    426e:	8f 85       	ldd	r24, Y+15	; 0x0f
    4270:	81 50       	subi	r24, 0x01	; 1
    4272:	8f 87       	std	Y+15, r24	; 0x0f
    4274:	7e cf       	rjmp	.-260    	; 0x4172 <HSSD_voidDisplayDescending+0x5a>

00004276 <HSTEP_voidFullStep>:
#include "../Include/HAL/STEPPER/STEPPER_Private.h"

#include <util/delay.h>

void HSTEP_voidFullStep()
{
    4276:	df 93       	push	r29
    4278:	cf 93       	push	r28
    427a:	cd b7       	in	r28, 0x3d	; 61
    427c:	de b7       	in	r29, 0x3e	; 62
    427e:	e8 97       	sbiw	r28, 0x38	; 56
    4280:	0f b6       	in	r0, 0x3f	; 63
    4282:	f8 94       	cli
    4284:	de bf       	out	0x3e, r29	; 62
    4286:	0f be       	out	0x3f, r0	; 63
    4288:	cd bf       	out	0x3d, r28	; 61
    MDIO_voidSetPinValue(STEPPER_PORT,BLUE_COIL_PIN,PIN_HIGH);
    428a:	80 e0       	ldi	r24, 0x00	; 0
    428c:	60 e0       	ldi	r22, 0x00	; 0
    428e:	41 e0       	ldi	r20, 0x01	; 1
    4290:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,PINK_COIL_PIN,PIN_LOW);
    4294:	80 e0       	ldi	r24, 0x00	; 0
    4296:	61 e0       	ldi	r22, 0x01	; 1
    4298:	40 e0       	ldi	r20, 0x00	; 0
    429a:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,YELLOW_COIL_PIN,PIN_HIGH);
    429e:	80 e0       	ldi	r24, 0x00	; 0
    42a0:	62 e0       	ldi	r22, 0x02	; 2
    42a2:	41 e0       	ldi	r20, 0x01	; 1
    42a4:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,ORANGE_COIL_PIN,PIN_HIGH);
    42a8:	80 e0       	ldi	r24, 0x00	; 0
    42aa:	63 e0       	ldi	r22, 0x03	; 3
    42ac:	41 e0       	ldi	r20, 0x01	; 1
    42ae:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    42b2:	80 e0       	ldi	r24, 0x00	; 0
    42b4:	90 e0       	ldi	r25, 0x00	; 0
    42b6:	a0 e2       	ldi	r26, 0x20	; 32
    42b8:	b1 e4       	ldi	r27, 0x41	; 65
    42ba:	8d ab       	std	Y+53, r24	; 0x35
    42bc:	9e ab       	std	Y+54, r25	; 0x36
    42be:	af ab       	std	Y+55, r26	; 0x37
    42c0:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    42c2:	6d a9       	ldd	r22, Y+53	; 0x35
    42c4:	7e a9       	ldd	r23, Y+54	; 0x36
    42c6:	8f a9       	ldd	r24, Y+55	; 0x37
    42c8:	98 ad       	ldd	r25, Y+56	; 0x38
    42ca:	20 e0       	ldi	r18, 0x00	; 0
    42cc:	30 e0       	ldi	r19, 0x00	; 0
    42ce:	4a ef       	ldi	r20, 0xFA	; 250
    42d0:	54 e4       	ldi	r21, 0x44	; 68
    42d2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    42d6:	dc 01       	movw	r26, r24
    42d8:	cb 01       	movw	r24, r22
    42da:	89 ab       	std	Y+49, r24	; 0x31
    42dc:	9a ab       	std	Y+50, r25	; 0x32
    42de:	ab ab       	std	Y+51, r26	; 0x33
    42e0:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    42e2:	69 a9       	ldd	r22, Y+49	; 0x31
    42e4:	7a a9       	ldd	r23, Y+50	; 0x32
    42e6:	8b a9       	ldd	r24, Y+51	; 0x33
    42e8:	9c a9       	ldd	r25, Y+52	; 0x34
    42ea:	20 e0       	ldi	r18, 0x00	; 0
    42ec:	30 e0       	ldi	r19, 0x00	; 0
    42ee:	40 e8       	ldi	r20, 0x80	; 128
    42f0:	5f e3       	ldi	r21, 0x3F	; 63
    42f2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    42f6:	88 23       	and	r24, r24
    42f8:	2c f4       	brge	.+10     	; 0x4304 <HSTEP_voidFullStep+0x8e>
		__ticks = 1;
    42fa:	81 e0       	ldi	r24, 0x01	; 1
    42fc:	90 e0       	ldi	r25, 0x00	; 0
    42fe:	98 ab       	std	Y+48, r25	; 0x30
    4300:	8f a7       	std	Y+47, r24	; 0x2f
    4302:	3f c0       	rjmp	.+126    	; 0x4382 <HSTEP_voidFullStep+0x10c>
	else if (__tmp > 65535)
    4304:	69 a9       	ldd	r22, Y+49	; 0x31
    4306:	7a a9       	ldd	r23, Y+50	; 0x32
    4308:	8b a9       	ldd	r24, Y+51	; 0x33
    430a:	9c a9       	ldd	r25, Y+52	; 0x34
    430c:	20 e0       	ldi	r18, 0x00	; 0
    430e:	3f ef       	ldi	r19, 0xFF	; 255
    4310:	4f e7       	ldi	r20, 0x7F	; 127
    4312:	57 e4       	ldi	r21, 0x47	; 71
    4314:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4318:	18 16       	cp	r1, r24
    431a:	4c f5       	brge	.+82     	; 0x436e <HSTEP_voidFullStep+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    431c:	6d a9       	ldd	r22, Y+53	; 0x35
    431e:	7e a9       	ldd	r23, Y+54	; 0x36
    4320:	8f a9       	ldd	r24, Y+55	; 0x37
    4322:	98 ad       	ldd	r25, Y+56	; 0x38
    4324:	20 e0       	ldi	r18, 0x00	; 0
    4326:	30 e0       	ldi	r19, 0x00	; 0
    4328:	40 e2       	ldi	r20, 0x20	; 32
    432a:	51 e4       	ldi	r21, 0x41	; 65
    432c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4330:	dc 01       	movw	r26, r24
    4332:	cb 01       	movw	r24, r22
    4334:	bc 01       	movw	r22, r24
    4336:	cd 01       	movw	r24, r26
    4338:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    433c:	dc 01       	movw	r26, r24
    433e:	cb 01       	movw	r24, r22
    4340:	98 ab       	std	Y+48, r25	; 0x30
    4342:	8f a7       	std	Y+47, r24	; 0x2f
    4344:	0f c0       	rjmp	.+30     	; 0x4364 <HSTEP_voidFullStep+0xee>
    4346:	88 ec       	ldi	r24, 0xC8	; 200
    4348:	90 e0       	ldi	r25, 0x00	; 0
    434a:	9e a7       	std	Y+46, r25	; 0x2e
    434c:	8d a7       	std	Y+45, r24	; 0x2d
    434e:	8d a5       	ldd	r24, Y+45	; 0x2d
    4350:	9e a5       	ldd	r25, Y+46	; 0x2e
    4352:	01 97       	sbiw	r24, 0x01	; 1
    4354:	f1 f7       	brne	.-4      	; 0x4352 <HSTEP_voidFullStep+0xdc>
    4356:	9e a7       	std	Y+46, r25	; 0x2e
    4358:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    435a:	8f a5       	ldd	r24, Y+47	; 0x2f
    435c:	98 a9       	ldd	r25, Y+48	; 0x30
    435e:	01 97       	sbiw	r24, 0x01	; 1
    4360:	98 ab       	std	Y+48, r25	; 0x30
    4362:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4364:	8f a5       	ldd	r24, Y+47	; 0x2f
    4366:	98 a9       	ldd	r25, Y+48	; 0x30
    4368:	00 97       	sbiw	r24, 0x00	; 0
    436a:	69 f7       	brne	.-38     	; 0x4346 <HSTEP_voidFullStep+0xd0>
    436c:	14 c0       	rjmp	.+40     	; 0x4396 <HSTEP_voidFullStep+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    436e:	69 a9       	ldd	r22, Y+49	; 0x31
    4370:	7a a9       	ldd	r23, Y+50	; 0x32
    4372:	8b a9       	ldd	r24, Y+51	; 0x33
    4374:	9c a9       	ldd	r25, Y+52	; 0x34
    4376:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    437a:	dc 01       	movw	r26, r24
    437c:	cb 01       	movw	r24, r22
    437e:	98 ab       	std	Y+48, r25	; 0x30
    4380:	8f a7       	std	Y+47, r24	; 0x2f
    4382:	8f a5       	ldd	r24, Y+47	; 0x2f
    4384:	98 a9       	ldd	r25, Y+48	; 0x30
    4386:	9c a7       	std	Y+44, r25	; 0x2c
    4388:	8b a7       	std	Y+43, r24	; 0x2b
    438a:	8b a5       	ldd	r24, Y+43	; 0x2b
    438c:	9c a5       	ldd	r25, Y+44	; 0x2c
    438e:	01 97       	sbiw	r24, 0x01	; 1
    4390:	f1 f7       	brne	.-4      	; 0x438e <HSTEP_voidFullStep+0x118>
    4392:	9c a7       	std	Y+44, r25	; 0x2c
    4394:	8b a7       	std	Y+43, r24	; 0x2b
    _delay_ms(10);
    MDIO_voidSetPinValue(STEPPER_PORT,BLUE_COIL_PIN,PIN_HIGH);
    4396:	80 e0       	ldi	r24, 0x00	; 0
    4398:	60 e0       	ldi	r22, 0x00	; 0
    439a:	41 e0       	ldi	r20, 0x01	; 1
    439c:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,PINK_COIL_PIN,PIN_HIGH);
    43a0:	80 e0       	ldi	r24, 0x00	; 0
    43a2:	61 e0       	ldi	r22, 0x01	; 1
    43a4:	41 e0       	ldi	r20, 0x01	; 1
    43a6:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,YELLOW_COIL_PIN,PIN_LOW);
    43aa:	80 e0       	ldi	r24, 0x00	; 0
    43ac:	62 e0       	ldi	r22, 0x02	; 2
    43ae:	40 e0       	ldi	r20, 0x00	; 0
    43b0:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,ORANGE_COIL_PIN,PIN_HIGH);
    43b4:	80 e0       	ldi	r24, 0x00	; 0
    43b6:	63 e0       	ldi	r22, 0x03	; 3
    43b8:	41 e0       	ldi	r20, 0x01	; 1
    43ba:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    43be:	80 e0       	ldi	r24, 0x00	; 0
    43c0:	90 e0       	ldi	r25, 0x00	; 0
    43c2:	a0 e2       	ldi	r26, 0x20	; 32
    43c4:	b1 e4       	ldi	r27, 0x41	; 65
    43c6:	8f a3       	std	Y+39, r24	; 0x27
    43c8:	98 a7       	std	Y+40, r25	; 0x28
    43ca:	a9 a7       	std	Y+41, r26	; 0x29
    43cc:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    43ce:	6f a1       	ldd	r22, Y+39	; 0x27
    43d0:	78 a5       	ldd	r23, Y+40	; 0x28
    43d2:	89 a5       	ldd	r24, Y+41	; 0x29
    43d4:	9a a5       	ldd	r25, Y+42	; 0x2a
    43d6:	20 e0       	ldi	r18, 0x00	; 0
    43d8:	30 e0       	ldi	r19, 0x00	; 0
    43da:	4a ef       	ldi	r20, 0xFA	; 250
    43dc:	54 e4       	ldi	r21, 0x44	; 68
    43de:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    43e2:	dc 01       	movw	r26, r24
    43e4:	cb 01       	movw	r24, r22
    43e6:	8b a3       	std	Y+35, r24	; 0x23
    43e8:	9c a3       	std	Y+36, r25	; 0x24
    43ea:	ad a3       	std	Y+37, r26	; 0x25
    43ec:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    43ee:	6b a1       	ldd	r22, Y+35	; 0x23
    43f0:	7c a1       	ldd	r23, Y+36	; 0x24
    43f2:	8d a1       	ldd	r24, Y+37	; 0x25
    43f4:	9e a1       	ldd	r25, Y+38	; 0x26
    43f6:	20 e0       	ldi	r18, 0x00	; 0
    43f8:	30 e0       	ldi	r19, 0x00	; 0
    43fa:	40 e8       	ldi	r20, 0x80	; 128
    43fc:	5f e3       	ldi	r21, 0x3F	; 63
    43fe:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4402:	88 23       	and	r24, r24
    4404:	2c f4       	brge	.+10     	; 0x4410 <HSTEP_voidFullStep+0x19a>
		__ticks = 1;
    4406:	81 e0       	ldi	r24, 0x01	; 1
    4408:	90 e0       	ldi	r25, 0x00	; 0
    440a:	9a a3       	std	Y+34, r25	; 0x22
    440c:	89 a3       	std	Y+33, r24	; 0x21
    440e:	3f c0       	rjmp	.+126    	; 0x448e <HSTEP_voidFullStep+0x218>
	else if (__tmp > 65535)
    4410:	6b a1       	ldd	r22, Y+35	; 0x23
    4412:	7c a1       	ldd	r23, Y+36	; 0x24
    4414:	8d a1       	ldd	r24, Y+37	; 0x25
    4416:	9e a1       	ldd	r25, Y+38	; 0x26
    4418:	20 e0       	ldi	r18, 0x00	; 0
    441a:	3f ef       	ldi	r19, 0xFF	; 255
    441c:	4f e7       	ldi	r20, 0x7F	; 127
    441e:	57 e4       	ldi	r21, 0x47	; 71
    4420:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4424:	18 16       	cp	r1, r24
    4426:	4c f5       	brge	.+82     	; 0x447a <HSTEP_voidFullStep+0x204>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4428:	6f a1       	ldd	r22, Y+39	; 0x27
    442a:	78 a5       	ldd	r23, Y+40	; 0x28
    442c:	89 a5       	ldd	r24, Y+41	; 0x29
    442e:	9a a5       	ldd	r25, Y+42	; 0x2a
    4430:	20 e0       	ldi	r18, 0x00	; 0
    4432:	30 e0       	ldi	r19, 0x00	; 0
    4434:	40 e2       	ldi	r20, 0x20	; 32
    4436:	51 e4       	ldi	r21, 0x41	; 65
    4438:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    443c:	dc 01       	movw	r26, r24
    443e:	cb 01       	movw	r24, r22
    4440:	bc 01       	movw	r22, r24
    4442:	cd 01       	movw	r24, r26
    4444:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4448:	dc 01       	movw	r26, r24
    444a:	cb 01       	movw	r24, r22
    444c:	9a a3       	std	Y+34, r25	; 0x22
    444e:	89 a3       	std	Y+33, r24	; 0x21
    4450:	0f c0       	rjmp	.+30     	; 0x4470 <HSTEP_voidFullStep+0x1fa>
    4452:	88 ec       	ldi	r24, 0xC8	; 200
    4454:	90 e0       	ldi	r25, 0x00	; 0
    4456:	98 a3       	std	Y+32, r25	; 0x20
    4458:	8f 8f       	std	Y+31, r24	; 0x1f
    445a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    445c:	98 a1       	ldd	r25, Y+32	; 0x20
    445e:	01 97       	sbiw	r24, 0x01	; 1
    4460:	f1 f7       	brne	.-4      	; 0x445e <HSTEP_voidFullStep+0x1e8>
    4462:	98 a3       	std	Y+32, r25	; 0x20
    4464:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4466:	89 a1       	ldd	r24, Y+33	; 0x21
    4468:	9a a1       	ldd	r25, Y+34	; 0x22
    446a:	01 97       	sbiw	r24, 0x01	; 1
    446c:	9a a3       	std	Y+34, r25	; 0x22
    446e:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4470:	89 a1       	ldd	r24, Y+33	; 0x21
    4472:	9a a1       	ldd	r25, Y+34	; 0x22
    4474:	00 97       	sbiw	r24, 0x00	; 0
    4476:	69 f7       	brne	.-38     	; 0x4452 <HSTEP_voidFullStep+0x1dc>
    4478:	14 c0       	rjmp	.+40     	; 0x44a2 <HSTEP_voidFullStep+0x22c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    447a:	6b a1       	ldd	r22, Y+35	; 0x23
    447c:	7c a1       	ldd	r23, Y+36	; 0x24
    447e:	8d a1       	ldd	r24, Y+37	; 0x25
    4480:	9e a1       	ldd	r25, Y+38	; 0x26
    4482:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4486:	dc 01       	movw	r26, r24
    4488:	cb 01       	movw	r24, r22
    448a:	9a a3       	std	Y+34, r25	; 0x22
    448c:	89 a3       	std	Y+33, r24	; 0x21
    448e:	89 a1       	ldd	r24, Y+33	; 0x21
    4490:	9a a1       	ldd	r25, Y+34	; 0x22
    4492:	9e 8f       	std	Y+30, r25	; 0x1e
    4494:	8d 8f       	std	Y+29, r24	; 0x1d
    4496:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4498:	9e 8d       	ldd	r25, Y+30	; 0x1e
    449a:	01 97       	sbiw	r24, 0x01	; 1
    449c:	f1 f7       	brne	.-4      	; 0x449a <HSTEP_voidFullStep+0x224>
    449e:	9e 8f       	std	Y+30, r25	; 0x1e
    44a0:	8d 8f       	std	Y+29, r24	; 0x1d
    _delay_ms(10);
    MDIO_voidSetPinValue(STEPPER_PORT,BLUE_COIL_PIN,PIN_HIGH);
    44a2:	80 e0       	ldi	r24, 0x00	; 0
    44a4:	60 e0       	ldi	r22, 0x00	; 0
    44a6:	41 e0       	ldi	r20, 0x01	; 1
    44a8:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,PINK_COIL_PIN,PIN_HIGH);
    44ac:	80 e0       	ldi	r24, 0x00	; 0
    44ae:	61 e0       	ldi	r22, 0x01	; 1
    44b0:	41 e0       	ldi	r20, 0x01	; 1
    44b2:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,YELLOW_COIL_PIN,PIN_HIGH);
    44b6:	80 e0       	ldi	r24, 0x00	; 0
    44b8:	62 e0       	ldi	r22, 0x02	; 2
    44ba:	41 e0       	ldi	r20, 0x01	; 1
    44bc:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,ORANGE_COIL_PIN,PIN_LOW);
    44c0:	80 e0       	ldi	r24, 0x00	; 0
    44c2:	63 e0       	ldi	r22, 0x03	; 3
    44c4:	40 e0       	ldi	r20, 0x00	; 0
    44c6:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    44ca:	80 e0       	ldi	r24, 0x00	; 0
    44cc:	90 e0       	ldi	r25, 0x00	; 0
    44ce:	a0 e2       	ldi	r26, 0x20	; 32
    44d0:	b1 e4       	ldi	r27, 0x41	; 65
    44d2:	89 8f       	std	Y+25, r24	; 0x19
    44d4:	9a 8f       	std	Y+26, r25	; 0x1a
    44d6:	ab 8f       	std	Y+27, r26	; 0x1b
    44d8:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    44da:	69 8d       	ldd	r22, Y+25	; 0x19
    44dc:	7a 8d       	ldd	r23, Y+26	; 0x1a
    44de:	8b 8d       	ldd	r24, Y+27	; 0x1b
    44e0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    44e2:	20 e0       	ldi	r18, 0x00	; 0
    44e4:	30 e0       	ldi	r19, 0x00	; 0
    44e6:	4a ef       	ldi	r20, 0xFA	; 250
    44e8:	54 e4       	ldi	r21, 0x44	; 68
    44ea:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    44ee:	dc 01       	movw	r26, r24
    44f0:	cb 01       	movw	r24, r22
    44f2:	8d 8b       	std	Y+21, r24	; 0x15
    44f4:	9e 8b       	std	Y+22, r25	; 0x16
    44f6:	af 8b       	std	Y+23, r26	; 0x17
    44f8:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    44fa:	6d 89       	ldd	r22, Y+21	; 0x15
    44fc:	7e 89       	ldd	r23, Y+22	; 0x16
    44fe:	8f 89       	ldd	r24, Y+23	; 0x17
    4500:	98 8d       	ldd	r25, Y+24	; 0x18
    4502:	20 e0       	ldi	r18, 0x00	; 0
    4504:	30 e0       	ldi	r19, 0x00	; 0
    4506:	40 e8       	ldi	r20, 0x80	; 128
    4508:	5f e3       	ldi	r21, 0x3F	; 63
    450a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    450e:	88 23       	and	r24, r24
    4510:	2c f4       	brge	.+10     	; 0x451c <HSTEP_voidFullStep+0x2a6>
		__ticks = 1;
    4512:	81 e0       	ldi	r24, 0x01	; 1
    4514:	90 e0       	ldi	r25, 0x00	; 0
    4516:	9c 8b       	std	Y+20, r25	; 0x14
    4518:	8b 8b       	std	Y+19, r24	; 0x13
    451a:	3f c0       	rjmp	.+126    	; 0x459a <HSTEP_voidFullStep+0x324>
	else if (__tmp > 65535)
    451c:	6d 89       	ldd	r22, Y+21	; 0x15
    451e:	7e 89       	ldd	r23, Y+22	; 0x16
    4520:	8f 89       	ldd	r24, Y+23	; 0x17
    4522:	98 8d       	ldd	r25, Y+24	; 0x18
    4524:	20 e0       	ldi	r18, 0x00	; 0
    4526:	3f ef       	ldi	r19, 0xFF	; 255
    4528:	4f e7       	ldi	r20, 0x7F	; 127
    452a:	57 e4       	ldi	r21, 0x47	; 71
    452c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4530:	18 16       	cp	r1, r24
    4532:	4c f5       	brge	.+82     	; 0x4586 <HSTEP_voidFullStep+0x310>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4534:	69 8d       	ldd	r22, Y+25	; 0x19
    4536:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4538:	8b 8d       	ldd	r24, Y+27	; 0x1b
    453a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    453c:	20 e0       	ldi	r18, 0x00	; 0
    453e:	30 e0       	ldi	r19, 0x00	; 0
    4540:	40 e2       	ldi	r20, 0x20	; 32
    4542:	51 e4       	ldi	r21, 0x41	; 65
    4544:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4548:	dc 01       	movw	r26, r24
    454a:	cb 01       	movw	r24, r22
    454c:	bc 01       	movw	r22, r24
    454e:	cd 01       	movw	r24, r26
    4550:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4554:	dc 01       	movw	r26, r24
    4556:	cb 01       	movw	r24, r22
    4558:	9c 8b       	std	Y+20, r25	; 0x14
    455a:	8b 8b       	std	Y+19, r24	; 0x13
    455c:	0f c0       	rjmp	.+30     	; 0x457c <HSTEP_voidFullStep+0x306>
    455e:	88 ec       	ldi	r24, 0xC8	; 200
    4560:	90 e0       	ldi	r25, 0x00	; 0
    4562:	9a 8b       	std	Y+18, r25	; 0x12
    4564:	89 8b       	std	Y+17, r24	; 0x11
    4566:	89 89       	ldd	r24, Y+17	; 0x11
    4568:	9a 89       	ldd	r25, Y+18	; 0x12
    456a:	01 97       	sbiw	r24, 0x01	; 1
    456c:	f1 f7       	brne	.-4      	; 0x456a <HSTEP_voidFullStep+0x2f4>
    456e:	9a 8b       	std	Y+18, r25	; 0x12
    4570:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4572:	8b 89       	ldd	r24, Y+19	; 0x13
    4574:	9c 89       	ldd	r25, Y+20	; 0x14
    4576:	01 97       	sbiw	r24, 0x01	; 1
    4578:	9c 8b       	std	Y+20, r25	; 0x14
    457a:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    457c:	8b 89       	ldd	r24, Y+19	; 0x13
    457e:	9c 89       	ldd	r25, Y+20	; 0x14
    4580:	00 97       	sbiw	r24, 0x00	; 0
    4582:	69 f7       	brne	.-38     	; 0x455e <HSTEP_voidFullStep+0x2e8>
    4584:	14 c0       	rjmp	.+40     	; 0x45ae <HSTEP_voidFullStep+0x338>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4586:	6d 89       	ldd	r22, Y+21	; 0x15
    4588:	7e 89       	ldd	r23, Y+22	; 0x16
    458a:	8f 89       	ldd	r24, Y+23	; 0x17
    458c:	98 8d       	ldd	r25, Y+24	; 0x18
    458e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4592:	dc 01       	movw	r26, r24
    4594:	cb 01       	movw	r24, r22
    4596:	9c 8b       	std	Y+20, r25	; 0x14
    4598:	8b 8b       	std	Y+19, r24	; 0x13
    459a:	8b 89       	ldd	r24, Y+19	; 0x13
    459c:	9c 89       	ldd	r25, Y+20	; 0x14
    459e:	98 8b       	std	Y+16, r25	; 0x10
    45a0:	8f 87       	std	Y+15, r24	; 0x0f
    45a2:	8f 85       	ldd	r24, Y+15	; 0x0f
    45a4:	98 89       	ldd	r25, Y+16	; 0x10
    45a6:	01 97       	sbiw	r24, 0x01	; 1
    45a8:	f1 f7       	brne	.-4      	; 0x45a6 <HSTEP_voidFullStep+0x330>
    45aa:	98 8b       	std	Y+16, r25	; 0x10
    45ac:	8f 87       	std	Y+15, r24	; 0x0f
    _delay_ms(10);
    MDIO_voidSetPinValue(STEPPER_PORT,BLUE_COIL_PIN,PIN_LOW);
    45ae:	80 e0       	ldi	r24, 0x00	; 0
    45b0:	60 e0       	ldi	r22, 0x00	; 0
    45b2:	40 e0       	ldi	r20, 0x00	; 0
    45b4:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,PINK_COIL_PIN,PIN_HIGH);
    45b8:	80 e0       	ldi	r24, 0x00	; 0
    45ba:	61 e0       	ldi	r22, 0x01	; 1
    45bc:	41 e0       	ldi	r20, 0x01	; 1
    45be:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,YELLOW_COIL_PIN,PIN_HIGH);
    45c2:	80 e0       	ldi	r24, 0x00	; 0
    45c4:	62 e0       	ldi	r22, 0x02	; 2
    45c6:	41 e0       	ldi	r20, 0x01	; 1
    45c8:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,ORANGE_COIL_PIN,PIN_HIGH);
    45cc:	80 e0       	ldi	r24, 0x00	; 0
    45ce:	63 e0       	ldi	r22, 0x03	; 3
    45d0:	41 e0       	ldi	r20, 0x01	; 1
    45d2:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    45d6:	80 e0       	ldi	r24, 0x00	; 0
    45d8:	90 e0       	ldi	r25, 0x00	; 0
    45da:	a0 e2       	ldi	r26, 0x20	; 32
    45dc:	b1 e4       	ldi	r27, 0x41	; 65
    45de:	8b 87       	std	Y+11, r24	; 0x0b
    45e0:	9c 87       	std	Y+12, r25	; 0x0c
    45e2:	ad 87       	std	Y+13, r26	; 0x0d
    45e4:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    45e6:	6b 85       	ldd	r22, Y+11	; 0x0b
    45e8:	7c 85       	ldd	r23, Y+12	; 0x0c
    45ea:	8d 85       	ldd	r24, Y+13	; 0x0d
    45ec:	9e 85       	ldd	r25, Y+14	; 0x0e
    45ee:	20 e0       	ldi	r18, 0x00	; 0
    45f0:	30 e0       	ldi	r19, 0x00	; 0
    45f2:	4a ef       	ldi	r20, 0xFA	; 250
    45f4:	54 e4       	ldi	r21, 0x44	; 68
    45f6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    45fa:	dc 01       	movw	r26, r24
    45fc:	cb 01       	movw	r24, r22
    45fe:	8f 83       	std	Y+7, r24	; 0x07
    4600:	98 87       	std	Y+8, r25	; 0x08
    4602:	a9 87       	std	Y+9, r26	; 0x09
    4604:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4606:	6f 81       	ldd	r22, Y+7	; 0x07
    4608:	78 85       	ldd	r23, Y+8	; 0x08
    460a:	89 85       	ldd	r24, Y+9	; 0x09
    460c:	9a 85       	ldd	r25, Y+10	; 0x0a
    460e:	20 e0       	ldi	r18, 0x00	; 0
    4610:	30 e0       	ldi	r19, 0x00	; 0
    4612:	40 e8       	ldi	r20, 0x80	; 128
    4614:	5f e3       	ldi	r21, 0x3F	; 63
    4616:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    461a:	88 23       	and	r24, r24
    461c:	2c f4       	brge	.+10     	; 0x4628 <HSTEP_voidFullStep+0x3b2>
		__ticks = 1;
    461e:	81 e0       	ldi	r24, 0x01	; 1
    4620:	90 e0       	ldi	r25, 0x00	; 0
    4622:	9e 83       	std	Y+6, r25	; 0x06
    4624:	8d 83       	std	Y+5, r24	; 0x05
    4626:	3f c0       	rjmp	.+126    	; 0x46a6 <HSTEP_voidFullStep+0x430>
	else if (__tmp > 65535)
    4628:	6f 81       	ldd	r22, Y+7	; 0x07
    462a:	78 85       	ldd	r23, Y+8	; 0x08
    462c:	89 85       	ldd	r24, Y+9	; 0x09
    462e:	9a 85       	ldd	r25, Y+10	; 0x0a
    4630:	20 e0       	ldi	r18, 0x00	; 0
    4632:	3f ef       	ldi	r19, 0xFF	; 255
    4634:	4f e7       	ldi	r20, 0x7F	; 127
    4636:	57 e4       	ldi	r21, 0x47	; 71
    4638:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    463c:	18 16       	cp	r1, r24
    463e:	4c f5       	brge	.+82     	; 0x4692 <HSTEP_voidFullStep+0x41c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4640:	6b 85       	ldd	r22, Y+11	; 0x0b
    4642:	7c 85       	ldd	r23, Y+12	; 0x0c
    4644:	8d 85       	ldd	r24, Y+13	; 0x0d
    4646:	9e 85       	ldd	r25, Y+14	; 0x0e
    4648:	20 e0       	ldi	r18, 0x00	; 0
    464a:	30 e0       	ldi	r19, 0x00	; 0
    464c:	40 e2       	ldi	r20, 0x20	; 32
    464e:	51 e4       	ldi	r21, 0x41	; 65
    4650:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4654:	dc 01       	movw	r26, r24
    4656:	cb 01       	movw	r24, r22
    4658:	bc 01       	movw	r22, r24
    465a:	cd 01       	movw	r24, r26
    465c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4660:	dc 01       	movw	r26, r24
    4662:	cb 01       	movw	r24, r22
    4664:	9e 83       	std	Y+6, r25	; 0x06
    4666:	8d 83       	std	Y+5, r24	; 0x05
    4668:	0f c0       	rjmp	.+30     	; 0x4688 <HSTEP_voidFullStep+0x412>
    466a:	88 ec       	ldi	r24, 0xC8	; 200
    466c:	90 e0       	ldi	r25, 0x00	; 0
    466e:	9c 83       	std	Y+4, r25	; 0x04
    4670:	8b 83       	std	Y+3, r24	; 0x03
    4672:	8b 81       	ldd	r24, Y+3	; 0x03
    4674:	9c 81       	ldd	r25, Y+4	; 0x04
    4676:	01 97       	sbiw	r24, 0x01	; 1
    4678:	f1 f7       	brne	.-4      	; 0x4676 <HSTEP_voidFullStep+0x400>
    467a:	9c 83       	std	Y+4, r25	; 0x04
    467c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    467e:	8d 81       	ldd	r24, Y+5	; 0x05
    4680:	9e 81       	ldd	r25, Y+6	; 0x06
    4682:	01 97       	sbiw	r24, 0x01	; 1
    4684:	9e 83       	std	Y+6, r25	; 0x06
    4686:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4688:	8d 81       	ldd	r24, Y+5	; 0x05
    468a:	9e 81       	ldd	r25, Y+6	; 0x06
    468c:	00 97       	sbiw	r24, 0x00	; 0
    468e:	69 f7       	brne	.-38     	; 0x466a <HSTEP_voidFullStep+0x3f4>
    4690:	14 c0       	rjmp	.+40     	; 0x46ba <HSTEP_voidFullStep+0x444>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4692:	6f 81       	ldd	r22, Y+7	; 0x07
    4694:	78 85       	ldd	r23, Y+8	; 0x08
    4696:	89 85       	ldd	r24, Y+9	; 0x09
    4698:	9a 85       	ldd	r25, Y+10	; 0x0a
    469a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    469e:	dc 01       	movw	r26, r24
    46a0:	cb 01       	movw	r24, r22
    46a2:	9e 83       	std	Y+6, r25	; 0x06
    46a4:	8d 83       	std	Y+5, r24	; 0x05
    46a6:	8d 81       	ldd	r24, Y+5	; 0x05
    46a8:	9e 81       	ldd	r25, Y+6	; 0x06
    46aa:	9a 83       	std	Y+2, r25	; 0x02
    46ac:	89 83       	std	Y+1, r24	; 0x01
    46ae:	89 81       	ldd	r24, Y+1	; 0x01
    46b0:	9a 81       	ldd	r25, Y+2	; 0x02
    46b2:	01 97       	sbiw	r24, 0x01	; 1
    46b4:	f1 f7       	brne	.-4      	; 0x46b2 <HSTEP_voidFullStep+0x43c>
    46b6:	9a 83       	std	Y+2, r25	; 0x02
    46b8:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(10);
}
    46ba:	e8 96       	adiw	r28, 0x38	; 56
    46bc:	0f b6       	in	r0, 0x3f	; 63
    46be:	f8 94       	cli
    46c0:	de bf       	out	0x3e, r29	; 62
    46c2:	0f be       	out	0x3f, r0	; 63
    46c4:	cd bf       	out	0x3d, r28	; 61
    46c6:	cf 91       	pop	r28
    46c8:	df 91       	pop	r29
    46ca:	08 95       	ret

000046cc <HSTEP_voidMotorAngle>:

void HSTEP_voidMotorAngle(u32 A_u32Angle)
{
    46cc:	df 93       	push	r29
    46ce:	cf 93       	push	r28
    46d0:	cd b7       	in	r28, 0x3d	; 61
    46d2:	de b7       	in	r29, 0x3e	; 62
    46d4:	c0 54       	subi	r28, 0x40	; 64
    46d6:	d0 40       	sbci	r29, 0x00	; 0
    46d8:	0f b6       	in	r0, 0x3f	; 63
    46da:	f8 94       	cli
    46dc:	de bf       	out	0x3e, r29	; 62
    46de:	0f be       	out	0x3f, r0	; 63
    46e0:	cd bf       	out	0x3d, r28	; 61
    46e2:	fe 01       	movw	r30, r28
    46e4:	ff 96       	adiw	r30, 0x3f	; 63
    46e6:	91 83       	std	Z+1, r25	; 0x01
    46e8:	80 83       	st	Z, r24
    u32 local_u32Angle=((NO_OF_STEPS_FOR_360*A_u32Angle)/CIRCLE_ANGLE);
    46ea:	fe 01       	movw	r30, r28
    46ec:	ff 96       	adiw	r30, 0x3f	; 63
    46ee:	80 81       	ld	r24, Z
    46f0:	91 81       	ldd	r25, Z+1	; 0x01
    46f2:	98 2f       	mov	r25, r24
    46f4:	88 27       	eor	r24, r24
    46f6:	99 0f       	add	r25, r25
    46f8:	99 0f       	add	r25, r25
    46fa:	99 0f       	add	r25, r25
    46fc:	28 e6       	ldi	r18, 0x68	; 104
    46fe:	31 e0       	ldi	r19, 0x01	; 1
    4700:	b9 01       	movw	r22, r18
    4702:	0e 94 16 3a 	call	0x742c	; 0x742c <__udivmodhi4>
    4706:	cb 01       	movw	r24, r22
    4708:	9e af       	std	Y+62, r25	; 0x3e
    470a:	8d af       	std	Y+61, r24	; 0x3d
    u32 local_u32Steps=local_u32Angle/NO_OF_COILS; 
    470c:	8d ad       	ldd	r24, Y+61	; 0x3d
    470e:	9e ad       	ldd	r25, Y+62	; 0x3e
    4710:	96 95       	lsr	r25
    4712:	87 95       	ror	r24
    4714:	96 95       	lsr	r25
    4716:	87 95       	ror	r24
    4718:	9c af       	std	Y+60, r25	; 0x3c
    471a:	8b af       	std	Y+59, r24	; 0x3b
    for(u16 i =0;i<local_u32Steps;i++)
    471c:	1a ae       	std	Y+58, r1	; 0x3a
    471e:	19 ae       	std	Y+57, r1	; 0x39
    4720:	1d c2       	rjmp	.+1082   	; 0x4b5c <HSTEP_voidMotorAngle+0x490>
	{
    MDIO_voidSetPinValue(STEPPER_PORT,BLUE_COIL_PIN,PIN_HIGH);
    4722:	80 e0       	ldi	r24, 0x00	; 0
    4724:	60 e0       	ldi	r22, 0x00	; 0
    4726:	41 e0       	ldi	r20, 0x01	; 1
    4728:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,PINK_COIL_PIN,PIN_LOW);
    472c:	80 e0       	ldi	r24, 0x00	; 0
    472e:	61 e0       	ldi	r22, 0x01	; 1
    4730:	40 e0       	ldi	r20, 0x00	; 0
    4732:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,YELLOW_COIL_PIN,PIN_HIGH);
    4736:	80 e0       	ldi	r24, 0x00	; 0
    4738:	62 e0       	ldi	r22, 0x02	; 2
    473a:	41 e0       	ldi	r20, 0x01	; 1
    473c:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,ORANGE_COIL_PIN,PIN_HIGH);
    4740:	80 e0       	ldi	r24, 0x00	; 0
    4742:	63 e0       	ldi	r22, 0x03	; 3
    4744:	41 e0       	ldi	r20, 0x01	; 1
    4746:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    474a:	80 e0       	ldi	r24, 0x00	; 0
    474c:	90 e0       	ldi	r25, 0x00	; 0
    474e:	a0 e2       	ldi	r26, 0x20	; 32
    4750:	b1 e4       	ldi	r27, 0x41	; 65
    4752:	8d ab       	std	Y+53, r24	; 0x35
    4754:	9e ab       	std	Y+54, r25	; 0x36
    4756:	af ab       	std	Y+55, r26	; 0x37
    4758:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    475a:	6d a9       	ldd	r22, Y+53	; 0x35
    475c:	7e a9       	ldd	r23, Y+54	; 0x36
    475e:	8f a9       	ldd	r24, Y+55	; 0x37
    4760:	98 ad       	ldd	r25, Y+56	; 0x38
    4762:	20 e0       	ldi	r18, 0x00	; 0
    4764:	30 e0       	ldi	r19, 0x00	; 0
    4766:	4a ef       	ldi	r20, 0xFA	; 250
    4768:	54 e4       	ldi	r21, 0x44	; 68
    476a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    476e:	dc 01       	movw	r26, r24
    4770:	cb 01       	movw	r24, r22
    4772:	89 ab       	std	Y+49, r24	; 0x31
    4774:	9a ab       	std	Y+50, r25	; 0x32
    4776:	ab ab       	std	Y+51, r26	; 0x33
    4778:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    477a:	69 a9       	ldd	r22, Y+49	; 0x31
    477c:	7a a9       	ldd	r23, Y+50	; 0x32
    477e:	8b a9       	ldd	r24, Y+51	; 0x33
    4780:	9c a9       	ldd	r25, Y+52	; 0x34
    4782:	20 e0       	ldi	r18, 0x00	; 0
    4784:	30 e0       	ldi	r19, 0x00	; 0
    4786:	40 e8       	ldi	r20, 0x80	; 128
    4788:	5f e3       	ldi	r21, 0x3F	; 63
    478a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    478e:	88 23       	and	r24, r24
    4790:	2c f4       	brge	.+10     	; 0x479c <HSTEP_voidMotorAngle+0xd0>
		__ticks = 1;
    4792:	81 e0       	ldi	r24, 0x01	; 1
    4794:	90 e0       	ldi	r25, 0x00	; 0
    4796:	98 ab       	std	Y+48, r25	; 0x30
    4798:	8f a7       	std	Y+47, r24	; 0x2f
    479a:	3f c0       	rjmp	.+126    	; 0x481a <HSTEP_voidMotorAngle+0x14e>
	else if (__tmp > 65535)
    479c:	69 a9       	ldd	r22, Y+49	; 0x31
    479e:	7a a9       	ldd	r23, Y+50	; 0x32
    47a0:	8b a9       	ldd	r24, Y+51	; 0x33
    47a2:	9c a9       	ldd	r25, Y+52	; 0x34
    47a4:	20 e0       	ldi	r18, 0x00	; 0
    47a6:	3f ef       	ldi	r19, 0xFF	; 255
    47a8:	4f e7       	ldi	r20, 0x7F	; 127
    47aa:	57 e4       	ldi	r21, 0x47	; 71
    47ac:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    47b0:	18 16       	cp	r1, r24
    47b2:	4c f5       	brge	.+82     	; 0x4806 <HSTEP_voidMotorAngle+0x13a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    47b4:	6d a9       	ldd	r22, Y+53	; 0x35
    47b6:	7e a9       	ldd	r23, Y+54	; 0x36
    47b8:	8f a9       	ldd	r24, Y+55	; 0x37
    47ba:	98 ad       	ldd	r25, Y+56	; 0x38
    47bc:	20 e0       	ldi	r18, 0x00	; 0
    47be:	30 e0       	ldi	r19, 0x00	; 0
    47c0:	40 e2       	ldi	r20, 0x20	; 32
    47c2:	51 e4       	ldi	r21, 0x41	; 65
    47c4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    47c8:	dc 01       	movw	r26, r24
    47ca:	cb 01       	movw	r24, r22
    47cc:	bc 01       	movw	r22, r24
    47ce:	cd 01       	movw	r24, r26
    47d0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    47d4:	dc 01       	movw	r26, r24
    47d6:	cb 01       	movw	r24, r22
    47d8:	98 ab       	std	Y+48, r25	; 0x30
    47da:	8f a7       	std	Y+47, r24	; 0x2f
    47dc:	0f c0       	rjmp	.+30     	; 0x47fc <HSTEP_voidMotorAngle+0x130>
    47de:	88 ec       	ldi	r24, 0xC8	; 200
    47e0:	90 e0       	ldi	r25, 0x00	; 0
    47e2:	9e a7       	std	Y+46, r25	; 0x2e
    47e4:	8d a7       	std	Y+45, r24	; 0x2d
    47e6:	8d a5       	ldd	r24, Y+45	; 0x2d
    47e8:	9e a5       	ldd	r25, Y+46	; 0x2e
    47ea:	01 97       	sbiw	r24, 0x01	; 1
    47ec:	f1 f7       	brne	.-4      	; 0x47ea <HSTEP_voidMotorAngle+0x11e>
    47ee:	9e a7       	std	Y+46, r25	; 0x2e
    47f0:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    47f2:	8f a5       	ldd	r24, Y+47	; 0x2f
    47f4:	98 a9       	ldd	r25, Y+48	; 0x30
    47f6:	01 97       	sbiw	r24, 0x01	; 1
    47f8:	98 ab       	std	Y+48, r25	; 0x30
    47fa:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    47fc:	8f a5       	ldd	r24, Y+47	; 0x2f
    47fe:	98 a9       	ldd	r25, Y+48	; 0x30
    4800:	00 97       	sbiw	r24, 0x00	; 0
    4802:	69 f7       	brne	.-38     	; 0x47de <HSTEP_voidMotorAngle+0x112>
    4804:	14 c0       	rjmp	.+40     	; 0x482e <HSTEP_voidMotorAngle+0x162>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4806:	69 a9       	ldd	r22, Y+49	; 0x31
    4808:	7a a9       	ldd	r23, Y+50	; 0x32
    480a:	8b a9       	ldd	r24, Y+51	; 0x33
    480c:	9c a9       	ldd	r25, Y+52	; 0x34
    480e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4812:	dc 01       	movw	r26, r24
    4814:	cb 01       	movw	r24, r22
    4816:	98 ab       	std	Y+48, r25	; 0x30
    4818:	8f a7       	std	Y+47, r24	; 0x2f
    481a:	8f a5       	ldd	r24, Y+47	; 0x2f
    481c:	98 a9       	ldd	r25, Y+48	; 0x30
    481e:	9c a7       	std	Y+44, r25	; 0x2c
    4820:	8b a7       	std	Y+43, r24	; 0x2b
    4822:	8b a5       	ldd	r24, Y+43	; 0x2b
    4824:	9c a5       	ldd	r25, Y+44	; 0x2c
    4826:	01 97       	sbiw	r24, 0x01	; 1
    4828:	f1 f7       	brne	.-4      	; 0x4826 <HSTEP_voidMotorAngle+0x15a>
    482a:	9c a7       	std	Y+44, r25	; 0x2c
    482c:	8b a7       	std	Y+43, r24	; 0x2b
    _delay_ms(10);
    MDIO_voidSetPinValue(STEPPER_PORT,BLUE_COIL_PIN,PIN_HIGH);
    482e:	80 e0       	ldi	r24, 0x00	; 0
    4830:	60 e0       	ldi	r22, 0x00	; 0
    4832:	41 e0       	ldi	r20, 0x01	; 1
    4834:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,PINK_COIL_PIN,PIN_HIGH);
    4838:	80 e0       	ldi	r24, 0x00	; 0
    483a:	61 e0       	ldi	r22, 0x01	; 1
    483c:	41 e0       	ldi	r20, 0x01	; 1
    483e:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,YELLOW_COIL_PIN,PIN_LOW);
    4842:	80 e0       	ldi	r24, 0x00	; 0
    4844:	62 e0       	ldi	r22, 0x02	; 2
    4846:	40 e0       	ldi	r20, 0x00	; 0
    4848:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,ORANGE_COIL_PIN,PIN_HIGH);
    484c:	80 e0       	ldi	r24, 0x00	; 0
    484e:	63 e0       	ldi	r22, 0x03	; 3
    4850:	41 e0       	ldi	r20, 0x01	; 1
    4852:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    4856:	80 e0       	ldi	r24, 0x00	; 0
    4858:	90 e0       	ldi	r25, 0x00	; 0
    485a:	a0 e2       	ldi	r26, 0x20	; 32
    485c:	b1 e4       	ldi	r27, 0x41	; 65
    485e:	8f a3       	std	Y+39, r24	; 0x27
    4860:	98 a7       	std	Y+40, r25	; 0x28
    4862:	a9 a7       	std	Y+41, r26	; 0x29
    4864:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4866:	6f a1       	ldd	r22, Y+39	; 0x27
    4868:	78 a5       	ldd	r23, Y+40	; 0x28
    486a:	89 a5       	ldd	r24, Y+41	; 0x29
    486c:	9a a5       	ldd	r25, Y+42	; 0x2a
    486e:	20 e0       	ldi	r18, 0x00	; 0
    4870:	30 e0       	ldi	r19, 0x00	; 0
    4872:	4a ef       	ldi	r20, 0xFA	; 250
    4874:	54 e4       	ldi	r21, 0x44	; 68
    4876:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    487a:	dc 01       	movw	r26, r24
    487c:	cb 01       	movw	r24, r22
    487e:	8b a3       	std	Y+35, r24	; 0x23
    4880:	9c a3       	std	Y+36, r25	; 0x24
    4882:	ad a3       	std	Y+37, r26	; 0x25
    4884:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    4886:	6b a1       	ldd	r22, Y+35	; 0x23
    4888:	7c a1       	ldd	r23, Y+36	; 0x24
    488a:	8d a1       	ldd	r24, Y+37	; 0x25
    488c:	9e a1       	ldd	r25, Y+38	; 0x26
    488e:	20 e0       	ldi	r18, 0x00	; 0
    4890:	30 e0       	ldi	r19, 0x00	; 0
    4892:	40 e8       	ldi	r20, 0x80	; 128
    4894:	5f e3       	ldi	r21, 0x3F	; 63
    4896:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    489a:	88 23       	and	r24, r24
    489c:	2c f4       	brge	.+10     	; 0x48a8 <HSTEP_voidMotorAngle+0x1dc>
		__ticks = 1;
    489e:	81 e0       	ldi	r24, 0x01	; 1
    48a0:	90 e0       	ldi	r25, 0x00	; 0
    48a2:	9a a3       	std	Y+34, r25	; 0x22
    48a4:	89 a3       	std	Y+33, r24	; 0x21
    48a6:	3f c0       	rjmp	.+126    	; 0x4926 <HSTEP_voidMotorAngle+0x25a>
	else if (__tmp > 65535)
    48a8:	6b a1       	ldd	r22, Y+35	; 0x23
    48aa:	7c a1       	ldd	r23, Y+36	; 0x24
    48ac:	8d a1       	ldd	r24, Y+37	; 0x25
    48ae:	9e a1       	ldd	r25, Y+38	; 0x26
    48b0:	20 e0       	ldi	r18, 0x00	; 0
    48b2:	3f ef       	ldi	r19, 0xFF	; 255
    48b4:	4f e7       	ldi	r20, 0x7F	; 127
    48b6:	57 e4       	ldi	r21, 0x47	; 71
    48b8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    48bc:	18 16       	cp	r1, r24
    48be:	4c f5       	brge	.+82     	; 0x4912 <HSTEP_voidMotorAngle+0x246>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    48c0:	6f a1       	ldd	r22, Y+39	; 0x27
    48c2:	78 a5       	ldd	r23, Y+40	; 0x28
    48c4:	89 a5       	ldd	r24, Y+41	; 0x29
    48c6:	9a a5       	ldd	r25, Y+42	; 0x2a
    48c8:	20 e0       	ldi	r18, 0x00	; 0
    48ca:	30 e0       	ldi	r19, 0x00	; 0
    48cc:	40 e2       	ldi	r20, 0x20	; 32
    48ce:	51 e4       	ldi	r21, 0x41	; 65
    48d0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    48d4:	dc 01       	movw	r26, r24
    48d6:	cb 01       	movw	r24, r22
    48d8:	bc 01       	movw	r22, r24
    48da:	cd 01       	movw	r24, r26
    48dc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    48e0:	dc 01       	movw	r26, r24
    48e2:	cb 01       	movw	r24, r22
    48e4:	9a a3       	std	Y+34, r25	; 0x22
    48e6:	89 a3       	std	Y+33, r24	; 0x21
    48e8:	0f c0       	rjmp	.+30     	; 0x4908 <HSTEP_voidMotorAngle+0x23c>
    48ea:	88 ec       	ldi	r24, 0xC8	; 200
    48ec:	90 e0       	ldi	r25, 0x00	; 0
    48ee:	98 a3       	std	Y+32, r25	; 0x20
    48f0:	8f 8f       	std	Y+31, r24	; 0x1f
    48f2:	8f 8d       	ldd	r24, Y+31	; 0x1f
    48f4:	98 a1       	ldd	r25, Y+32	; 0x20
    48f6:	01 97       	sbiw	r24, 0x01	; 1
    48f8:	f1 f7       	brne	.-4      	; 0x48f6 <HSTEP_voidMotorAngle+0x22a>
    48fa:	98 a3       	std	Y+32, r25	; 0x20
    48fc:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    48fe:	89 a1       	ldd	r24, Y+33	; 0x21
    4900:	9a a1       	ldd	r25, Y+34	; 0x22
    4902:	01 97       	sbiw	r24, 0x01	; 1
    4904:	9a a3       	std	Y+34, r25	; 0x22
    4906:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4908:	89 a1       	ldd	r24, Y+33	; 0x21
    490a:	9a a1       	ldd	r25, Y+34	; 0x22
    490c:	00 97       	sbiw	r24, 0x00	; 0
    490e:	69 f7       	brne	.-38     	; 0x48ea <HSTEP_voidMotorAngle+0x21e>
    4910:	14 c0       	rjmp	.+40     	; 0x493a <HSTEP_voidMotorAngle+0x26e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4912:	6b a1       	ldd	r22, Y+35	; 0x23
    4914:	7c a1       	ldd	r23, Y+36	; 0x24
    4916:	8d a1       	ldd	r24, Y+37	; 0x25
    4918:	9e a1       	ldd	r25, Y+38	; 0x26
    491a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    491e:	dc 01       	movw	r26, r24
    4920:	cb 01       	movw	r24, r22
    4922:	9a a3       	std	Y+34, r25	; 0x22
    4924:	89 a3       	std	Y+33, r24	; 0x21
    4926:	89 a1       	ldd	r24, Y+33	; 0x21
    4928:	9a a1       	ldd	r25, Y+34	; 0x22
    492a:	9e 8f       	std	Y+30, r25	; 0x1e
    492c:	8d 8f       	std	Y+29, r24	; 0x1d
    492e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4930:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4932:	01 97       	sbiw	r24, 0x01	; 1
    4934:	f1 f7       	brne	.-4      	; 0x4932 <HSTEP_voidMotorAngle+0x266>
    4936:	9e 8f       	std	Y+30, r25	; 0x1e
    4938:	8d 8f       	std	Y+29, r24	; 0x1d
    _delay_ms(10);
    MDIO_voidSetPinValue(STEPPER_PORT,BLUE_COIL_PIN,PIN_HIGH);
    493a:	80 e0       	ldi	r24, 0x00	; 0
    493c:	60 e0       	ldi	r22, 0x00	; 0
    493e:	41 e0       	ldi	r20, 0x01	; 1
    4940:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,PINK_COIL_PIN,PIN_HIGH);
    4944:	80 e0       	ldi	r24, 0x00	; 0
    4946:	61 e0       	ldi	r22, 0x01	; 1
    4948:	41 e0       	ldi	r20, 0x01	; 1
    494a:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,YELLOW_COIL_PIN,PIN_HIGH);
    494e:	80 e0       	ldi	r24, 0x00	; 0
    4950:	62 e0       	ldi	r22, 0x02	; 2
    4952:	41 e0       	ldi	r20, 0x01	; 1
    4954:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,ORANGE_COIL_PIN,PIN_LOW);
    4958:	80 e0       	ldi	r24, 0x00	; 0
    495a:	63 e0       	ldi	r22, 0x03	; 3
    495c:	40 e0       	ldi	r20, 0x00	; 0
    495e:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    4962:	80 e0       	ldi	r24, 0x00	; 0
    4964:	90 e0       	ldi	r25, 0x00	; 0
    4966:	a0 e2       	ldi	r26, 0x20	; 32
    4968:	b1 e4       	ldi	r27, 0x41	; 65
    496a:	89 8f       	std	Y+25, r24	; 0x19
    496c:	9a 8f       	std	Y+26, r25	; 0x1a
    496e:	ab 8f       	std	Y+27, r26	; 0x1b
    4970:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4972:	69 8d       	ldd	r22, Y+25	; 0x19
    4974:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4976:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4978:	9c 8d       	ldd	r25, Y+28	; 0x1c
    497a:	20 e0       	ldi	r18, 0x00	; 0
    497c:	30 e0       	ldi	r19, 0x00	; 0
    497e:	4a ef       	ldi	r20, 0xFA	; 250
    4980:	54 e4       	ldi	r21, 0x44	; 68
    4982:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4986:	dc 01       	movw	r26, r24
    4988:	cb 01       	movw	r24, r22
    498a:	8d 8b       	std	Y+21, r24	; 0x15
    498c:	9e 8b       	std	Y+22, r25	; 0x16
    498e:	af 8b       	std	Y+23, r26	; 0x17
    4990:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    4992:	6d 89       	ldd	r22, Y+21	; 0x15
    4994:	7e 89       	ldd	r23, Y+22	; 0x16
    4996:	8f 89       	ldd	r24, Y+23	; 0x17
    4998:	98 8d       	ldd	r25, Y+24	; 0x18
    499a:	20 e0       	ldi	r18, 0x00	; 0
    499c:	30 e0       	ldi	r19, 0x00	; 0
    499e:	40 e8       	ldi	r20, 0x80	; 128
    49a0:	5f e3       	ldi	r21, 0x3F	; 63
    49a2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    49a6:	88 23       	and	r24, r24
    49a8:	2c f4       	brge	.+10     	; 0x49b4 <HSTEP_voidMotorAngle+0x2e8>
		__ticks = 1;
    49aa:	81 e0       	ldi	r24, 0x01	; 1
    49ac:	90 e0       	ldi	r25, 0x00	; 0
    49ae:	9c 8b       	std	Y+20, r25	; 0x14
    49b0:	8b 8b       	std	Y+19, r24	; 0x13
    49b2:	3f c0       	rjmp	.+126    	; 0x4a32 <HSTEP_voidMotorAngle+0x366>
	else if (__tmp > 65535)
    49b4:	6d 89       	ldd	r22, Y+21	; 0x15
    49b6:	7e 89       	ldd	r23, Y+22	; 0x16
    49b8:	8f 89       	ldd	r24, Y+23	; 0x17
    49ba:	98 8d       	ldd	r25, Y+24	; 0x18
    49bc:	20 e0       	ldi	r18, 0x00	; 0
    49be:	3f ef       	ldi	r19, 0xFF	; 255
    49c0:	4f e7       	ldi	r20, 0x7F	; 127
    49c2:	57 e4       	ldi	r21, 0x47	; 71
    49c4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    49c8:	18 16       	cp	r1, r24
    49ca:	4c f5       	brge	.+82     	; 0x4a1e <HSTEP_voidMotorAngle+0x352>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    49cc:	69 8d       	ldd	r22, Y+25	; 0x19
    49ce:	7a 8d       	ldd	r23, Y+26	; 0x1a
    49d0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    49d2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    49d4:	20 e0       	ldi	r18, 0x00	; 0
    49d6:	30 e0       	ldi	r19, 0x00	; 0
    49d8:	40 e2       	ldi	r20, 0x20	; 32
    49da:	51 e4       	ldi	r21, 0x41	; 65
    49dc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    49e0:	dc 01       	movw	r26, r24
    49e2:	cb 01       	movw	r24, r22
    49e4:	bc 01       	movw	r22, r24
    49e6:	cd 01       	movw	r24, r26
    49e8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    49ec:	dc 01       	movw	r26, r24
    49ee:	cb 01       	movw	r24, r22
    49f0:	9c 8b       	std	Y+20, r25	; 0x14
    49f2:	8b 8b       	std	Y+19, r24	; 0x13
    49f4:	0f c0       	rjmp	.+30     	; 0x4a14 <HSTEP_voidMotorAngle+0x348>
    49f6:	88 ec       	ldi	r24, 0xC8	; 200
    49f8:	90 e0       	ldi	r25, 0x00	; 0
    49fa:	9a 8b       	std	Y+18, r25	; 0x12
    49fc:	89 8b       	std	Y+17, r24	; 0x11
    49fe:	89 89       	ldd	r24, Y+17	; 0x11
    4a00:	9a 89       	ldd	r25, Y+18	; 0x12
    4a02:	01 97       	sbiw	r24, 0x01	; 1
    4a04:	f1 f7       	brne	.-4      	; 0x4a02 <HSTEP_voidMotorAngle+0x336>
    4a06:	9a 8b       	std	Y+18, r25	; 0x12
    4a08:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4a0a:	8b 89       	ldd	r24, Y+19	; 0x13
    4a0c:	9c 89       	ldd	r25, Y+20	; 0x14
    4a0e:	01 97       	sbiw	r24, 0x01	; 1
    4a10:	9c 8b       	std	Y+20, r25	; 0x14
    4a12:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4a14:	8b 89       	ldd	r24, Y+19	; 0x13
    4a16:	9c 89       	ldd	r25, Y+20	; 0x14
    4a18:	00 97       	sbiw	r24, 0x00	; 0
    4a1a:	69 f7       	brne	.-38     	; 0x49f6 <HSTEP_voidMotorAngle+0x32a>
    4a1c:	14 c0       	rjmp	.+40     	; 0x4a46 <HSTEP_voidMotorAngle+0x37a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4a1e:	6d 89       	ldd	r22, Y+21	; 0x15
    4a20:	7e 89       	ldd	r23, Y+22	; 0x16
    4a22:	8f 89       	ldd	r24, Y+23	; 0x17
    4a24:	98 8d       	ldd	r25, Y+24	; 0x18
    4a26:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4a2a:	dc 01       	movw	r26, r24
    4a2c:	cb 01       	movw	r24, r22
    4a2e:	9c 8b       	std	Y+20, r25	; 0x14
    4a30:	8b 8b       	std	Y+19, r24	; 0x13
    4a32:	8b 89       	ldd	r24, Y+19	; 0x13
    4a34:	9c 89       	ldd	r25, Y+20	; 0x14
    4a36:	98 8b       	std	Y+16, r25	; 0x10
    4a38:	8f 87       	std	Y+15, r24	; 0x0f
    4a3a:	8f 85       	ldd	r24, Y+15	; 0x0f
    4a3c:	98 89       	ldd	r25, Y+16	; 0x10
    4a3e:	01 97       	sbiw	r24, 0x01	; 1
    4a40:	f1 f7       	brne	.-4      	; 0x4a3e <HSTEP_voidMotorAngle+0x372>
    4a42:	98 8b       	std	Y+16, r25	; 0x10
    4a44:	8f 87       	std	Y+15, r24	; 0x0f
    _delay_ms(10);
    MDIO_voidSetPinValue(STEPPER_PORT,BLUE_COIL_PIN,PIN_LOW);
    4a46:	80 e0       	ldi	r24, 0x00	; 0
    4a48:	60 e0       	ldi	r22, 0x00	; 0
    4a4a:	40 e0       	ldi	r20, 0x00	; 0
    4a4c:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,PINK_COIL_PIN,PIN_HIGH);
    4a50:	80 e0       	ldi	r24, 0x00	; 0
    4a52:	61 e0       	ldi	r22, 0x01	; 1
    4a54:	41 e0       	ldi	r20, 0x01	; 1
    4a56:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,YELLOW_COIL_PIN,PIN_HIGH);
    4a5a:	80 e0       	ldi	r24, 0x00	; 0
    4a5c:	62 e0       	ldi	r22, 0x02	; 2
    4a5e:	41 e0       	ldi	r20, 0x01	; 1
    4a60:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,ORANGE_COIL_PIN,PIN_HIGH);
    4a64:	80 e0       	ldi	r24, 0x00	; 0
    4a66:	63 e0       	ldi	r22, 0x03	; 3
    4a68:	41 e0       	ldi	r20, 0x01	; 1
    4a6a:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
    4a6e:	80 e0       	ldi	r24, 0x00	; 0
    4a70:	90 e0       	ldi	r25, 0x00	; 0
    4a72:	a0 e2       	ldi	r26, 0x20	; 32
    4a74:	b1 e4       	ldi	r27, 0x41	; 65
    4a76:	8b 87       	std	Y+11, r24	; 0x0b
    4a78:	9c 87       	std	Y+12, r25	; 0x0c
    4a7a:	ad 87       	std	Y+13, r26	; 0x0d
    4a7c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4a7e:	6b 85       	ldd	r22, Y+11	; 0x0b
    4a80:	7c 85       	ldd	r23, Y+12	; 0x0c
    4a82:	8d 85       	ldd	r24, Y+13	; 0x0d
    4a84:	9e 85       	ldd	r25, Y+14	; 0x0e
    4a86:	20 e0       	ldi	r18, 0x00	; 0
    4a88:	30 e0       	ldi	r19, 0x00	; 0
    4a8a:	4a ef       	ldi	r20, 0xFA	; 250
    4a8c:	54 e4       	ldi	r21, 0x44	; 68
    4a8e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4a92:	dc 01       	movw	r26, r24
    4a94:	cb 01       	movw	r24, r22
    4a96:	8f 83       	std	Y+7, r24	; 0x07
    4a98:	98 87       	std	Y+8, r25	; 0x08
    4a9a:	a9 87       	std	Y+9, r26	; 0x09
    4a9c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4a9e:	6f 81       	ldd	r22, Y+7	; 0x07
    4aa0:	78 85       	ldd	r23, Y+8	; 0x08
    4aa2:	89 85       	ldd	r24, Y+9	; 0x09
    4aa4:	9a 85       	ldd	r25, Y+10	; 0x0a
    4aa6:	20 e0       	ldi	r18, 0x00	; 0
    4aa8:	30 e0       	ldi	r19, 0x00	; 0
    4aaa:	40 e8       	ldi	r20, 0x80	; 128
    4aac:	5f e3       	ldi	r21, 0x3F	; 63
    4aae:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4ab2:	88 23       	and	r24, r24
    4ab4:	2c f4       	brge	.+10     	; 0x4ac0 <HSTEP_voidMotorAngle+0x3f4>
		__ticks = 1;
    4ab6:	81 e0       	ldi	r24, 0x01	; 1
    4ab8:	90 e0       	ldi	r25, 0x00	; 0
    4aba:	9e 83       	std	Y+6, r25	; 0x06
    4abc:	8d 83       	std	Y+5, r24	; 0x05
    4abe:	3f c0       	rjmp	.+126    	; 0x4b3e <HSTEP_voidMotorAngle+0x472>
	else if (__tmp > 65535)
    4ac0:	6f 81       	ldd	r22, Y+7	; 0x07
    4ac2:	78 85       	ldd	r23, Y+8	; 0x08
    4ac4:	89 85       	ldd	r24, Y+9	; 0x09
    4ac6:	9a 85       	ldd	r25, Y+10	; 0x0a
    4ac8:	20 e0       	ldi	r18, 0x00	; 0
    4aca:	3f ef       	ldi	r19, 0xFF	; 255
    4acc:	4f e7       	ldi	r20, 0x7F	; 127
    4ace:	57 e4       	ldi	r21, 0x47	; 71
    4ad0:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4ad4:	18 16       	cp	r1, r24
    4ad6:	4c f5       	brge	.+82     	; 0x4b2a <HSTEP_voidMotorAngle+0x45e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4ad8:	6b 85       	ldd	r22, Y+11	; 0x0b
    4ada:	7c 85       	ldd	r23, Y+12	; 0x0c
    4adc:	8d 85       	ldd	r24, Y+13	; 0x0d
    4ade:	9e 85       	ldd	r25, Y+14	; 0x0e
    4ae0:	20 e0       	ldi	r18, 0x00	; 0
    4ae2:	30 e0       	ldi	r19, 0x00	; 0
    4ae4:	40 e2       	ldi	r20, 0x20	; 32
    4ae6:	51 e4       	ldi	r21, 0x41	; 65
    4ae8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4aec:	dc 01       	movw	r26, r24
    4aee:	cb 01       	movw	r24, r22
    4af0:	bc 01       	movw	r22, r24
    4af2:	cd 01       	movw	r24, r26
    4af4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4af8:	dc 01       	movw	r26, r24
    4afa:	cb 01       	movw	r24, r22
    4afc:	9e 83       	std	Y+6, r25	; 0x06
    4afe:	8d 83       	std	Y+5, r24	; 0x05
    4b00:	0f c0       	rjmp	.+30     	; 0x4b20 <HSTEP_voidMotorAngle+0x454>
    4b02:	88 ec       	ldi	r24, 0xC8	; 200
    4b04:	90 e0       	ldi	r25, 0x00	; 0
    4b06:	9c 83       	std	Y+4, r25	; 0x04
    4b08:	8b 83       	std	Y+3, r24	; 0x03
    4b0a:	8b 81       	ldd	r24, Y+3	; 0x03
    4b0c:	9c 81       	ldd	r25, Y+4	; 0x04
    4b0e:	01 97       	sbiw	r24, 0x01	; 1
    4b10:	f1 f7       	brne	.-4      	; 0x4b0e <HSTEP_voidMotorAngle+0x442>
    4b12:	9c 83       	std	Y+4, r25	; 0x04
    4b14:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4b16:	8d 81       	ldd	r24, Y+5	; 0x05
    4b18:	9e 81       	ldd	r25, Y+6	; 0x06
    4b1a:	01 97       	sbiw	r24, 0x01	; 1
    4b1c:	9e 83       	std	Y+6, r25	; 0x06
    4b1e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4b20:	8d 81       	ldd	r24, Y+5	; 0x05
    4b22:	9e 81       	ldd	r25, Y+6	; 0x06
    4b24:	00 97       	sbiw	r24, 0x00	; 0
    4b26:	69 f7       	brne	.-38     	; 0x4b02 <HSTEP_voidMotorAngle+0x436>
    4b28:	14 c0       	rjmp	.+40     	; 0x4b52 <HSTEP_voidMotorAngle+0x486>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4b2a:	6f 81       	ldd	r22, Y+7	; 0x07
    4b2c:	78 85       	ldd	r23, Y+8	; 0x08
    4b2e:	89 85       	ldd	r24, Y+9	; 0x09
    4b30:	9a 85       	ldd	r25, Y+10	; 0x0a
    4b32:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4b36:	dc 01       	movw	r26, r24
    4b38:	cb 01       	movw	r24, r22
    4b3a:	9e 83       	std	Y+6, r25	; 0x06
    4b3c:	8d 83       	std	Y+5, r24	; 0x05
    4b3e:	8d 81       	ldd	r24, Y+5	; 0x05
    4b40:	9e 81       	ldd	r25, Y+6	; 0x06
    4b42:	9a 83       	std	Y+2, r25	; 0x02
    4b44:	89 83       	std	Y+1, r24	; 0x01
    4b46:	89 81       	ldd	r24, Y+1	; 0x01
    4b48:	9a 81       	ldd	r25, Y+2	; 0x02
    4b4a:	01 97       	sbiw	r24, 0x01	; 1
    4b4c:	f1 f7       	brne	.-4      	; 0x4b4a <HSTEP_voidMotorAngle+0x47e>
    4b4e:	9a 83       	std	Y+2, r25	; 0x02
    4b50:	89 83       	std	Y+1, r24	; 0x01

void HSTEP_voidMotorAngle(u32 A_u32Angle)
{
    u32 local_u32Angle=((NO_OF_STEPS_FOR_360*A_u32Angle)/CIRCLE_ANGLE);
    u32 local_u32Steps=local_u32Angle/NO_OF_COILS; 
    for(u16 i =0;i<local_u32Steps;i++)
    4b52:	89 ad       	ldd	r24, Y+57	; 0x39
    4b54:	9a ad       	ldd	r25, Y+58	; 0x3a
    4b56:	01 96       	adiw	r24, 0x01	; 1
    4b58:	9a af       	std	Y+58, r25	; 0x3a
    4b5a:	89 af       	std	Y+57, r24	; 0x39
    4b5c:	29 ad       	ldd	r18, Y+57	; 0x39
    4b5e:	3a ad       	ldd	r19, Y+58	; 0x3a
    4b60:	8b ad       	ldd	r24, Y+59	; 0x3b
    4b62:	9c ad       	ldd	r25, Y+60	; 0x3c
    4b64:	28 17       	cp	r18, r24
    4b66:	39 07       	cpc	r19, r25
    4b68:	08 f4       	brcc	.+2      	; 0x4b6c <HSTEP_voidMotorAngle+0x4a0>
    4b6a:	db cd       	rjmp	.-1098   	; 0x4722 <HSTEP_voidMotorAngle+0x56>
    MDIO_voidSetPinValue(STEPPER_PORT,PINK_COIL_PIN,PIN_HIGH);
    MDIO_voidSetPinValue(STEPPER_PORT,YELLOW_COIL_PIN,PIN_HIGH);
    MDIO_voidSetPinValue(STEPPER_PORT,ORANGE_COIL_PIN,PIN_HIGH);
    _delay_ms(10);
    }
    4b6c:	c0 5c       	subi	r28, 0xC0	; 192
    4b6e:	df 4f       	sbci	r29, 0xFF	; 255
    4b70:	0f b6       	in	r0, 0x3f	; 63
    4b72:	f8 94       	cli
    4b74:	de bf       	out	0x3e, r29	; 62
    4b76:	0f be       	out	0x3f, r0	; 63
    4b78:	cd bf       	out	0x3d, r28	; 61
    4b7a:	cf 91       	pop	r28
    4b7c:	df 91       	pop	r29
    4b7e:	08 95       	ret

00004b80 <MTIMER0_voidInit>:




void MTIMER0_voidInit(void)
{
    4b80:	df 93       	push	r29
    4b82:	cf 93       	push	r28
    4b84:	cd b7       	in	r28, 0x3d	; 61
    4b86:	de b7       	in	r29, 0x3e	; 62
        CLR_BIT(TCCR0,WGM01);

        TCCR0&=0b11001000;
        TCCR0|=(CLK_CONFIGURATION|(CTC_OC0_PIN_ACTION<<COM));
    #elif TIMER0_MODE == CTC_MODE 
        CLR_BIT(TCCR0,WGM00);
    4b88:	a3 e5       	ldi	r26, 0x53	; 83
    4b8a:	b0 e0       	ldi	r27, 0x00	; 0
    4b8c:	e3 e5       	ldi	r30, 0x53	; 83
    4b8e:	f0 e0       	ldi	r31, 0x00	; 0
    4b90:	80 81       	ld	r24, Z
    4b92:	8f 7b       	andi	r24, 0xBF	; 191
    4b94:	8c 93       	st	X, r24
        SET_BIT(TCCR0,WGM01);
    4b96:	a3 e5       	ldi	r26, 0x53	; 83
    4b98:	b0 e0       	ldi	r27, 0x00	; 0
    4b9a:	e3 e5       	ldi	r30, 0x53	; 83
    4b9c:	f0 e0       	ldi	r31, 0x00	; 0
    4b9e:	80 81       	ld	r24, Z
    4ba0:	88 60       	ori	r24, 0x08	; 8
    4ba2:	8c 93       	st	X, r24

        SET_BIT(TIMSK,OCIE0);
    4ba4:	a9 e5       	ldi	r26, 0x59	; 89
    4ba6:	b0 e0       	ldi	r27, 0x00	; 0
    4ba8:	e9 e5       	ldi	r30, 0x59	; 89
    4baa:	f0 e0       	ldi	r31, 0x00	; 0
    4bac:	80 81       	ld	r24, Z
    4bae:	82 60       	ori	r24, 0x02	; 2
    4bb0:	8c 93       	st	X, r24

        //clk configuration + OC0 action
        TCCR0&=0b11001000;
    4bb2:	a3 e5       	ldi	r26, 0x53	; 83
    4bb4:	b0 e0       	ldi	r27, 0x00	; 0
    4bb6:	e3 e5       	ldi	r30, 0x53	; 83
    4bb8:	f0 e0       	ldi	r31, 0x00	; 0
    4bba:	80 81       	ld	r24, Z
    4bbc:	88 7c       	andi	r24, 0xC8	; 200
    4bbe:	8c 93       	st	X, r24
        TCCR0|=(CLK_CONFIGURATION|(CTC_OC0_PIN_ACTION<<COM));
    4bc0:	a3 e5       	ldi	r26, 0x53	; 83
    4bc2:	b0 e0       	ldi	r27, 0x00	; 0
    4bc4:	e3 e5       	ldi	r30, 0x53	; 83
    4bc6:	f0 e0       	ldi	r31, 0x00	; 0
    4bc8:	80 81       	ld	r24, Z
    4bca:	82 60       	ori	r24, 0x02	; 2
    4bcc:	8c 93       	st	X, r24

        // Set compare match unit value
        OCR0=OCR0_VALUE;
    4bce:	ec e5       	ldi	r30, 0x5C	; 92
    4bd0:	f0 e0       	ldi	r31, 0x00	; 0
    4bd2:	87 ec       	ldi	r24, 0xC7	; 199
    4bd4:	80 83       	st	Z, r24
    #else 
        #error Wrong TIMER0 mode Configuration
    #endif 


}
    4bd6:	cf 91       	pop	r28
    4bd8:	df 91       	pop	r29
    4bda:	08 95       	ret

00004bdc <MTIMER0_voidStopTimer>:

void MTIMER0_voidStopTimer(void)
{
    4bdc:	df 93       	push	r29
    4bde:	cf 93       	push	r28
    4be0:	cd b7       	in	r28, 0x3d	; 61
    4be2:	de b7       	in	r29, 0x3e	; 62
    //stop Clock of Timer 0
    TCCR0&=0b11111000;
    4be4:	a3 e5       	ldi	r26, 0x53	; 83
    4be6:	b0 e0       	ldi	r27, 0x00	; 0
    4be8:	e3 e5       	ldi	r30, 0x53	; 83
    4bea:	f0 e0       	ldi	r31, 0x00	; 0
    4bec:	80 81       	ld	r24, Z
    4bee:	88 7f       	andi	r24, 0xF8	; 248
    4bf0:	8c 93       	st	X, r24

}
    4bf2:	cf 91       	pop	r28
    4bf4:	df 91       	pop	r29
    4bf6:	08 95       	ret

00004bf8 <MTIMER0_voidSetCallBackOVF>:

void MTIMER0_voidSetCallBackOVF(void (*ptrToFunc)(void))
{
    4bf8:	df 93       	push	r29
    4bfa:	cf 93       	push	r28
    4bfc:	00 d0       	rcall	.+0      	; 0x4bfe <MTIMER0_voidSetCallBackOVF+0x6>
    4bfe:	cd b7       	in	r28, 0x3d	; 61
    4c00:	de b7       	in	r29, 0x3e	; 62
    4c02:	9a 83       	std	Y+2, r25	; 0x02
    4c04:	89 83       	std	Y+1, r24	; 0x01
    if(ptrToFunc!=NULL)
    4c06:	89 81       	ldd	r24, Y+1	; 0x01
    4c08:	9a 81       	ldd	r25, Y+2	; 0x02
    4c0a:	00 97       	sbiw	r24, 0x00	; 0
    4c0c:	31 f0       	breq	.+12     	; 0x4c1a <MTIMER0_voidSetCallBackOVF+0x22>
        {
            TIMER0_OVF_CallBack=ptrToFunc;
    4c0e:	89 81       	ldd	r24, Y+1	; 0x01
    4c10:	9a 81       	ldd	r25, Y+2	; 0x02
    4c12:	90 93 a6 00 	sts	0x00A6, r25
    4c16:	80 93 a5 00 	sts	0x00A5, r24
        }
}
    4c1a:	0f 90       	pop	r0
    4c1c:	0f 90       	pop	r0
    4c1e:	cf 91       	pop	r28
    4c20:	df 91       	pop	r29
    4c22:	08 95       	ret

00004c24 <MTIMER0_voidSetCallBackCTC>:

void MTIMER0_voidSetCallBackCTC(void (*ptrToFunc)(void))
{
    4c24:	df 93       	push	r29
    4c26:	cf 93       	push	r28
    4c28:	00 d0       	rcall	.+0      	; 0x4c2a <MTIMER0_voidSetCallBackCTC+0x6>
    4c2a:	cd b7       	in	r28, 0x3d	; 61
    4c2c:	de b7       	in	r29, 0x3e	; 62
    4c2e:	9a 83       	std	Y+2, r25	; 0x02
    4c30:	89 83       	std	Y+1, r24	; 0x01
    if(ptrToFunc!=NULL)
    4c32:	89 81       	ldd	r24, Y+1	; 0x01
    4c34:	9a 81       	ldd	r25, Y+2	; 0x02
    4c36:	00 97       	sbiw	r24, 0x00	; 0
    4c38:	31 f0       	breq	.+12     	; 0x4c46 <MTIMER0_voidSetCallBackCTC+0x22>
        {
            TIMER0_CTC_CallBack=ptrToFunc;
    4c3a:	89 81       	ldd	r24, Y+1	; 0x01
    4c3c:	9a 81       	ldd	r25, Y+2	; 0x02
    4c3e:	90 93 a8 00 	sts	0x00A8, r25
    4c42:	80 93 a7 00 	sts	0x00A7, r24
        }
}
    4c46:	0f 90       	pop	r0
    4c48:	0f 90       	pop	r0
    4c4a:	cf 91       	pop	r28
    4c4c:	df 91       	pop	r29
    4c4e:	08 95       	ret

00004c50 <MTIMER0_voidSetPreloadValue>:

void MTIMER0_voidSetPreloadValue(u8 A_u8Preload)
{
    4c50:	df 93       	push	r29
    4c52:	cf 93       	push	r28
    4c54:	0f 92       	push	r0
    4c56:	cd b7       	in	r28, 0x3d	; 61
    4c58:	de b7       	in	r29, 0x3e	; 62
    4c5a:	89 83       	std	Y+1, r24	; 0x01
    TCNT0=A_u8Preload;
    4c5c:	e2 e5       	ldi	r30, 0x52	; 82
    4c5e:	f0 e0       	ldi	r31, 0x00	; 0
    4c60:	89 81       	ldd	r24, Y+1	; 0x01
    4c62:	80 83       	st	Z, r24
}
    4c64:	0f 90       	pop	r0
    4c66:	cf 91       	pop	r28
    4c68:	df 91       	pop	r29
    4c6a:	08 95       	ret

00004c6c <MTIMER0_voidSetOCR0Value>:

void MTIMER0_voidSetOCR0Value(u8 A_u8Value)
{
    4c6c:	df 93       	push	r29
    4c6e:	cf 93       	push	r28
    4c70:	0f 92       	push	r0
    4c72:	cd b7       	in	r28, 0x3d	; 61
    4c74:	de b7       	in	r29, 0x3e	; 62
    4c76:	89 83       	std	Y+1, r24	; 0x01
    OCR0=A_u8Value;
    4c78:	ec e5       	ldi	r30, 0x5C	; 92
    4c7a:	f0 e0       	ldi	r31, 0x00	; 0
    4c7c:	89 81       	ldd	r24, Y+1	; 0x01
    4c7e:	80 83       	st	Z, r24
}
    4c80:	0f 90       	pop	r0
    4c82:	cf 91       	pop	r28
    4c84:	df 91       	pop	r29
    4c86:	08 95       	ret

00004c88 <__vector_11>:
//    float difference2=256-(difference*256);
//    TCNT0=difference2;
//}

ISR(TIMER0_OVF_VECT)
{
    4c88:	1f 92       	push	r1
    4c8a:	0f 92       	push	r0
    4c8c:	0f b6       	in	r0, 0x3f	; 63
    4c8e:	0f 92       	push	r0
    4c90:	11 24       	eor	r1, r1
    4c92:	2f 93       	push	r18
    4c94:	3f 93       	push	r19
    4c96:	4f 93       	push	r20
    4c98:	5f 93       	push	r21
    4c9a:	6f 93       	push	r22
    4c9c:	7f 93       	push	r23
    4c9e:	8f 93       	push	r24
    4ca0:	9f 93       	push	r25
    4ca2:	af 93       	push	r26
    4ca4:	bf 93       	push	r27
    4ca6:	ef 93       	push	r30
    4ca8:	ff 93       	push	r31
    4caa:	df 93       	push	r29
    4cac:	cf 93       	push	r28
    4cae:	cd b7       	in	r28, 0x3d	; 61
    4cb0:	de b7       	in	r29, 0x3e	; 62
    if(TIMER0_OVF_CallBack!=NULL)
    4cb2:	80 91 a5 00 	lds	r24, 0x00A5
    4cb6:	90 91 a6 00 	lds	r25, 0x00A6
    4cba:	00 97       	sbiw	r24, 0x00	; 0
    4cbc:	29 f0       	breq	.+10     	; 0x4cc8 <__vector_11+0x40>
    {
        TIMER0_OVF_CallBack();
    4cbe:	e0 91 a5 00 	lds	r30, 0x00A5
    4cc2:	f0 91 a6 00 	lds	r31, 0x00A6
    4cc6:	09 95       	icall
    }
}
    4cc8:	cf 91       	pop	r28
    4cca:	df 91       	pop	r29
    4ccc:	ff 91       	pop	r31
    4cce:	ef 91       	pop	r30
    4cd0:	bf 91       	pop	r27
    4cd2:	af 91       	pop	r26
    4cd4:	9f 91       	pop	r25
    4cd6:	8f 91       	pop	r24
    4cd8:	7f 91       	pop	r23
    4cda:	6f 91       	pop	r22
    4cdc:	5f 91       	pop	r21
    4cde:	4f 91       	pop	r20
    4ce0:	3f 91       	pop	r19
    4ce2:	2f 91       	pop	r18
    4ce4:	0f 90       	pop	r0
    4ce6:	0f be       	out	0x3f, r0	; 63
    4ce8:	0f 90       	pop	r0
    4cea:	1f 90       	pop	r1
    4cec:	18 95       	reti

00004cee <__vector_10>:

ISR(TIMER0_CTC_VECT)
{
    4cee:	1f 92       	push	r1
    4cf0:	0f 92       	push	r0
    4cf2:	0f b6       	in	r0, 0x3f	; 63
    4cf4:	0f 92       	push	r0
    4cf6:	11 24       	eor	r1, r1
    4cf8:	2f 93       	push	r18
    4cfa:	3f 93       	push	r19
    4cfc:	4f 93       	push	r20
    4cfe:	5f 93       	push	r21
    4d00:	6f 93       	push	r22
    4d02:	7f 93       	push	r23
    4d04:	8f 93       	push	r24
    4d06:	9f 93       	push	r25
    4d08:	af 93       	push	r26
    4d0a:	bf 93       	push	r27
    4d0c:	ef 93       	push	r30
    4d0e:	ff 93       	push	r31
    4d10:	df 93       	push	r29
    4d12:	cf 93       	push	r28
    4d14:	cd b7       	in	r28, 0x3d	; 61
    4d16:	de b7       	in	r29, 0x3e	; 62
    if(TIMER0_CTC_CallBack!=NULL)
    4d18:	80 91 a7 00 	lds	r24, 0x00A7
    4d1c:	90 91 a8 00 	lds	r25, 0x00A8
    4d20:	00 97       	sbiw	r24, 0x00	; 0
    4d22:	29 f0       	breq	.+10     	; 0x4d2e <__vector_10+0x40>
    {
        TIMER0_CTC_CallBack();
    4d24:	e0 91 a7 00 	lds	r30, 0x00A7
    4d28:	f0 91 a8 00 	lds	r31, 0x00A8
    4d2c:	09 95       	icall
    }
}
    4d2e:	cf 91       	pop	r28
    4d30:	df 91       	pop	r29
    4d32:	ff 91       	pop	r31
    4d34:	ef 91       	pop	r30
    4d36:	bf 91       	pop	r27
    4d38:	af 91       	pop	r26
    4d3a:	9f 91       	pop	r25
    4d3c:	8f 91       	pop	r24
    4d3e:	7f 91       	pop	r23
    4d40:	6f 91       	pop	r22
    4d42:	5f 91       	pop	r21
    4d44:	4f 91       	pop	r20
    4d46:	3f 91       	pop	r19
    4d48:	2f 91       	pop	r18
    4d4a:	0f 90       	pop	r0
    4d4c:	0f be       	out	0x3f, r0	; 63
    4d4e:	0f 90       	pop	r0
    4d50:	1f 90       	pop	r1
    4d52:	18 95       	reti

00004d54 <main>:
void AppTask1(void*copy_VP);
void AppTask2(void*copy_VP);
void AppTask3(void*copy_VP);

void main(void)
{
    4d54:	af 92       	push	r10
    4d56:	bf 92       	push	r11
    4d58:	cf 92       	push	r12
    4d5a:	df 92       	push	r13
    4d5c:	ef 92       	push	r14
    4d5e:	ff 92       	push	r15
    4d60:	0f 93       	push	r16
    4d62:	df 93       	push	r29
    4d64:	cf 93       	push	r28
    4d66:	cd b7       	in	r28, 0x3d	; 61
    4d68:	de b7       	in	r29, 0x3e	; 62
    MDIO_voidInit();
    4d6a:	0e 94 24 08 	call	0x1048	; 0x1048 <MDIO_voidInit>
    MGI_voidEnable();
    4d6e:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <MGI_voidEnable>

	xTaskCreate(AppTask1,NULL,200,NULL,4,NULL);
    4d72:	8d ee       	ldi	r24, 0xED	; 237
    4d74:	96 e2       	ldi	r25, 0x26	; 38
    4d76:	60 e0       	ldi	r22, 0x00	; 0
    4d78:	70 e0       	ldi	r23, 0x00	; 0
    4d7a:	48 ec       	ldi	r20, 0xC8	; 200
    4d7c:	50 e0       	ldi	r21, 0x00	; 0
    4d7e:	20 e0       	ldi	r18, 0x00	; 0
    4d80:	30 e0       	ldi	r19, 0x00	; 0
    4d82:	04 e0       	ldi	r16, 0x04	; 4
    4d84:	ee 24       	eor	r14, r14
    4d86:	ff 24       	eor	r15, r15
    4d88:	cc 24       	eor	r12, r12
    4d8a:	dd 24       	eor	r13, r13
    4d8c:	aa 24       	eor	r10, r10
    4d8e:	bb 24       	eor	r11, r11
    4d90:	0e 94 2b 33 	call	0x6656	; 0x6656 <xTaskGenericCreate>
	xTaskCreate(AppTask2,NULL,200,NULL,3,NULL);
    4d94:	81 e1       	ldi	r24, 0x11	; 17
    4d96:	97 e2       	ldi	r25, 0x27	; 39
    4d98:	60 e0       	ldi	r22, 0x00	; 0
    4d9a:	70 e0       	ldi	r23, 0x00	; 0
    4d9c:	48 ec       	ldi	r20, 0xC8	; 200
    4d9e:	50 e0       	ldi	r21, 0x00	; 0
    4da0:	20 e0       	ldi	r18, 0x00	; 0
    4da2:	30 e0       	ldi	r19, 0x00	; 0
    4da4:	03 e0       	ldi	r16, 0x03	; 3
    4da6:	ee 24       	eor	r14, r14
    4da8:	ff 24       	eor	r15, r15
    4daa:	cc 24       	eor	r12, r12
    4dac:	dd 24       	eor	r13, r13
    4dae:	aa 24       	eor	r10, r10
    4db0:	bb 24       	eor	r11, r11
    4db2:	0e 94 2b 33 	call	0x6656	; 0x6656 <xTaskGenericCreate>
	xTaskCreate(AppTask3,NULL,200,NULL,2,NULL);
    4db6:	85 e3       	ldi	r24, 0x35	; 53
    4db8:	97 e2       	ldi	r25, 0x27	; 39
    4dba:	60 e0       	ldi	r22, 0x00	; 0
    4dbc:	70 e0       	ldi	r23, 0x00	; 0
    4dbe:	48 ec       	ldi	r20, 0xC8	; 200
    4dc0:	50 e0       	ldi	r21, 0x00	; 0
    4dc2:	20 e0       	ldi	r18, 0x00	; 0
    4dc4:	30 e0       	ldi	r19, 0x00	; 0
    4dc6:	02 e0       	ldi	r16, 0x02	; 2
    4dc8:	ee 24       	eor	r14, r14
    4dca:	ff 24       	eor	r15, r15
    4dcc:	cc 24       	eor	r12, r12
    4dce:	dd 24       	eor	r13, r13
    4dd0:	aa 24       	eor	r10, r10
    4dd2:	bb 24       	eor	r11, r11
    4dd4:	0e 94 2b 33 	call	0x6656	; 0x6656 <xTaskGenericCreate>
    4dd8:	ff cf       	rjmp	.-2      	; 0x4dd8 <main+0x84>

00004dda <AppTask1>:
// 		MDIO_voidSetPinValue(PORTA,PIN2,PIN_LOW);
// 	}
// }

void AppTask1(void*copy_VP)
{
    4dda:	df 93       	push	r29
    4ddc:	cf 93       	push	r28
    4dde:	00 d0       	rcall	.+0      	; 0x4de0 <AppTask1+0x6>
    4de0:	cd b7       	in	r28, 0x3d	; 61
    4de2:	de b7       	in	r29, 0x3e	; 62
    4de4:	9a 83       	std	Y+2, r25	; 0x02
    4de6:	89 83       	std	Y+1, r24	; 0x01
	static u8 flag=0;
	while(1)
	{
		if(!flag)
    4de8:	80 91 a9 00 	lds	r24, 0x00A9
    4dec:	88 23       	and	r24, r24
    4dee:	59 f4       	brne	.+22     	; 0x4e06 <AppTask1+0x2c>
		{
			MDIO_voidSetPinValue(PORTA,PIN0,PIN_HIGH);
    4df0:	eb e3       	ldi	r30, 0x3B	; 59
    4df2:	f0 e0       	ldi	r31, 0x00	; 0
    4df4:	80 81       	ld	r24, Z
    4df6:	60 e0       	ldi	r22, 0x00	; 0
    4df8:	41 e0       	ldi	r20, 0x01	; 1
    4dfa:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
			flag=1;
    4dfe:	81 e0       	ldi	r24, 0x01	; 1
    4e00:	80 93 a9 00 	sts	0x00A9, r24
    4e04:	09 c0       	rjmp	.+18     	; 0x4e18 <AppTask1+0x3e>
		}
		else
		{
			MDIO_voidSetPinValue(PORTA,PIN0,PIN_LOW);
    4e06:	eb e3       	ldi	r30, 0x3B	; 59
    4e08:	f0 e0       	ldi	r31, 0x00	; 0
    4e0a:	80 81       	ld	r24, Z
    4e0c:	60 e0       	ldi	r22, 0x00	; 0
    4e0e:	40 e0       	ldi	r20, 0x00	; 0
    4e10:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
			flag=0;
    4e14:	10 92 a9 00 	sts	0x00A9, r1
		}
		vTaskDelay(1000);
    4e18:	88 ee       	ldi	r24, 0xE8	; 232
    4e1a:	93 e0       	ldi	r25, 0x03	; 3
    4e1c:	0e 94 ef 34 	call	0x69de	; 0x69de <vTaskDelay>
    4e20:	e3 cf       	rjmp	.-58     	; 0x4de8 <AppTask1+0xe>

00004e22 <AppTask2>:
	}
}
void AppTask2(void*copy_VP)
{
    4e22:	df 93       	push	r29
    4e24:	cf 93       	push	r28
    4e26:	00 d0       	rcall	.+0      	; 0x4e28 <AppTask2+0x6>
    4e28:	cd b7       	in	r28, 0x3d	; 61
    4e2a:	de b7       	in	r29, 0x3e	; 62
    4e2c:	9a 83       	std	Y+2, r25	; 0x02
    4e2e:	89 83       	std	Y+1, r24	; 0x01
	static u8 flag=0;
	while(1)
	{
		if(!flag)
    4e30:	80 91 aa 00 	lds	r24, 0x00AA
    4e34:	88 23       	and	r24, r24
    4e36:	59 f4       	brne	.+22     	; 0x4e4e <AppTask2+0x2c>
		{
			MDIO_voidSetPinValue(PORTA,PIN1,PIN_HIGH);
    4e38:	eb e3       	ldi	r30, 0x3B	; 59
    4e3a:	f0 e0       	ldi	r31, 0x00	; 0
    4e3c:	80 81       	ld	r24, Z
    4e3e:	61 e0       	ldi	r22, 0x01	; 1
    4e40:	41 e0       	ldi	r20, 0x01	; 1
    4e42:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
			flag=1;
    4e46:	81 e0       	ldi	r24, 0x01	; 1
    4e48:	80 93 aa 00 	sts	0x00AA, r24
    4e4c:	09 c0       	rjmp	.+18     	; 0x4e60 <AppTask2+0x3e>
		}
		else
		{
			MDIO_voidSetPinValue(PORTA,PIN1,PIN_LOW);
    4e4e:	eb e3       	ldi	r30, 0x3B	; 59
    4e50:	f0 e0       	ldi	r31, 0x00	; 0
    4e52:	80 81       	ld	r24, Z
    4e54:	61 e0       	ldi	r22, 0x01	; 1
    4e56:	40 e0       	ldi	r20, 0x00	; 0
    4e58:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
			flag=0;
    4e5c:	10 92 aa 00 	sts	0x00AA, r1
		}
		vTaskDelay(1000);
    4e60:	88 ee       	ldi	r24, 0xE8	; 232
    4e62:	93 e0       	ldi	r25, 0x03	; 3
    4e64:	0e 94 ef 34 	call	0x69de	; 0x69de <vTaskDelay>
    4e68:	e3 cf       	rjmp	.-58     	; 0x4e30 <AppTask2+0xe>

00004e6a <AppTask3>:
	}
}
void AppTask3(void*copy_VP)
{
    4e6a:	df 93       	push	r29
    4e6c:	cf 93       	push	r28
    4e6e:	00 d0       	rcall	.+0      	; 0x4e70 <AppTask3+0x6>
    4e70:	cd b7       	in	r28, 0x3d	; 61
    4e72:	de b7       	in	r29, 0x3e	; 62
    4e74:	9a 83       	std	Y+2, r25	; 0x02
    4e76:	89 83       	std	Y+1, r24	; 0x01
	static u8 flag=0;
	while(1)
	{
		if(!flag)
    4e78:	80 91 ab 00 	lds	r24, 0x00AB
    4e7c:	88 23       	and	r24, r24
    4e7e:	59 f4       	brne	.+22     	; 0x4e96 <AppTask3+0x2c>
		{
			MDIO_voidSetPinValue(PORTA,PIN2,PIN_HIGH);
    4e80:	eb e3       	ldi	r30, 0x3B	; 59
    4e82:	f0 e0       	ldi	r31, 0x00	; 0
    4e84:	80 81       	ld	r24, Z
    4e86:	62 e0       	ldi	r22, 0x02	; 2
    4e88:	41 e0       	ldi	r20, 0x01	; 1
    4e8a:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
			flag=1;
    4e8e:	81 e0       	ldi	r24, 0x01	; 1
    4e90:	80 93 ab 00 	sts	0x00AB, r24
    4e94:	09 c0       	rjmp	.+18     	; 0x4ea8 <AppTask3+0x3e>
		}
		else
		{
			MDIO_voidSetPinValue(PORTA,PIN2,PIN_LOW);
    4e96:	eb e3       	ldi	r30, 0x3B	; 59
    4e98:	f0 e0       	ldi	r31, 0x00	; 0
    4e9a:	80 81       	ld	r24, Z
    4e9c:	62 e0       	ldi	r22, 0x02	; 2
    4e9e:	40 e0       	ldi	r20, 0x00	; 0
    4ea0:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <MDIO_voidSetPinValue>
			flag=0;
    4ea4:	10 92 ab 00 	sts	0x00AB, r1
		}
		vTaskDelay(1000);
    4ea8:	88 ee       	ldi	r24, 0xE8	; 232
    4eaa:	93 e0       	ldi	r25, 0x03	; 3
    4eac:	0e 94 ef 34 	call	0x69de	; 0x69de <vTaskDelay>
    4eb0:	e3 cf       	rjmp	.-58     	; 0x4e78 <AppTask3+0xe>

00004eb2 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    4eb2:	df 93       	push	r29
    4eb4:	cf 93       	push	r28
    4eb6:	cd b7       	in	r28, 0x3d	; 61
    4eb8:	de b7       	in	r29, 0x3e	; 62
    4eba:	27 97       	sbiw	r28, 0x07	; 7
    4ebc:	0f b6       	in	r0, 0x3f	; 63
    4ebe:	f8 94       	cli
    4ec0:	de bf       	out	0x3e, r29	; 62
    4ec2:	0f be       	out	0x3f, r0	; 63
    4ec4:	cd bf       	out	0x3d, r28	; 61
    4ec6:	9d 83       	std	Y+5, r25	; 0x05
    4ec8:	8c 83       	std	Y+4, r24	; 0x04
    4eca:	6e 83       	std	Y+6, r22	; 0x06
    4ecc:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    4ece:	8a e1       	ldi	r24, 0x1A	; 26
    4ed0:	90 e0       	ldi	r25, 0x00	; 0
    4ed2:	0e 94 31 2a 	call	0x5462	; 0x5462 <pvPortMalloc>
    4ed6:	9a 83       	std	Y+2, r25	; 0x02
    4ed8:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    4eda:	89 81       	ldd	r24, Y+1	; 0x01
    4edc:	9a 81       	ldd	r25, Y+2	; 0x02
    4ede:	00 97       	sbiw	r24, 0x00	; 0
    4ee0:	09 f4       	brne	.+2      	; 0x4ee4 <xCoRoutineCreate+0x32>
    4ee2:	6f c0       	rjmp	.+222    	; 0x4fc2 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    4ee4:	80 91 ac 00 	lds	r24, 0x00AC
    4ee8:	90 91 ad 00 	lds	r25, 0x00AD
    4eec:	00 97       	sbiw	r24, 0x00	; 0
    4eee:	41 f4       	brne	.+16     	; 0x4f00 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    4ef0:	89 81       	ldd	r24, Y+1	; 0x01
    4ef2:	9a 81       	ldd	r25, Y+2	; 0x02
    4ef4:	90 93 ad 00 	sts	0x00AD, r25
    4ef8:	80 93 ac 00 	sts	0x00AC, r24
			prvInitialiseCoRoutineLists();
    4efc:	0e 94 c0 29 	call	0x5380	; 0x5380 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    4f00:	8e 81       	ldd	r24, Y+6	; 0x06
    4f02:	82 30       	cpi	r24, 0x02	; 2
    4f04:	10 f0       	brcs	.+4      	; 0x4f0a <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    4f06:	81 e0       	ldi	r24, 0x01	; 1
    4f08:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    4f0a:	e9 81       	ldd	r30, Y+1	; 0x01
    4f0c:	fa 81       	ldd	r31, Y+2	; 0x02
    4f0e:	11 8e       	std	Z+25, r1	; 0x19
    4f10:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    4f12:	e9 81       	ldd	r30, Y+1	; 0x01
    4f14:	fa 81       	ldd	r31, Y+2	; 0x02
    4f16:	8e 81       	ldd	r24, Y+6	; 0x06
    4f18:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    4f1a:	e9 81       	ldd	r30, Y+1	; 0x01
    4f1c:	fa 81       	ldd	r31, Y+2	; 0x02
    4f1e:	8f 81       	ldd	r24, Y+7	; 0x07
    4f20:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    4f22:	e9 81       	ldd	r30, Y+1	; 0x01
    4f24:	fa 81       	ldd	r31, Y+2	; 0x02
    4f26:	8c 81       	ldd	r24, Y+4	; 0x04
    4f28:	9d 81       	ldd	r25, Y+5	; 0x05
    4f2a:	91 83       	std	Z+1, r25	; 0x01
    4f2c:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    4f2e:	89 81       	ldd	r24, Y+1	; 0x01
    4f30:	9a 81       	ldd	r25, Y+2	; 0x02
    4f32:	02 96       	adiw	r24, 0x02	; 2
    4f34:	0e 94 c7 2a 	call	0x558e	; 0x558e <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    4f38:	89 81       	ldd	r24, Y+1	; 0x01
    4f3a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f3c:	0c 96       	adiw	r24, 0x0c	; 12
    4f3e:	0e 94 c7 2a 	call	0x558e	; 0x558e <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    4f42:	e9 81       	ldd	r30, Y+1	; 0x01
    4f44:	fa 81       	ldd	r31, Y+2	; 0x02
    4f46:	89 81       	ldd	r24, Y+1	; 0x01
    4f48:	9a 81       	ldd	r25, Y+2	; 0x02
    4f4a:	91 87       	std	Z+9, r25	; 0x09
    4f4c:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    4f4e:	e9 81       	ldd	r30, Y+1	; 0x01
    4f50:	fa 81       	ldd	r31, Y+2	; 0x02
    4f52:	89 81       	ldd	r24, Y+1	; 0x01
    4f54:	9a 81       	ldd	r25, Y+2	; 0x02
    4f56:	93 8b       	std	Z+19, r25	; 0x13
    4f58:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    4f5a:	8e 81       	ldd	r24, Y+6	; 0x06
    4f5c:	28 2f       	mov	r18, r24
    4f5e:	30 e0       	ldi	r19, 0x00	; 0
    4f60:	85 e0       	ldi	r24, 0x05	; 5
    4f62:	90 e0       	ldi	r25, 0x00	; 0
    4f64:	82 1b       	sub	r24, r18
    4f66:	93 0b       	sbc	r25, r19
    4f68:	e9 81       	ldd	r30, Y+1	; 0x01
    4f6a:	fa 81       	ldd	r31, Y+2	; 0x02
    4f6c:	95 87       	std	Z+13, r25	; 0x0d
    4f6e:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    4f70:	e9 81       	ldd	r30, Y+1	; 0x01
    4f72:	fa 81       	ldd	r31, Y+2	; 0x02
    4f74:	96 89       	ldd	r25, Z+22	; 0x16
    4f76:	80 91 ae 00 	lds	r24, 0x00AE
    4f7a:	89 17       	cp	r24, r25
    4f7c:	28 f4       	brcc	.+10     	; 0x4f88 <xCoRoutineCreate+0xd6>
    4f7e:	e9 81       	ldd	r30, Y+1	; 0x01
    4f80:	fa 81       	ldd	r31, Y+2	; 0x02
    4f82:	86 89       	ldd	r24, Z+22	; 0x16
    4f84:	80 93 ae 00 	sts	0x00AE, r24
    4f88:	e9 81       	ldd	r30, Y+1	; 0x01
    4f8a:	fa 81       	ldd	r31, Y+2	; 0x02
    4f8c:	86 89       	ldd	r24, Z+22	; 0x16
    4f8e:	28 2f       	mov	r18, r24
    4f90:	30 e0       	ldi	r19, 0x00	; 0
    4f92:	c9 01       	movw	r24, r18
    4f94:	88 0f       	add	r24, r24
    4f96:	99 1f       	adc	r25, r25
    4f98:	88 0f       	add	r24, r24
    4f9a:	99 1f       	adc	r25, r25
    4f9c:	88 0f       	add	r24, r24
    4f9e:	99 1f       	adc	r25, r25
    4fa0:	82 0f       	add	r24, r18
    4fa2:	93 1f       	adc	r25, r19
    4fa4:	ac 01       	movw	r20, r24
    4fa6:	4b 54       	subi	r20, 0x4B	; 75
    4fa8:	5f 4f       	sbci	r21, 0xFF	; 255
    4faa:	89 81       	ldd	r24, Y+1	; 0x01
    4fac:	9a 81       	ldd	r25, Y+2	; 0x02
    4fae:	9c 01       	movw	r18, r24
    4fb0:	2e 5f       	subi	r18, 0xFE	; 254
    4fb2:	3f 4f       	sbci	r19, 0xFF	; 255
    4fb4:	ca 01       	movw	r24, r20
    4fb6:	b9 01       	movw	r22, r18
    4fb8:	0e 94 d7 2a 	call	0x55ae	; 0x55ae <vListInsertEnd>

		xReturn = pdPASS;
    4fbc:	81 e0       	ldi	r24, 0x01	; 1
    4fbe:	8b 83       	std	Y+3, r24	; 0x03
    4fc0:	02 c0       	rjmp	.+4      	; 0x4fc6 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4fc2:	8f ef       	ldi	r24, 0xFF	; 255
    4fc4:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    4fc6:	8b 81       	ldd	r24, Y+3	; 0x03
}
    4fc8:	27 96       	adiw	r28, 0x07	; 7
    4fca:	0f b6       	in	r0, 0x3f	; 63
    4fcc:	f8 94       	cli
    4fce:	de bf       	out	0x3e, r29	; 62
    4fd0:	0f be       	out	0x3f, r0	; 63
    4fd2:	cd bf       	out	0x3d, r28	; 61
    4fd4:	cf 91       	pop	r28
    4fd6:	df 91       	pop	r29
    4fd8:	08 95       	ret

00004fda <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    4fda:	df 93       	push	r29
    4fdc:	cf 93       	push	r28
    4fde:	00 d0       	rcall	.+0      	; 0x4fe0 <vCoRoutineAddToDelayedList+0x6>
    4fe0:	00 d0       	rcall	.+0      	; 0x4fe2 <vCoRoutineAddToDelayedList+0x8>
    4fe2:	00 d0       	rcall	.+0      	; 0x4fe4 <vCoRoutineAddToDelayedList+0xa>
    4fe4:	cd b7       	in	r28, 0x3d	; 61
    4fe6:	de b7       	in	r29, 0x3e	; 62
    4fe8:	9c 83       	std	Y+4, r25	; 0x04
    4fea:	8b 83       	std	Y+3, r24	; 0x03
    4fec:	7e 83       	std	Y+6, r23	; 0x06
    4fee:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    4ff0:	20 91 af 00 	lds	r18, 0x00AF
    4ff4:	30 91 b0 00 	lds	r19, 0x00B0
    4ff8:	8b 81       	ldd	r24, Y+3	; 0x03
    4ffa:	9c 81       	ldd	r25, Y+4	; 0x04
    4ffc:	82 0f       	add	r24, r18
    4ffe:	93 1f       	adc	r25, r19
    5000:	9a 83       	std	Y+2, r25	; 0x02
    5002:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    5004:	80 91 ac 00 	lds	r24, 0x00AC
    5008:	90 91 ad 00 	lds	r25, 0x00AD
    500c:	02 96       	adiw	r24, 0x02	; 2
    500e:	0e 94 8f 2b 	call	0x571e	; 0x571e <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    5012:	e0 91 ac 00 	lds	r30, 0x00AC
    5016:	f0 91 ad 00 	lds	r31, 0x00AD
    501a:	89 81       	ldd	r24, Y+1	; 0x01
    501c:	9a 81       	ldd	r25, Y+2	; 0x02
    501e:	93 83       	std	Z+3, r25	; 0x03
    5020:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    5022:	20 91 af 00 	lds	r18, 0x00AF
    5026:	30 91 b0 00 	lds	r19, 0x00B0
    502a:	89 81       	ldd	r24, Y+1	; 0x01
    502c:	9a 81       	ldd	r25, Y+2	; 0x02
    502e:	82 17       	cp	r24, r18
    5030:	93 07       	cpc	r25, r19
    5032:	70 f4       	brcc	.+28     	; 0x5050 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    5034:	80 91 db 00 	lds	r24, 0x00DB
    5038:	90 91 dc 00 	lds	r25, 0x00DC
    503c:	20 91 ac 00 	lds	r18, 0x00AC
    5040:	30 91 ad 00 	lds	r19, 0x00AD
    5044:	2e 5f       	subi	r18, 0xFE	; 254
    5046:	3f 4f       	sbci	r19, 0xFF	; 255
    5048:	b9 01       	movw	r22, r18
    504a:	0e 94 23 2b 	call	0x5646	; 0x5646 <vListInsert>
    504e:	0d c0       	rjmp	.+26     	; 0x506a <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    5050:	80 91 d9 00 	lds	r24, 0x00D9
    5054:	90 91 da 00 	lds	r25, 0x00DA
    5058:	20 91 ac 00 	lds	r18, 0x00AC
    505c:	30 91 ad 00 	lds	r19, 0x00AD
    5060:	2e 5f       	subi	r18, 0xFE	; 254
    5062:	3f 4f       	sbci	r19, 0xFF	; 255
    5064:	b9 01       	movw	r22, r18
    5066:	0e 94 23 2b 	call	0x5646	; 0x5646 <vListInsert>
	}

	if( pxEventList )
    506a:	8d 81       	ldd	r24, Y+5	; 0x05
    506c:	9e 81       	ldd	r25, Y+6	; 0x06
    506e:	00 97       	sbiw	r24, 0x00	; 0
    5070:	61 f0       	breq	.+24     	; 0x508a <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    5072:	80 91 ac 00 	lds	r24, 0x00AC
    5076:	90 91 ad 00 	lds	r25, 0x00AD
    507a:	9c 01       	movw	r18, r24
    507c:	24 5f       	subi	r18, 0xF4	; 244
    507e:	3f 4f       	sbci	r19, 0xFF	; 255
    5080:	8d 81       	ldd	r24, Y+5	; 0x05
    5082:	9e 81       	ldd	r25, Y+6	; 0x06
    5084:	b9 01       	movw	r22, r18
    5086:	0e 94 23 2b 	call	0x5646	; 0x5646 <vListInsert>
	}
}
    508a:	26 96       	adiw	r28, 0x06	; 6
    508c:	0f b6       	in	r0, 0x3f	; 63
    508e:	f8 94       	cli
    5090:	de bf       	out	0x3e, r29	; 62
    5092:	0f be       	out	0x3f, r0	; 63
    5094:	cd bf       	out	0x3d, r28	; 61
    5096:	cf 91       	pop	r28
    5098:	df 91       	pop	r29
    509a:	08 95       	ret

0000509c <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    509c:	df 93       	push	r29
    509e:	cf 93       	push	r28
    50a0:	00 d0       	rcall	.+0      	; 0x50a2 <prvCheckPendingReadyList+0x6>
    50a2:	cd b7       	in	r28, 0x3d	; 61
    50a4:	de b7       	in	r29, 0x3e	; 62
    50a6:	3a c0       	rjmp	.+116    	; 0x511c <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    50a8:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    50aa:	e0 91 e2 00 	lds	r30, 0x00E2
    50ae:	f0 91 e3 00 	lds	r31, 0x00E3
    50b2:	86 81       	ldd	r24, Z+6	; 0x06
    50b4:	97 81       	ldd	r25, Z+7	; 0x07
    50b6:	9a 83       	std	Y+2, r25	; 0x02
    50b8:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    50ba:	89 81       	ldd	r24, Y+1	; 0x01
    50bc:	9a 81       	ldd	r25, Y+2	; 0x02
    50be:	0c 96       	adiw	r24, 0x0c	; 12
    50c0:	0e 94 8f 2b 	call	0x571e	; 0x571e <vListRemove>
		}
		portENABLE_INTERRUPTS();
    50c4:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    50c6:	89 81       	ldd	r24, Y+1	; 0x01
    50c8:	9a 81       	ldd	r25, Y+2	; 0x02
    50ca:	02 96       	adiw	r24, 0x02	; 2
    50cc:	0e 94 8f 2b 	call	0x571e	; 0x571e <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    50d0:	e9 81       	ldd	r30, Y+1	; 0x01
    50d2:	fa 81       	ldd	r31, Y+2	; 0x02
    50d4:	96 89       	ldd	r25, Z+22	; 0x16
    50d6:	80 91 ae 00 	lds	r24, 0x00AE
    50da:	89 17       	cp	r24, r25
    50dc:	28 f4       	brcc	.+10     	; 0x50e8 <prvCheckPendingReadyList+0x4c>
    50de:	e9 81       	ldd	r30, Y+1	; 0x01
    50e0:	fa 81       	ldd	r31, Y+2	; 0x02
    50e2:	86 89       	ldd	r24, Z+22	; 0x16
    50e4:	80 93 ae 00 	sts	0x00AE, r24
    50e8:	e9 81       	ldd	r30, Y+1	; 0x01
    50ea:	fa 81       	ldd	r31, Y+2	; 0x02
    50ec:	86 89       	ldd	r24, Z+22	; 0x16
    50ee:	28 2f       	mov	r18, r24
    50f0:	30 e0       	ldi	r19, 0x00	; 0
    50f2:	c9 01       	movw	r24, r18
    50f4:	88 0f       	add	r24, r24
    50f6:	99 1f       	adc	r25, r25
    50f8:	88 0f       	add	r24, r24
    50fa:	99 1f       	adc	r25, r25
    50fc:	88 0f       	add	r24, r24
    50fe:	99 1f       	adc	r25, r25
    5100:	82 0f       	add	r24, r18
    5102:	93 1f       	adc	r25, r19
    5104:	ac 01       	movw	r20, r24
    5106:	4b 54       	subi	r20, 0x4B	; 75
    5108:	5f 4f       	sbci	r21, 0xFF	; 255
    510a:	89 81       	ldd	r24, Y+1	; 0x01
    510c:	9a 81       	ldd	r25, Y+2	; 0x02
    510e:	9c 01       	movw	r18, r24
    5110:	2e 5f       	subi	r18, 0xFE	; 254
    5112:	3f 4f       	sbci	r19, 0xFF	; 255
    5114:	ca 01       	movw	r24, r20
    5116:	b9 01       	movw	r22, r18
    5118:	0e 94 d7 2a 	call	0x55ae	; 0x55ae <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    511c:	80 91 dd 00 	lds	r24, 0x00DD
    5120:	88 23       	and	r24, r24
    5122:	09 f0       	breq	.+2      	; 0x5126 <prvCheckPendingReadyList+0x8a>
    5124:	c1 cf       	rjmp	.-126    	; 0x50a8 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    5126:	0f 90       	pop	r0
    5128:	0f 90       	pop	r0
    512a:	cf 91       	pop	r28
    512c:	df 91       	pop	r29
    512e:	08 95       	ret

00005130 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    5130:	df 93       	push	r29
    5132:	cf 93       	push	r28
    5134:	00 d0       	rcall	.+0      	; 0x5136 <prvCheckDelayedList+0x6>
    5136:	00 d0       	rcall	.+0      	; 0x5138 <prvCheckDelayedList+0x8>
    5138:	cd b7       	in	r28, 0x3d	; 61
    513a:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    513c:	0e 94 fd 35 	call	0x6bfa	; 0x6bfa <xTaskGetTickCount>
    5140:	20 91 b1 00 	lds	r18, 0x00B1
    5144:	30 91 b2 00 	lds	r19, 0x00B2
    5148:	82 1b       	sub	r24, r18
    514a:	93 0b       	sbc	r25, r19
    514c:	90 93 b4 00 	sts	0x00B4, r25
    5150:	80 93 b3 00 	sts	0x00B3, r24
    5154:	85 c0       	rjmp	.+266    	; 0x5260 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    5156:	80 91 af 00 	lds	r24, 0x00AF
    515a:	90 91 b0 00 	lds	r25, 0x00B0
    515e:	01 96       	adiw	r24, 0x01	; 1
    5160:	90 93 b0 00 	sts	0x00B0, r25
    5164:	80 93 af 00 	sts	0x00AF, r24
		xPassedTicks--;
    5168:	80 91 b3 00 	lds	r24, 0x00B3
    516c:	90 91 b4 00 	lds	r25, 0x00B4
    5170:	01 97       	sbiw	r24, 0x01	; 1
    5172:	90 93 b4 00 	sts	0x00B4, r25
    5176:	80 93 b3 00 	sts	0x00B3, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    517a:	80 91 af 00 	lds	r24, 0x00AF
    517e:	90 91 b0 00 	lds	r25, 0x00B0
    5182:	00 97       	sbiw	r24, 0x00	; 0
    5184:	09 f0       	breq	.+2      	; 0x5188 <prvCheckDelayedList+0x58>
    5186:	64 c0       	rjmp	.+200    	; 0x5250 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    5188:	80 91 d9 00 	lds	r24, 0x00D9
    518c:	90 91 da 00 	lds	r25, 0x00DA
    5190:	9a 83       	std	Y+2, r25	; 0x02
    5192:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    5194:	80 91 db 00 	lds	r24, 0x00DB
    5198:	90 91 dc 00 	lds	r25, 0x00DC
    519c:	90 93 da 00 	sts	0x00DA, r25
    51a0:	80 93 d9 00 	sts	0x00D9, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    51a4:	89 81       	ldd	r24, Y+1	; 0x01
    51a6:	9a 81       	ldd	r25, Y+2	; 0x02
    51a8:	90 93 dc 00 	sts	0x00DC, r25
    51ac:	80 93 db 00 	sts	0x00DB, r24
    51b0:	4f c0       	rjmp	.+158    	; 0x5250 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    51b2:	e0 91 d9 00 	lds	r30, 0x00D9
    51b6:	f0 91 da 00 	lds	r31, 0x00DA
    51ba:	05 80       	ldd	r0, Z+5	; 0x05
    51bc:	f6 81       	ldd	r31, Z+6	; 0x06
    51be:	e0 2d       	mov	r30, r0
    51c0:	86 81       	ldd	r24, Z+6	; 0x06
    51c2:	97 81       	ldd	r25, Z+7	; 0x07
    51c4:	9c 83       	std	Y+4, r25	; 0x04
    51c6:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    51c8:	eb 81       	ldd	r30, Y+3	; 0x03
    51ca:	fc 81       	ldd	r31, Y+4	; 0x04
    51cc:	22 81       	ldd	r18, Z+2	; 0x02
    51ce:	33 81       	ldd	r19, Z+3	; 0x03
    51d0:	80 91 af 00 	lds	r24, 0x00AF
    51d4:	90 91 b0 00 	lds	r25, 0x00B0
    51d8:	82 17       	cp	r24, r18
    51da:	93 07       	cpc	r25, r19
    51dc:	08 f4       	brcc	.+2      	; 0x51e0 <prvCheckDelayedList+0xb0>
    51de:	40 c0       	rjmp	.+128    	; 0x5260 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    51e0:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    51e2:	8b 81       	ldd	r24, Y+3	; 0x03
    51e4:	9c 81       	ldd	r25, Y+4	; 0x04
    51e6:	02 96       	adiw	r24, 0x02	; 2
    51e8:	0e 94 8f 2b 	call	0x571e	; 0x571e <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    51ec:	eb 81       	ldd	r30, Y+3	; 0x03
    51ee:	fc 81       	ldd	r31, Y+4	; 0x04
    51f0:	84 89       	ldd	r24, Z+20	; 0x14
    51f2:	95 89       	ldd	r25, Z+21	; 0x15
    51f4:	00 97       	sbiw	r24, 0x00	; 0
    51f6:	29 f0       	breq	.+10     	; 0x5202 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    51f8:	8b 81       	ldd	r24, Y+3	; 0x03
    51fa:	9c 81       	ldd	r25, Y+4	; 0x04
    51fc:	0c 96       	adiw	r24, 0x0c	; 12
    51fe:	0e 94 8f 2b 	call	0x571e	; 0x571e <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    5202:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    5204:	eb 81       	ldd	r30, Y+3	; 0x03
    5206:	fc 81       	ldd	r31, Y+4	; 0x04
    5208:	96 89       	ldd	r25, Z+22	; 0x16
    520a:	80 91 ae 00 	lds	r24, 0x00AE
    520e:	89 17       	cp	r24, r25
    5210:	28 f4       	brcc	.+10     	; 0x521c <prvCheckDelayedList+0xec>
    5212:	eb 81       	ldd	r30, Y+3	; 0x03
    5214:	fc 81       	ldd	r31, Y+4	; 0x04
    5216:	86 89       	ldd	r24, Z+22	; 0x16
    5218:	80 93 ae 00 	sts	0x00AE, r24
    521c:	eb 81       	ldd	r30, Y+3	; 0x03
    521e:	fc 81       	ldd	r31, Y+4	; 0x04
    5220:	86 89       	ldd	r24, Z+22	; 0x16
    5222:	28 2f       	mov	r18, r24
    5224:	30 e0       	ldi	r19, 0x00	; 0
    5226:	c9 01       	movw	r24, r18
    5228:	88 0f       	add	r24, r24
    522a:	99 1f       	adc	r25, r25
    522c:	88 0f       	add	r24, r24
    522e:	99 1f       	adc	r25, r25
    5230:	88 0f       	add	r24, r24
    5232:	99 1f       	adc	r25, r25
    5234:	82 0f       	add	r24, r18
    5236:	93 1f       	adc	r25, r19
    5238:	ac 01       	movw	r20, r24
    523a:	4b 54       	subi	r20, 0x4B	; 75
    523c:	5f 4f       	sbci	r21, 0xFF	; 255
    523e:	8b 81       	ldd	r24, Y+3	; 0x03
    5240:	9c 81       	ldd	r25, Y+4	; 0x04
    5242:	9c 01       	movw	r18, r24
    5244:	2e 5f       	subi	r18, 0xFE	; 254
    5246:	3f 4f       	sbci	r19, 0xFF	; 255
    5248:	ca 01       	movw	r24, r20
    524a:	b9 01       	movw	r22, r18
    524c:	0e 94 d7 2a 	call	0x55ae	; 0x55ae <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    5250:	e0 91 d9 00 	lds	r30, 0x00D9
    5254:	f0 91 da 00 	lds	r31, 0x00DA
    5258:	80 81       	ld	r24, Z
    525a:	88 23       	and	r24, r24
    525c:	09 f0       	breq	.+2      	; 0x5260 <prvCheckDelayedList+0x130>
    525e:	a9 cf       	rjmp	.-174    	; 0x51b2 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    5260:	80 91 b3 00 	lds	r24, 0x00B3
    5264:	90 91 b4 00 	lds	r25, 0x00B4
    5268:	00 97       	sbiw	r24, 0x00	; 0
    526a:	09 f0       	breq	.+2      	; 0x526e <prvCheckDelayedList+0x13e>
    526c:	74 cf       	rjmp	.-280    	; 0x5156 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    526e:	80 91 af 00 	lds	r24, 0x00AF
    5272:	90 91 b0 00 	lds	r25, 0x00B0
    5276:	90 93 b2 00 	sts	0x00B2, r25
    527a:	80 93 b1 00 	sts	0x00B1, r24
}
    527e:	0f 90       	pop	r0
    5280:	0f 90       	pop	r0
    5282:	0f 90       	pop	r0
    5284:	0f 90       	pop	r0
    5286:	cf 91       	pop	r28
    5288:	df 91       	pop	r29
    528a:	08 95       	ret

0000528c <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    528c:	df 93       	push	r29
    528e:	cf 93       	push	r28
    5290:	00 d0       	rcall	.+0      	; 0x5292 <vCoRoutineSchedule+0x6>
    5292:	cd b7       	in	r28, 0x3d	; 61
    5294:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    5296:	0e 94 4e 28 	call	0x509c	; 0x509c <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    529a:	0e 94 98 28 	call	0x5130	; 0x5130 <prvCheckDelayedList>
    529e:	0a c0       	rjmp	.+20     	; 0x52b4 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    52a0:	80 91 ae 00 	lds	r24, 0x00AE
    52a4:	88 23       	and	r24, r24
    52a6:	09 f4       	brne	.+2      	; 0x52aa <vCoRoutineSchedule+0x1e>
    52a8:	66 c0       	rjmp	.+204    	; 0x5376 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    52aa:	80 91 ae 00 	lds	r24, 0x00AE
    52ae:	81 50       	subi	r24, 0x01	; 1
    52b0:	80 93 ae 00 	sts	0x00AE, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    52b4:	80 91 ae 00 	lds	r24, 0x00AE
    52b8:	28 2f       	mov	r18, r24
    52ba:	30 e0       	ldi	r19, 0x00	; 0
    52bc:	c9 01       	movw	r24, r18
    52be:	88 0f       	add	r24, r24
    52c0:	99 1f       	adc	r25, r25
    52c2:	88 0f       	add	r24, r24
    52c4:	99 1f       	adc	r25, r25
    52c6:	88 0f       	add	r24, r24
    52c8:	99 1f       	adc	r25, r25
    52ca:	82 0f       	add	r24, r18
    52cc:	93 1f       	adc	r25, r19
    52ce:	fc 01       	movw	r30, r24
    52d0:	eb 54       	subi	r30, 0x4B	; 75
    52d2:	ff 4f       	sbci	r31, 0xFF	; 255
    52d4:	80 81       	ld	r24, Z
    52d6:	88 23       	and	r24, r24
    52d8:	19 f3       	breq	.-58     	; 0x52a0 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    52da:	80 91 ae 00 	lds	r24, 0x00AE
    52de:	28 2f       	mov	r18, r24
    52e0:	30 e0       	ldi	r19, 0x00	; 0
    52e2:	c9 01       	movw	r24, r18
    52e4:	88 0f       	add	r24, r24
    52e6:	99 1f       	adc	r25, r25
    52e8:	88 0f       	add	r24, r24
    52ea:	99 1f       	adc	r25, r25
    52ec:	88 0f       	add	r24, r24
    52ee:	99 1f       	adc	r25, r25
    52f0:	82 0f       	add	r24, r18
    52f2:	93 1f       	adc	r25, r19
    52f4:	8b 54       	subi	r24, 0x4B	; 75
    52f6:	9f 4f       	sbci	r25, 0xFF	; 255
    52f8:	9a 83       	std	Y+2, r25	; 0x02
    52fa:	89 83       	std	Y+1, r24	; 0x01
    52fc:	e9 81       	ldd	r30, Y+1	; 0x01
    52fe:	fa 81       	ldd	r31, Y+2	; 0x02
    5300:	01 80       	ldd	r0, Z+1	; 0x01
    5302:	f2 81       	ldd	r31, Z+2	; 0x02
    5304:	e0 2d       	mov	r30, r0
    5306:	82 81       	ldd	r24, Z+2	; 0x02
    5308:	93 81       	ldd	r25, Z+3	; 0x03
    530a:	e9 81       	ldd	r30, Y+1	; 0x01
    530c:	fa 81       	ldd	r31, Y+2	; 0x02
    530e:	92 83       	std	Z+2, r25	; 0x02
    5310:	81 83       	std	Z+1, r24	; 0x01
    5312:	e9 81       	ldd	r30, Y+1	; 0x01
    5314:	fa 81       	ldd	r31, Y+2	; 0x02
    5316:	21 81       	ldd	r18, Z+1	; 0x01
    5318:	32 81       	ldd	r19, Z+2	; 0x02
    531a:	89 81       	ldd	r24, Y+1	; 0x01
    531c:	9a 81       	ldd	r25, Y+2	; 0x02
    531e:	03 96       	adiw	r24, 0x03	; 3
    5320:	28 17       	cp	r18, r24
    5322:	39 07       	cpc	r19, r25
    5324:	59 f4       	brne	.+22     	; 0x533c <vCoRoutineSchedule+0xb0>
    5326:	e9 81       	ldd	r30, Y+1	; 0x01
    5328:	fa 81       	ldd	r31, Y+2	; 0x02
    532a:	01 80       	ldd	r0, Z+1	; 0x01
    532c:	f2 81       	ldd	r31, Z+2	; 0x02
    532e:	e0 2d       	mov	r30, r0
    5330:	82 81       	ldd	r24, Z+2	; 0x02
    5332:	93 81       	ldd	r25, Z+3	; 0x03
    5334:	e9 81       	ldd	r30, Y+1	; 0x01
    5336:	fa 81       	ldd	r31, Y+2	; 0x02
    5338:	92 83       	std	Z+2, r25	; 0x02
    533a:	81 83       	std	Z+1, r24	; 0x01
    533c:	e9 81       	ldd	r30, Y+1	; 0x01
    533e:	fa 81       	ldd	r31, Y+2	; 0x02
    5340:	01 80       	ldd	r0, Z+1	; 0x01
    5342:	f2 81       	ldd	r31, Z+2	; 0x02
    5344:	e0 2d       	mov	r30, r0
    5346:	86 81       	ldd	r24, Z+6	; 0x06
    5348:	97 81       	ldd	r25, Z+7	; 0x07
    534a:	90 93 ad 00 	sts	0x00AD, r25
    534e:	80 93 ac 00 	sts	0x00AC, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    5352:	e0 91 ac 00 	lds	r30, 0x00AC
    5356:	f0 91 ad 00 	lds	r31, 0x00AD
    535a:	40 81       	ld	r20, Z
    535c:	51 81       	ldd	r21, Z+1	; 0x01
    535e:	80 91 ac 00 	lds	r24, 0x00AC
    5362:	90 91 ad 00 	lds	r25, 0x00AD
    5366:	e0 91 ac 00 	lds	r30, 0x00AC
    536a:	f0 91 ad 00 	lds	r31, 0x00AD
    536e:	27 89       	ldd	r18, Z+23	; 0x17
    5370:	62 2f       	mov	r22, r18
    5372:	fa 01       	movw	r30, r20
    5374:	09 95       	icall

	return;
}
    5376:	0f 90       	pop	r0
    5378:	0f 90       	pop	r0
    537a:	cf 91       	pop	r28
    537c:	df 91       	pop	r29
    537e:	08 95       	ret

00005380 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    5380:	df 93       	push	r29
    5382:	cf 93       	push	r28
    5384:	0f 92       	push	r0
    5386:	cd b7       	in	r28, 0x3d	; 61
    5388:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    538a:	19 82       	std	Y+1, r1	; 0x01
    538c:	13 c0       	rjmp	.+38     	; 0x53b4 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    538e:	89 81       	ldd	r24, Y+1	; 0x01
    5390:	28 2f       	mov	r18, r24
    5392:	30 e0       	ldi	r19, 0x00	; 0
    5394:	c9 01       	movw	r24, r18
    5396:	88 0f       	add	r24, r24
    5398:	99 1f       	adc	r25, r25
    539a:	88 0f       	add	r24, r24
    539c:	99 1f       	adc	r25, r25
    539e:	88 0f       	add	r24, r24
    53a0:	99 1f       	adc	r25, r25
    53a2:	82 0f       	add	r24, r18
    53a4:	93 1f       	adc	r25, r19
    53a6:	8b 54       	subi	r24, 0x4B	; 75
    53a8:	9f 4f       	sbci	r25, 0xFF	; 255
    53aa:	0e 94 9d 2a 	call	0x553a	; 0x553a <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    53ae:	89 81       	ldd	r24, Y+1	; 0x01
    53b0:	8f 5f       	subi	r24, 0xFF	; 255
    53b2:	89 83       	std	Y+1, r24	; 0x01
    53b4:	89 81       	ldd	r24, Y+1	; 0x01
    53b6:	82 30       	cpi	r24, 0x02	; 2
    53b8:	50 f3       	brcs	.-44     	; 0x538e <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    53ba:	87 ec       	ldi	r24, 0xC7	; 199
    53bc:	90 e0       	ldi	r25, 0x00	; 0
    53be:	0e 94 9d 2a 	call	0x553a	; 0x553a <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    53c2:	80 ed       	ldi	r24, 0xD0	; 208
    53c4:	90 e0       	ldi	r25, 0x00	; 0
    53c6:	0e 94 9d 2a 	call	0x553a	; 0x553a <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    53ca:	8d ed       	ldi	r24, 0xDD	; 221
    53cc:	90 e0       	ldi	r25, 0x00	; 0
    53ce:	0e 94 9d 2a 	call	0x553a	; 0x553a <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    53d2:	87 ec       	ldi	r24, 0xC7	; 199
    53d4:	90 e0       	ldi	r25, 0x00	; 0
    53d6:	90 93 da 00 	sts	0x00DA, r25
    53da:	80 93 d9 00 	sts	0x00D9, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    53de:	80 ed       	ldi	r24, 0xD0	; 208
    53e0:	90 e0       	ldi	r25, 0x00	; 0
    53e2:	90 93 dc 00 	sts	0x00DC, r25
    53e6:	80 93 db 00 	sts	0x00DB, r24
}
    53ea:	0f 90       	pop	r0
    53ec:	cf 91       	pop	r28
    53ee:	df 91       	pop	r29
    53f0:	08 95       	ret

000053f2 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    53f2:	df 93       	push	r29
    53f4:	cf 93       	push	r28
    53f6:	00 d0       	rcall	.+0      	; 0x53f8 <xCoRoutineRemoveFromEventList+0x6>
    53f8:	00 d0       	rcall	.+0      	; 0x53fa <xCoRoutineRemoveFromEventList+0x8>
    53fa:	0f 92       	push	r0
    53fc:	cd b7       	in	r28, 0x3d	; 61
    53fe:	de b7       	in	r29, 0x3e	; 62
    5400:	9d 83       	std	Y+5, r25	; 0x05
    5402:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    5404:	ec 81       	ldd	r30, Y+4	; 0x04
    5406:	fd 81       	ldd	r31, Y+5	; 0x05
    5408:	05 80       	ldd	r0, Z+5	; 0x05
    540a:	f6 81       	ldd	r31, Z+6	; 0x06
    540c:	e0 2d       	mov	r30, r0
    540e:	86 81       	ldd	r24, Z+6	; 0x06
    5410:	97 81       	ldd	r25, Z+7	; 0x07
    5412:	9b 83       	std	Y+3, r25	; 0x03
    5414:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    5416:	8a 81       	ldd	r24, Y+2	; 0x02
    5418:	9b 81       	ldd	r25, Y+3	; 0x03
    541a:	0c 96       	adiw	r24, 0x0c	; 12
    541c:	0e 94 8f 2b 	call	0x571e	; 0x571e <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    5420:	8a 81       	ldd	r24, Y+2	; 0x02
    5422:	9b 81       	ldd	r25, Y+3	; 0x03
    5424:	9c 01       	movw	r18, r24
    5426:	24 5f       	subi	r18, 0xF4	; 244
    5428:	3f 4f       	sbci	r19, 0xFF	; 255
    542a:	8d ed       	ldi	r24, 0xDD	; 221
    542c:	90 e0       	ldi	r25, 0x00	; 0
    542e:	b9 01       	movw	r22, r18
    5430:	0e 94 d7 2a 	call	0x55ae	; 0x55ae <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    5434:	ea 81       	ldd	r30, Y+2	; 0x02
    5436:	fb 81       	ldd	r31, Y+3	; 0x03
    5438:	96 89       	ldd	r25, Z+22	; 0x16
    543a:	e0 91 ac 00 	lds	r30, 0x00AC
    543e:	f0 91 ad 00 	lds	r31, 0x00AD
    5442:	86 89       	ldd	r24, Z+22	; 0x16
    5444:	98 17       	cp	r25, r24
    5446:	18 f0       	brcs	.+6      	; 0x544e <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    5448:	81 e0       	ldi	r24, 0x01	; 1
    544a:	89 83       	std	Y+1, r24	; 0x01
    544c:	01 c0       	rjmp	.+2      	; 0x5450 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    544e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5450:	89 81       	ldd	r24, Y+1	; 0x01
}
    5452:	0f 90       	pop	r0
    5454:	0f 90       	pop	r0
    5456:	0f 90       	pop	r0
    5458:	0f 90       	pop	r0
    545a:	0f 90       	pop	r0
    545c:	cf 91       	pop	r28
    545e:	df 91       	pop	r29
    5460:	08 95       	ret

00005462 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    5462:	df 93       	push	r29
    5464:	cf 93       	push	r28
    5466:	00 d0       	rcall	.+0      	; 0x5468 <pvPortMalloc+0x6>
    5468:	00 d0       	rcall	.+0      	; 0x546a <pvPortMalloc+0x8>
    546a:	cd b7       	in	r28, 0x3d	; 61
    546c:	de b7       	in	r29, 0x3e	; 62
    546e:	9c 83       	std	Y+4, r25	; 0x04
    5470:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    5472:	1a 82       	std	Y+2, r1	; 0x02
    5474:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    5476:	0e 94 67 35 	call	0x6ace	; 0x6ace <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    547a:	80 91 e6 00 	lds	r24, 0x00E6
    547e:	90 91 e7 00 	lds	r25, 0x00E7
    5482:	2b 81       	ldd	r18, Y+3	; 0x03
    5484:	3c 81       	ldd	r19, Y+4	; 0x04
    5486:	82 0f       	add	r24, r18
    5488:	93 1f       	adc	r25, r19
    548a:	25 e0       	ldi	r18, 0x05	; 5
    548c:	8c 3d       	cpi	r24, 0xDC	; 220
    548e:	92 07       	cpc	r25, r18
    5490:	18 f5       	brcc	.+70     	; 0x54d8 <pvPortMalloc+0x76>
    5492:	20 91 e6 00 	lds	r18, 0x00E6
    5496:	30 91 e7 00 	lds	r19, 0x00E7
    549a:	8b 81       	ldd	r24, Y+3	; 0x03
    549c:	9c 81       	ldd	r25, Y+4	; 0x04
    549e:	28 0f       	add	r18, r24
    54a0:	39 1f       	adc	r19, r25
    54a2:	80 91 e6 00 	lds	r24, 0x00E6
    54a6:	90 91 e7 00 	lds	r25, 0x00E7
    54aa:	82 17       	cp	r24, r18
    54ac:	93 07       	cpc	r25, r19
    54ae:	a0 f4       	brcc	.+40     	; 0x54d8 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    54b0:	80 91 e6 00 	lds	r24, 0x00E6
    54b4:	90 91 e7 00 	lds	r25, 0x00E7
    54b8:	88 51       	subi	r24, 0x18	; 24
    54ba:	9f 4f       	sbci	r25, 0xFF	; 255
    54bc:	9a 83       	std	Y+2, r25	; 0x02
    54be:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    54c0:	20 91 e6 00 	lds	r18, 0x00E6
    54c4:	30 91 e7 00 	lds	r19, 0x00E7
    54c8:	8b 81       	ldd	r24, Y+3	; 0x03
    54ca:	9c 81       	ldd	r25, Y+4	; 0x04
    54cc:	82 0f       	add	r24, r18
    54ce:	93 1f       	adc	r25, r19
    54d0:	90 93 e7 00 	sts	0x00E7, r25
    54d4:	80 93 e6 00 	sts	0x00E6, r24
		}	
	}
	xTaskResumeAll();
    54d8:	0e 94 73 35 	call	0x6ae6	; 0x6ae6 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    54dc:	89 81       	ldd	r24, Y+1	; 0x01
    54de:	9a 81       	ldd	r25, Y+2	; 0x02
}
    54e0:	0f 90       	pop	r0
    54e2:	0f 90       	pop	r0
    54e4:	0f 90       	pop	r0
    54e6:	0f 90       	pop	r0
    54e8:	cf 91       	pop	r28
    54ea:	df 91       	pop	r29
    54ec:	08 95       	ret

000054ee <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    54ee:	df 93       	push	r29
    54f0:	cf 93       	push	r28
    54f2:	00 d0       	rcall	.+0      	; 0x54f4 <vPortFree+0x6>
    54f4:	cd b7       	in	r28, 0x3d	; 61
    54f6:	de b7       	in	r29, 0x3e	; 62
    54f8:	9a 83       	std	Y+2, r25	; 0x02
    54fa:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    54fc:	0f 90       	pop	r0
    54fe:	0f 90       	pop	r0
    5500:	cf 91       	pop	r28
    5502:	df 91       	pop	r29
    5504:	08 95       	ret

00005506 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    5506:	df 93       	push	r29
    5508:	cf 93       	push	r28
    550a:	cd b7       	in	r28, 0x3d	; 61
    550c:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    550e:	10 92 e7 00 	sts	0x00E7, r1
    5512:	10 92 e6 00 	sts	0x00E6, r1
}
    5516:	cf 91       	pop	r28
    5518:	df 91       	pop	r29
    551a:	08 95       	ret

0000551c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    551c:	df 93       	push	r29
    551e:	cf 93       	push	r28
    5520:	cd b7       	in	r28, 0x3d	; 61
    5522:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    5524:	20 91 e6 00 	lds	r18, 0x00E6
    5528:	30 91 e7 00 	lds	r19, 0x00E7
    552c:	8c ed       	ldi	r24, 0xDC	; 220
    552e:	95 e0       	ldi	r25, 0x05	; 5
    5530:	82 1b       	sub	r24, r18
    5532:	93 0b       	sbc	r25, r19
}
    5534:	cf 91       	pop	r28
    5536:	df 91       	pop	r29
    5538:	08 95       	ret

0000553a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    553a:	df 93       	push	r29
    553c:	cf 93       	push	r28
    553e:	00 d0       	rcall	.+0      	; 0x5540 <vListInitialise+0x6>
    5540:	cd b7       	in	r28, 0x3d	; 61
    5542:	de b7       	in	r29, 0x3e	; 62
    5544:	9a 83       	std	Y+2, r25	; 0x02
    5546:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    5548:	89 81       	ldd	r24, Y+1	; 0x01
    554a:	9a 81       	ldd	r25, Y+2	; 0x02
    554c:	03 96       	adiw	r24, 0x03	; 3
    554e:	e9 81       	ldd	r30, Y+1	; 0x01
    5550:	fa 81       	ldd	r31, Y+2	; 0x02
    5552:	92 83       	std	Z+2, r25	; 0x02
    5554:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    5556:	e9 81       	ldd	r30, Y+1	; 0x01
    5558:	fa 81       	ldd	r31, Y+2	; 0x02
    555a:	8f ef       	ldi	r24, 0xFF	; 255
    555c:	9f ef       	ldi	r25, 0xFF	; 255
    555e:	94 83       	std	Z+4, r25	; 0x04
    5560:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    5562:	89 81       	ldd	r24, Y+1	; 0x01
    5564:	9a 81       	ldd	r25, Y+2	; 0x02
    5566:	03 96       	adiw	r24, 0x03	; 3
    5568:	e9 81       	ldd	r30, Y+1	; 0x01
    556a:	fa 81       	ldd	r31, Y+2	; 0x02
    556c:	96 83       	std	Z+6, r25	; 0x06
    556e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    5570:	89 81       	ldd	r24, Y+1	; 0x01
    5572:	9a 81       	ldd	r25, Y+2	; 0x02
    5574:	03 96       	adiw	r24, 0x03	; 3
    5576:	e9 81       	ldd	r30, Y+1	; 0x01
    5578:	fa 81       	ldd	r31, Y+2	; 0x02
    557a:	90 87       	std	Z+8, r25	; 0x08
    557c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    557e:	e9 81       	ldd	r30, Y+1	; 0x01
    5580:	fa 81       	ldd	r31, Y+2	; 0x02
    5582:	10 82       	st	Z, r1
}
    5584:	0f 90       	pop	r0
    5586:	0f 90       	pop	r0
    5588:	cf 91       	pop	r28
    558a:	df 91       	pop	r29
    558c:	08 95       	ret

0000558e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    558e:	df 93       	push	r29
    5590:	cf 93       	push	r28
    5592:	00 d0       	rcall	.+0      	; 0x5594 <vListInitialiseItem+0x6>
    5594:	cd b7       	in	r28, 0x3d	; 61
    5596:	de b7       	in	r29, 0x3e	; 62
    5598:	9a 83       	std	Y+2, r25	; 0x02
    559a:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    559c:	e9 81       	ldd	r30, Y+1	; 0x01
    559e:	fa 81       	ldd	r31, Y+2	; 0x02
    55a0:	11 86       	std	Z+9, r1	; 0x09
    55a2:	10 86       	std	Z+8, r1	; 0x08
}
    55a4:	0f 90       	pop	r0
    55a6:	0f 90       	pop	r0
    55a8:	cf 91       	pop	r28
    55aa:	df 91       	pop	r29
    55ac:	08 95       	ret

000055ae <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    55ae:	df 93       	push	r29
    55b0:	cf 93       	push	r28
    55b2:	00 d0       	rcall	.+0      	; 0x55b4 <vListInsertEnd+0x6>
    55b4:	00 d0       	rcall	.+0      	; 0x55b6 <vListInsertEnd+0x8>
    55b6:	00 d0       	rcall	.+0      	; 0x55b8 <vListInsertEnd+0xa>
    55b8:	cd b7       	in	r28, 0x3d	; 61
    55ba:	de b7       	in	r29, 0x3e	; 62
    55bc:	9c 83       	std	Y+4, r25	; 0x04
    55be:	8b 83       	std	Y+3, r24	; 0x03
    55c0:	7e 83       	std	Y+6, r23	; 0x06
    55c2:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    55c4:	eb 81       	ldd	r30, Y+3	; 0x03
    55c6:	fc 81       	ldd	r31, Y+4	; 0x04
    55c8:	81 81       	ldd	r24, Z+1	; 0x01
    55ca:	92 81       	ldd	r25, Z+2	; 0x02
    55cc:	9a 83       	std	Y+2, r25	; 0x02
    55ce:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    55d0:	e9 81       	ldd	r30, Y+1	; 0x01
    55d2:	fa 81       	ldd	r31, Y+2	; 0x02
    55d4:	82 81       	ldd	r24, Z+2	; 0x02
    55d6:	93 81       	ldd	r25, Z+3	; 0x03
    55d8:	ed 81       	ldd	r30, Y+5	; 0x05
    55da:	fe 81       	ldd	r31, Y+6	; 0x06
    55dc:	93 83       	std	Z+3, r25	; 0x03
    55de:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    55e0:	eb 81       	ldd	r30, Y+3	; 0x03
    55e2:	fc 81       	ldd	r31, Y+4	; 0x04
    55e4:	81 81       	ldd	r24, Z+1	; 0x01
    55e6:	92 81       	ldd	r25, Z+2	; 0x02
    55e8:	ed 81       	ldd	r30, Y+5	; 0x05
    55ea:	fe 81       	ldd	r31, Y+6	; 0x06
    55ec:	95 83       	std	Z+5, r25	; 0x05
    55ee:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    55f0:	e9 81       	ldd	r30, Y+1	; 0x01
    55f2:	fa 81       	ldd	r31, Y+2	; 0x02
    55f4:	02 80       	ldd	r0, Z+2	; 0x02
    55f6:	f3 81       	ldd	r31, Z+3	; 0x03
    55f8:	e0 2d       	mov	r30, r0
    55fa:	8d 81       	ldd	r24, Y+5	; 0x05
    55fc:	9e 81       	ldd	r25, Y+6	; 0x06
    55fe:	95 83       	std	Z+5, r25	; 0x05
    5600:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    5602:	8d 81       	ldd	r24, Y+5	; 0x05
    5604:	9e 81       	ldd	r25, Y+6	; 0x06
    5606:	e9 81       	ldd	r30, Y+1	; 0x01
    5608:	fa 81       	ldd	r31, Y+2	; 0x02
    560a:	93 83       	std	Z+3, r25	; 0x03
    560c:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    560e:	8d 81       	ldd	r24, Y+5	; 0x05
    5610:	9e 81       	ldd	r25, Y+6	; 0x06
    5612:	eb 81       	ldd	r30, Y+3	; 0x03
    5614:	fc 81       	ldd	r31, Y+4	; 0x04
    5616:	92 83       	std	Z+2, r25	; 0x02
    5618:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    561a:	ed 81       	ldd	r30, Y+5	; 0x05
    561c:	fe 81       	ldd	r31, Y+6	; 0x06
    561e:	8b 81       	ldd	r24, Y+3	; 0x03
    5620:	9c 81       	ldd	r25, Y+4	; 0x04
    5622:	91 87       	std	Z+9, r25	; 0x09
    5624:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    5626:	eb 81       	ldd	r30, Y+3	; 0x03
    5628:	fc 81       	ldd	r31, Y+4	; 0x04
    562a:	80 81       	ld	r24, Z
    562c:	8f 5f       	subi	r24, 0xFF	; 255
    562e:	eb 81       	ldd	r30, Y+3	; 0x03
    5630:	fc 81       	ldd	r31, Y+4	; 0x04
    5632:	80 83       	st	Z, r24
}
    5634:	26 96       	adiw	r28, 0x06	; 6
    5636:	0f b6       	in	r0, 0x3f	; 63
    5638:	f8 94       	cli
    563a:	de bf       	out	0x3e, r29	; 62
    563c:	0f be       	out	0x3f, r0	; 63
    563e:	cd bf       	out	0x3d, r28	; 61
    5640:	cf 91       	pop	r28
    5642:	df 91       	pop	r29
    5644:	08 95       	ret

00005646 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    5646:	df 93       	push	r29
    5648:	cf 93       	push	r28
    564a:	cd b7       	in	r28, 0x3d	; 61
    564c:	de b7       	in	r29, 0x3e	; 62
    564e:	28 97       	sbiw	r28, 0x08	; 8
    5650:	0f b6       	in	r0, 0x3f	; 63
    5652:	f8 94       	cli
    5654:	de bf       	out	0x3e, r29	; 62
    5656:	0f be       	out	0x3f, r0	; 63
    5658:	cd bf       	out	0x3d, r28	; 61
    565a:	9e 83       	std	Y+6, r25	; 0x06
    565c:	8d 83       	std	Y+5, r24	; 0x05
    565e:	78 87       	std	Y+8, r23	; 0x08
    5660:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    5662:	ef 81       	ldd	r30, Y+7	; 0x07
    5664:	f8 85       	ldd	r31, Y+8	; 0x08
    5666:	80 81       	ld	r24, Z
    5668:	91 81       	ldd	r25, Z+1	; 0x01
    566a:	9a 83       	std	Y+2, r25	; 0x02
    566c:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    566e:	89 81       	ldd	r24, Y+1	; 0x01
    5670:	9a 81       	ldd	r25, Y+2	; 0x02
    5672:	2f ef       	ldi	r18, 0xFF	; 255
    5674:	8f 3f       	cpi	r24, 0xFF	; 255
    5676:	92 07       	cpc	r25, r18
    5678:	39 f4       	brne	.+14     	; 0x5688 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    567a:	ed 81       	ldd	r30, Y+5	; 0x05
    567c:	fe 81       	ldd	r31, Y+6	; 0x06
    567e:	87 81       	ldd	r24, Z+7	; 0x07
    5680:	90 85       	ldd	r25, Z+8	; 0x08
    5682:	9c 83       	std	Y+4, r25	; 0x04
    5684:	8b 83       	std	Y+3, r24	; 0x03
    5686:	18 c0       	rjmp	.+48     	; 0x56b8 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    5688:	8d 81       	ldd	r24, Y+5	; 0x05
    568a:	9e 81       	ldd	r25, Y+6	; 0x06
    568c:	03 96       	adiw	r24, 0x03	; 3
    568e:	9c 83       	std	Y+4, r25	; 0x04
    5690:	8b 83       	std	Y+3, r24	; 0x03
    5692:	06 c0       	rjmp	.+12     	; 0x56a0 <vListInsert+0x5a>
    5694:	eb 81       	ldd	r30, Y+3	; 0x03
    5696:	fc 81       	ldd	r31, Y+4	; 0x04
    5698:	82 81       	ldd	r24, Z+2	; 0x02
    569a:	93 81       	ldd	r25, Z+3	; 0x03
    569c:	9c 83       	std	Y+4, r25	; 0x04
    569e:	8b 83       	std	Y+3, r24	; 0x03
    56a0:	eb 81       	ldd	r30, Y+3	; 0x03
    56a2:	fc 81       	ldd	r31, Y+4	; 0x04
    56a4:	02 80       	ldd	r0, Z+2	; 0x02
    56a6:	f3 81       	ldd	r31, Z+3	; 0x03
    56a8:	e0 2d       	mov	r30, r0
    56aa:	20 81       	ld	r18, Z
    56ac:	31 81       	ldd	r19, Z+1	; 0x01
    56ae:	89 81       	ldd	r24, Y+1	; 0x01
    56b0:	9a 81       	ldd	r25, Y+2	; 0x02
    56b2:	82 17       	cp	r24, r18
    56b4:	93 07       	cpc	r25, r19
    56b6:	70 f7       	brcc	.-36     	; 0x5694 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    56b8:	eb 81       	ldd	r30, Y+3	; 0x03
    56ba:	fc 81       	ldd	r31, Y+4	; 0x04
    56bc:	82 81       	ldd	r24, Z+2	; 0x02
    56be:	93 81       	ldd	r25, Z+3	; 0x03
    56c0:	ef 81       	ldd	r30, Y+7	; 0x07
    56c2:	f8 85       	ldd	r31, Y+8	; 0x08
    56c4:	93 83       	std	Z+3, r25	; 0x03
    56c6:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    56c8:	ef 81       	ldd	r30, Y+7	; 0x07
    56ca:	f8 85       	ldd	r31, Y+8	; 0x08
    56cc:	02 80       	ldd	r0, Z+2	; 0x02
    56ce:	f3 81       	ldd	r31, Z+3	; 0x03
    56d0:	e0 2d       	mov	r30, r0
    56d2:	8f 81       	ldd	r24, Y+7	; 0x07
    56d4:	98 85       	ldd	r25, Y+8	; 0x08
    56d6:	95 83       	std	Z+5, r25	; 0x05
    56d8:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    56da:	ef 81       	ldd	r30, Y+7	; 0x07
    56dc:	f8 85       	ldd	r31, Y+8	; 0x08
    56de:	8b 81       	ldd	r24, Y+3	; 0x03
    56e0:	9c 81       	ldd	r25, Y+4	; 0x04
    56e2:	95 83       	std	Z+5, r25	; 0x05
    56e4:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    56e6:	8f 81       	ldd	r24, Y+7	; 0x07
    56e8:	98 85       	ldd	r25, Y+8	; 0x08
    56ea:	eb 81       	ldd	r30, Y+3	; 0x03
    56ec:	fc 81       	ldd	r31, Y+4	; 0x04
    56ee:	93 83       	std	Z+3, r25	; 0x03
    56f0:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    56f2:	ef 81       	ldd	r30, Y+7	; 0x07
    56f4:	f8 85       	ldd	r31, Y+8	; 0x08
    56f6:	8d 81       	ldd	r24, Y+5	; 0x05
    56f8:	9e 81       	ldd	r25, Y+6	; 0x06
    56fa:	91 87       	std	Z+9, r25	; 0x09
    56fc:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    56fe:	ed 81       	ldd	r30, Y+5	; 0x05
    5700:	fe 81       	ldd	r31, Y+6	; 0x06
    5702:	80 81       	ld	r24, Z
    5704:	8f 5f       	subi	r24, 0xFF	; 255
    5706:	ed 81       	ldd	r30, Y+5	; 0x05
    5708:	fe 81       	ldd	r31, Y+6	; 0x06
    570a:	80 83       	st	Z, r24
}
    570c:	28 96       	adiw	r28, 0x08	; 8
    570e:	0f b6       	in	r0, 0x3f	; 63
    5710:	f8 94       	cli
    5712:	de bf       	out	0x3e, r29	; 62
    5714:	0f be       	out	0x3f, r0	; 63
    5716:	cd bf       	out	0x3d, r28	; 61
    5718:	cf 91       	pop	r28
    571a:	df 91       	pop	r29
    571c:	08 95       	ret

0000571e <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    571e:	df 93       	push	r29
    5720:	cf 93       	push	r28
    5722:	00 d0       	rcall	.+0      	; 0x5724 <vListRemove+0x6>
    5724:	00 d0       	rcall	.+0      	; 0x5726 <vListRemove+0x8>
    5726:	cd b7       	in	r28, 0x3d	; 61
    5728:	de b7       	in	r29, 0x3e	; 62
    572a:	9c 83       	std	Y+4, r25	; 0x04
    572c:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    572e:	eb 81       	ldd	r30, Y+3	; 0x03
    5730:	fc 81       	ldd	r31, Y+4	; 0x04
    5732:	a2 81       	ldd	r26, Z+2	; 0x02
    5734:	b3 81       	ldd	r27, Z+3	; 0x03
    5736:	eb 81       	ldd	r30, Y+3	; 0x03
    5738:	fc 81       	ldd	r31, Y+4	; 0x04
    573a:	84 81       	ldd	r24, Z+4	; 0x04
    573c:	95 81       	ldd	r25, Z+5	; 0x05
    573e:	15 96       	adiw	r26, 0x05	; 5
    5740:	9c 93       	st	X, r25
    5742:	8e 93       	st	-X, r24
    5744:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    5746:	eb 81       	ldd	r30, Y+3	; 0x03
    5748:	fc 81       	ldd	r31, Y+4	; 0x04
    574a:	a4 81       	ldd	r26, Z+4	; 0x04
    574c:	b5 81       	ldd	r27, Z+5	; 0x05
    574e:	eb 81       	ldd	r30, Y+3	; 0x03
    5750:	fc 81       	ldd	r31, Y+4	; 0x04
    5752:	82 81       	ldd	r24, Z+2	; 0x02
    5754:	93 81       	ldd	r25, Z+3	; 0x03
    5756:	13 96       	adiw	r26, 0x03	; 3
    5758:	9c 93       	st	X, r25
    575a:	8e 93       	st	-X, r24
    575c:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    575e:	eb 81       	ldd	r30, Y+3	; 0x03
    5760:	fc 81       	ldd	r31, Y+4	; 0x04
    5762:	80 85       	ldd	r24, Z+8	; 0x08
    5764:	91 85       	ldd	r25, Z+9	; 0x09
    5766:	9a 83       	std	Y+2, r25	; 0x02
    5768:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    576a:	e9 81       	ldd	r30, Y+1	; 0x01
    576c:	fa 81       	ldd	r31, Y+2	; 0x02
    576e:	21 81       	ldd	r18, Z+1	; 0x01
    5770:	32 81       	ldd	r19, Z+2	; 0x02
    5772:	8b 81       	ldd	r24, Y+3	; 0x03
    5774:	9c 81       	ldd	r25, Y+4	; 0x04
    5776:	28 17       	cp	r18, r24
    5778:	39 07       	cpc	r19, r25
    577a:	41 f4       	brne	.+16     	; 0x578c <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    577c:	eb 81       	ldd	r30, Y+3	; 0x03
    577e:	fc 81       	ldd	r31, Y+4	; 0x04
    5780:	84 81       	ldd	r24, Z+4	; 0x04
    5782:	95 81       	ldd	r25, Z+5	; 0x05
    5784:	e9 81       	ldd	r30, Y+1	; 0x01
    5786:	fa 81       	ldd	r31, Y+2	; 0x02
    5788:	92 83       	std	Z+2, r25	; 0x02
    578a:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    578c:	eb 81       	ldd	r30, Y+3	; 0x03
    578e:	fc 81       	ldd	r31, Y+4	; 0x04
    5790:	11 86       	std	Z+9, r1	; 0x09
    5792:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    5794:	e9 81       	ldd	r30, Y+1	; 0x01
    5796:	fa 81       	ldd	r31, Y+2	; 0x02
    5798:	80 81       	ld	r24, Z
    579a:	81 50       	subi	r24, 0x01	; 1
    579c:	e9 81       	ldd	r30, Y+1	; 0x01
    579e:	fa 81       	ldd	r31, Y+2	; 0x02
    57a0:	80 83       	st	Z, r24
}
    57a2:	0f 90       	pop	r0
    57a4:	0f 90       	pop	r0
    57a6:	0f 90       	pop	r0
    57a8:	0f 90       	pop	r0
    57aa:	cf 91       	pop	r28
    57ac:	df 91       	pop	r29
    57ae:	08 95       	ret

000057b0 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    57b0:	df 93       	push	r29
    57b2:	cf 93       	push	r28
    57b4:	cd b7       	in	r28, 0x3d	; 61
    57b6:	de b7       	in	r29, 0x3e	; 62
    57b8:	28 97       	sbiw	r28, 0x08	; 8
    57ba:	0f b6       	in	r0, 0x3f	; 63
    57bc:	f8 94       	cli
    57be:	de bf       	out	0x3e, r29	; 62
    57c0:	0f be       	out	0x3f, r0	; 63
    57c2:	cd bf       	out	0x3d, r28	; 61
    57c4:	9c 83       	std	Y+4, r25	; 0x04
    57c6:	8b 83       	std	Y+3, r24	; 0x03
    57c8:	7e 83       	std	Y+6, r23	; 0x06
    57ca:	6d 83       	std	Y+5, r22	; 0x05
    57cc:	58 87       	std	Y+8, r21	; 0x08
    57ce:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    57d0:	eb 81       	ldd	r30, Y+3	; 0x03
    57d2:	fc 81       	ldd	r31, Y+4	; 0x04
    57d4:	81 e1       	ldi	r24, 0x11	; 17
    57d6:	80 83       	st	Z, r24
	pxTopOfStack--;
    57d8:	8b 81       	ldd	r24, Y+3	; 0x03
    57da:	9c 81       	ldd	r25, Y+4	; 0x04
    57dc:	01 97       	sbiw	r24, 0x01	; 1
    57de:	9c 83       	std	Y+4, r25	; 0x04
    57e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    57e2:	eb 81       	ldd	r30, Y+3	; 0x03
    57e4:	fc 81       	ldd	r31, Y+4	; 0x04
    57e6:	82 e2       	ldi	r24, 0x22	; 34
    57e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    57ea:	8b 81       	ldd	r24, Y+3	; 0x03
    57ec:	9c 81       	ldd	r25, Y+4	; 0x04
    57ee:	01 97       	sbiw	r24, 0x01	; 1
    57f0:	9c 83       	std	Y+4, r25	; 0x04
    57f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    57f4:	eb 81       	ldd	r30, Y+3	; 0x03
    57f6:	fc 81       	ldd	r31, Y+4	; 0x04
    57f8:	83 e3       	ldi	r24, 0x33	; 51
    57fa:	80 83       	st	Z, r24
	pxTopOfStack--;
    57fc:	8b 81       	ldd	r24, Y+3	; 0x03
    57fe:	9c 81       	ldd	r25, Y+4	; 0x04
    5800:	01 97       	sbiw	r24, 0x01	; 1
    5802:	9c 83       	std	Y+4, r25	; 0x04
    5804:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    5806:	8d 81       	ldd	r24, Y+5	; 0x05
    5808:	9e 81       	ldd	r25, Y+6	; 0x06
    580a:	9a 83       	std	Y+2, r25	; 0x02
    580c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    580e:	89 81       	ldd	r24, Y+1	; 0x01
    5810:	eb 81       	ldd	r30, Y+3	; 0x03
    5812:	fc 81       	ldd	r31, Y+4	; 0x04
    5814:	80 83       	st	Z, r24
	pxTopOfStack--;
    5816:	8b 81       	ldd	r24, Y+3	; 0x03
    5818:	9c 81       	ldd	r25, Y+4	; 0x04
    581a:	01 97       	sbiw	r24, 0x01	; 1
    581c:	9c 83       	std	Y+4, r25	; 0x04
    581e:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    5820:	89 81       	ldd	r24, Y+1	; 0x01
    5822:	9a 81       	ldd	r25, Y+2	; 0x02
    5824:	89 2f       	mov	r24, r25
    5826:	99 27       	eor	r25, r25
    5828:	9a 83       	std	Y+2, r25	; 0x02
    582a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    582c:	89 81       	ldd	r24, Y+1	; 0x01
    582e:	eb 81       	ldd	r30, Y+3	; 0x03
    5830:	fc 81       	ldd	r31, Y+4	; 0x04
    5832:	80 83       	st	Z, r24
	pxTopOfStack--;
    5834:	8b 81       	ldd	r24, Y+3	; 0x03
    5836:	9c 81       	ldd	r25, Y+4	; 0x04
    5838:	01 97       	sbiw	r24, 0x01	; 1
    583a:	9c 83       	std	Y+4, r25	; 0x04
    583c:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    583e:	eb 81       	ldd	r30, Y+3	; 0x03
    5840:	fc 81       	ldd	r31, Y+4	; 0x04
    5842:	10 82       	st	Z, r1
	pxTopOfStack--;
    5844:	8b 81       	ldd	r24, Y+3	; 0x03
    5846:	9c 81       	ldd	r25, Y+4	; 0x04
    5848:	01 97       	sbiw	r24, 0x01	; 1
    584a:	9c 83       	std	Y+4, r25	; 0x04
    584c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    584e:	eb 81       	ldd	r30, Y+3	; 0x03
    5850:	fc 81       	ldd	r31, Y+4	; 0x04
    5852:	80 e8       	ldi	r24, 0x80	; 128
    5854:	80 83       	st	Z, r24
	pxTopOfStack--;
    5856:	8b 81       	ldd	r24, Y+3	; 0x03
    5858:	9c 81       	ldd	r25, Y+4	; 0x04
    585a:	01 97       	sbiw	r24, 0x01	; 1
    585c:	9c 83       	std	Y+4, r25	; 0x04
    585e:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    5860:	eb 81       	ldd	r30, Y+3	; 0x03
    5862:	fc 81       	ldd	r31, Y+4	; 0x04
    5864:	10 82       	st	Z, r1
	pxTopOfStack--;
    5866:	8b 81       	ldd	r24, Y+3	; 0x03
    5868:	9c 81       	ldd	r25, Y+4	; 0x04
    586a:	01 97       	sbiw	r24, 0x01	; 1
    586c:	9c 83       	std	Y+4, r25	; 0x04
    586e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    5870:	eb 81       	ldd	r30, Y+3	; 0x03
    5872:	fc 81       	ldd	r31, Y+4	; 0x04
    5874:	82 e0       	ldi	r24, 0x02	; 2
    5876:	80 83       	st	Z, r24
	pxTopOfStack--;
    5878:	8b 81       	ldd	r24, Y+3	; 0x03
    587a:	9c 81       	ldd	r25, Y+4	; 0x04
    587c:	01 97       	sbiw	r24, 0x01	; 1
    587e:	9c 83       	std	Y+4, r25	; 0x04
    5880:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    5882:	eb 81       	ldd	r30, Y+3	; 0x03
    5884:	fc 81       	ldd	r31, Y+4	; 0x04
    5886:	83 e0       	ldi	r24, 0x03	; 3
    5888:	80 83       	st	Z, r24
	pxTopOfStack--;
    588a:	8b 81       	ldd	r24, Y+3	; 0x03
    588c:	9c 81       	ldd	r25, Y+4	; 0x04
    588e:	01 97       	sbiw	r24, 0x01	; 1
    5890:	9c 83       	std	Y+4, r25	; 0x04
    5892:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    5894:	eb 81       	ldd	r30, Y+3	; 0x03
    5896:	fc 81       	ldd	r31, Y+4	; 0x04
    5898:	84 e0       	ldi	r24, 0x04	; 4
    589a:	80 83       	st	Z, r24
	pxTopOfStack--;
    589c:	8b 81       	ldd	r24, Y+3	; 0x03
    589e:	9c 81       	ldd	r25, Y+4	; 0x04
    58a0:	01 97       	sbiw	r24, 0x01	; 1
    58a2:	9c 83       	std	Y+4, r25	; 0x04
    58a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    58a6:	eb 81       	ldd	r30, Y+3	; 0x03
    58a8:	fc 81       	ldd	r31, Y+4	; 0x04
    58aa:	85 e0       	ldi	r24, 0x05	; 5
    58ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    58ae:	8b 81       	ldd	r24, Y+3	; 0x03
    58b0:	9c 81       	ldd	r25, Y+4	; 0x04
    58b2:	01 97       	sbiw	r24, 0x01	; 1
    58b4:	9c 83       	std	Y+4, r25	; 0x04
    58b6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    58b8:	eb 81       	ldd	r30, Y+3	; 0x03
    58ba:	fc 81       	ldd	r31, Y+4	; 0x04
    58bc:	86 e0       	ldi	r24, 0x06	; 6
    58be:	80 83       	st	Z, r24
	pxTopOfStack--;
    58c0:	8b 81       	ldd	r24, Y+3	; 0x03
    58c2:	9c 81       	ldd	r25, Y+4	; 0x04
    58c4:	01 97       	sbiw	r24, 0x01	; 1
    58c6:	9c 83       	std	Y+4, r25	; 0x04
    58c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    58ca:	eb 81       	ldd	r30, Y+3	; 0x03
    58cc:	fc 81       	ldd	r31, Y+4	; 0x04
    58ce:	87 e0       	ldi	r24, 0x07	; 7
    58d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    58d2:	8b 81       	ldd	r24, Y+3	; 0x03
    58d4:	9c 81       	ldd	r25, Y+4	; 0x04
    58d6:	01 97       	sbiw	r24, 0x01	; 1
    58d8:	9c 83       	std	Y+4, r25	; 0x04
    58da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    58dc:	eb 81       	ldd	r30, Y+3	; 0x03
    58de:	fc 81       	ldd	r31, Y+4	; 0x04
    58e0:	88 e0       	ldi	r24, 0x08	; 8
    58e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    58e4:	8b 81       	ldd	r24, Y+3	; 0x03
    58e6:	9c 81       	ldd	r25, Y+4	; 0x04
    58e8:	01 97       	sbiw	r24, 0x01	; 1
    58ea:	9c 83       	std	Y+4, r25	; 0x04
    58ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    58ee:	eb 81       	ldd	r30, Y+3	; 0x03
    58f0:	fc 81       	ldd	r31, Y+4	; 0x04
    58f2:	89 e0       	ldi	r24, 0x09	; 9
    58f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    58f6:	8b 81       	ldd	r24, Y+3	; 0x03
    58f8:	9c 81       	ldd	r25, Y+4	; 0x04
    58fa:	01 97       	sbiw	r24, 0x01	; 1
    58fc:	9c 83       	std	Y+4, r25	; 0x04
    58fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    5900:	eb 81       	ldd	r30, Y+3	; 0x03
    5902:	fc 81       	ldd	r31, Y+4	; 0x04
    5904:	80 e1       	ldi	r24, 0x10	; 16
    5906:	80 83       	st	Z, r24
	pxTopOfStack--;
    5908:	8b 81       	ldd	r24, Y+3	; 0x03
    590a:	9c 81       	ldd	r25, Y+4	; 0x04
    590c:	01 97       	sbiw	r24, 0x01	; 1
    590e:	9c 83       	std	Y+4, r25	; 0x04
    5910:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    5912:	eb 81       	ldd	r30, Y+3	; 0x03
    5914:	fc 81       	ldd	r31, Y+4	; 0x04
    5916:	81 e1       	ldi	r24, 0x11	; 17
    5918:	80 83       	st	Z, r24
	pxTopOfStack--;
    591a:	8b 81       	ldd	r24, Y+3	; 0x03
    591c:	9c 81       	ldd	r25, Y+4	; 0x04
    591e:	01 97       	sbiw	r24, 0x01	; 1
    5920:	9c 83       	std	Y+4, r25	; 0x04
    5922:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    5924:	eb 81       	ldd	r30, Y+3	; 0x03
    5926:	fc 81       	ldd	r31, Y+4	; 0x04
    5928:	82 e1       	ldi	r24, 0x12	; 18
    592a:	80 83       	st	Z, r24
	pxTopOfStack--;
    592c:	8b 81       	ldd	r24, Y+3	; 0x03
    592e:	9c 81       	ldd	r25, Y+4	; 0x04
    5930:	01 97       	sbiw	r24, 0x01	; 1
    5932:	9c 83       	std	Y+4, r25	; 0x04
    5934:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    5936:	eb 81       	ldd	r30, Y+3	; 0x03
    5938:	fc 81       	ldd	r31, Y+4	; 0x04
    593a:	83 e1       	ldi	r24, 0x13	; 19
    593c:	80 83       	st	Z, r24
	pxTopOfStack--;
    593e:	8b 81       	ldd	r24, Y+3	; 0x03
    5940:	9c 81       	ldd	r25, Y+4	; 0x04
    5942:	01 97       	sbiw	r24, 0x01	; 1
    5944:	9c 83       	std	Y+4, r25	; 0x04
    5946:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    5948:	eb 81       	ldd	r30, Y+3	; 0x03
    594a:	fc 81       	ldd	r31, Y+4	; 0x04
    594c:	84 e1       	ldi	r24, 0x14	; 20
    594e:	80 83       	st	Z, r24
	pxTopOfStack--;
    5950:	8b 81       	ldd	r24, Y+3	; 0x03
    5952:	9c 81       	ldd	r25, Y+4	; 0x04
    5954:	01 97       	sbiw	r24, 0x01	; 1
    5956:	9c 83       	std	Y+4, r25	; 0x04
    5958:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    595a:	eb 81       	ldd	r30, Y+3	; 0x03
    595c:	fc 81       	ldd	r31, Y+4	; 0x04
    595e:	85 e1       	ldi	r24, 0x15	; 21
    5960:	80 83       	st	Z, r24
	pxTopOfStack--;
    5962:	8b 81       	ldd	r24, Y+3	; 0x03
    5964:	9c 81       	ldd	r25, Y+4	; 0x04
    5966:	01 97       	sbiw	r24, 0x01	; 1
    5968:	9c 83       	std	Y+4, r25	; 0x04
    596a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    596c:	eb 81       	ldd	r30, Y+3	; 0x03
    596e:	fc 81       	ldd	r31, Y+4	; 0x04
    5970:	86 e1       	ldi	r24, 0x16	; 22
    5972:	80 83       	st	Z, r24
	pxTopOfStack--;
    5974:	8b 81       	ldd	r24, Y+3	; 0x03
    5976:	9c 81       	ldd	r25, Y+4	; 0x04
    5978:	01 97       	sbiw	r24, 0x01	; 1
    597a:	9c 83       	std	Y+4, r25	; 0x04
    597c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    597e:	eb 81       	ldd	r30, Y+3	; 0x03
    5980:	fc 81       	ldd	r31, Y+4	; 0x04
    5982:	87 e1       	ldi	r24, 0x17	; 23
    5984:	80 83       	st	Z, r24
	pxTopOfStack--;
    5986:	8b 81       	ldd	r24, Y+3	; 0x03
    5988:	9c 81       	ldd	r25, Y+4	; 0x04
    598a:	01 97       	sbiw	r24, 0x01	; 1
    598c:	9c 83       	std	Y+4, r25	; 0x04
    598e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    5990:	eb 81       	ldd	r30, Y+3	; 0x03
    5992:	fc 81       	ldd	r31, Y+4	; 0x04
    5994:	88 e1       	ldi	r24, 0x18	; 24
    5996:	80 83       	st	Z, r24
	pxTopOfStack--;
    5998:	8b 81       	ldd	r24, Y+3	; 0x03
    599a:	9c 81       	ldd	r25, Y+4	; 0x04
    599c:	01 97       	sbiw	r24, 0x01	; 1
    599e:	9c 83       	std	Y+4, r25	; 0x04
    59a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    59a2:	eb 81       	ldd	r30, Y+3	; 0x03
    59a4:	fc 81       	ldd	r31, Y+4	; 0x04
    59a6:	89 e1       	ldi	r24, 0x19	; 25
    59a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    59aa:	8b 81       	ldd	r24, Y+3	; 0x03
    59ac:	9c 81       	ldd	r25, Y+4	; 0x04
    59ae:	01 97       	sbiw	r24, 0x01	; 1
    59b0:	9c 83       	std	Y+4, r25	; 0x04
    59b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    59b4:	eb 81       	ldd	r30, Y+3	; 0x03
    59b6:	fc 81       	ldd	r31, Y+4	; 0x04
    59b8:	80 e2       	ldi	r24, 0x20	; 32
    59ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    59bc:	8b 81       	ldd	r24, Y+3	; 0x03
    59be:	9c 81       	ldd	r25, Y+4	; 0x04
    59c0:	01 97       	sbiw	r24, 0x01	; 1
    59c2:	9c 83       	std	Y+4, r25	; 0x04
    59c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    59c6:	eb 81       	ldd	r30, Y+3	; 0x03
    59c8:	fc 81       	ldd	r31, Y+4	; 0x04
    59ca:	81 e2       	ldi	r24, 0x21	; 33
    59cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    59ce:	8b 81       	ldd	r24, Y+3	; 0x03
    59d0:	9c 81       	ldd	r25, Y+4	; 0x04
    59d2:	01 97       	sbiw	r24, 0x01	; 1
    59d4:	9c 83       	std	Y+4, r25	; 0x04
    59d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    59d8:	eb 81       	ldd	r30, Y+3	; 0x03
    59da:	fc 81       	ldd	r31, Y+4	; 0x04
    59dc:	82 e2       	ldi	r24, 0x22	; 34
    59de:	80 83       	st	Z, r24
	pxTopOfStack--;
    59e0:	8b 81       	ldd	r24, Y+3	; 0x03
    59e2:	9c 81       	ldd	r25, Y+4	; 0x04
    59e4:	01 97       	sbiw	r24, 0x01	; 1
    59e6:	9c 83       	std	Y+4, r25	; 0x04
    59e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    59ea:	eb 81       	ldd	r30, Y+3	; 0x03
    59ec:	fc 81       	ldd	r31, Y+4	; 0x04
    59ee:	83 e2       	ldi	r24, 0x23	; 35
    59f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    59f2:	8b 81       	ldd	r24, Y+3	; 0x03
    59f4:	9c 81       	ldd	r25, Y+4	; 0x04
    59f6:	01 97       	sbiw	r24, 0x01	; 1
    59f8:	9c 83       	std	Y+4, r25	; 0x04
    59fa:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    59fc:	8f 81       	ldd	r24, Y+7	; 0x07
    59fe:	98 85       	ldd	r25, Y+8	; 0x08
    5a00:	9a 83       	std	Y+2, r25	; 0x02
    5a02:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    5a04:	89 81       	ldd	r24, Y+1	; 0x01
    5a06:	eb 81       	ldd	r30, Y+3	; 0x03
    5a08:	fc 81       	ldd	r31, Y+4	; 0x04
    5a0a:	80 83       	st	Z, r24
	pxTopOfStack--;
    5a0c:	8b 81       	ldd	r24, Y+3	; 0x03
    5a0e:	9c 81       	ldd	r25, Y+4	; 0x04
    5a10:	01 97       	sbiw	r24, 0x01	; 1
    5a12:	9c 83       	std	Y+4, r25	; 0x04
    5a14:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    5a16:	89 81       	ldd	r24, Y+1	; 0x01
    5a18:	9a 81       	ldd	r25, Y+2	; 0x02
    5a1a:	89 2f       	mov	r24, r25
    5a1c:	99 27       	eor	r25, r25
    5a1e:	9a 83       	std	Y+2, r25	; 0x02
    5a20:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    5a22:	89 81       	ldd	r24, Y+1	; 0x01
    5a24:	eb 81       	ldd	r30, Y+3	; 0x03
    5a26:	fc 81       	ldd	r31, Y+4	; 0x04
    5a28:	80 83       	st	Z, r24
	pxTopOfStack--;
    5a2a:	8b 81       	ldd	r24, Y+3	; 0x03
    5a2c:	9c 81       	ldd	r25, Y+4	; 0x04
    5a2e:	01 97       	sbiw	r24, 0x01	; 1
    5a30:	9c 83       	std	Y+4, r25	; 0x04
    5a32:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    5a34:	eb 81       	ldd	r30, Y+3	; 0x03
    5a36:	fc 81       	ldd	r31, Y+4	; 0x04
    5a38:	86 e2       	ldi	r24, 0x26	; 38
    5a3a:	80 83       	st	Z, r24
	pxTopOfStack--;
    5a3c:	8b 81       	ldd	r24, Y+3	; 0x03
    5a3e:	9c 81       	ldd	r25, Y+4	; 0x04
    5a40:	01 97       	sbiw	r24, 0x01	; 1
    5a42:	9c 83       	std	Y+4, r25	; 0x04
    5a44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    5a46:	eb 81       	ldd	r30, Y+3	; 0x03
    5a48:	fc 81       	ldd	r31, Y+4	; 0x04
    5a4a:	87 e2       	ldi	r24, 0x27	; 39
    5a4c:	80 83       	st	Z, r24
	pxTopOfStack--;
    5a4e:	8b 81       	ldd	r24, Y+3	; 0x03
    5a50:	9c 81       	ldd	r25, Y+4	; 0x04
    5a52:	01 97       	sbiw	r24, 0x01	; 1
    5a54:	9c 83       	std	Y+4, r25	; 0x04
    5a56:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    5a58:	eb 81       	ldd	r30, Y+3	; 0x03
    5a5a:	fc 81       	ldd	r31, Y+4	; 0x04
    5a5c:	88 e2       	ldi	r24, 0x28	; 40
    5a5e:	80 83       	st	Z, r24
	pxTopOfStack--;
    5a60:	8b 81       	ldd	r24, Y+3	; 0x03
    5a62:	9c 81       	ldd	r25, Y+4	; 0x04
    5a64:	01 97       	sbiw	r24, 0x01	; 1
    5a66:	9c 83       	std	Y+4, r25	; 0x04
    5a68:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    5a6a:	eb 81       	ldd	r30, Y+3	; 0x03
    5a6c:	fc 81       	ldd	r31, Y+4	; 0x04
    5a6e:	89 e2       	ldi	r24, 0x29	; 41
    5a70:	80 83       	st	Z, r24
	pxTopOfStack--;
    5a72:	8b 81       	ldd	r24, Y+3	; 0x03
    5a74:	9c 81       	ldd	r25, Y+4	; 0x04
    5a76:	01 97       	sbiw	r24, 0x01	; 1
    5a78:	9c 83       	std	Y+4, r25	; 0x04
    5a7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    5a7c:	eb 81       	ldd	r30, Y+3	; 0x03
    5a7e:	fc 81       	ldd	r31, Y+4	; 0x04
    5a80:	80 e3       	ldi	r24, 0x30	; 48
    5a82:	80 83       	st	Z, r24
	pxTopOfStack--;
    5a84:	8b 81       	ldd	r24, Y+3	; 0x03
    5a86:	9c 81       	ldd	r25, Y+4	; 0x04
    5a88:	01 97       	sbiw	r24, 0x01	; 1
    5a8a:	9c 83       	std	Y+4, r25	; 0x04
    5a8c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    5a8e:	eb 81       	ldd	r30, Y+3	; 0x03
    5a90:	fc 81       	ldd	r31, Y+4	; 0x04
    5a92:	81 e3       	ldi	r24, 0x31	; 49
    5a94:	80 83       	st	Z, r24
	pxTopOfStack--;
    5a96:	8b 81       	ldd	r24, Y+3	; 0x03
    5a98:	9c 81       	ldd	r25, Y+4	; 0x04
    5a9a:	01 97       	sbiw	r24, 0x01	; 1
    5a9c:	9c 83       	std	Y+4, r25	; 0x04
    5a9e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    5aa0:	8b 81       	ldd	r24, Y+3	; 0x03
    5aa2:	9c 81       	ldd	r25, Y+4	; 0x04
}
    5aa4:	28 96       	adiw	r28, 0x08	; 8
    5aa6:	0f b6       	in	r0, 0x3f	; 63
    5aa8:	f8 94       	cli
    5aaa:	de bf       	out	0x3e, r29	; 62
    5aac:	0f be       	out	0x3f, r0	; 63
    5aae:	cd bf       	out	0x3d, r28	; 61
    5ab0:	cf 91       	pop	r28
    5ab2:	df 91       	pop	r29
    5ab4:	08 95       	ret

00005ab6 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    5ab6:	df 93       	push	r29
    5ab8:	cf 93       	push	r28
    5aba:	cd b7       	in	r28, 0x3d	; 61
    5abc:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    5abe:	0e 94 4b 2e 	call	0x5c96	; 0x5c96 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    5ac2:	a0 91 c4 06 	lds	r26, 0x06C4
    5ac6:	b0 91 c5 06 	lds	r27, 0x06C5
    5aca:	cd 91       	ld	r28, X+
    5acc:	cd bf       	out	0x3d, r28	; 61
    5ace:	dd 91       	ld	r29, X+
    5ad0:	de bf       	out	0x3e, r29	; 62
    5ad2:	ff 91       	pop	r31
    5ad4:	ef 91       	pop	r30
    5ad6:	df 91       	pop	r29
    5ad8:	cf 91       	pop	r28
    5ada:	bf 91       	pop	r27
    5adc:	af 91       	pop	r26
    5ade:	9f 91       	pop	r25
    5ae0:	8f 91       	pop	r24
    5ae2:	7f 91       	pop	r23
    5ae4:	6f 91       	pop	r22
    5ae6:	5f 91       	pop	r21
    5ae8:	4f 91       	pop	r20
    5aea:	3f 91       	pop	r19
    5aec:	2f 91       	pop	r18
    5aee:	1f 91       	pop	r17
    5af0:	0f 91       	pop	r16
    5af2:	ff 90       	pop	r15
    5af4:	ef 90       	pop	r14
    5af6:	df 90       	pop	r13
    5af8:	cf 90       	pop	r12
    5afa:	bf 90       	pop	r11
    5afc:	af 90       	pop	r10
    5afe:	9f 90       	pop	r9
    5b00:	8f 90       	pop	r8
    5b02:	7f 90       	pop	r7
    5b04:	6f 90       	pop	r6
    5b06:	5f 90       	pop	r5
    5b08:	4f 90       	pop	r4
    5b0a:	3f 90       	pop	r3
    5b0c:	2f 90       	pop	r2
    5b0e:	1f 90       	pop	r1
    5b10:	0f 90       	pop	r0
    5b12:	0f be       	out	0x3f, r0	; 63
    5b14:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    5b16:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    5b18:	81 e0       	ldi	r24, 0x01	; 1
}
    5b1a:	cf 91       	pop	r28
    5b1c:	df 91       	pop	r29
    5b1e:	08 95       	ret

00005b20 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    5b20:	df 93       	push	r29
    5b22:	cf 93       	push	r28
    5b24:	cd b7       	in	r28, 0x3d	; 61
    5b26:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    5b28:	cf 91       	pop	r28
    5b2a:	df 91       	pop	r29
    5b2c:	08 95       	ret

00005b2e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    5b2e:	0f 92       	push	r0
    5b30:	0f b6       	in	r0, 0x3f	; 63
    5b32:	f8 94       	cli
    5b34:	0f 92       	push	r0
    5b36:	1f 92       	push	r1
    5b38:	11 24       	eor	r1, r1
    5b3a:	2f 92       	push	r2
    5b3c:	3f 92       	push	r3
    5b3e:	4f 92       	push	r4
    5b40:	5f 92       	push	r5
    5b42:	6f 92       	push	r6
    5b44:	7f 92       	push	r7
    5b46:	8f 92       	push	r8
    5b48:	9f 92       	push	r9
    5b4a:	af 92       	push	r10
    5b4c:	bf 92       	push	r11
    5b4e:	cf 92       	push	r12
    5b50:	df 92       	push	r13
    5b52:	ef 92       	push	r14
    5b54:	ff 92       	push	r15
    5b56:	0f 93       	push	r16
    5b58:	1f 93       	push	r17
    5b5a:	2f 93       	push	r18
    5b5c:	3f 93       	push	r19
    5b5e:	4f 93       	push	r20
    5b60:	5f 93       	push	r21
    5b62:	6f 93       	push	r22
    5b64:	7f 93       	push	r23
    5b66:	8f 93       	push	r24
    5b68:	9f 93       	push	r25
    5b6a:	af 93       	push	r26
    5b6c:	bf 93       	push	r27
    5b6e:	cf 93       	push	r28
    5b70:	df 93       	push	r29
    5b72:	ef 93       	push	r30
    5b74:	ff 93       	push	r31
    5b76:	a0 91 c4 06 	lds	r26, 0x06C4
    5b7a:	b0 91 c5 06 	lds	r27, 0x06C5
    5b7e:	0d b6       	in	r0, 0x3d	; 61
    5b80:	0d 92       	st	X+, r0
    5b82:	0e b6       	in	r0, 0x3e	; 62
    5b84:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    5b86:	0e 94 07 37 	call	0x6e0e	; 0x6e0e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    5b8a:	a0 91 c4 06 	lds	r26, 0x06C4
    5b8e:	b0 91 c5 06 	lds	r27, 0x06C5
    5b92:	cd 91       	ld	r28, X+
    5b94:	cd bf       	out	0x3d, r28	; 61
    5b96:	dd 91       	ld	r29, X+
    5b98:	de bf       	out	0x3e, r29	; 62
    5b9a:	ff 91       	pop	r31
    5b9c:	ef 91       	pop	r30
    5b9e:	df 91       	pop	r29
    5ba0:	cf 91       	pop	r28
    5ba2:	bf 91       	pop	r27
    5ba4:	af 91       	pop	r26
    5ba6:	9f 91       	pop	r25
    5ba8:	8f 91       	pop	r24
    5baa:	7f 91       	pop	r23
    5bac:	6f 91       	pop	r22
    5bae:	5f 91       	pop	r21
    5bb0:	4f 91       	pop	r20
    5bb2:	3f 91       	pop	r19
    5bb4:	2f 91       	pop	r18
    5bb6:	1f 91       	pop	r17
    5bb8:	0f 91       	pop	r16
    5bba:	ff 90       	pop	r15
    5bbc:	ef 90       	pop	r14
    5bbe:	df 90       	pop	r13
    5bc0:	cf 90       	pop	r12
    5bc2:	bf 90       	pop	r11
    5bc4:	af 90       	pop	r10
    5bc6:	9f 90       	pop	r9
    5bc8:	8f 90       	pop	r8
    5bca:	7f 90       	pop	r7
    5bcc:	6f 90       	pop	r6
    5bce:	5f 90       	pop	r5
    5bd0:	4f 90       	pop	r4
    5bd2:	3f 90       	pop	r3
    5bd4:	2f 90       	pop	r2
    5bd6:	1f 90       	pop	r1
    5bd8:	0f 90       	pop	r0
    5bda:	0f be       	out	0x3f, r0	; 63
    5bdc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    5bde:	08 95       	ret

00005be0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    5be0:	0f 92       	push	r0
    5be2:	0f b6       	in	r0, 0x3f	; 63
    5be4:	f8 94       	cli
    5be6:	0f 92       	push	r0
    5be8:	1f 92       	push	r1
    5bea:	11 24       	eor	r1, r1
    5bec:	2f 92       	push	r2
    5bee:	3f 92       	push	r3
    5bf0:	4f 92       	push	r4
    5bf2:	5f 92       	push	r5
    5bf4:	6f 92       	push	r6
    5bf6:	7f 92       	push	r7
    5bf8:	8f 92       	push	r8
    5bfa:	9f 92       	push	r9
    5bfc:	af 92       	push	r10
    5bfe:	bf 92       	push	r11
    5c00:	cf 92       	push	r12
    5c02:	df 92       	push	r13
    5c04:	ef 92       	push	r14
    5c06:	ff 92       	push	r15
    5c08:	0f 93       	push	r16
    5c0a:	1f 93       	push	r17
    5c0c:	2f 93       	push	r18
    5c0e:	3f 93       	push	r19
    5c10:	4f 93       	push	r20
    5c12:	5f 93       	push	r21
    5c14:	6f 93       	push	r22
    5c16:	7f 93       	push	r23
    5c18:	8f 93       	push	r24
    5c1a:	9f 93       	push	r25
    5c1c:	af 93       	push	r26
    5c1e:	bf 93       	push	r27
    5c20:	cf 93       	push	r28
    5c22:	df 93       	push	r29
    5c24:	ef 93       	push	r30
    5c26:	ff 93       	push	r31
    5c28:	a0 91 c4 06 	lds	r26, 0x06C4
    5c2c:	b0 91 c5 06 	lds	r27, 0x06C5
    5c30:	0d b6       	in	r0, 0x3d	; 61
    5c32:	0d 92       	st	X+, r0
    5c34:	0e b6       	in	r0, 0x3e	; 62
    5c36:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    5c38:	0e 94 32 36 	call	0x6c64	; 0x6c64 <vTaskIncrementTick>
	vTaskSwitchContext();
    5c3c:	0e 94 07 37 	call	0x6e0e	; 0x6e0e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    5c40:	a0 91 c4 06 	lds	r26, 0x06C4
    5c44:	b0 91 c5 06 	lds	r27, 0x06C5
    5c48:	cd 91       	ld	r28, X+
    5c4a:	cd bf       	out	0x3d, r28	; 61
    5c4c:	dd 91       	ld	r29, X+
    5c4e:	de bf       	out	0x3e, r29	; 62
    5c50:	ff 91       	pop	r31
    5c52:	ef 91       	pop	r30
    5c54:	df 91       	pop	r29
    5c56:	cf 91       	pop	r28
    5c58:	bf 91       	pop	r27
    5c5a:	af 91       	pop	r26
    5c5c:	9f 91       	pop	r25
    5c5e:	8f 91       	pop	r24
    5c60:	7f 91       	pop	r23
    5c62:	6f 91       	pop	r22
    5c64:	5f 91       	pop	r21
    5c66:	4f 91       	pop	r20
    5c68:	3f 91       	pop	r19
    5c6a:	2f 91       	pop	r18
    5c6c:	1f 91       	pop	r17
    5c6e:	0f 91       	pop	r16
    5c70:	ff 90       	pop	r15
    5c72:	ef 90       	pop	r14
    5c74:	df 90       	pop	r13
    5c76:	cf 90       	pop	r12
    5c78:	bf 90       	pop	r11
    5c7a:	af 90       	pop	r10
    5c7c:	9f 90       	pop	r9
    5c7e:	8f 90       	pop	r8
    5c80:	7f 90       	pop	r7
    5c82:	6f 90       	pop	r6
    5c84:	5f 90       	pop	r5
    5c86:	4f 90       	pop	r4
    5c88:	3f 90       	pop	r3
    5c8a:	2f 90       	pop	r2
    5c8c:	1f 90       	pop	r1
    5c8e:	0f 90       	pop	r0
    5c90:	0f be       	out	0x3f, r0	; 63
    5c92:	0f 90       	pop	r0

	asm volatile ( "ret" );
    5c94:	08 95       	ret

00005c96 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    5c96:	df 93       	push	r29
    5c98:	cf 93       	push	r28
    5c9a:	00 d0       	rcall	.+0      	; 0x5c9c <prvSetupTimerInterrupt+0x6>
    5c9c:	00 d0       	rcall	.+0      	; 0x5c9e <prvSetupTimerInterrupt+0x8>
    5c9e:	00 d0       	rcall	.+0      	; 0x5ca0 <prvSetupTimerInterrupt+0xa>
    5ca0:	cd b7       	in	r28, 0x3d	; 61
    5ca2:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    5ca4:	80 e4       	ldi	r24, 0x40	; 64
    5ca6:	9f e1       	ldi	r25, 0x1F	; 31
    5ca8:	a0 e0       	ldi	r26, 0x00	; 0
    5caa:	b0 e0       	ldi	r27, 0x00	; 0
    5cac:	8b 83       	std	Y+3, r24	; 0x03
    5cae:	9c 83       	std	Y+4, r25	; 0x04
    5cb0:	ad 83       	std	Y+5, r26	; 0x05
    5cb2:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    5cb4:	8b 81       	ldd	r24, Y+3	; 0x03
    5cb6:	9c 81       	ldd	r25, Y+4	; 0x04
    5cb8:	ad 81       	ldd	r26, Y+5	; 0x05
    5cba:	be 81       	ldd	r27, Y+6	; 0x06
    5cbc:	68 94       	set
    5cbe:	15 f8       	bld	r1, 5
    5cc0:	b6 95       	lsr	r27
    5cc2:	a7 95       	ror	r26
    5cc4:	97 95       	ror	r25
    5cc6:	87 95       	ror	r24
    5cc8:	16 94       	lsr	r1
    5cca:	d1 f7       	brne	.-12     	; 0x5cc0 <prvSetupTimerInterrupt+0x2a>
    5ccc:	8b 83       	std	Y+3, r24	; 0x03
    5cce:	9c 83       	std	Y+4, r25	; 0x04
    5cd0:	ad 83       	std	Y+5, r26	; 0x05
    5cd2:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    5cd4:	8b 81       	ldd	r24, Y+3	; 0x03
    5cd6:	9c 81       	ldd	r25, Y+4	; 0x04
    5cd8:	ad 81       	ldd	r26, Y+5	; 0x05
    5cda:	be 81       	ldd	r27, Y+6	; 0x06
    5cdc:	01 97       	sbiw	r24, 0x01	; 1
    5cde:	a1 09       	sbc	r26, r1
    5ce0:	b1 09       	sbc	r27, r1
    5ce2:	8b 83       	std	Y+3, r24	; 0x03
    5ce4:	9c 83       	std	Y+4, r25	; 0x04
    5ce6:	ad 83       	std	Y+5, r26	; 0x05
    5ce8:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    5cea:	8b 81       	ldd	r24, Y+3	; 0x03
    5cec:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    5cee:	8b 81       	ldd	r24, Y+3	; 0x03
    5cf0:	9c 81       	ldd	r25, Y+4	; 0x04
    5cf2:	ad 81       	ldd	r26, Y+5	; 0x05
    5cf4:	be 81       	ldd	r27, Y+6	; 0x06
    5cf6:	89 2f       	mov	r24, r25
    5cf8:	9a 2f       	mov	r25, r26
    5cfa:	ab 2f       	mov	r26, r27
    5cfc:	bb 27       	eor	r27, r27
    5cfe:	8b 83       	std	Y+3, r24	; 0x03
    5d00:	9c 83       	std	Y+4, r25	; 0x04
    5d02:	ad 83       	std	Y+5, r26	; 0x05
    5d04:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    5d06:	8b 81       	ldd	r24, Y+3	; 0x03
    5d08:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    5d0a:	eb e4       	ldi	r30, 0x4B	; 75
    5d0c:	f0 e0       	ldi	r31, 0x00	; 0
    5d0e:	8a 81       	ldd	r24, Y+2	; 0x02
    5d10:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    5d12:	ea e4       	ldi	r30, 0x4A	; 74
    5d14:	f0 e0       	ldi	r31, 0x00	; 0
    5d16:	89 81       	ldd	r24, Y+1	; 0x01
    5d18:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    5d1a:	8b e0       	ldi	r24, 0x0B	; 11
    5d1c:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    5d1e:	ee e4       	ldi	r30, 0x4E	; 78
    5d20:	f0 e0       	ldi	r31, 0x00	; 0
    5d22:	89 81       	ldd	r24, Y+1	; 0x01
    5d24:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    5d26:	e9 e5       	ldi	r30, 0x59	; 89
    5d28:	f0 e0       	ldi	r31, 0x00	; 0
    5d2a:	80 81       	ld	r24, Z
    5d2c:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    5d2e:	89 81       	ldd	r24, Y+1	; 0x01
    5d30:	80 61       	ori	r24, 0x10	; 16
    5d32:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    5d34:	e9 e5       	ldi	r30, 0x59	; 89
    5d36:	f0 e0       	ldi	r31, 0x00	; 0
    5d38:	89 81       	ldd	r24, Y+1	; 0x01
    5d3a:	80 83       	st	Z, r24
}
    5d3c:	26 96       	adiw	r28, 0x06	; 6
    5d3e:	0f b6       	in	r0, 0x3f	; 63
    5d40:	f8 94       	cli
    5d42:	de bf       	out	0x3e, r29	; 62
    5d44:	0f be       	out	0x3f, r0	; 63
    5d46:	cd bf       	out	0x3d, r28	; 61
    5d48:	cf 91       	pop	r28
    5d4a:	df 91       	pop	r29
    5d4c:	08 95       	ret

00005d4e <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    5d4e:	0e 94 f0 2d 	call	0x5be0	; 0x5be0 <vPortYieldFromTick>
		asm volatile ( "reti" );
    5d52:	18 95       	reti

00005d54 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    5d54:	df 93       	push	r29
    5d56:	cf 93       	push	r28
    5d58:	cd b7       	in	r28, 0x3d	; 61
    5d5a:	de b7       	in	r29, 0x3e	; 62
    5d5c:	28 97       	sbiw	r28, 0x08	; 8
    5d5e:	0f b6       	in	r0, 0x3f	; 63
    5d60:	f8 94       	cli
    5d62:	de bf       	out	0x3e, r29	; 62
    5d64:	0f be       	out	0x3f, r0	; 63
    5d66:	cd bf       	out	0x3d, r28	; 61
    5d68:	8f 83       	std	Y+7, r24	; 0x07
    5d6a:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    5d6c:	1a 82       	std	Y+2, r1	; 0x02
    5d6e:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    5d70:	8f 81       	ldd	r24, Y+7	; 0x07
    5d72:	88 23       	and	r24, r24
    5d74:	09 f4       	brne	.+2      	; 0x5d78 <xQueueCreate+0x24>
    5d76:	8c c0       	rjmp	.+280    	; 0x5e90 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    5d78:	8f e1       	ldi	r24, 0x1F	; 31
    5d7a:	90 e0       	ldi	r25, 0x00	; 0
    5d7c:	0e 94 31 2a 	call	0x5462	; 0x5462 <pvPortMalloc>
    5d80:	9e 83       	std	Y+6, r25	; 0x06
    5d82:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    5d84:	8d 81       	ldd	r24, Y+5	; 0x05
    5d86:	9e 81       	ldd	r25, Y+6	; 0x06
    5d88:	00 97       	sbiw	r24, 0x00	; 0
    5d8a:	09 f4       	brne	.+2      	; 0x5d8e <xQueueCreate+0x3a>
    5d8c:	81 c0       	rjmp	.+258    	; 0x5e90 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    5d8e:	8f 81       	ldd	r24, Y+7	; 0x07
    5d90:	28 2f       	mov	r18, r24
    5d92:	30 e0       	ldi	r19, 0x00	; 0
    5d94:	88 85       	ldd	r24, Y+8	; 0x08
    5d96:	88 2f       	mov	r24, r24
    5d98:	90 e0       	ldi	r25, 0x00	; 0
    5d9a:	ac 01       	movw	r20, r24
    5d9c:	24 9f       	mul	r18, r20
    5d9e:	c0 01       	movw	r24, r0
    5da0:	25 9f       	mul	r18, r21
    5da2:	90 0d       	add	r25, r0
    5da4:	34 9f       	mul	r19, r20
    5da6:	90 0d       	add	r25, r0
    5da8:	11 24       	eor	r1, r1
    5daa:	01 96       	adiw	r24, 0x01	; 1
    5dac:	9c 83       	std	Y+4, r25	; 0x04
    5dae:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    5db0:	8b 81       	ldd	r24, Y+3	; 0x03
    5db2:	9c 81       	ldd	r25, Y+4	; 0x04
    5db4:	0e 94 31 2a 	call	0x5462	; 0x5462 <pvPortMalloc>
    5db8:	ed 81       	ldd	r30, Y+5	; 0x05
    5dba:	fe 81       	ldd	r31, Y+6	; 0x06
    5dbc:	91 83       	std	Z+1, r25	; 0x01
    5dbe:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    5dc0:	ed 81       	ldd	r30, Y+5	; 0x05
    5dc2:	fe 81       	ldd	r31, Y+6	; 0x06
    5dc4:	80 81       	ld	r24, Z
    5dc6:	91 81       	ldd	r25, Z+1	; 0x01
    5dc8:	00 97       	sbiw	r24, 0x00	; 0
    5dca:	09 f4       	brne	.+2      	; 0x5dce <xQueueCreate+0x7a>
    5dcc:	5d c0       	rjmp	.+186    	; 0x5e88 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    5dce:	ed 81       	ldd	r30, Y+5	; 0x05
    5dd0:	fe 81       	ldd	r31, Y+6	; 0x06
    5dd2:	40 81       	ld	r20, Z
    5dd4:	51 81       	ldd	r21, Z+1	; 0x01
    5dd6:	8f 81       	ldd	r24, Y+7	; 0x07
    5dd8:	28 2f       	mov	r18, r24
    5dda:	30 e0       	ldi	r19, 0x00	; 0
    5ddc:	88 85       	ldd	r24, Y+8	; 0x08
    5dde:	88 2f       	mov	r24, r24
    5de0:	90 e0       	ldi	r25, 0x00	; 0
    5de2:	bc 01       	movw	r22, r24
    5de4:	26 9f       	mul	r18, r22
    5de6:	c0 01       	movw	r24, r0
    5de8:	27 9f       	mul	r18, r23
    5dea:	90 0d       	add	r25, r0
    5dec:	36 9f       	mul	r19, r22
    5dee:	90 0d       	add	r25, r0
    5df0:	11 24       	eor	r1, r1
    5df2:	84 0f       	add	r24, r20
    5df4:	95 1f       	adc	r25, r21
    5df6:	ed 81       	ldd	r30, Y+5	; 0x05
    5df8:	fe 81       	ldd	r31, Y+6	; 0x06
    5dfa:	93 83       	std	Z+3, r25	; 0x03
    5dfc:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    5dfe:	ed 81       	ldd	r30, Y+5	; 0x05
    5e00:	fe 81       	ldd	r31, Y+6	; 0x06
    5e02:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    5e04:	ed 81       	ldd	r30, Y+5	; 0x05
    5e06:	fe 81       	ldd	r31, Y+6	; 0x06
    5e08:	80 81       	ld	r24, Z
    5e0a:	91 81       	ldd	r25, Z+1	; 0x01
    5e0c:	ed 81       	ldd	r30, Y+5	; 0x05
    5e0e:	fe 81       	ldd	r31, Y+6	; 0x06
    5e10:	95 83       	std	Z+5, r25	; 0x05
    5e12:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    5e14:	ed 81       	ldd	r30, Y+5	; 0x05
    5e16:	fe 81       	ldd	r31, Y+6	; 0x06
    5e18:	40 81       	ld	r20, Z
    5e1a:	51 81       	ldd	r21, Z+1	; 0x01
    5e1c:	8f 81       	ldd	r24, Y+7	; 0x07
    5e1e:	88 2f       	mov	r24, r24
    5e20:	90 e0       	ldi	r25, 0x00	; 0
    5e22:	9c 01       	movw	r18, r24
    5e24:	21 50       	subi	r18, 0x01	; 1
    5e26:	30 40       	sbci	r19, 0x00	; 0
    5e28:	88 85       	ldd	r24, Y+8	; 0x08
    5e2a:	88 2f       	mov	r24, r24
    5e2c:	90 e0       	ldi	r25, 0x00	; 0
    5e2e:	bc 01       	movw	r22, r24
    5e30:	26 9f       	mul	r18, r22
    5e32:	c0 01       	movw	r24, r0
    5e34:	27 9f       	mul	r18, r23
    5e36:	90 0d       	add	r25, r0
    5e38:	36 9f       	mul	r19, r22
    5e3a:	90 0d       	add	r25, r0
    5e3c:	11 24       	eor	r1, r1
    5e3e:	84 0f       	add	r24, r20
    5e40:	95 1f       	adc	r25, r21
    5e42:	ed 81       	ldd	r30, Y+5	; 0x05
    5e44:	fe 81       	ldd	r31, Y+6	; 0x06
    5e46:	97 83       	std	Z+7, r25	; 0x07
    5e48:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    5e4a:	ed 81       	ldd	r30, Y+5	; 0x05
    5e4c:	fe 81       	ldd	r31, Y+6	; 0x06
    5e4e:	8f 81       	ldd	r24, Y+7	; 0x07
    5e50:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    5e52:	ed 81       	ldd	r30, Y+5	; 0x05
    5e54:	fe 81       	ldd	r31, Y+6	; 0x06
    5e56:	88 85       	ldd	r24, Y+8	; 0x08
    5e58:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    5e5a:	ed 81       	ldd	r30, Y+5	; 0x05
    5e5c:	fe 81       	ldd	r31, Y+6	; 0x06
    5e5e:	8f ef       	ldi	r24, 0xFF	; 255
    5e60:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    5e62:	ed 81       	ldd	r30, Y+5	; 0x05
    5e64:	fe 81       	ldd	r31, Y+6	; 0x06
    5e66:	8f ef       	ldi	r24, 0xFF	; 255
    5e68:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    5e6a:	8d 81       	ldd	r24, Y+5	; 0x05
    5e6c:	9e 81       	ldd	r25, Y+6	; 0x06
    5e6e:	08 96       	adiw	r24, 0x08	; 8
    5e70:	0e 94 9d 2a 	call	0x553a	; 0x553a <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    5e74:	8d 81       	ldd	r24, Y+5	; 0x05
    5e76:	9e 81       	ldd	r25, Y+6	; 0x06
    5e78:	41 96       	adiw	r24, 0x11	; 17
    5e7a:	0e 94 9d 2a 	call	0x553a	; 0x553a <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    5e7e:	8d 81       	ldd	r24, Y+5	; 0x05
    5e80:	9e 81       	ldd	r25, Y+6	; 0x06
    5e82:	9a 83       	std	Y+2, r25	; 0x02
    5e84:	89 83       	std	Y+1, r24	; 0x01
    5e86:	04 c0       	rjmp	.+8      	; 0x5e90 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    5e88:	8d 81       	ldd	r24, Y+5	; 0x05
    5e8a:	9e 81       	ldd	r25, Y+6	; 0x06
    5e8c:	0e 94 77 2a 	call	0x54ee	; 0x54ee <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    5e90:	89 81       	ldd	r24, Y+1	; 0x01
    5e92:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5e94:	28 96       	adiw	r28, 0x08	; 8
    5e96:	0f b6       	in	r0, 0x3f	; 63
    5e98:	f8 94       	cli
    5e9a:	de bf       	out	0x3e, r29	; 62
    5e9c:	0f be       	out	0x3f, r0	; 63
    5e9e:	cd bf       	out	0x3d, r28	; 61
    5ea0:	cf 91       	pop	r28
    5ea2:	df 91       	pop	r29
    5ea4:	08 95       	ret

00005ea6 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    5ea6:	df 93       	push	r29
    5ea8:	cf 93       	push	r28
    5eaa:	cd b7       	in	r28, 0x3d	; 61
    5eac:	de b7       	in	r29, 0x3e	; 62
    5eae:	2c 97       	sbiw	r28, 0x0c	; 12
    5eb0:	0f b6       	in	r0, 0x3f	; 63
    5eb2:	f8 94       	cli
    5eb4:	de bf       	out	0x3e, r29	; 62
    5eb6:	0f be       	out	0x3f, r0	; 63
    5eb8:	cd bf       	out	0x3d, r28	; 61
    5eba:	9e 83       	std	Y+6, r25	; 0x06
    5ebc:	8d 83       	std	Y+5, r24	; 0x05
    5ebe:	78 87       	std	Y+8, r23	; 0x08
    5ec0:	6f 83       	std	Y+7, r22	; 0x07
    5ec2:	5a 87       	std	Y+10, r21	; 0x0a
    5ec4:	49 87       	std	Y+9, r20	; 0x09
    5ec6:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    5ec8:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    5eca:	0f b6       	in	r0, 0x3f	; 63
    5ecc:	f8 94       	cli
    5ece:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    5ed0:	ed 81       	ldd	r30, Y+5	; 0x05
    5ed2:	fe 81       	ldd	r31, Y+6	; 0x06
    5ed4:	92 8d       	ldd	r25, Z+26	; 0x1a
    5ed6:	ed 81       	ldd	r30, Y+5	; 0x05
    5ed8:	fe 81       	ldd	r31, Y+6	; 0x06
    5eda:	83 8d       	ldd	r24, Z+27	; 0x1b
    5edc:	98 17       	cp	r25, r24
    5ede:	d8 f4       	brcc	.+54     	; 0x5f16 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    5ee0:	8d 81       	ldd	r24, Y+5	; 0x05
    5ee2:	9e 81       	ldd	r25, Y+6	; 0x06
    5ee4:	2f 81       	ldd	r18, Y+7	; 0x07
    5ee6:	38 85       	ldd	r19, Y+8	; 0x08
    5ee8:	b9 01       	movw	r22, r18
    5eea:	4b 85       	ldd	r20, Y+11	; 0x0b
    5eec:	0e 94 8e 31 	call	0x631c	; 0x631c <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5ef0:	ed 81       	ldd	r30, Y+5	; 0x05
    5ef2:	fe 81       	ldd	r31, Y+6	; 0x06
    5ef4:	81 89       	ldd	r24, Z+17	; 0x11
    5ef6:	88 23       	and	r24, r24
    5ef8:	49 f0       	breq	.+18     	; 0x5f0c <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    5efa:	8d 81       	ldd	r24, Y+5	; 0x05
    5efc:	9e 81       	ldd	r25, Y+6	; 0x06
    5efe:	41 96       	adiw	r24, 0x11	; 17
    5f00:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <xTaskRemoveFromEventList>
    5f04:	81 30       	cpi	r24, 0x01	; 1
    5f06:	11 f4       	brne	.+4      	; 0x5f0c <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    5f08:	0e 94 97 2d 	call	0x5b2e	; 0x5b2e <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    5f0c:	0f 90       	pop	r0
    5f0e:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    5f10:	81 e0       	ldi	r24, 0x01	; 1
    5f12:	8c 87       	std	Y+12, r24	; 0x0c
    5f14:	5c c0       	rjmp	.+184    	; 0x5fce <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    5f16:	89 85       	ldd	r24, Y+9	; 0x09
    5f18:	9a 85       	ldd	r25, Y+10	; 0x0a
    5f1a:	00 97       	sbiw	r24, 0x00	; 0
    5f1c:	21 f4       	brne	.+8      	; 0x5f26 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    5f1e:	0f 90       	pop	r0
    5f20:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    5f22:	1c 86       	std	Y+12, r1	; 0x0c
    5f24:	54 c0       	rjmp	.+168    	; 0x5fce <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    5f26:	89 81       	ldd	r24, Y+1	; 0x01
    5f28:	88 23       	and	r24, r24
    5f2a:	31 f4       	brne	.+12     	; 0x5f38 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    5f2c:	ce 01       	movw	r24, r28
    5f2e:	02 96       	adiw	r24, 0x02	; 2
    5f30:	0e 94 0b 38 	call	0x7016	; 0x7016 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    5f34:	81 e0       	ldi	r24, 0x01	; 1
    5f36:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    5f38:	0f 90       	pop	r0
    5f3a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    5f3c:	0e 94 67 35 	call	0x6ace	; 0x6ace <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    5f40:	0f b6       	in	r0, 0x3f	; 63
    5f42:	f8 94       	cli
    5f44:	0f 92       	push	r0
    5f46:	ed 81       	ldd	r30, Y+5	; 0x05
    5f48:	fe 81       	ldd	r31, Y+6	; 0x06
    5f4a:	85 8d       	ldd	r24, Z+29	; 0x1d
    5f4c:	8f 3f       	cpi	r24, 0xFF	; 255
    5f4e:	19 f4       	brne	.+6      	; 0x5f56 <xQueueGenericSend+0xb0>
    5f50:	ed 81       	ldd	r30, Y+5	; 0x05
    5f52:	fe 81       	ldd	r31, Y+6	; 0x06
    5f54:	15 8e       	std	Z+29, r1	; 0x1d
    5f56:	ed 81       	ldd	r30, Y+5	; 0x05
    5f58:	fe 81       	ldd	r31, Y+6	; 0x06
    5f5a:	86 8d       	ldd	r24, Z+30	; 0x1e
    5f5c:	8f 3f       	cpi	r24, 0xFF	; 255
    5f5e:	19 f4       	brne	.+6      	; 0x5f66 <xQueueGenericSend+0xc0>
    5f60:	ed 81       	ldd	r30, Y+5	; 0x05
    5f62:	fe 81       	ldd	r31, Y+6	; 0x06
    5f64:	16 8e       	std	Z+30, r1	; 0x1e
    5f66:	0f 90       	pop	r0
    5f68:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    5f6a:	ce 01       	movw	r24, r28
    5f6c:	02 96       	adiw	r24, 0x02	; 2
    5f6e:	9e 01       	movw	r18, r28
    5f70:	27 5f       	subi	r18, 0xF7	; 247
    5f72:	3f 4f       	sbci	r19, 0xFF	; 255
    5f74:	b9 01       	movw	r22, r18
    5f76:	0e 94 24 38 	call	0x7048	; 0x7048 <xTaskCheckForTimeOut>
    5f7a:	88 23       	and	r24, r24
    5f7c:	09 f5       	brne	.+66     	; 0x5fc0 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    5f7e:	8d 81       	ldd	r24, Y+5	; 0x05
    5f80:	9e 81       	ldd	r25, Y+6	; 0x06
    5f82:	0e 94 f2 32 	call	0x65e4	; 0x65e4 <prvIsQueueFull>
    5f86:	88 23       	and	r24, r24
    5f88:	a1 f0       	breq	.+40     	; 0x5fb2 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    5f8a:	8d 81       	ldd	r24, Y+5	; 0x05
    5f8c:	9e 81       	ldd	r25, Y+6	; 0x06
    5f8e:	08 96       	adiw	r24, 0x08	; 8
    5f90:	29 85       	ldd	r18, Y+9	; 0x09
    5f92:	3a 85       	ldd	r19, Y+10	; 0x0a
    5f94:	b9 01       	movw	r22, r18
    5f96:	0e 94 6d 37 	call	0x6eda	; 0x6eda <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    5f9a:	8d 81       	ldd	r24, Y+5	; 0x05
    5f9c:	9e 81       	ldd	r25, Y+6	; 0x06
    5f9e:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    5fa2:	0e 94 73 35 	call	0x6ae6	; 0x6ae6 <xTaskResumeAll>
    5fa6:	88 23       	and	r24, r24
    5fa8:	09 f0       	breq	.+2      	; 0x5fac <xQueueGenericSend+0x106>
    5faa:	8f cf       	rjmp	.-226    	; 0x5eca <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    5fac:	0e 94 97 2d 	call	0x5b2e	; 0x5b2e <vPortYield>
    5fb0:	8c cf       	rjmp	.-232    	; 0x5eca <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    5fb2:	8d 81       	ldd	r24, Y+5	; 0x05
    5fb4:	9e 81       	ldd	r25, Y+6	; 0x06
    5fb6:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    5fba:	0e 94 73 35 	call	0x6ae6	; 0x6ae6 <xTaskResumeAll>
    5fbe:	85 cf       	rjmp	.-246    	; 0x5eca <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    5fc0:	8d 81       	ldd	r24, Y+5	; 0x05
    5fc2:	9e 81       	ldd	r25, Y+6	; 0x06
    5fc4:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    5fc8:	0e 94 73 35 	call	0x6ae6	; 0x6ae6 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    5fcc:	1c 86       	std	Y+12, r1	; 0x0c
    5fce:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    5fd0:	2c 96       	adiw	r28, 0x0c	; 12
    5fd2:	0f b6       	in	r0, 0x3f	; 63
    5fd4:	f8 94       	cli
    5fd6:	de bf       	out	0x3e, r29	; 62
    5fd8:	0f be       	out	0x3f, r0	; 63
    5fda:	cd bf       	out	0x3d, r28	; 61
    5fdc:	cf 91       	pop	r28
    5fde:	df 91       	pop	r29
    5fe0:	08 95       	ret

00005fe2 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    5fe2:	df 93       	push	r29
    5fe4:	cf 93       	push	r28
    5fe6:	cd b7       	in	r28, 0x3d	; 61
    5fe8:	de b7       	in	r29, 0x3e	; 62
    5fea:	29 97       	sbiw	r28, 0x09	; 9
    5fec:	0f b6       	in	r0, 0x3f	; 63
    5fee:	f8 94       	cli
    5ff0:	de bf       	out	0x3e, r29	; 62
    5ff2:	0f be       	out	0x3f, r0	; 63
    5ff4:	cd bf       	out	0x3d, r28	; 61
    5ff6:	9c 83       	std	Y+4, r25	; 0x04
    5ff8:	8b 83       	std	Y+3, r24	; 0x03
    5ffa:	7e 83       	std	Y+6, r23	; 0x06
    5ffc:	6d 83       	std	Y+5, r22	; 0x05
    5ffe:	58 87       	std	Y+8, r21	; 0x08
    6000:	4f 83       	std	Y+7, r20	; 0x07
    6002:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    6004:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    6006:	eb 81       	ldd	r30, Y+3	; 0x03
    6008:	fc 81       	ldd	r31, Y+4	; 0x04
    600a:	92 8d       	ldd	r25, Z+26	; 0x1a
    600c:	eb 81       	ldd	r30, Y+3	; 0x03
    600e:	fc 81       	ldd	r31, Y+4	; 0x04
    6010:	83 8d       	ldd	r24, Z+27	; 0x1b
    6012:	98 17       	cp	r25, r24
    6014:	40 f5       	brcc	.+80     	; 0x6066 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    6016:	8b 81       	ldd	r24, Y+3	; 0x03
    6018:	9c 81       	ldd	r25, Y+4	; 0x04
    601a:	2d 81       	ldd	r18, Y+5	; 0x05
    601c:	3e 81       	ldd	r19, Y+6	; 0x06
    601e:	b9 01       	movw	r22, r18
    6020:	49 85       	ldd	r20, Y+9	; 0x09
    6022:	0e 94 8e 31 	call	0x631c	; 0x631c <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    6026:	eb 81       	ldd	r30, Y+3	; 0x03
    6028:	fc 81       	ldd	r31, Y+4	; 0x04
    602a:	86 8d       	ldd	r24, Z+30	; 0x1e
    602c:	8f 3f       	cpi	r24, 0xFF	; 255
    602e:	89 f4       	brne	.+34     	; 0x6052 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    6030:	eb 81       	ldd	r30, Y+3	; 0x03
    6032:	fc 81       	ldd	r31, Y+4	; 0x04
    6034:	81 89       	ldd	r24, Z+17	; 0x11
    6036:	88 23       	and	r24, r24
    6038:	99 f0       	breq	.+38     	; 0x6060 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    603a:	8b 81       	ldd	r24, Y+3	; 0x03
    603c:	9c 81       	ldd	r25, Y+4	; 0x04
    603e:	41 96       	adiw	r24, 0x11	; 17
    6040:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <xTaskRemoveFromEventList>
    6044:	88 23       	and	r24, r24
    6046:	61 f0       	breq	.+24     	; 0x6060 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    6048:	ef 81       	ldd	r30, Y+7	; 0x07
    604a:	f8 85       	ldd	r31, Y+8	; 0x08
    604c:	81 e0       	ldi	r24, 0x01	; 1
    604e:	80 83       	st	Z, r24
    6050:	07 c0       	rjmp	.+14     	; 0x6060 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    6052:	eb 81       	ldd	r30, Y+3	; 0x03
    6054:	fc 81       	ldd	r31, Y+4	; 0x04
    6056:	86 8d       	ldd	r24, Z+30	; 0x1e
    6058:	8f 5f       	subi	r24, 0xFF	; 255
    605a:	eb 81       	ldd	r30, Y+3	; 0x03
    605c:	fc 81       	ldd	r31, Y+4	; 0x04
    605e:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    6060:	81 e0       	ldi	r24, 0x01	; 1
    6062:	8a 83       	std	Y+2, r24	; 0x02
    6064:	01 c0       	rjmp	.+2      	; 0x6068 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    6066:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    6068:	8a 81       	ldd	r24, Y+2	; 0x02
}
    606a:	29 96       	adiw	r28, 0x09	; 9
    606c:	0f b6       	in	r0, 0x3f	; 63
    606e:	f8 94       	cli
    6070:	de bf       	out	0x3e, r29	; 62
    6072:	0f be       	out	0x3f, r0	; 63
    6074:	cd bf       	out	0x3d, r28	; 61
    6076:	cf 91       	pop	r28
    6078:	df 91       	pop	r29
    607a:	08 95       	ret

0000607c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    607c:	df 93       	push	r29
    607e:	cf 93       	push	r28
    6080:	cd b7       	in	r28, 0x3d	; 61
    6082:	de b7       	in	r29, 0x3e	; 62
    6084:	2e 97       	sbiw	r28, 0x0e	; 14
    6086:	0f b6       	in	r0, 0x3f	; 63
    6088:	f8 94       	cli
    608a:	de bf       	out	0x3e, r29	; 62
    608c:	0f be       	out	0x3f, r0	; 63
    608e:	cd bf       	out	0x3d, r28	; 61
    6090:	98 87       	std	Y+8, r25	; 0x08
    6092:	8f 83       	std	Y+7, r24	; 0x07
    6094:	7a 87       	std	Y+10, r23	; 0x0a
    6096:	69 87       	std	Y+9, r22	; 0x09
    6098:	5c 87       	std	Y+12, r21	; 0x0c
    609a:	4b 87       	std	Y+11, r20	; 0x0b
    609c:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    609e:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    60a0:	0f b6       	in	r0, 0x3f	; 63
    60a2:	f8 94       	cli
    60a4:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    60a6:	ef 81       	ldd	r30, Y+7	; 0x07
    60a8:	f8 85       	ldd	r31, Y+8	; 0x08
    60aa:	82 8d       	ldd	r24, Z+26	; 0x1a
    60ac:	88 23       	and	r24, r24
    60ae:	09 f4       	brne	.+2      	; 0x60b2 <xQueueGenericReceive+0x36>
    60b0:	3f c0       	rjmp	.+126    	; 0x6130 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    60b2:	ef 81       	ldd	r30, Y+7	; 0x07
    60b4:	f8 85       	ldd	r31, Y+8	; 0x08
    60b6:	86 81       	ldd	r24, Z+6	; 0x06
    60b8:	97 81       	ldd	r25, Z+7	; 0x07
    60ba:	9a 83       	std	Y+2, r25	; 0x02
    60bc:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    60be:	8f 81       	ldd	r24, Y+7	; 0x07
    60c0:	98 85       	ldd	r25, Y+8	; 0x08
    60c2:	29 85       	ldd	r18, Y+9	; 0x09
    60c4:	3a 85       	ldd	r19, Y+10	; 0x0a
    60c6:	b9 01       	movw	r22, r18
    60c8:	0e 94 23 32 	call	0x6446	; 0x6446 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    60cc:	8d 85       	ldd	r24, Y+13	; 0x0d
    60ce:	88 23       	and	r24, r24
    60d0:	b1 f4       	brne	.+44     	; 0x60fe <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    60d2:	ef 81       	ldd	r30, Y+7	; 0x07
    60d4:	f8 85       	ldd	r31, Y+8	; 0x08
    60d6:	82 8d       	ldd	r24, Z+26	; 0x1a
    60d8:	81 50       	subi	r24, 0x01	; 1
    60da:	ef 81       	ldd	r30, Y+7	; 0x07
    60dc:	f8 85       	ldd	r31, Y+8	; 0x08
    60de:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    60e0:	ef 81       	ldd	r30, Y+7	; 0x07
    60e2:	f8 85       	ldd	r31, Y+8	; 0x08
    60e4:	80 85       	ldd	r24, Z+8	; 0x08
    60e6:	88 23       	and	r24, r24
    60e8:	f1 f0       	breq	.+60     	; 0x6126 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    60ea:	8f 81       	ldd	r24, Y+7	; 0x07
    60ec:	98 85       	ldd	r25, Y+8	; 0x08
    60ee:	08 96       	adiw	r24, 0x08	; 8
    60f0:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <xTaskRemoveFromEventList>
    60f4:	81 30       	cpi	r24, 0x01	; 1
    60f6:	b9 f4       	brne	.+46     	; 0x6126 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    60f8:	0e 94 97 2d 	call	0x5b2e	; 0x5b2e <vPortYield>
    60fc:	14 c0       	rjmp	.+40     	; 0x6126 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    60fe:	ef 81       	ldd	r30, Y+7	; 0x07
    6100:	f8 85       	ldd	r31, Y+8	; 0x08
    6102:	89 81       	ldd	r24, Y+1	; 0x01
    6104:	9a 81       	ldd	r25, Y+2	; 0x02
    6106:	97 83       	std	Z+7, r25	; 0x07
    6108:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    610a:	ef 81       	ldd	r30, Y+7	; 0x07
    610c:	f8 85       	ldd	r31, Y+8	; 0x08
    610e:	81 89       	ldd	r24, Z+17	; 0x11
    6110:	88 23       	and	r24, r24
    6112:	49 f0       	breq	.+18     	; 0x6126 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    6114:	8f 81       	ldd	r24, Y+7	; 0x07
    6116:	98 85       	ldd	r25, Y+8	; 0x08
    6118:	41 96       	adiw	r24, 0x11	; 17
    611a:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <xTaskRemoveFromEventList>
    611e:	88 23       	and	r24, r24
    6120:	11 f0       	breq	.+4      	; 0x6126 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    6122:	0e 94 97 2d 	call	0x5b2e	; 0x5b2e <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    6126:	0f 90       	pop	r0
    6128:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    612a:	81 e0       	ldi	r24, 0x01	; 1
    612c:	8e 87       	std	Y+14, r24	; 0x0e
    612e:	5c c0       	rjmp	.+184    	; 0x61e8 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    6130:	8b 85       	ldd	r24, Y+11	; 0x0b
    6132:	9c 85       	ldd	r25, Y+12	; 0x0c
    6134:	00 97       	sbiw	r24, 0x00	; 0
    6136:	21 f4       	brne	.+8      	; 0x6140 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    6138:	0f 90       	pop	r0
    613a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    613c:	1e 86       	std	Y+14, r1	; 0x0e
    613e:	54 c0       	rjmp	.+168    	; 0x61e8 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    6140:	8b 81       	ldd	r24, Y+3	; 0x03
    6142:	88 23       	and	r24, r24
    6144:	31 f4       	brne	.+12     	; 0x6152 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    6146:	ce 01       	movw	r24, r28
    6148:	04 96       	adiw	r24, 0x04	; 4
    614a:	0e 94 0b 38 	call	0x7016	; 0x7016 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    614e:	81 e0       	ldi	r24, 0x01	; 1
    6150:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    6152:	0f 90       	pop	r0
    6154:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    6156:	0e 94 67 35 	call	0x6ace	; 0x6ace <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    615a:	0f b6       	in	r0, 0x3f	; 63
    615c:	f8 94       	cli
    615e:	0f 92       	push	r0
    6160:	ef 81       	ldd	r30, Y+7	; 0x07
    6162:	f8 85       	ldd	r31, Y+8	; 0x08
    6164:	85 8d       	ldd	r24, Z+29	; 0x1d
    6166:	8f 3f       	cpi	r24, 0xFF	; 255
    6168:	19 f4       	brne	.+6      	; 0x6170 <xQueueGenericReceive+0xf4>
    616a:	ef 81       	ldd	r30, Y+7	; 0x07
    616c:	f8 85       	ldd	r31, Y+8	; 0x08
    616e:	15 8e       	std	Z+29, r1	; 0x1d
    6170:	ef 81       	ldd	r30, Y+7	; 0x07
    6172:	f8 85       	ldd	r31, Y+8	; 0x08
    6174:	86 8d       	ldd	r24, Z+30	; 0x1e
    6176:	8f 3f       	cpi	r24, 0xFF	; 255
    6178:	19 f4       	brne	.+6      	; 0x6180 <xQueueGenericReceive+0x104>
    617a:	ef 81       	ldd	r30, Y+7	; 0x07
    617c:	f8 85       	ldd	r31, Y+8	; 0x08
    617e:	16 8e       	std	Z+30, r1	; 0x1e
    6180:	0f 90       	pop	r0
    6182:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    6184:	ce 01       	movw	r24, r28
    6186:	04 96       	adiw	r24, 0x04	; 4
    6188:	9e 01       	movw	r18, r28
    618a:	25 5f       	subi	r18, 0xF5	; 245
    618c:	3f 4f       	sbci	r19, 0xFF	; 255
    618e:	b9 01       	movw	r22, r18
    6190:	0e 94 24 38 	call	0x7048	; 0x7048 <xTaskCheckForTimeOut>
    6194:	88 23       	and	r24, r24
    6196:	09 f5       	brne	.+66     	; 0x61da <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    6198:	8f 81       	ldd	r24, Y+7	; 0x07
    619a:	98 85       	ldd	r25, Y+8	; 0x08
    619c:	0e 94 bf 32 	call	0x657e	; 0x657e <prvIsQueueEmpty>
    61a0:	88 23       	and	r24, r24
    61a2:	a1 f0       	breq	.+40     	; 0x61cc <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    61a4:	8f 81       	ldd	r24, Y+7	; 0x07
    61a6:	98 85       	ldd	r25, Y+8	; 0x08
    61a8:	41 96       	adiw	r24, 0x11	; 17
    61aa:	2b 85       	ldd	r18, Y+11	; 0x0b
    61ac:	3c 85       	ldd	r19, Y+12	; 0x0c
    61ae:	b9 01       	movw	r22, r18
    61b0:	0e 94 6d 37 	call	0x6eda	; 0x6eda <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    61b4:	8f 81       	ldd	r24, Y+7	; 0x07
    61b6:	98 85       	ldd	r25, Y+8	; 0x08
    61b8:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    61bc:	0e 94 73 35 	call	0x6ae6	; 0x6ae6 <xTaskResumeAll>
    61c0:	88 23       	and	r24, r24
    61c2:	09 f0       	breq	.+2      	; 0x61c6 <xQueueGenericReceive+0x14a>
    61c4:	6d cf       	rjmp	.-294    	; 0x60a0 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    61c6:	0e 94 97 2d 	call	0x5b2e	; 0x5b2e <vPortYield>
    61ca:	6a cf       	rjmp	.-300    	; 0x60a0 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    61cc:	8f 81       	ldd	r24, Y+7	; 0x07
    61ce:	98 85       	ldd	r25, Y+8	; 0x08
    61d0:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    61d4:	0e 94 73 35 	call	0x6ae6	; 0x6ae6 <xTaskResumeAll>
    61d8:	63 cf       	rjmp	.-314    	; 0x60a0 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    61da:	8f 81       	ldd	r24, Y+7	; 0x07
    61dc:	98 85       	ldd	r25, Y+8	; 0x08
    61de:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    61e2:	0e 94 73 35 	call	0x6ae6	; 0x6ae6 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    61e6:	1e 86       	std	Y+14, r1	; 0x0e
    61e8:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    61ea:	2e 96       	adiw	r28, 0x0e	; 14
    61ec:	0f b6       	in	r0, 0x3f	; 63
    61ee:	f8 94       	cli
    61f0:	de bf       	out	0x3e, r29	; 62
    61f2:	0f be       	out	0x3f, r0	; 63
    61f4:	cd bf       	out	0x3d, r28	; 61
    61f6:	cf 91       	pop	r28
    61f8:	df 91       	pop	r29
    61fa:	08 95       	ret

000061fc <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    61fc:	df 93       	push	r29
    61fe:	cf 93       	push	r28
    6200:	cd b7       	in	r28, 0x3d	; 61
    6202:	de b7       	in	r29, 0x3e	; 62
    6204:	28 97       	sbiw	r28, 0x08	; 8
    6206:	0f b6       	in	r0, 0x3f	; 63
    6208:	f8 94       	cli
    620a:	de bf       	out	0x3e, r29	; 62
    620c:	0f be       	out	0x3f, r0	; 63
    620e:	cd bf       	out	0x3d, r28	; 61
    6210:	9c 83       	std	Y+4, r25	; 0x04
    6212:	8b 83       	std	Y+3, r24	; 0x03
    6214:	7e 83       	std	Y+6, r23	; 0x06
    6216:	6d 83       	std	Y+5, r22	; 0x05
    6218:	58 87       	std	Y+8, r21	; 0x08
    621a:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    621c:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    621e:	eb 81       	ldd	r30, Y+3	; 0x03
    6220:	fc 81       	ldd	r31, Y+4	; 0x04
    6222:	82 8d       	ldd	r24, Z+26	; 0x1a
    6224:	88 23       	and	r24, r24
    6226:	71 f1       	breq	.+92     	; 0x6284 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    6228:	8b 81       	ldd	r24, Y+3	; 0x03
    622a:	9c 81       	ldd	r25, Y+4	; 0x04
    622c:	2d 81       	ldd	r18, Y+5	; 0x05
    622e:	3e 81       	ldd	r19, Y+6	; 0x06
    6230:	b9 01       	movw	r22, r18
    6232:	0e 94 23 32 	call	0x6446	; 0x6446 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    6236:	eb 81       	ldd	r30, Y+3	; 0x03
    6238:	fc 81       	ldd	r31, Y+4	; 0x04
    623a:	82 8d       	ldd	r24, Z+26	; 0x1a
    623c:	81 50       	subi	r24, 0x01	; 1
    623e:	eb 81       	ldd	r30, Y+3	; 0x03
    6240:	fc 81       	ldd	r31, Y+4	; 0x04
    6242:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    6244:	eb 81       	ldd	r30, Y+3	; 0x03
    6246:	fc 81       	ldd	r31, Y+4	; 0x04
    6248:	85 8d       	ldd	r24, Z+29	; 0x1d
    624a:	8f 3f       	cpi	r24, 0xFF	; 255
    624c:	89 f4       	brne	.+34     	; 0x6270 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    624e:	eb 81       	ldd	r30, Y+3	; 0x03
    6250:	fc 81       	ldd	r31, Y+4	; 0x04
    6252:	80 85       	ldd	r24, Z+8	; 0x08
    6254:	88 23       	and	r24, r24
    6256:	99 f0       	breq	.+38     	; 0x627e <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    6258:	8b 81       	ldd	r24, Y+3	; 0x03
    625a:	9c 81       	ldd	r25, Y+4	; 0x04
    625c:	08 96       	adiw	r24, 0x08	; 8
    625e:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <xTaskRemoveFromEventList>
    6262:	88 23       	and	r24, r24
    6264:	61 f0       	breq	.+24     	; 0x627e <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    6266:	ef 81       	ldd	r30, Y+7	; 0x07
    6268:	f8 85       	ldd	r31, Y+8	; 0x08
    626a:	81 e0       	ldi	r24, 0x01	; 1
    626c:	80 83       	st	Z, r24
    626e:	07 c0       	rjmp	.+14     	; 0x627e <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    6270:	eb 81       	ldd	r30, Y+3	; 0x03
    6272:	fc 81       	ldd	r31, Y+4	; 0x04
    6274:	85 8d       	ldd	r24, Z+29	; 0x1d
    6276:	8f 5f       	subi	r24, 0xFF	; 255
    6278:	eb 81       	ldd	r30, Y+3	; 0x03
    627a:	fc 81       	ldd	r31, Y+4	; 0x04
    627c:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    627e:	81 e0       	ldi	r24, 0x01	; 1
    6280:	8a 83       	std	Y+2, r24	; 0x02
    6282:	01 c0       	rjmp	.+2      	; 0x6286 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    6284:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    6286:	8a 81       	ldd	r24, Y+2	; 0x02
}
    6288:	28 96       	adiw	r28, 0x08	; 8
    628a:	0f b6       	in	r0, 0x3f	; 63
    628c:	f8 94       	cli
    628e:	de bf       	out	0x3e, r29	; 62
    6290:	0f be       	out	0x3f, r0	; 63
    6292:	cd bf       	out	0x3d, r28	; 61
    6294:	cf 91       	pop	r28
    6296:	df 91       	pop	r29
    6298:	08 95       	ret

0000629a <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    629a:	df 93       	push	r29
    629c:	cf 93       	push	r28
    629e:	00 d0       	rcall	.+0      	; 0x62a0 <uxQueueMessagesWaiting+0x6>
    62a0:	0f 92       	push	r0
    62a2:	cd b7       	in	r28, 0x3d	; 61
    62a4:	de b7       	in	r29, 0x3e	; 62
    62a6:	9b 83       	std	Y+3, r25	; 0x03
    62a8:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    62aa:	0f b6       	in	r0, 0x3f	; 63
    62ac:	f8 94       	cli
    62ae:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    62b0:	ea 81       	ldd	r30, Y+2	; 0x02
    62b2:	fb 81       	ldd	r31, Y+3	; 0x03
    62b4:	82 8d       	ldd	r24, Z+26	; 0x1a
    62b6:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    62b8:	0f 90       	pop	r0
    62ba:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    62bc:	89 81       	ldd	r24, Y+1	; 0x01
}
    62be:	0f 90       	pop	r0
    62c0:	0f 90       	pop	r0
    62c2:	0f 90       	pop	r0
    62c4:	cf 91       	pop	r28
    62c6:	df 91       	pop	r29
    62c8:	08 95       	ret

000062ca <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    62ca:	df 93       	push	r29
    62cc:	cf 93       	push	r28
    62ce:	00 d0       	rcall	.+0      	; 0x62d0 <uxQueueMessagesWaitingFromISR+0x6>
    62d0:	0f 92       	push	r0
    62d2:	cd b7       	in	r28, 0x3d	; 61
    62d4:	de b7       	in	r29, 0x3e	; 62
    62d6:	9b 83       	std	Y+3, r25	; 0x03
    62d8:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    62da:	ea 81       	ldd	r30, Y+2	; 0x02
    62dc:	fb 81       	ldd	r31, Y+3	; 0x03
    62de:	82 8d       	ldd	r24, Z+26	; 0x1a
    62e0:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    62e2:	89 81       	ldd	r24, Y+1	; 0x01
}
    62e4:	0f 90       	pop	r0
    62e6:	0f 90       	pop	r0
    62e8:	0f 90       	pop	r0
    62ea:	cf 91       	pop	r28
    62ec:	df 91       	pop	r29
    62ee:	08 95       	ret

000062f0 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    62f0:	df 93       	push	r29
    62f2:	cf 93       	push	r28
    62f4:	00 d0       	rcall	.+0      	; 0x62f6 <vQueueDelete+0x6>
    62f6:	cd b7       	in	r28, 0x3d	; 61
    62f8:	de b7       	in	r29, 0x3e	; 62
    62fa:	9a 83       	std	Y+2, r25	; 0x02
    62fc:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    62fe:	e9 81       	ldd	r30, Y+1	; 0x01
    6300:	fa 81       	ldd	r31, Y+2	; 0x02
    6302:	80 81       	ld	r24, Z
    6304:	91 81       	ldd	r25, Z+1	; 0x01
    6306:	0e 94 77 2a 	call	0x54ee	; 0x54ee <vPortFree>
	vPortFree( pxQueue );
    630a:	89 81       	ldd	r24, Y+1	; 0x01
    630c:	9a 81       	ldd	r25, Y+2	; 0x02
    630e:	0e 94 77 2a 	call	0x54ee	; 0x54ee <vPortFree>
}
    6312:	0f 90       	pop	r0
    6314:	0f 90       	pop	r0
    6316:	cf 91       	pop	r28
    6318:	df 91       	pop	r29
    631a:	08 95       	ret

0000631c <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    631c:	df 93       	push	r29
    631e:	cf 93       	push	r28
    6320:	00 d0       	rcall	.+0      	; 0x6322 <prvCopyDataToQueue+0x6>
    6322:	00 d0       	rcall	.+0      	; 0x6324 <prvCopyDataToQueue+0x8>
    6324:	0f 92       	push	r0
    6326:	cd b7       	in	r28, 0x3d	; 61
    6328:	de b7       	in	r29, 0x3e	; 62
    632a:	9a 83       	std	Y+2, r25	; 0x02
    632c:	89 83       	std	Y+1, r24	; 0x01
    632e:	7c 83       	std	Y+4, r23	; 0x04
    6330:	6b 83       	std	Y+3, r22	; 0x03
    6332:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    6334:	e9 81       	ldd	r30, Y+1	; 0x01
    6336:	fa 81       	ldd	r31, Y+2	; 0x02
    6338:	84 8d       	ldd	r24, Z+28	; 0x1c
    633a:	88 23       	and	r24, r24
    633c:	09 f4       	brne	.+2      	; 0x6340 <prvCopyDataToQueue+0x24>
    633e:	74 c0       	rjmp	.+232    	; 0x6428 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    6340:	8d 81       	ldd	r24, Y+5	; 0x05
    6342:	88 23       	and	r24, r24
    6344:	99 f5       	brne	.+102    	; 0x63ac <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    6346:	e9 81       	ldd	r30, Y+1	; 0x01
    6348:	fa 81       	ldd	r31, Y+2	; 0x02
    634a:	64 81       	ldd	r22, Z+4	; 0x04
    634c:	75 81       	ldd	r23, Z+5	; 0x05
    634e:	e9 81       	ldd	r30, Y+1	; 0x01
    6350:	fa 81       	ldd	r31, Y+2	; 0x02
    6352:	84 8d       	ldd	r24, Z+28	; 0x1c
    6354:	48 2f       	mov	r20, r24
    6356:	50 e0       	ldi	r21, 0x00	; 0
    6358:	2b 81       	ldd	r18, Y+3	; 0x03
    635a:	3c 81       	ldd	r19, Y+4	; 0x04
    635c:	cb 01       	movw	r24, r22
    635e:	b9 01       	movw	r22, r18
    6360:	0e 94 61 3a 	call	0x74c2	; 0x74c2 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    6364:	e9 81       	ldd	r30, Y+1	; 0x01
    6366:	fa 81       	ldd	r31, Y+2	; 0x02
    6368:	24 81       	ldd	r18, Z+4	; 0x04
    636a:	35 81       	ldd	r19, Z+5	; 0x05
    636c:	e9 81       	ldd	r30, Y+1	; 0x01
    636e:	fa 81       	ldd	r31, Y+2	; 0x02
    6370:	84 8d       	ldd	r24, Z+28	; 0x1c
    6372:	88 2f       	mov	r24, r24
    6374:	90 e0       	ldi	r25, 0x00	; 0
    6376:	82 0f       	add	r24, r18
    6378:	93 1f       	adc	r25, r19
    637a:	e9 81       	ldd	r30, Y+1	; 0x01
    637c:	fa 81       	ldd	r31, Y+2	; 0x02
    637e:	95 83       	std	Z+5, r25	; 0x05
    6380:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    6382:	e9 81       	ldd	r30, Y+1	; 0x01
    6384:	fa 81       	ldd	r31, Y+2	; 0x02
    6386:	24 81       	ldd	r18, Z+4	; 0x04
    6388:	35 81       	ldd	r19, Z+5	; 0x05
    638a:	e9 81       	ldd	r30, Y+1	; 0x01
    638c:	fa 81       	ldd	r31, Y+2	; 0x02
    638e:	82 81       	ldd	r24, Z+2	; 0x02
    6390:	93 81       	ldd	r25, Z+3	; 0x03
    6392:	28 17       	cp	r18, r24
    6394:	39 07       	cpc	r19, r25
    6396:	08 f4       	brcc	.+2      	; 0x639a <prvCopyDataToQueue+0x7e>
    6398:	47 c0       	rjmp	.+142    	; 0x6428 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    639a:	e9 81       	ldd	r30, Y+1	; 0x01
    639c:	fa 81       	ldd	r31, Y+2	; 0x02
    639e:	80 81       	ld	r24, Z
    63a0:	91 81       	ldd	r25, Z+1	; 0x01
    63a2:	e9 81       	ldd	r30, Y+1	; 0x01
    63a4:	fa 81       	ldd	r31, Y+2	; 0x02
    63a6:	95 83       	std	Z+5, r25	; 0x05
    63a8:	84 83       	std	Z+4, r24	; 0x04
    63aa:	3e c0       	rjmp	.+124    	; 0x6428 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    63ac:	e9 81       	ldd	r30, Y+1	; 0x01
    63ae:	fa 81       	ldd	r31, Y+2	; 0x02
    63b0:	66 81       	ldd	r22, Z+6	; 0x06
    63b2:	77 81       	ldd	r23, Z+7	; 0x07
    63b4:	e9 81       	ldd	r30, Y+1	; 0x01
    63b6:	fa 81       	ldd	r31, Y+2	; 0x02
    63b8:	84 8d       	ldd	r24, Z+28	; 0x1c
    63ba:	48 2f       	mov	r20, r24
    63bc:	50 e0       	ldi	r21, 0x00	; 0
    63be:	2b 81       	ldd	r18, Y+3	; 0x03
    63c0:	3c 81       	ldd	r19, Y+4	; 0x04
    63c2:	cb 01       	movw	r24, r22
    63c4:	b9 01       	movw	r22, r18
    63c6:	0e 94 61 3a 	call	0x74c2	; 0x74c2 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    63ca:	e9 81       	ldd	r30, Y+1	; 0x01
    63cc:	fa 81       	ldd	r31, Y+2	; 0x02
    63ce:	26 81       	ldd	r18, Z+6	; 0x06
    63d0:	37 81       	ldd	r19, Z+7	; 0x07
    63d2:	e9 81       	ldd	r30, Y+1	; 0x01
    63d4:	fa 81       	ldd	r31, Y+2	; 0x02
    63d6:	84 8d       	ldd	r24, Z+28	; 0x1c
    63d8:	88 2f       	mov	r24, r24
    63da:	90 e0       	ldi	r25, 0x00	; 0
    63dc:	90 95       	com	r25
    63de:	81 95       	neg	r24
    63e0:	9f 4f       	sbci	r25, 0xFF	; 255
    63e2:	82 0f       	add	r24, r18
    63e4:	93 1f       	adc	r25, r19
    63e6:	e9 81       	ldd	r30, Y+1	; 0x01
    63e8:	fa 81       	ldd	r31, Y+2	; 0x02
    63ea:	97 83       	std	Z+7, r25	; 0x07
    63ec:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    63ee:	e9 81       	ldd	r30, Y+1	; 0x01
    63f0:	fa 81       	ldd	r31, Y+2	; 0x02
    63f2:	26 81       	ldd	r18, Z+6	; 0x06
    63f4:	37 81       	ldd	r19, Z+7	; 0x07
    63f6:	e9 81       	ldd	r30, Y+1	; 0x01
    63f8:	fa 81       	ldd	r31, Y+2	; 0x02
    63fa:	80 81       	ld	r24, Z
    63fc:	91 81       	ldd	r25, Z+1	; 0x01
    63fe:	28 17       	cp	r18, r24
    6400:	39 07       	cpc	r19, r25
    6402:	90 f4       	brcc	.+36     	; 0x6428 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    6404:	e9 81       	ldd	r30, Y+1	; 0x01
    6406:	fa 81       	ldd	r31, Y+2	; 0x02
    6408:	22 81       	ldd	r18, Z+2	; 0x02
    640a:	33 81       	ldd	r19, Z+3	; 0x03
    640c:	e9 81       	ldd	r30, Y+1	; 0x01
    640e:	fa 81       	ldd	r31, Y+2	; 0x02
    6410:	84 8d       	ldd	r24, Z+28	; 0x1c
    6412:	88 2f       	mov	r24, r24
    6414:	90 e0       	ldi	r25, 0x00	; 0
    6416:	90 95       	com	r25
    6418:	81 95       	neg	r24
    641a:	9f 4f       	sbci	r25, 0xFF	; 255
    641c:	82 0f       	add	r24, r18
    641e:	93 1f       	adc	r25, r19
    6420:	e9 81       	ldd	r30, Y+1	; 0x01
    6422:	fa 81       	ldd	r31, Y+2	; 0x02
    6424:	97 83       	std	Z+7, r25	; 0x07
    6426:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    6428:	e9 81       	ldd	r30, Y+1	; 0x01
    642a:	fa 81       	ldd	r31, Y+2	; 0x02
    642c:	82 8d       	ldd	r24, Z+26	; 0x1a
    642e:	8f 5f       	subi	r24, 0xFF	; 255
    6430:	e9 81       	ldd	r30, Y+1	; 0x01
    6432:	fa 81       	ldd	r31, Y+2	; 0x02
    6434:	82 8f       	std	Z+26, r24	; 0x1a
}
    6436:	0f 90       	pop	r0
    6438:	0f 90       	pop	r0
    643a:	0f 90       	pop	r0
    643c:	0f 90       	pop	r0
    643e:	0f 90       	pop	r0
    6440:	cf 91       	pop	r28
    6442:	df 91       	pop	r29
    6444:	08 95       	ret

00006446 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    6446:	df 93       	push	r29
    6448:	cf 93       	push	r28
    644a:	00 d0       	rcall	.+0      	; 0x644c <prvCopyDataFromQueue+0x6>
    644c:	00 d0       	rcall	.+0      	; 0x644e <prvCopyDataFromQueue+0x8>
    644e:	cd b7       	in	r28, 0x3d	; 61
    6450:	de b7       	in	r29, 0x3e	; 62
    6452:	9a 83       	std	Y+2, r25	; 0x02
    6454:	89 83       	std	Y+1, r24	; 0x01
    6456:	7c 83       	std	Y+4, r23	; 0x04
    6458:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    645a:	e9 81       	ldd	r30, Y+1	; 0x01
    645c:	fa 81       	ldd	r31, Y+2	; 0x02
    645e:	80 81       	ld	r24, Z
    6460:	91 81       	ldd	r25, Z+1	; 0x01
    6462:	00 97       	sbiw	r24, 0x00	; 0
    6464:	89 f1       	breq	.+98     	; 0x64c8 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    6466:	e9 81       	ldd	r30, Y+1	; 0x01
    6468:	fa 81       	ldd	r31, Y+2	; 0x02
    646a:	26 81       	ldd	r18, Z+6	; 0x06
    646c:	37 81       	ldd	r19, Z+7	; 0x07
    646e:	e9 81       	ldd	r30, Y+1	; 0x01
    6470:	fa 81       	ldd	r31, Y+2	; 0x02
    6472:	84 8d       	ldd	r24, Z+28	; 0x1c
    6474:	88 2f       	mov	r24, r24
    6476:	90 e0       	ldi	r25, 0x00	; 0
    6478:	82 0f       	add	r24, r18
    647a:	93 1f       	adc	r25, r19
    647c:	e9 81       	ldd	r30, Y+1	; 0x01
    647e:	fa 81       	ldd	r31, Y+2	; 0x02
    6480:	97 83       	std	Z+7, r25	; 0x07
    6482:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    6484:	e9 81       	ldd	r30, Y+1	; 0x01
    6486:	fa 81       	ldd	r31, Y+2	; 0x02
    6488:	26 81       	ldd	r18, Z+6	; 0x06
    648a:	37 81       	ldd	r19, Z+7	; 0x07
    648c:	e9 81       	ldd	r30, Y+1	; 0x01
    648e:	fa 81       	ldd	r31, Y+2	; 0x02
    6490:	82 81       	ldd	r24, Z+2	; 0x02
    6492:	93 81       	ldd	r25, Z+3	; 0x03
    6494:	28 17       	cp	r18, r24
    6496:	39 07       	cpc	r19, r25
    6498:	40 f0       	brcs	.+16     	; 0x64aa <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    649a:	e9 81       	ldd	r30, Y+1	; 0x01
    649c:	fa 81       	ldd	r31, Y+2	; 0x02
    649e:	80 81       	ld	r24, Z
    64a0:	91 81       	ldd	r25, Z+1	; 0x01
    64a2:	e9 81       	ldd	r30, Y+1	; 0x01
    64a4:	fa 81       	ldd	r31, Y+2	; 0x02
    64a6:	97 83       	std	Z+7, r25	; 0x07
    64a8:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    64aa:	e9 81       	ldd	r30, Y+1	; 0x01
    64ac:	fa 81       	ldd	r31, Y+2	; 0x02
    64ae:	46 81       	ldd	r20, Z+6	; 0x06
    64b0:	57 81       	ldd	r21, Z+7	; 0x07
    64b2:	e9 81       	ldd	r30, Y+1	; 0x01
    64b4:	fa 81       	ldd	r31, Y+2	; 0x02
    64b6:	84 8d       	ldd	r24, Z+28	; 0x1c
    64b8:	28 2f       	mov	r18, r24
    64ba:	30 e0       	ldi	r19, 0x00	; 0
    64bc:	8b 81       	ldd	r24, Y+3	; 0x03
    64be:	9c 81       	ldd	r25, Y+4	; 0x04
    64c0:	ba 01       	movw	r22, r20
    64c2:	a9 01       	movw	r20, r18
    64c4:	0e 94 61 3a 	call	0x74c2	; 0x74c2 <memcpy>
	}
}
    64c8:	0f 90       	pop	r0
    64ca:	0f 90       	pop	r0
    64cc:	0f 90       	pop	r0
    64ce:	0f 90       	pop	r0
    64d0:	cf 91       	pop	r28
    64d2:	df 91       	pop	r29
    64d4:	08 95       	ret

000064d6 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    64d6:	df 93       	push	r29
    64d8:	cf 93       	push	r28
    64da:	00 d0       	rcall	.+0      	; 0x64dc <prvUnlockQueue+0x6>
    64dc:	cd b7       	in	r28, 0x3d	; 61
    64de:	de b7       	in	r29, 0x3e	; 62
    64e0:	9a 83       	std	Y+2, r25	; 0x02
    64e2:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    64e4:	0f b6       	in	r0, 0x3f	; 63
    64e6:	f8 94       	cli
    64e8:	0f 92       	push	r0
    64ea:	15 c0       	rjmp	.+42     	; 0x6516 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    64ec:	e9 81       	ldd	r30, Y+1	; 0x01
    64ee:	fa 81       	ldd	r31, Y+2	; 0x02
    64f0:	81 89       	ldd	r24, Z+17	; 0x11
    64f2:	88 23       	and	r24, r24
    64f4:	a9 f0       	breq	.+42     	; 0x6520 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    64f6:	89 81       	ldd	r24, Y+1	; 0x01
    64f8:	9a 81       	ldd	r25, Y+2	; 0x02
    64fa:	41 96       	adiw	r24, 0x11	; 17
    64fc:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <xTaskRemoveFromEventList>
    6500:	88 23       	and	r24, r24
    6502:	11 f0       	breq	.+4      	; 0x6508 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    6504:	0e 94 81 38 	call	0x7102	; 0x7102 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    6508:	e9 81       	ldd	r30, Y+1	; 0x01
    650a:	fa 81       	ldd	r31, Y+2	; 0x02
    650c:	86 8d       	ldd	r24, Z+30	; 0x1e
    650e:	81 50       	subi	r24, 0x01	; 1
    6510:	e9 81       	ldd	r30, Y+1	; 0x01
    6512:	fa 81       	ldd	r31, Y+2	; 0x02
    6514:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    6516:	e9 81       	ldd	r30, Y+1	; 0x01
    6518:	fa 81       	ldd	r31, Y+2	; 0x02
    651a:	86 8d       	ldd	r24, Z+30	; 0x1e
    651c:	18 16       	cp	r1, r24
    651e:	34 f3       	brlt	.-52     	; 0x64ec <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    6520:	e9 81       	ldd	r30, Y+1	; 0x01
    6522:	fa 81       	ldd	r31, Y+2	; 0x02
    6524:	8f ef       	ldi	r24, 0xFF	; 255
    6526:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    6528:	0f 90       	pop	r0
    652a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    652c:	0f b6       	in	r0, 0x3f	; 63
    652e:	f8 94       	cli
    6530:	0f 92       	push	r0
    6532:	15 c0       	rjmp	.+42     	; 0x655e <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    6534:	e9 81       	ldd	r30, Y+1	; 0x01
    6536:	fa 81       	ldd	r31, Y+2	; 0x02
    6538:	80 85       	ldd	r24, Z+8	; 0x08
    653a:	88 23       	and	r24, r24
    653c:	a9 f0       	breq	.+42     	; 0x6568 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    653e:	89 81       	ldd	r24, Y+1	; 0x01
    6540:	9a 81       	ldd	r25, Y+2	; 0x02
    6542:	08 96       	adiw	r24, 0x08	; 8
    6544:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <xTaskRemoveFromEventList>
    6548:	88 23       	and	r24, r24
    654a:	11 f0       	breq	.+4      	; 0x6550 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    654c:	0e 94 81 38 	call	0x7102	; 0x7102 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    6550:	e9 81       	ldd	r30, Y+1	; 0x01
    6552:	fa 81       	ldd	r31, Y+2	; 0x02
    6554:	85 8d       	ldd	r24, Z+29	; 0x1d
    6556:	81 50       	subi	r24, 0x01	; 1
    6558:	e9 81       	ldd	r30, Y+1	; 0x01
    655a:	fa 81       	ldd	r31, Y+2	; 0x02
    655c:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    655e:	e9 81       	ldd	r30, Y+1	; 0x01
    6560:	fa 81       	ldd	r31, Y+2	; 0x02
    6562:	85 8d       	ldd	r24, Z+29	; 0x1d
    6564:	18 16       	cp	r1, r24
    6566:	34 f3       	brlt	.-52     	; 0x6534 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    6568:	e9 81       	ldd	r30, Y+1	; 0x01
    656a:	fa 81       	ldd	r31, Y+2	; 0x02
    656c:	8f ef       	ldi	r24, 0xFF	; 255
    656e:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    6570:	0f 90       	pop	r0
    6572:	0f be       	out	0x3f, r0	; 63
}
    6574:	0f 90       	pop	r0
    6576:	0f 90       	pop	r0
    6578:	cf 91       	pop	r28
    657a:	df 91       	pop	r29
    657c:	08 95       	ret

0000657e <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    657e:	df 93       	push	r29
    6580:	cf 93       	push	r28
    6582:	00 d0       	rcall	.+0      	; 0x6584 <prvIsQueueEmpty+0x6>
    6584:	0f 92       	push	r0
    6586:	cd b7       	in	r28, 0x3d	; 61
    6588:	de b7       	in	r29, 0x3e	; 62
    658a:	9b 83       	std	Y+3, r25	; 0x03
    658c:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    658e:	0f b6       	in	r0, 0x3f	; 63
    6590:	f8 94       	cli
    6592:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    6594:	ea 81       	ldd	r30, Y+2	; 0x02
    6596:	fb 81       	ldd	r31, Y+3	; 0x03
    6598:	82 8d       	ldd	r24, Z+26	; 0x1a
    659a:	19 82       	std	Y+1, r1	; 0x01
    659c:	88 23       	and	r24, r24
    659e:	11 f4       	brne	.+4      	; 0x65a4 <prvIsQueueEmpty+0x26>
    65a0:	81 e0       	ldi	r24, 0x01	; 1
    65a2:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    65a4:	0f 90       	pop	r0
    65a6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    65a8:	89 81       	ldd	r24, Y+1	; 0x01
}
    65aa:	0f 90       	pop	r0
    65ac:	0f 90       	pop	r0
    65ae:	0f 90       	pop	r0
    65b0:	cf 91       	pop	r28
    65b2:	df 91       	pop	r29
    65b4:	08 95       	ret

000065b6 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    65b6:	df 93       	push	r29
    65b8:	cf 93       	push	r28
    65ba:	00 d0       	rcall	.+0      	; 0x65bc <xQueueIsQueueEmptyFromISR+0x6>
    65bc:	0f 92       	push	r0
    65be:	cd b7       	in	r28, 0x3d	; 61
    65c0:	de b7       	in	r29, 0x3e	; 62
    65c2:	9b 83       	std	Y+3, r25	; 0x03
    65c4:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    65c6:	ea 81       	ldd	r30, Y+2	; 0x02
    65c8:	fb 81       	ldd	r31, Y+3	; 0x03
    65ca:	82 8d       	ldd	r24, Z+26	; 0x1a
    65cc:	19 82       	std	Y+1, r1	; 0x01
    65ce:	88 23       	and	r24, r24
    65d0:	11 f4       	brne	.+4      	; 0x65d6 <xQueueIsQueueEmptyFromISR+0x20>
    65d2:	81 e0       	ldi	r24, 0x01	; 1
    65d4:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    65d6:	89 81       	ldd	r24, Y+1	; 0x01
}
    65d8:	0f 90       	pop	r0
    65da:	0f 90       	pop	r0
    65dc:	0f 90       	pop	r0
    65de:	cf 91       	pop	r28
    65e0:	df 91       	pop	r29
    65e2:	08 95       	ret

000065e4 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    65e4:	df 93       	push	r29
    65e6:	cf 93       	push	r28
    65e8:	00 d0       	rcall	.+0      	; 0x65ea <prvIsQueueFull+0x6>
    65ea:	0f 92       	push	r0
    65ec:	cd b7       	in	r28, 0x3d	; 61
    65ee:	de b7       	in	r29, 0x3e	; 62
    65f0:	9b 83       	std	Y+3, r25	; 0x03
    65f2:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    65f4:	0f b6       	in	r0, 0x3f	; 63
    65f6:	f8 94       	cli
    65f8:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    65fa:	ea 81       	ldd	r30, Y+2	; 0x02
    65fc:	fb 81       	ldd	r31, Y+3	; 0x03
    65fe:	92 8d       	ldd	r25, Z+26	; 0x1a
    6600:	ea 81       	ldd	r30, Y+2	; 0x02
    6602:	fb 81       	ldd	r31, Y+3	; 0x03
    6604:	83 8d       	ldd	r24, Z+27	; 0x1b
    6606:	19 82       	std	Y+1, r1	; 0x01
    6608:	98 17       	cp	r25, r24
    660a:	11 f4       	brne	.+4      	; 0x6610 <prvIsQueueFull+0x2c>
    660c:	81 e0       	ldi	r24, 0x01	; 1
    660e:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    6610:	0f 90       	pop	r0
    6612:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    6614:	89 81       	ldd	r24, Y+1	; 0x01
}
    6616:	0f 90       	pop	r0
    6618:	0f 90       	pop	r0
    661a:	0f 90       	pop	r0
    661c:	cf 91       	pop	r28
    661e:	df 91       	pop	r29
    6620:	08 95       	ret

00006622 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    6622:	df 93       	push	r29
    6624:	cf 93       	push	r28
    6626:	00 d0       	rcall	.+0      	; 0x6628 <xQueueIsQueueFullFromISR+0x6>
    6628:	0f 92       	push	r0
    662a:	cd b7       	in	r28, 0x3d	; 61
    662c:	de b7       	in	r29, 0x3e	; 62
    662e:	9b 83       	std	Y+3, r25	; 0x03
    6630:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    6632:	ea 81       	ldd	r30, Y+2	; 0x02
    6634:	fb 81       	ldd	r31, Y+3	; 0x03
    6636:	92 8d       	ldd	r25, Z+26	; 0x1a
    6638:	ea 81       	ldd	r30, Y+2	; 0x02
    663a:	fb 81       	ldd	r31, Y+3	; 0x03
    663c:	83 8d       	ldd	r24, Z+27	; 0x1b
    663e:	19 82       	std	Y+1, r1	; 0x01
    6640:	98 17       	cp	r25, r24
    6642:	11 f4       	brne	.+4      	; 0x6648 <xQueueIsQueueFullFromISR+0x26>
    6644:	81 e0       	ldi	r24, 0x01	; 1
    6646:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    6648:	89 81       	ldd	r24, Y+1	; 0x01
}
    664a:	0f 90       	pop	r0
    664c:	0f 90       	pop	r0
    664e:	0f 90       	pop	r0
    6650:	cf 91       	pop	r28
    6652:	df 91       	pop	r29
    6654:	08 95       	ret

00006656 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    6656:	af 92       	push	r10
    6658:	bf 92       	push	r11
    665a:	cf 92       	push	r12
    665c:	df 92       	push	r13
    665e:	ef 92       	push	r14
    6660:	ff 92       	push	r15
    6662:	0f 93       	push	r16
    6664:	1f 93       	push	r17
    6666:	df 93       	push	r29
    6668:	cf 93       	push	r28
    666a:	cd b7       	in	r28, 0x3d	; 61
    666c:	de b7       	in	r29, 0x3e	; 62
    666e:	64 97       	sbiw	r28, 0x14	; 20
    6670:	0f b6       	in	r0, 0x3f	; 63
    6672:	f8 94       	cli
    6674:	de bf       	out	0x3e, r29	; 62
    6676:	0f be       	out	0x3f, r0	; 63
    6678:	cd bf       	out	0x3d, r28	; 61
    667a:	9f 83       	std	Y+7, r25	; 0x07
    667c:	8e 83       	std	Y+6, r24	; 0x06
    667e:	79 87       	std	Y+9, r23	; 0x09
    6680:	68 87       	std	Y+8, r22	; 0x08
    6682:	5b 87       	std	Y+11, r21	; 0x0b
    6684:	4a 87       	std	Y+10, r20	; 0x0a
    6686:	3d 87       	std	Y+13, r19	; 0x0d
    6688:	2c 87       	std	Y+12, r18	; 0x0c
    668a:	0e 87       	std	Y+14, r16	; 0x0e
    668c:	f8 8a       	std	Y+16, r15	; 0x10
    668e:	ef 86       	std	Y+15, r14	; 0x0f
    6690:	da 8a       	std	Y+18, r13	; 0x12
    6692:	c9 8a       	std	Y+17, r12	; 0x11
    6694:	bc 8a       	std	Y+20, r11	; 0x14
    6696:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    6698:	8a 85       	ldd	r24, Y+10	; 0x0a
    669a:	9b 85       	ldd	r25, Y+11	; 0x0b
    669c:	29 89       	ldd	r18, Y+17	; 0x11
    669e:	3a 89       	ldd	r19, Y+18	; 0x12
    66a0:	b9 01       	movw	r22, r18
    66a2:	0e 94 b0 39 	call	0x7360	; 0x7360 <prvAllocateTCBAndStack>
    66a6:	9c 83       	std	Y+4, r25	; 0x04
    66a8:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    66aa:	8b 81       	ldd	r24, Y+3	; 0x03
    66ac:	9c 81       	ldd	r25, Y+4	; 0x04
    66ae:	00 97       	sbiw	r24, 0x00	; 0
    66b0:	09 f4       	brne	.+2      	; 0x66b4 <xTaskGenericCreate+0x5e>
    66b2:	99 c0       	rjmp	.+306    	; 0x67e6 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    66b4:	eb 81       	ldd	r30, Y+3	; 0x03
    66b6:	fc 81       	ldd	r31, Y+4	; 0x04
    66b8:	27 89       	ldd	r18, Z+23	; 0x17
    66ba:	30 8d       	ldd	r19, Z+24	; 0x18
    66bc:	8a 85       	ldd	r24, Y+10	; 0x0a
    66be:	9b 85       	ldd	r25, Y+11	; 0x0b
    66c0:	01 97       	sbiw	r24, 0x01	; 1
    66c2:	82 0f       	add	r24, r18
    66c4:	93 1f       	adc	r25, r19
    66c6:	9a 83       	std	Y+2, r25	; 0x02
    66c8:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    66ca:	8b 81       	ldd	r24, Y+3	; 0x03
    66cc:	9c 81       	ldd	r25, Y+4	; 0x04
    66ce:	28 85       	ldd	r18, Y+8	; 0x08
    66d0:	39 85       	ldd	r19, Y+9	; 0x09
    66d2:	eb 89       	ldd	r30, Y+19	; 0x13
    66d4:	fc 89       	ldd	r31, Y+20	; 0x14
    66d6:	aa 85       	ldd	r26, Y+10	; 0x0a
    66d8:	bb 85       	ldd	r27, Y+11	; 0x0b
    66da:	b9 01       	movw	r22, r18
    66dc:	4e 85       	ldd	r20, Y+14	; 0x0e
    66de:	9f 01       	movw	r18, r30
    66e0:	8d 01       	movw	r16, r26
    66e2:	0e 94 95 38 	call	0x712a	; 0x712a <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    66e6:	89 81       	ldd	r24, Y+1	; 0x01
    66e8:	9a 81       	ldd	r25, Y+2	; 0x02
    66ea:	2e 81       	ldd	r18, Y+6	; 0x06
    66ec:	3f 81       	ldd	r19, Y+7	; 0x07
    66ee:	4c 85       	ldd	r20, Y+12	; 0x0c
    66f0:	5d 85       	ldd	r21, Y+13	; 0x0d
    66f2:	b9 01       	movw	r22, r18
    66f4:	0e 94 d8 2b 	call	0x57b0	; 0x57b0 <pxPortInitialiseStack>
    66f8:	eb 81       	ldd	r30, Y+3	; 0x03
    66fa:	fc 81       	ldd	r31, Y+4	; 0x04
    66fc:	91 83       	std	Z+1, r25	; 0x01
    66fe:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    6700:	8f 85       	ldd	r24, Y+15	; 0x0f
    6702:	98 89       	ldd	r25, Y+16	; 0x10
    6704:	00 97       	sbiw	r24, 0x00	; 0
    6706:	31 f0       	breq	.+12     	; 0x6714 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    6708:	ef 85       	ldd	r30, Y+15	; 0x0f
    670a:	f8 89       	ldd	r31, Y+16	; 0x10
    670c:	8b 81       	ldd	r24, Y+3	; 0x03
    670e:	9c 81       	ldd	r25, Y+4	; 0x04
    6710:	91 83       	std	Z+1, r25	; 0x01
    6712:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    6714:	0f b6       	in	r0, 0x3f	; 63
    6716:	f8 94       	cli
    6718:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    671a:	80 91 c7 06 	lds	r24, 0x06C7
    671e:	8f 5f       	subi	r24, 0xFF	; 255
    6720:	80 93 c7 06 	sts	0x06C7, r24
			if( pxCurrentTCB == NULL )
    6724:	80 91 c4 06 	lds	r24, 0x06C4
    6728:	90 91 c5 06 	lds	r25, 0x06C5
    672c:	00 97       	sbiw	r24, 0x00	; 0
    672e:	69 f4       	brne	.+26     	; 0x674a <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    6730:	8b 81       	ldd	r24, Y+3	; 0x03
    6732:	9c 81       	ldd	r25, Y+4	; 0x04
    6734:	90 93 c5 06 	sts	0x06C5, r25
    6738:	80 93 c4 06 	sts	0x06C4, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    673c:	80 91 c7 06 	lds	r24, 0x06C7
    6740:	81 30       	cpi	r24, 0x01	; 1
    6742:	a9 f4       	brne	.+42     	; 0x676e <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    6744:	0e 94 ec 38 	call	0x71d8	; 0x71d8 <prvInitialiseTaskLists>
    6748:	12 c0       	rjmp	.+36     	; 0x676e <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    674a:	80 91 cc 06 	lds	r24, 0x06CC
    674e:	88 23       	and	r24, r24
    6750:	71 f4       	brne	.+28     	; 0x676e <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    6752:	e0 91 c4 06 	lds	r30, 0x06C4
    6756:	f0 91 c5 06 	lds	r31, 0x06C5
    675a:	96 89       	ldd	r25, Z+22	; 0x16
    675c:	8e 85       	ldd	r24, Y+14	; 0x0e
    675e:	89 17       	cp	r24, r25
    6760:	30 f0       	brcs	.+12     	; 0x676e <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    6762:	8b 81       	ldd	r24, Y+3	; 0x03
    6764:	9c 81       	ldd	r25, Y+4	; 0x04
    6766:	90 93 c5 06 	sts	0x06C5, r25
    676a:	80 93 c4 06 	sts	0x06C4, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    676e:	eb 81       	ldd	r30, Y+3	; 0x03
    6770:	fc 81       	ldd	r31, Y+4	; 0x04
    6772:	96 89       	ldd	r25, Z+22	; 0x16
    6774:	80 91 ca 06 	lds	r24, 0x06CA
    6778:	89 17       	cp	r24, r25
    677a:	28 f4       	brcc	.+10     	; 0x6786 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    677c:	eb 81       	ldd	r30, Y+3	; 0x03
    677e:	fc 81       	ldd	r31, Y+4	; 0x04
    6780:	86 89       	ldd	r24, Z+22	; 0x16
    6782:	80 93 ca 06 	sts	0x06CA, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    6786:	80 91 d1 06 	lds	r24, 0x06D1
    678a:	8f 5f       	subi	r24, 0xFF	; 255
    678c:	80 93 d1 06 	sts	0x06D1, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    6790:	eb 81       	ldd	r30, Y+3	; 0x03
    6792:	fc 81       	ldd	r31, Y+4	; 0x04
    6794:	96 89       	ldd	r25, Z+22	; 0x16
    6796:	80 91 cb 06 	lds	r24, 0x06CB
    679a:	89 17       	cp	r24, r25
    679c:	28 f4       	brcc	.+10     	; 0x67a8 <xTaskGenericCreate+0x152>
    679e:	eb 81       	ldd	r30, Y+3	; 0x03
    67a0:	fc 81       	ldd	r31, Y+4	; 0x04
    67a2:	86 89       	ldd	r24, Z+22	; 0x16
    67a4:	80 93 cb 06 	sts	0x06CB, r24
    67a8:	eb 81       	ldd	r30, Y+3	; 0x03
    67aa:	fc 81       	ldd	r31, Y+4	; 0x04
    67ac:	86 89       	ldd	r24, Z+22	; 0x16
    67ae:	28 2f       	mov	r18, r24
    67b0:	30 e0       	ldi	r19, 0x00	; 0
    67b2:	c9 01       	movw	r24, r18
    67b4:	88 0f       	add	r24, r24
    67b6:	99 1f       	adc	r25, r25
    67b8:	88 0f       	add	r24, r24
    67ba:	99 1f       	adc	r25, r25
    67bc:	88 0f       	add	r24, r24
    67be:	99 1f       	adc	r25, r25
    67c0:	82 0f       	add	r24, r18
    67c2:	93 1f       	adc	r25, r19
    67c4:	ac 01       	movw	r20, r24
    67c6:	4e 52       	subi	r20, 0x2E	; 46
    67c8:	59 4f       	sbci	r21, 0xF9	; 249
    67ca:	8b 81       	ldd	r24, Y+3	; 0x03
    67cc:	9c 81       	ldd	r25, Y+4	; 0x04
    67ce:	9c 01       	movw	r18, r24
    67d0:	2e 5f       	subi	r18, 0xFE	; 254
    67d2:	3f 4f       	sbci	r19, 0xFF	; 255
    67d4:	ca 01       	movw	r24, r20
    67d6:	b9 01       	movw	r22, r18
    67d8:	0e 94 d7 2a 	call	0x55ae	; 0x55ae <vListInsertEnd>

			xReturn = pdPASS;
    67dc:	81 e0       	ldi	r24, 0x01	; 1
    67de:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    67e0:	0f 90       	pop	r0
    67e2:	0f be       	out	0x3f, r0	; 63
    67e4:	02 c0       	rjmp	.+4      	; 0x67ea <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    67e6:	8f ef       	ldi	r24, 0xFF	; 255
    67e8:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    67ea:	8d 81       	ldd	r24, Y+5	; 0x05
    67ec:	81 30       	cpi	r24, 0x01	; 1
    67ee:	71 f4       	brne	.+28     	; 0x680c <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    67f0:	80 91 cc 06 	lds	r24, 0x06CC
    67f4:	88 23       	and	r24, r24
    67f6:	51 f0       	breq	.+20     	; 0x680c <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    67f8:	e0 91 c4 06 	lds	r30, 0x06C4
    67fc:	f0 91 c5 06 	lds	r31, 0x06C5
    6800:	96 89       	ldd	r25, Z+22	; 0x16
    6802:	8e 85       	ldd	r24, Y+14	; 0x0e
    6804:	98 17       	cp	r25, r24
    6806:	10 f4       	brcc	.+4      	; 0x680c <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    6808:	0e 94 97 2d 	call	0x5b2e	; 0x5b2e <vPortYield>
			}
		}
	}

	return xReturn;
    680c:	8d 81       	ldd	r24, Y+5	; 0x05
}
    680e:	64 96       	adiw	r28, 0x14	; 20
    6810:	0f b6       	in	r0, 0x3f	; 63
    6812:	f8 94       	cli
    6814:	de bf       	out	0x3e, r29	; 62
    6816:	0f be       	out	0x3f, r0	; 63
    6818:	cd bf       	out	0x3d, r28	; 61
    681a:	cf 91       	pop	r28
    681c:	df 91       	pop	r29
    681e:	1f 91       	pop	r17
    6820:	0f 91       	pop	r16
    6822:	ff 90       	pop	r15
    6824:	ef 90       	pop	r14
    6826:	df 90       	pop	r13
    6828:	cf 90       	pop	r12
    682a:	bf 90       	pop	r11
    682c:	af 90       	pop	r10
    682e:	08 95       	ret

00006830 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    6830:	df 93       	push	r29
    6832:	cf 93       	push	r28
    6834:	00 d0       	rcall	.+0      	; 0x6836 <vTaskDelete+0x6>
    6836:	00 d0       	rcall	.+0      	; 0x6838 <vTaskDelete+0x8>
    6838:	00 d0       	rcall	.+0      	; 0x683a <vTaskDelete+0xa>
    683a:	cd b7       	in	r28, 0x3d	; 61
    683c:	de b7       	in	r29, 0x3e	; 62
    683e:	9c 83       	std	Y+4, r25	; 0x04
    6840:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    6842:	0f b6       	in	r0, 0x3f	; 63
    6844:	f8 94       	cli
    6846:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    6848:	20 91 c4 06 	lds	r18, 0x06C4
    684c:	30 91 c5 06 	lds	r19, 0x06C5
    6850:	8b 81       	ldd	r24, Y+3	; 0x03
    6852:	9c 81       	ldd	r25, Y+4	; 0x04
    6854:	82 17       	cp	r24, r18
    6856:	93 07       	cpc	r25, r19
    6858:	11 f4       	brne	.+4      	; 0x685e <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    685a:	1c 82       	std	Y+4, r1	; 0x04
    685c:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    685e:	8b 81       	ldd	r24, Y+3	; 0x03
    6860:	9c 81       	ldd	r25, Y+4	; 0x04
    6862:	00 97       	sbiw	r24, 0x00	; 0
    6864:	39 f4       	brne	.+14     	; 0x6874 <vTaskDelete+0x44>
    6866:	80 91 c4 06 	lds	r24, 0x06C4
    686a:	90 91 c5 06 	lds	r25, 0x06C5
    686e:	9e 83       	std	Y+6, r25	; 0x06
    6870:	8d 83       	std	Y+5, r24	; 0x05
    6872:	04 c0       	rjmp	.+8      	; 0x687c <vTaskDelete+0x4c>
    6874:	8b 81       	ldd	r24, Y+3	; 0x03
    6876:	9c 81       	ldd	r25, Y+4	; 0x04
    6878:	9e 83       	std	Y+6, r25	; 0x06
    687a:	8d 83       	std	Y+5, r24	; 0x05
    687c:	8d 81       	ldd	r24, Y+5	; 0x05
    687e:	9e 81       	ldd	r25, Y+6	; 0x06
    6880:	9a 83       	std	Y+2, r25	; 0x02
    6882:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    6884:	89 81       	ldd	r24, Y+1	; 0x01
    6886:	9a 81       	ldd	r25, Y+2	; 0x02
    6888:	02 96       	adiw	r24, 0x02	; 2
    688a:	0e 94 8f 2b 	call	0x571e	; 0x571e <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    688e:	e9 81       	ldd	r30, Y+1	; 0x01
    6890:	fa 81       	ldd	r31, Y+2	; 0x02
    6892:	84 89       	ldd	r24, Z+20	; 0x14
    6894:	95 89       	ldd	r25, Z+21	; 0x15
    6896:	00 97       	sbiw	r24, 0x00	; 0
    6898:	29 f0       	breq	.+10     	; 0x68a4 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    689a:	89 81       	ldd	r24, Y+1	; 0x01
    689c:	9a 81       	ldd	r25, Y+2	; 0x02
    689e:	0c 96       	adiw	r24, 0x0c	; 12
    68a0:	0e 94 8f 2b 	call	0x571e	; 0x571e <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    68a4:	89 81       	ldd	r24, Y+1	; 0x01
    68a6:	9a 81       	ldd	r25, Y+2	; 0x02
    68a8:	9c 01       	movw	r18, r24
    68aa:	2e 5f       	subi	r18, 0xFE	; 254
    68ac:	3f 4f       	sbci	r19, 0xFF	; 255
    68ae:	8e e1       	ldi	r24, 0x1E	; 30
    68b0:	97 e0       	ldi	r25, 0x07	; 7
    68b2:	b9 01       	movw	r22, r18
    68b4:	0e 94 d7 2a 	call	0x55ae	; 0x55ae <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    68b8:	80 91 c6 06 	lds	r24, 0x06C6
    68bc:	8f 5f       	subi	r24, 0xFF	; 255
    68be:	80 93 c6 06 	sts	0x06C6, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    68c2:	80 91 d1 06 	lds	r24, 0x06D1
    68c6:	8f 5f       	subi	r24, 0xFF	; 255
    68c8:	80 93 d1 06 	sts	0x06D1, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    68cc:	0f 90       	pop	r0
    68ce:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    68d0:	80 91 cc 06 	lds	r24, 0x06CC
    68d4:	88 23       	and	r24, r24
    68d6:	31 f0       	breq	.+12     	; 0x68e4 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    68d8:	8b 81       	ldd	r24, Y+3	; 0x03
    68da:	9c 81       	ldd	r25, Y+4	; 0x04
    68dc:	00 97       	sbiw	r24, 0x00	; 0
    68de:	11 f4       	brne	.+4      	; 0x68e4 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    68e0:	0e 94 97 2d 	call	0x5b2e	; 0x5b2e <vPortYield>
			}
		}
	}
    68e4:	26 96       	adiw	r28, 0x06	; 6
    68e6:	0f b6       	in	r0, 0x3f	; 63
    68e8:	f8 94       	cli
    68ea:	de bf       	out	0x3e, r29	; 62
    68ec:	0f be       	out	0x3f, r0	; 63
    68ee:	cd bf       	out	0x3d, r28	; 61
    68f0:	cf 91       	pop	r28
    68f2:	df 91       	pop	r29
    68f4:	08 95       	ret

000068f6 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    68f6:	df 93       	push	r29
    68f8:	cf 93       	push	r28
    68fa:	cd b7       	in	r28, 0x3d	; 61
    68fc:	de b7       	in	r29, 0x3e	; 62
    68fe:	28 97       	sbiw	r28, 0x08	; 8
    6900:	0f b6       	in	r0, 0x3f	; 63
    6902:	f8 94       	cli
    6904:	de bf       	out	0x3e, r29	; 62
    6906:	0f be       	out	0x3f, r0	; 63
    6908:	cd bf       	out	0x3d, r28	; 61
    690a:	9e 83       	std	Y+6, r25	; 0x06
    690c:	8d 83       	std	Y+5, r24	; 0x05
    690e:	78 87       	std	Y+8, r23	; 0x08
    6910:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    6912:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    6914:	0e 94 67 35 	call	0x6ace	; 0x6ace <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    6918:	ed 81       	ldd	r30, Y+5	; 0x05
    691a:	fe 81       	ldd	r31, Y+6	; 0x06
    691c:	20 81       	ld	r18, Z
    691e:	31 81       	ldd	r19, Z+1	; 0x01
    6920:	8f 81       	ldd	r24, Y+7	; 0x07
    6922:	98 85       	ldd	r25, Y+8	; 0x08
    6924:	82 0f       	add	r24, r18
    6926:	93 1f       	adc	r25, r19
    6928:	9c 83       	std	Y+4, r25	; 0x04
    692a:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    692c:	ed 81       	ldd	r30, Y+5	; 0x05
    692e:	fe 81       	ldd	r31, Y+6	; 0x06
    6930:	20 81       	ld	r18, Z
    6932:	31 81       	ldd	r19, Z+1	; 0x01
    6934:	80 91 c8 06 	lds	r24, 0x06C8
    6938:	90 91 c9 06 	lds	r25, 0x06C9
    693c:	82 17       	cp	r24, r18
    693e:	93 07       	cpc	r25, r19
    6940:	a8 f4       	brcc	.+42     	; 0x696c <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    6942:	ed 81       	ldd	r30, Y+5	; 0x05
    6944:	fe 81       	ldd	r31, Y+6	; 0x06
    6946:	20 81       	ld	r18, Z
    6948:	31 81       	ldd	r19, Z+1	; 0x01
    694a:	8b 81       	ldd	r24, Y+3	; 0x03
    694c:	9c 81       	ldd	r25, Y+4	; 0x04
    694e:	82 17       	cp	r24, r18
    6950:	93 07       	cpc	r25, r19
    6952:	00 f5       	brcc	.+64     	; 0x6994 <vTaskDelayUntil+0x9e>
    6954:	20 91 c8 06 	lds	r18, 0x06C8
    6958:	30 91 c9 06 	lds	r19, 0x06C9
    695c:	8b 81       	ldd	r24, Y+3	; 0x03
    695e:	9c 81       	ldd	r25, Y+4	; 0x04
    6960:	28 17       	cp	r18, r24
    6962:	39 07       	cpc	r19, r25
    6964:	b8 f4       	brcc	.+46     	; 0x6994 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    6966:	81 e0       	ldi	r24, 0x01	; 1
    6968:	89 83       	std	Y+1, r24	; 0x01
    696a:	14 c0       	rjmp	.+40     	; 0x6994 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    696c:	ed 81       	ldd	r30, Y+5	; 0x05
    696e:	fe 81       	ldd	r31, Y+6	; 0x06
    6970:	20 81       	ld	r18, Z
    6972:	31 81       	ldd	r19, Z+1	; 0x01
    6974:	8b 81       	ldd	r24, Y+3	; 0x03
    6976:	9c 81       	ldd	r25, Y+4	; 0x04
    6978:	82 17       	cp	r24, r18
    697a:	93 07       	cpc	r25, r19
    697c:	48 f0       	brcs	.+18     	; 0x6990 <vTaskDelayUntil+0x9a>
    697e:	20 91 c8 06 	lds	r18, 0x06C8
    6982:	30 91 c9 06 	lds	r19, 0x06C9
    6986:	8b 81       	ldd	r24, Y+3	; 0x03
    6988:	9c 81       	ldd	r25, Y+4	; 0x04
    698a:	28 17       	cp	r18, r24
    698c:	39 07       	cpc	r19, r25
    698e:	10 f4       	brcc	.+4      	; 0x6994 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    6990:	81 e0       	ldi	r24, 0x01	; 1
    6992:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    6994:	ed 81       	ldd	r30, Y+5	; 0x05
    6996:	fe 81       	ldd	r31, Y+6	; 0x06
    6998:	8b 81       	ldd	r24, Y+3	; 0x03
    699a:	9c 81       	ldd	r25, Y+4	; 0x04
    699c:	91 83       	std	Z+1, r25	; 0x01
    699e:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    69a0:	89 81       	ldd	r24, Y+1	; 0x01
    69a2:	88 23       	and	r24, r24
    69a4:	59 f0       	breq	.+22     	; 0x69bc <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    69a6:	80 91 c4 06 	lds	r24, 0x06C4
    69aa:	90 91 c5 06 	lds	r25, 0x06C5
    69ae:	02 96       	adiw	r24, 0x02	; 2
    69b0:	0e 94 8f 2b 	call	0x571e	; 0x571e <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    69b4:	8b 81       	ldd	r24, Y+3	; 0x03
    69b6:	9c 81       	ldd	r25, Y+4	; 0x04
    69b8:	0e 94 67 39 	call	0x72ce	; 0x72ce <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    69bc:	0e 94 73 35 	call	0x6ae6	; 0x6ae6 <xTaskResumeAll>
    69c0:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    69c2:	8a 81       	ldd	r24, Y+2	; 0x02
    69c4:	88 23       	and	r24, r24
    69c6:	11 f4       	brne	.+4      	; 0x69cc <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    69c8:	0e 94 97 2d 	call	0x5b2e	; 0x5b2e <vPortYield>
		}
	}
    69cc:	28 96       	adiw	r28, 0x08	; 8
    69ce:	0f b6       	in	r0, 0x3f	; 63
    69d0:	f8 94       	cli
    69d2:	de bf       	out	0x3e, r29	; 62
    69d4:	0f be       	out	0x3f, r0	; 63
    69d6:	cd bf       	out	0x3d, r28	; 61
    69d8:	cf 91       	pop	r28
    69da:	df 91       	pop	r29
    69dc:	08 95       	ret

000069de <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    69de:	df 93       	push	r29
    69e0:	cf 93       	push	r28
    69e2:	00 d0       	rcall	.+0      	; 0x69e4 <vTaskDelay+0x6>
    69e4:	00 d0       	rcall	.+0      	; 0x69e6 <vTaskDelay+0x8>
    69e6:	0f 92       	push	r0
    69e8:	cd b7       	in	r28, 0x3d	; 61
    69ea:	de b7       	in	r29, 0x3e	; 62
    69ec:	9d 83       	std	Y+5, r25	; 0x05
    69ee:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    69f0:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    69f2:	8c 81       	ldd	r24, Y+4	; 0x04
    69f4:	9d 81       	ldd	r25, Y+5	; 0x05
    69f6:	00 97       	sbiw	r24, 0x00	; 0
    69f8:	d1 f0       	breq	.+52     	; 0x6a2e <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    69fa:	0e 94 67 35 	call	0x6ace	; 0x6ace <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    69fe:	20 91 c8 06 	lds	r18, 0x06C8
    6a02:	30 91 c9 06 	lds	r19, 0x06C9
    6a06:	8c 81       	ldd	r24, Y+4	; 0x04
    6a08:	9d 81       	ldd	r25, Y+5	; 0x05
    6a0a:	82 0f       	add	r24, r18
    6a0c:	93 1f       	adc	r25, r19
    6a0e:	9b 83       	std	Y+3, r25	; 0x03
    6a10:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    6a12:	80 91 c4 06 	lds	r24, 0x06C4
    6a16:	90 91 c5 06 	lds	r25, 0x06C5
    6a1a:	02 96       	adiw	r24, 0x02	; 2
    6a1c:	0e 94 8f 2b 	call	0x571e	; 0x571e <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    6a20:	8a 81       	ldd	r24, Y+2	; 0x02
    6a22:	9b 81       	ldd	r25, Y+3	; 0x03
    6a24:	0e 94 67 39 	call	0x72ce	; 0x72ce <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    6a28:	0e 94 73 35 	call	0x6ae6	; 0x6ae6 <xTaskResumeAll>
    6a2c:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    6a2e:	89 81       	ldd	r24, Y+1	; 0x01
    6a30:	88 23       	and	r24, r24
    6a32:	11 f4       	brne	.+4      	; 0x6a38 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    6a34:	0e 94 97 2d 	call	0x5b2e	; 0x5b2e <vPortYield>
		}
	}
    6a38:	0f 90       	pop	r0
    6a3a:	0f 90       	pop	r0
    6a3c:	0f 90       	pop	r0
    6a3e:	0f 90       	pop	r0
    6a40:	0f 90       	pop	r0
    6a42:	cf 91       	pop	r28
    6a44:	df 91       	pop	r29
    6a46:	08 95       	ret

00006a48 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    6a48:	af 92       	push	r10
    6a4a:	bf 92       	push	r11
    6a4c:	cf 92       	push	r12
    6a4e:	df 92       	push	r13
    6a50:	ef 92       	push	r14
    6a52:	ff 92       	push	r15
    6a54:	0f 93       	push	r16
    6a56:	df 93       	push	r29
    6a58:	cf 93       	push	r28
    6a5a:	0f 92       	push	r0
    6a5c:	cd b7       	in	r28, 0x3d	; 61
    6a5e:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    6a60:	20 e6       	ldi	r18, 0x60	; 96
    6a62:	30 e0       	ldi	r19, 0x00	; 0
    6a64:	8b e8       	ldi	r24, 0x8B	; 139
    6a66:	98 e3       	ldi	r25, 0x38	; 56
    6a68:	b9 01       	movw	r22, r18
    6a6a:	45 e5       	ldi	r20, 0x55	; 85
    6a6c:	50 e0       	ldi	r21, 0x00	; 0
    6a6e:	20 e0       	ldi	r18, 0x00	; 0
    6a70:	30 e0       	ldi	r19, 0x00	; 0
    6a72:	00 e0       	ldi	r16, 0x00	; 0
    6a74:	ee 24       	eor	r14, r14
    6a76:	ff 24       	eor	r15, r15
    6a78:	cc 24       	eor	r12, r12
    6a7a:	dd 24       	eor	r13, r13
    6a7c:	aa 24       	eor	r10, r10
    6a7e:	bb 24       	eor	r11, r11
    6a80:	0e 94 2b 33 	call	0x6656	; 0x6656 <xTaskGenericCreate>
    6a84:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    6a86:	89 81       	ldd	r24, Y+1	; 0x01
    6a88:	81 30       	cpi	r24, 0x01	; 1
    6a8a:	51 f4       	brne	.+20     	; 0x6aa0 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    6a8c:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    6a8e:	81 e0       	ldi	r24, 0x01	; 1
    6a90:	80 93 cc 06 	sts	0x06CC, r24
		xTickCount = ( portTickType ) 0U;
    6a94:	10 92 c9 06 	sts	0x06C9, r1
    6a98:	10 92 c8 06 	sts	0x06C8, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    6a9c:	0e 94 5b 2d 	call	0x5ab6	; 0x5ab6 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    6aa0:	0f 90       	pop	r0
    6aa2:	cf 91       	pop	r28
    6aa4:	df 91       	pop	r29
    6aa6:	0f 91       	pop	r16
    6aa8:	ff 90       	pop	r15
    6aaa:	ef 90       	pop	r14
    6aac:	df 90       	pop	r13
    6aae:	cf 90       	pop	r12
    6ab0:	bf 90       	pop	r11
    6ab2:	af 90       	pop	r10
    6ab4:	08 95       	ret

00006ab6 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    6ab6:	df 93       	push	r29
    6ab8:	cf 93       	push	r28
    6aba:	cd b7       	in	r28, 0x3d	; 61
    6abc:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    6abe:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    6ac0:	10 92 cc 06 	sts	0x06CC, r1
	vPortEndScheduler();
    6ac4:	0e 94 90 2d 	call	0x5b20	; 0x5b20 <vPortEndScheduler>
}
    6ac8:	cf 91       	pop	r28
    6aca:	df 91       	pop	r29
    6acc:	08 95       	ret

00006ace <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    6ace:	df 93       	push	r29
    6ad0:	cf 93       	push	r28
    6ad2:	cd b7       	in	r28, 0x3d	; 61
    6ad4:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    6ad6:	80 91 cd 06 	lds	r24, 0x06CD
    6ada:	8f 5f       	subi	r24, 0xFF	; 255
    6adc:	80 93 cd 06 	sts	0x06CD, r24
}
    6ae0:	cf 91       	pop	r28
    6ae2:	df 91       	pop	r29
    6ae4:	08 95       	ret

00006ae6 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    6ae6:	df 93       	push	r29
    6ae8:	cf 93       	push	r28
    6aea:	00 d0       	rcall	.+0      	; 0x6aec <xTaskResumeAll+0x6>
    6aec:	00 d0       	rcall	.+0      	; 0x6aee <xTaskResumeAll+0x8>
    6aee:	cd b7       	in	r28, 0x3d	; 61
    6af0:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    6af2:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    6af4:	0f b6       	in	r0, 0x3f	; 63
    6af6:	f8 94       	cli
    6af8:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    6afa:	80 91 cd 06 	lds	r24, 0x06CD
    6afe:	81 50       	subi	r24, 0x01	; 1
    6b00:	80 93 cd 06 	sts	0x06CD, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    6b04:	80 91 cd 06 	lds	r24, 0x06CD
    6b08:	88 23       	and	r24, r24
    6b0a:	09 f0       	breq	.+2      	; 0x6b0e <xTaskResumeAll+0x28>
    6b0c:	6c c0       	rjmp	.+216    	; 0x6be6 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    6b0e:	80 91 c7 06 	lds	r24, 0x06C7
    6b12:	88 23       	and	r24, r24
    6b14:	09 f4       	brne	.+2      	; 0x6b18 <xTaskResumeAll+0x32>
    6b16:	67 c0       	rjmp	.+206    	; 0x6be6 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    6b18:	19 82       	std	Y+1, r1	; 0x01
    6b1a:	41 c0       	rjmp	.+130    	; 0x6b9e <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    6b1c:	e0 91 1a 07 	lds	r30, 0x071A
    6b20:	f0 91 1b 07 	lds	r31, 0x071B
    6b24:	86 81       	ldd	r24, Z+6	; 0x06
    6b26:	97 81       	ldd	r25, Z+7	; 0x07
    6b28:	9c 83       	std	Y+4, r25	; 0x04
    6b2a:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    6b2c:	8b 81       	ldd	r24, Y+3	; 0x03
    6b2e:	9c 81       	ldd	r25, Y+4	; 0x04
    6b30:	0c 96       	adiw	r24, 0x0c	; 12
    6b32:	0e 94 8f 2b 	call	0x571e	; 0x571e <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    6b36:	8b 81       	ldd	r24, Y+3	; 0x03
    6b38:	9c 81       	ldd	r25, Y+4	; 0x04
    6b3a:	02 96       	adiw	r24, 0x02	; 2
    6b3c:	0e 94 8f 2b 	call	0x571e	; 0x571e <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    6b40:	eb 81       	ldd	r30, Y+3	; 0x03
    6b42:	fc 81       	ldd	r31, Y+4	; 0x04
    6b44:	96 89       	ldd	r25, Z+22	; 0x16
    6b46:	80 91 cb 06 	lds	r24, 0x06CB
    6b4a:	89 17       	cp	r24, r25
    6b4c:	28 f4       	brcc	.+10     	; 0x6b58 <xTaskResumeAll+0x72>
    6b4e:	eb 81       	ldd	r30, Y+3	; 0x03
    6b50:	fc 81       	ldd	r31, Y+4	; 0x04
    6b52:	86 89       	ldd	r24, Z+22	; 0x16
    6b54:	80 93 cb 06 	sts	0x06CB, r24
    6b58:	eb 81       	ldd	r30, Y+3	; 0x03
    6b5a:	fc 81       	ldd	r31, Y+4	; 0x04
    6b5c:	86 89       	ldd	r24, Z+22	; 0x16
    6b5e:	28 2f       	mov	r18, r24
    6b60:	30 e0       	ldi	r19, 0x00	; 0
    6b62:	c9 01       	movw	r24, r18
    6b64:	88 0f       	add	r24, r24
    6b66:	99 1f       	adc	r25, r25
    6b68:	88 0f       	add	r24, r24
    6b6a:	99 1f       	adc	r25, r25
    6b6c:	88 0f       	add	r24, r24
    6b6e:	99 1f       	adc	r25, r25
    6b70:	82 0f       	add	r24, r18
    6b72:	93 1f       	adc	r25, r19
    6b74:	8e 52       	subi	r24, 0x2E	; 46
    6b76:	99 4f       	sbci	r25, 0xF9	; 249
    6b78:	2b 81       	ldd	r18, Y+3	; 0x03
    6b7a:	3c 81       	ldd	r19, Y+4	; 0x04
    6b7c:	2e 5f       	subi	r18, 0xFE	; 254
    6b7e:	3f 4f       	sbci	r19, 0xFF	; 255
    6b80:	b9 01       	movw	r22, r18
    6b82:	0e 94 d7 2a 	call	0x55ae	; 0x55ae <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    6b86:	eb 81       	ldd	r30, Y+3	; 0x03
    6b88:	fc 81       	ldd	r31, Y+4	; 0x04
    6b8a:	96 89       	ldd	r25, Z+22	; 0x16
    6b8c:	e0 91 c4 06 	lds	r30, 0x06C4
    6b90:	f0 91 c5 06 	lds	r31, 0x06C5
    6b94:	86 89       	ldd	r24, Z+22	; 0x16
    6b96:	98 17       	cp	r25, r24
    6b98:	10 f0       	brcs	.+4      	; 0x6b9e <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    6b9a:	81 e0       	ldi	r24, 0x01	; 1
    6b9c:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    6b9e:	80 91 15 07 	lds	r24, 0x0715
    6ba2:	88 23       	and	r24, r24
    6ba4:	09 f0       	breq	.+2      	; 0x6ba8 <xTaskResumeAll+0xc2>
    6ba6:	ba cf       	rjmp	.-140    	; 0x6b1c <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    6ba8:	80 91 ce 06 	lds	r24, 0x06CE
    6bac:	88 23       	and	r24, r24
    6bae:	71 f0       	breq	.+28     	; 0x6bcc <xTaskResumeAll+0xe6>
    6bb0:	07 c0       	rjmp	.+14     	; 0x6bc0 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    6bb2:	0e 94 32 36 	call	0x6c64	; 0x6c64 <vTaskIncrementTick>
						--uxMissedTicks;
    6bb6:	80 91 ce 06 	lds	r24, 0x06CE
    6bba:	81 50       	subi	r24, 0x01	; 1
    6bbc:	80 93 ce 06 	sts	0x06CE, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    6bc0:	80 91 ce 06 	lds	r24, 0x06CE
    6bc4:	88 23       	and	r24, r24
    6bc6:	a9 f7       	brne	.-22     	; 0x6bb2 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    6bc8:	81 e0       	ldi	r24, 0x01	; 1
    6bca:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    6bcc:	89 81       	ldd	r24, Y+1	; 0x01
    6bce:	81 30       	cpi	r24, 0x01	; 1
    6bd0:	21 f0       	breq	.+8      	; 0x6bda <xTaskResumeAll+0xf4>
    6bd2:	80 91 cf 06 	lds	r24, 0x06CF
    6bd6:	81 30       	cpi	r24, 0x01	; 1
    6bd8:	31 f4       	brne	.+12     	; 0x6be6 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    6bda:	81 e0       	ldi	r24, 0x01	; 1
    6bdc:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    6bde:	10 92 cf 06 	sts	0x06CF, r1
					portYIELD_WITHIN_API();
    6be2:	0e 94 97 2d 	call	0x5b2e	; 0x5b2e <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    6be6:	0f 90       	pop	r0
    6be8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    6bea:	8a 81       	ldd	r24, Y+2	; 0x02
}
    6bec:	0f 90       	pop	r0
    6bee:	0f 90       	pop	r0
    6bf0:	0f 90       	pop	r0
    6bf2:	0f 90       	pop	r0
    6bf4:	cf 91       	pop	r28
    6bf6:	df 91       	pop	r29
    6bf8:	08 95       	ret

00006bfa <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    6bfa:	df 93       	push	r29
    6bfc:	cf 93       	push	r28
    6bfe:	00 d0       	rcall	.+0      	; 0x6c00 <xTaskGetTickCount+0x6>
    6c00:	cd b7       	in	r28, 0x3d	; 61
    6c02:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    6c04:	0f b6       	in	r0, 0x3f	; 63
    6c06:	f8 94       	cli
    6c08:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    6c0a:	80 91 c8 06 	lds	r24, 0x06C8
    6c0e:	90 91 c9 06 	lds	r25, 0x06C9
    6c12:	9a 83       	std	Y+2, r25	; 0x02
    6c14:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    6c16:	0f 90       	pop	r0
    6c18:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    6c1a:	89 81       	ldd	r24, Y+1	; 0x01
    6c1c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6c1e:	0f 90       	pop	r0
    6c20:	0f 90       	pop	r0
    6c22:	cf 91       	pop	r28
    6c24:	df 91       	pop	r29
    6c26:	08 95       	ret

00006c28 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    6c28:	df 93       	push	r29
    6c2a:	cf 93       	push	r28
    6c2c:	00 d0       	rcall	.+0      	; 0x6c2e <xTaskGetTickCountFromISR+0x6>
    6c2e:	0f 92       	push	r0
    6c30:	cd b7       	in	r28, 0x3d	; 61
    6c32:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    6c34:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    6c36:	80 91 c8 06 	lds	r24, 0x06C8
    6c3a:	90 91 c9 06 	lds	r25, 0x06C9
    6c3e:	9b 83       	std	Y+3, r25	; 0x03
    6c40:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    6c42:	8a 81       	ldd	r24, Y+2	; 0x02
    6c44:	9b 81       	ldd	r25, Y+3	; 0x03
}
    6c46:	0f 90       	pop	r0
    6c48:	0f 90       	pop	r0
    6c4a:	0f 90       	pop	r0
    6c4c:	cf 91       	pop	r28
    6c4e:	df 91       	pop	r29
    6c50:	08 95       	ret

00006c52 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    6c52:	df 93       	push	r29
    6c54:	cf 93       	push	r28
    6c56:	cd b7       	in	r28, 0x3d	; 61
    6c58:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    6c5a:	80 91 c7 06 	lds	r24, 0x06C7
}
    6c5e:	cf 91       	pop	r28
    6c60:	df 91       	pop	r29
    6c62:	08 95       	ret

00006c64 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    6c64:	df 93       	push	r29
    6c66:	cf 93       	push	r28
    6c68:	00 d0       	rcall	.+0      	; 0x6c6a <vTaskIncrementTick+0x6>
    6c6a:	00 d0       	rcall	.+0      	; 0x6c6c <vTaskIncrementTick+0x8>
    6c6c:	00 d0       	rcall	.+0      	; 0x6c6e <vTaskIncrementTick+0xa>
    6c6e:	cd b7       	in	r28, 0x3d	; 61
    6c70:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    6c72:	80 91 cd 06 	lds	r24, 0x06CD
    6c76:	88 23       	and	r24, r24
    6c78:	09 f0       	breq	.+2      	; 0x6c7c <vTaskIncrementTick+0x18>
    6c7a:	bb c0       	rjmp	.+374    	; 0x6df2 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    6c7c:	80 91 c8 06 	lds	r24, 0x06C8
    6c80:	90 91 c9 06 	lds	r25, 0x06C9
    6c84:	01 96       	adiw	r24, 0x01	; 1
    6c86:	90 93 c9 06 	sts	0x06C9, r25
    6c8a:	80 93 c8 06 	sts	0x06C8, r24
		if( xTickCount == ( portTickType ) 0U )
    6c8e:	80 91 c8 06 	lds	r24, 0x06C8
    6c92:	90 91 c9 06 	lds	r25, 0x06C9
    6c96:	00 97       	sbiw	r24, 0x00	; 0
    6c98:	d1 f5       	brne	.+116    	; 0x6d0e <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    6c9a:	80 91 11 07 	lds	r24, 0x0711
    6c9e:	90 91 12 07 	lds	r25, 0x0712
    6ca2:	9c 83       	std	Y+4, r25	; 0x04
    6ca4:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    6ca6:	80 91 13 07 	lds	r24, 0x0713
    6caa:	90 91 14 07 	lds	r25, 0x0714
    6cae:	90 93 12 07 	sts	0x0712, r25
    6cb2:	80 93 11 07 	sts	0x0711, r24
			pxOverflowDelayedTaskList = pxTemp;
    6cb6:	8b 81       	ldd	r24, Y+3	; 0x03
    6cb8:	9c 81       	ldd	r25, Y+4	; 0x04
    6cba:	90 93 14 07 	sts	0x0714, r25
    6cbe:	80 93 13 07 	sts	0x0713, r24
			xNumOfOverflows++;
    6cc2:	80 91 d0 06 	lds	r24, 0x06D0
    6cc6:	8f 5f       	subi	r24, 0xFF	; 255
    6cc8:	80 93 d0 06 	sts	0x06D0, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    6ccc:	e0 91 11 07 	lds	r30, 0x0711
    6cd0:	f0 91 12 07 	lds	r31, 0x0712
    6cd4:	80 81       	ld	r24, Z
    6cd6:	88 23       	and	r24, r24
    6cd8:	39 f4       	brne	.+14     	; 0x6ce8 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    6cda:	8f ef       	ldi	r24, 0xFF	; 255
    6cdc:	9f ef       	ldi	r25, 0xFF	; 255
    6cde:	90 93 86 00 	sts	0x0086, r25
    6ce2:	80 93 85 00 	sts	0x0085, r24
    6ce6:	13 c0       	rjmp	.+38     	; 0x6d0e <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    6ce8:	e0 91 11 07 	lds	r30, 0x0711
    6cec:	f0 91 12 07 	lds	r31, 0x0712
    6cf0:	05 80       	ldd	r0, Z+5	; 0x05
    6cf2:	f6 81       	ldd	r31, Z+6	; 0x06
    6cf4:	e0 2d       	mov	r30, r0
    6cf6:	86 81       	ldd	r24, Z+6	; 0x06
    6cf8:	97 81       	ldd	r25, Z+7	; 0x07
    6cfa:	9e 83       	std	Y+6, r25	; 0x06
    6cfc:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    6cfe:	ed 81       	ldd	r30, Y+5	; 0x05
    6d00:	fe 81       	ldd	r31, Y+6	; 0x06
    6d02:	82 81       	ldd	r24, Z+2	; 0x02
    6d04:	93 81       	ldd	r25, Z+3	; 0x03
    6d06:	90 93 86 00 	sts	0x0086, r25
    6d0a:	80 93 85 00 	sts	0x0085, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    6d0e:	20 91 c8 06 	lds	r18, 0x06C8
    6d12:	30 91 c9 06 	lds	r19, 0x06C9
    6d16:	80 91 85 00 	lds	r24, 0x0085
    6d1a:	90 91 86 00 	lds	r25, 0x0086
    6d1e:	28 17       	cp	r18, r24
    6d20:	39 07       	cpc	r19, r25
    6d22:	08 f4       	brcc	.+2      	; 0x6d26 <vTaskIncrementTick+0xc2>
    6d24:	6b c0       	rjmp	.+214    	; 0x6dfc <vTaskIncrementTick+0x198>
    6d26:	e0 91 11 07 	lds	r30, 0x0711
    6d2a:	f0 91 12 07 	lds	r31, 0x0712
    6d2e:	80 81       	ld	r24, Z
    6d30:	88 23       	and	r24, r24
    6d32:	39 f4       	brne	.+14     	; 0x6d42 <vTaskIncrementTick+0xde>
    6d34:	8f ef       	ldi	r24, 0xFF	; 255
    6d36:	9f ef       	ldi	r25, 0xFF	; 255
    6d38:	90 93 86 00 	sts	0x0086, r25
    6d3c:	80 93 85 00 	sts	0x0085, r24
    6d40:	5d c0       	rjmp	.+186    	; 0x6dfc <vTaskIncrementTick+0x198>
    6d42:	e0 91 11 07 	lds	r30, 0x0711
    6d46:	f0 91 12 07 	lds	r31, 0x0712
    6d4a:	05 80       	ldd	r0, Z+5	; 0x05
    6d4c:	f6 81       	ldd	r31, Z+6	; 0x06
    6d4e:	e0 2d       	mov	r30, r0
    6d50:	86 81       	ldd	r24, Z+6	; 0x06
    6d52:	97 81       	ldd	r25, Z+7	; 0x07
    6d54:	9e 83       	std	Y+6, r25	; 0x06
    6d56:	8d 83       	std	Y+5, r24	; 0x05
    6d58:	ed 81       	ldd	r30, Y+5	; 0x05
    6d5a:	fe 81       	ldd	r31, Y+6	; 0x06
    6d5c:	82 81       	ldd	r24, Z+2	; 0x02
    6d5e:	93 81       	ldd	r25, Z+3	; 0x03
    6d60:	9a 83       	std	Y+2, r25	; 0x02
    6d62:	89 83       	std	Y+1, r24	; 0x01
    6d64:	20 91 c8 06 	lds	r18, 0x06C8
    6d68:	30 91 c9 06 	lds	r19, 0x06C9
    6d6c:	89 81       	ldd	r24, Y+1	; 0x01
    6d6e:	9a 81       	ldd	r25, Y+2	; 0x02
    6d70:	28 17       	cp	r18, r24
    6d72:	39 07       	cpc	r19, r25
    6d74:	38 f4       	brcc	.+14     	; 0x6d84 <vTaskIncrementTick+0x120>
    6d76:	89 81       	ldd	r24, Y+1	; 0x01
    6d78:	9a 81       	ldd	r25, Y+2	; 0x02
    6d7a:	90 93 86 00 	sts	0x0086, r25
    6d7e:	80 93 85 00 	sts	0x0085, r24
    6d82:	3c c0       	rjmp	.+120    	; 0x6dfc <vTaskIncrementTick+0x198>
    6d84:	8d 81       	ldd	r24, Y+5	; 0x05
    6d86:	9e 81       	ldd	r25, Y+6	; 0x06
    6d88:	02 96       	adiw	r24, 0x02	; 2
    6d8a:	0e 94 8f 2b 	call	0x571e	; 0x571e <vListRemove>
    6d8e:	ed 81       	ldd	r30, Y+5	; 0x05
    6d90:	fe 81       	ldd	r31, Y+6	; 0x06
    6d92:	84 89       	ldd	r24, Z+20	; 0x14
    6d94:	95 89       	ldd	r25, Z+21	; 0x15
    6d96:	00 97       	sbiw	r24, 0x00	; 0
    6d98:	29 f0       	breq	.+10     	; 0x6da4 <vTaskIncrementTick+0x140>
    6d9a:	8d 81       	ldd	r24, Y+5	; 0x05
    6d9c:	9e 81       	ldd	r25, Y+6	; 0x06
    6d9e:	0c 96       	adiw	r24, 0x0c	; 12
    6da0:	0e 94 8f 2b 	call	0x571e	; 0x571e <vListRemove>
    6da4:	ed 81       	ldd	r30, Y+5	; 0x05
    6da6:	fe 81       	ldd	r31, Y+6	; 0x06
    6da8:	96 89       	ldd	r25, Z+22	; 0x16
    6daa:	80 91 cb 06 	lds	r24, 0x06CB
    6dae:	89 17       	cp	r24, r25
    6db0:	28 f4       	brcc	.+10     	; 0x6dbc <vTaskIncrementTick+0x158>
    6db2:	ed 81       	ldd	r30, Y+5	; 0x05
    6db4:	fe 81       	ldd	r31, Y+6	; 0x06
    6db6:	86 89       	ldd	r24, Z+22	; 0x16
    6db8:	80 93 cb 06 	sts	0x06CB, r24
    6dbc:	ed 81       	ldd	r30, Y+5	; 0x05
    6dbe:	fe 81       	ldd	r31, Y+6	; 0x06
    6dc0:	86 89       	ldd	r24, Z+22	; 0x16
    6dc2:	28 2f       	mov	r18, r24
    6dc4:	30 e0       	ldi	r19, 0x00	; 0
    6dc6:	c9 01       	movw	r24, r18
    6dc8:	88 0f       	add	r24, r24
    6dca:	99 1f       	adc	r25, r25
    6dcc:	88 0f       	add	r24, r24
    6dce:	99 1f       	adc	r25, r25
    6dd0:	88 0f       	add	r24, r24
    6dd2:	99 1f       	adc	r25, r25
    6dd4:	82 0f       	add	r24, r18
    6dd6:	93 1f       	adc	r25, r19
    6dd8:	ac 01       	movw	r20, r24
    6dda:	4e 52       	subi	r20, 0x2E	; 46
    6ddc:	59 4f       	sbci	r21, 0xF9	; 249
    6dde:	8d 81       	ldd	r24, Y+5	; 0x05
    6de0:	9e 81       	ldd	r25, Y+6	; 0x06
    6de2:	9c 01       	movw	r18, r24
    6de4:	2e 5f       	subi	r18, 0xFE	; 254
    6de6:	3f 4f       	sbci	r19, 0xFF	; 255
    6de8:	ca 01       	movw	r24, r20
    6dea:	b9 01       	movw	r22, r18
    6dec:	0e 94 d7 2a 	call	0x55ae	; 0x55ae <vListInsertEnd>
    6df0:	9a cf       	rjmp	.-204    	; 0x6d26 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    6df2:	80 91 ce 06 	lds	r24, 0x06CE
    6df6:	8f 5f       	subi	r24, 0xFF	; 255
    6df8:	80 93 ce 06 	sts	0x06CE, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    6dfc:	26 96       	adiw	r28, 0x06	; 6
    6dfe:	0f b6       	in	r0, 0x3f	; 63
    6e00:	f8 94       	cli
    6e02:	de bf       	out	0x3e, r29	; 62
    6e04:	0f be       	out	0x3f, r0	; 63
    6e06:	cd bf       	out	0x3d, r28	; 61
    6e08:	cf 91       	pop	r28
    6e0a:	df 91       	pop	r29
    6e0c:	08 95       	ret

00006e0e <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    6e0e:	df 93       	push	r29
    6e10:	cf 93       	push	r28
    6e12:	00 d0       	rcall	.+0      	; 0x6e14 <vTaskSwitchContext+0x6>
    6e14:	cd b7       	in	r28, 0x3d	; 61
    6e16:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    6e18:	80 91 cd 06 	lds	r24, 0x06CD
    6e1c:	88 23       	and	r24, r24
    6e1e:	49 f0       	breq	.+18     	; 0x6e32 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    6e20:	81 e0       	ldi	r24, 0x01	; 1
    6e22:	80 93 cf 06 	sts	0x06CF, r24
    6e26:	54 c0       	rjmp	.+168    	; 0x6ed0 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    6e28:	80 91 cb 06 	lds	r24, 0x06CB
    6e2c:	81 50       	subi	r24, 0x01	; 1
    6e2e:	80 93 cb 06 	sts	0x06CB, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    6e32:	80 91 cb 06 	lds	r24, 0x06CB
    6e36:	28 2f       	mov	r18, r24
    6e38:	30 e0       	ldi	r19, 0x00	; 0
    6e3a:	c9 01       	movw	r24, r18
    6e3c:	88 0f       	add	r24, r24
    6e3e:	99 1f       	adc	r25, r25
    6e40:	88 0f       	add	r24, r24
    6e42:	99 1f       	adc	r25, r25
    6e44:	88 0f       	add	r24, r24
    6e46:	99 1f       	adc	r25, r25
    6e48:	82 0f       	add	r24, r18
    6e4a:	93 1f       	adc	r25, r19
    6e4c:	fc 01       	movw	r30, r24
    6e4e:	ee 52       	subi	r30, 0x2E	; 46
    6e50:	f9 4f       	sbci	r31, 0xF9	; 249
    6e52:	80 81       	ld	r24, Z
    6e54:	88 23       	and	r24, r24
    6e56:	41 f3       	breq	.-48     	; 0x6e28 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    6e58:	80 91 cb 06 	lds	r24, 0x06CB
    6e5c:	28 2f       	mov	r18, r24
    6e5e:	30 e0       	ldi	r19, 0x00	; 0
    6e60:	c9 01       	movw	r24, r18
    6e62:	88 0f       	add	r24, r24
    6e64:	99 1f       	adc	r25, r25
    6e66:	88 0f       	add	r24, r24
    6e68:	99 1f       	adc	r25, r25
    6e6a:	88 0f       	add	r24, r24
    6e6c:	99 1f       	adc	r25, r25
    6e6e:	82 0f       	add	r24, r18
    6e70:	93 1f       	adc	r25, r19
    6e72:	8e 52       	subi	r24, 0x2E	; 46
    6e74:	99 4f       	sbci	r25, 0xF9	; 249
    6e76:	9a 83       	std	Y+2, r25	; 0x02
    6e78:	89 83       	std	Y+1, r24	; 0x01
    6e7a:	e9 81       	ldd	r30, Y+1	; 0x01
    6e7c:	fa 81       	ldd	r31, Y+2	; 0x02
    6e7e:	01 80       	ldd	r0, Z+1	; 0x01
    6e80:	f2 81       	ldd	r31, Z+2	; 0x02
    6e82:	e0 2d       	mov	r30, r0
    6e84:	82 81       	ldd	r24, Z+2	; 0x02
    6e86:	93 81       	ldd	r25, Z+3	; 0x03
    6e88:	e9 81       	ldd	r30, Y+1	; 0x01
    6e8a:	fa 81       	ldd	r31, Y+2	; 0x02
    6e8c:	92 83       	std	Z+2, r25	; 0x02
    6e8e:	81 83       	std	Z+1, r24	; 0x01
    6e90:	e9 81       	ldd	r30, Y+1	; 0x01
    6e92:	fa 81       	ldd	r31, Y+2	; 0x02
    6e94:	21 81       	ldd	r18, Z+1	; 0x01
    6e96:	32 81       	ldd	r19, Z+2	; 0x02
    6e98:	89 81       	ldd	r24, Y+1	; 0x01
    6e9a:	9a 81       	ldd	r25, Y+2	; 0x02
    6e9c:	03 96       	adiw	r24, 0x03	; 3
    6e9e:	28 17       	cp	r18, r24
    6ea0:	39 07       	cpc	r19, r25
    6ea2:	59 f4       	brne	.+22     	; 0x6eba <vTaskSwitchContext+0xac>
    6ea4:	e9 81       	ldd	r30, Y+1	; 0x01
    6ea6:	fa 81       	ldd	r31, Y+2	; 0x02
    6ea8:	01 80       	ldd	r0, Z+1	; 0x01
    6eaa:	f2 81       	ldd	r31, Z+2	; 0x02
    6eac:	e0 2d       	mov	r30, r0
    6eae:	82 81       	ldd	r24, Z+2	; 0x02
    6eb0:	93 81       	ldd	r25, Z+3	; 0x03
    6eb2:	e9 81       	ldd	r30, Y+1	; 0x01
    6eb4:	fa 81       	ldd	r31, Y+2	; 0x02
    6eb6:	92 83       	std	Z+2, r25	; 0x02
    6eb8:	81 83       	std	Z+1, r24	; 0x01
    6eba:	e9 81       	ldd	r30, Y+1	; 0x01
    6ebc:	fa 81       	ldd	r31, Y+2	; 0x02
    6ebe:	01 80       	ldd	r0, Z+1	; 0x01
    6ec0:	f2 81       	ldd	r31, Z+2	; 0x02
    6ec2:	e0 2d       	mov	r30, r0
    6ec4:	86 81       	ldd	r24, Z+6	; 0x06
    6ec6:	97 81       	ldd	r25, Z+7	; 0x07
    6ec8:	90 93 c5 06 	sts	0x06C5, r25
    6ecc:	80 93 c4 06 	sts	0x06C4, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    6ed0:	0f 90       	pop	r0
    6ed2:	0f 90       	pop	r0
    6ed4:	cf 91       	pop	r28
    6ed6:	df 91       	pop	r29
    6ed8:	08 95       	ret

00006eda <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    6eda:	df 93       	push	r29
    6edc:	cf 93       	push	r28
    6ede:	00 d0       	rcall	.+0      	; 0x6ee0 <vTaskPlaceOnEventList+0x6>
    6ee0:	00 d0       	rcall	.+0      	; 0x6ee2 <vTaskPlaceOnEventList+0x8>
    6ee2:	00 d0       	rcall	.+0      	; 0x6ee4 <vTaskPlaceOnEventList+0xa>
    6ee4:	cd b7       	in	r28, 0x3d	; 61
    6ee6:	de b7       	in	r29, 0x3e	; 62
    6ee8:	9c 83       	std	Y+4, r25	; 0x04
    6eea:	8b 83       	std	Y+3, r24	; 0x03
    6eec:	7e 83       	std	Y+6, r23	; 0x06
    6eee:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    6ef0:	4b 81       	ldd	r20, Y+3	; 0x03
    6ef2:	5c 81       	ldd	r21, Y+4	; 0x04
    6ef4:	80 91 c4 06 	lds	r24, 0x06C4
    6ef8:	90 91 c5 06 	lds	r25, 0x06C5
    6efc:	9c 01       	movw	r18, r24
    6efe:	24 5f       	subi	r18, 0xF4	; 244
    6f00:	3f 4f       	sbci	r19, 0xFF	; 255
    6f02:	ca 01       	movw	r24, r20
    6f04:	b9 01       	movw	r22, r18
    6f06:	0e 94 23 2b 	call	0x5646	; 0x5646 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    6f0a:	80 91 c4 06 	lds	r24, 0x06C4
    6f0e:	90 91 c5 06 	lds	r25, 0x06C5
    6f12:	02 96       	adiw	r24, 0x02	; 2
    6f14:	0e 94 8f 2b 	call	0x571e	; 0x571e <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    6f18:	20 91 c8 06 	lds	r18, 0x06C8
    6f1c:	30 91 c9 06 	lds	r19, 0x06C9
    6f20:	8d 81       	ldd	r24, Y+5	; 0x05
    6f22:	9e 81       	ldd	r25, Y+6	; 0x06
    6f24:	82 0f       	add	r24, r18
    6f26:	93 1f       	adc	r25, r19
    6f28:	9a 83       	std	Y+2, r25	; 0x02
    6f2a:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    6f2c:	89 81       	ldd	r24, Y+1	; 0x01
    6f2e:	9a 81       	ldd	r25, Y+2	; 0x02
    6f30:	0e 94 67 39 	call	0x72ce	; 0x72ce <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    6f34:	26 96       	adiw	r28, 0x06	; 6
    6f36:	0f b6       	in	r0, 0x3f	; 63
    6f38:	f8 94       	cli
    6f3a:	de bf       	out	0x3e, r29	; 62
    6f3c:	0f be       	out	0x3f, r0	; 63
    6f3e:	cd bf       	out	0x3d, r28	; 61
    6f40:	cf 91       	pop	r28
    6f42:	df 91       	pop	r29
    6f44:	08 95       	ret

00006f46 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    6f46:	df 93       	push	r29
    6f48:	cf 93       	push	r28
    6f4a:	00 d0       	rcall	.+0      	; 0x6f4c <xTaskRemoveFromEventList+0x6>
    6f4c:	00 d0       	rcall	.+0      	; 0x6f4e <xTaskRemoveFromEventList+0x8>
    6f4e:	0f 92       	push	r0
    6f50:	cd b7       	in	r28, 0x3d	; 61
    6f52:	de b7       	in	r29, 0x3e	; 62
    6f54:	9d 83       	std	Y+5, r25	; 0x05
    6f56:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    6f58:	ec 81       	ldd	r30, Y+4	; 0x04
    6f5a:	fd 81       	ldd	r31, Y+5	; 0x05
    6f5c:	05 80       	ldd	r0, Z+5	; 0x05
    6f5e:	f6 81       	ldd	r31, Z+6	; 0x06
    6f60:	e0 2d       	mov	r30, r0
    6f62:	86 81       	ldd	r24, Z+6	; 0x06
    6f64:	97 81       	ldd	r25, Z+7	; 0x07
    6f66:	9b 83       	std	Y+3, r25	; 0x03
    6f68:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    6f6a:	8a 81       	ldd	r24, Y+2	; 0x02
    6f6c:	9b 81       	ldd	r25, Y+3	; 0x03
    6f6e:	0c 96       	adiw	r24, 0x0c	; 12
    6f70:	0e 94 8f 2b 	call	0x571e	; 0x571e <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    6f74:	80 91 cd 06 	lds	r24, 0x06CD
    6f78:	88 23       	and	r24, r24
    6f7a:	61 f5       	brne	.+88     	; 0x6fd4 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    6f7c:	8a 81       	ldd	r24, Y+2	; 0x02
    6f7e:	9b 81       	ldd	r25, Y+3	; 0x03
    6f80:	02 96       	adiw	r24, 0x02	; 2
    6f82:	0e 94 8f 2b 	call	0x571e	; 0x571e <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    6f86:	ea 81       	ldd	r30, Y+2	; 0x02
    6f88:	fb 81       	ldd	r31, Y+3	; 0x03
    6f8a:	96 89       	ldd	r25, Z+22	; 0x16
    6f8c:	80 91 cb 06 	lds	r24, 0x06CB
    6f90:	89 17       	cp	r24, r25
    6f92:	28 f4       	brcc	.+10     	; 0x6f9e <xTaskRemoveFromEventList+0x58>
    6f94:	ea 81       	ldd	r30, Y+2	; 0x02
    6f96:	fb 81       	ldd	r31, Y+3	; 0x03
    6f98:	86 89       	ldd	r24, Z+22	; 0x16
    6f9a:	80 93 cb 06 	sts	0x06CB, r24
    6f9e:	ea 81       	ldd	r30, Y+2	; 0x02
    6fa0:	fb 81       	ldd	r31, Y+3	; 0x03
    6fa2:	86 89       	ldd	r24, Z+22	; 0x16
    6fa4:	28 2f       	mov	r18, r24
    6fa6:	30 e0       	ldi	r19, 0x00	; 0
    6fa8:	c9 01       	movw	r24, r18
    6faa:	88 0f       	add	r24, r24
    6fac:	99 1f       	adc	r25, r25
    6fae:	88 0f       	add	r24, r24
    6fb0:	99 1f       	adc	r25, r25
    6fb2:	88 0f       	add	r24, r24
    6fb4:	99 1f       	adc	r25, r25
    6fb6:	82 0f       	add	r24, r18
    6fb8:	93 1f       	adc	r25, r19
    6fba:	ac 01       	movw	r20, r24
    6fbc:	4e 52       	subi	r20, 0x2E	; 46
    6fbe:	59 4f       	sbci	r21, 0xF9	; 249
    6fc0:	8a 81       	ldd	r24, Y+2	; 0x02
    6fc2:	9b 81       	ldd	r25, Y+3	; 0x03
    6fc4:	9c 01       	movw	r18, r24
    6fc6:	2e 5f       	subi	r18, 0xFE	; 254
    6fc8:	3f 4f       	sbci	r19, 0xFF	; 255
    6fca:	ca 01       	movw	r24, r20
    6fcc:	b9 01       	movw	r22, r18
    6fce:	0e 94 d7 2a 	call	0x55ae	; 0x55ae <vListInsertEnd>
    6fd2:	0a c0       	rjmp	.+20     	; 0x6fe8 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    6fd4:	8a 81       	ldd	r24, Y+2	; 0x02
    6fd6:	9b 81       	ldd	r25, Y+3	; 0x03
    6fd8:	9c 01       	movw	r18, r24
    6fda:	24 5f       	subi	r18, 0xF4	; 244
    6fdc:	3f 4f       	sbci	r19, 0xFF	; 255
    6fde:	85 e1       	ldi	r24, 0x15	; 21
    6fe0:	97 e0       	ldi	r25, 0x07	; 7
    6fe2:	b9 01       	movw	r22, r18
    6fe4:	0e 94 d7 2a 	call	0x55ae	; 0x55ae <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    6fe8:	ea 81       	ldd	r30, Y+2	; 0x02
    6fea:	fb 81       	ldd	r31, Y+3	; 0x03
    6fec:	96 89       	ldd	r25, Z+22	; 0x16
    6fee:	e0 91 c4 06 	lds	r30, 0x06C4
    6ff2:	f0 91 c5 06 	lds	r31, 0x06C5
    6ff6:	86 89       	ldd	r24, Z+22	; 0x16
    6ff8:	98 17       	cp	r25, r24
    6ffa:	18 f0       	brcs	.+6      	; 0x7002 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    6ffc:	81 e0       	ldi	r24, 0x01	; 1
    6ffe:	89 83       	std	Y+1, r24	; 0x01
    7000:	01 c0       	rjmp	.+2      	; 0x7004 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    7002:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    7004:	89 81       	ldd	r24, Y+1	; 0x01
}
    7006:	0f 90       	pop	r0
    7008:	0f 90       	pop	r0
    700a:	0f 90       	pop	r0
    700c:	0f 90       	pop	r0
    700e:	0f 90       	pop	r0
    7010:	cf 91       	pop	r28
    7012:	df 91       	pop	r29
    7014:	08 95       	ret

00007016 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    7016:	df 93       	push	r29
    7018:	cf 93       	push	r28
    701a:	00 d0       	rcall	.+0      	; 0x701c <vTaskSetTimeOutState+0x6>
    701c:	cd b7       	in	r28, 0x3d	; 61
    701e:	de b7       	in	r29, 0x3e	; 62
    7020:	9a 83       	std	Y+2, r25	; 0x02
    7022:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    7024:	80 91 d0 06 	lds	r24, 0x06D0
    7028:	e9 81       	ldd	r30, Y+1	; 0x01
    702a:	fa 81       	ldd	r31, Y+2	; 0x02
    702c:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    702e:	80 91 c8 06 	lds	r24, 0x06C8
    7032:	90 91 c9 06 	lds	r25, 0x06C9
    7036:	e9 81       	ldd	r30, Y+1	; 0x01
    7038:	fa 81       	ldd	r31, Y+2	; 0x02
    703a:	92 83       	std	Z+2, r25	; 0x02
    703c:	81 83       	std	Z+1, r24	; 0x01
}
    703e:	0f 90       	pop	r0
    7040:	0f 90       	pop	r0
    7042:	cf 91       	pop	r28
    7044:	df 91       	pop	r29
    7046:	08 95       	ret

00007048 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    7048:	df 93       	push	r29
    704a:	cf 93       	push	r28
    704c:	00 d0       	rcall	.+0      	; 0x704e <xTaskCheckForTimeOut+0x6>
    704e:	00 d0       	rcall	.+0      	; 0x7050 <xTaskCheckForTimeOut+0x8>
    7050:	0f 92       	push	r0
    7052:	cd b7       	in	r28, 0x3d	; 61
    7054:	de b7       	in	r29, 0x3e	; 62
    7056:	9b 83       	std	Y+3, r25	; 0x03
    7058:	8a 83       	std	Y+2, r24	; 0x02
    705a:	7d 83       	std	Y+5, r23	; 0x05
    705c:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    705e:	0f b6       	in	r0, 0x3f	; 63
    7060:	f8 94       	cli
    7062:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    7064:	ea 81       	ldd	r30, Y+2	; 0x02
    7066:	fb 81       	ldd	r31, Y+3	; 0x03
    7068:	90 81       	ld	r25, Z
    706a:	80 91 d0 06 	lds	r24, 0x06D0
    706e:	98 17       	cp	r25, r24
    7070:	71 f0       	breq	.+28     	; 0x708e <xTaskCheckForTimeOut+0x46>
    7072:	ea 81       	ldd	r30, Y+2	; 0x02
    7074:	fb 81       	ldd	r31, Y+3	; 0x03
    7076:	21 81       	ldd	r18, Z+1	; 0x01
    7078:	32 81       	ldd	r19, Z+2	; 0x02
    707a:	80 91 c8 06 	lds	r24, 0x06C8
    707e:	90 91 c9 06 	lds	r25, 0x06C9
    7082:	82 17       	cp	r24, r18
    7084:	93 07       	cpc	r25, r19
    7086:	18 f0       	brcs	.+6      	; 0x708e <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    7088:	81 e0       	ldi	r24, 0x01	; 1
    708a:	89 83       	std	Y+1, r24	; 0x01
    708c:	2f c0       	rjmp	.+94     	; 0x70ec <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    708e:	20 91 c8 06 	lds	r18, 0x06C8
    7092:	30 91 c9 06 	lds	r19, 0x06C9
    7096:	ea 81       	ldd	r30, Y+2	; 0x02
    7098:	fb 81       	ldd	r31, Y+3	; 0x03
    709a:	81 81       	ldd	r24, Z+1	; 0x01
    709c:	92 81       	ldd	r25, Z+2	; 0x02
    709e:	28 1b       	sub	r18, r24
    70a0:	39 0b       	sbc	r19, r25
    70a2:	ec 81       	ldd	r30, Y+4	; 0x04
    70a4:	fd 81       	ldd	r31, Y+5	; 0x05
    70a6:	80 81       	ld	r24, Z
    70a8:	91 81       	ldd	r25, Z+1	; 0x01
    70aa:	28 17       	cp	r18, r24
    70ac:	39 07       	cpc	r19, r25
    70ae:	e0 f4       	brcc	.+56     	; 0x70e8 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    70b0:	ec 81       	ldd	r30, Y+4	; 0x04
    70b2:	fd 81       	ldd	r31, Y+5	; 0x05
    70b4:	40 81       	ld	r20, Z
    70b6:	51 81       	ldd	r21, Z+1	; 0x01
    70b8:	ea 81       	ldd	r30, Y+2	; 0x02
    70ba:	fb 81       	ldd	r31, Y+3	; 0x03
    70bc:	21 81       	ldd	r18, Z+1	; 0x01
    70be:	32 81       	ldd	r19, Z+2	; 0x02
    70c0:	80 91 c8 06 	lds	r24, 0x06C8
    70c4:	90 91 c9 06 	lds	r25, 0x06C9
    70c8:	b9 01       	movw	r22, r18
    70ca:	68 1b       	sub	r22, r24
    70cc:	79 0b       	sbc	r23, r25
    70ce:	cb 01       	movw	r24, r22
    70d0:	84 0f       	add	r24, r20
    70d2:	95 1f       	adc	r25, r21
    70d4:	ec 81       	ldd	r30, Y+4	; 0x04
    70d6:	fd 81       	ldd	r31, Y+5	; 0x05
    70d8:	91 83       	std	Z+1, r25	; 0x01
    70da:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    70dc:	8a 81       	ldd	r24, Y+2	; 0x02
    70de:	9b 81       	ldd	r25, Y+3	; 0x03
    70e0:	0e 94 0b 38 	call	0x7016	; 0x7016 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    70e4:	19 82       	std	Y+1, r1	; 0x01
    70e6:	02 c0       	rjmp	.+4      	; 0x70ec <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    70e8:	81 e0       	ldi	r24, 0x01	; 1
    70ea:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    70ec:	0f 90       	pop	r0
    70ee:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    70f0:	89 81       	ldd	r24, Y+1	; 0x01
}
    70f2:	0f 90       	pop	r0
    70f4:	0f 90       	pop	r0
    70f6:	0f 90       	pop	r0
    70f8:	0f 90       	pop	r0
    70fa:	0f 90       	pop	r0
    70fc:	cf 91       	pop	r28
    70fe:	df 91       	pop	r29
    7100:	08 95       	ret

00007102 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    7102:	df 93       	push	r29
    7104:	cf 93       	push	r28
    7106:	cd b7       	in	r28, 0x3d	; 61
    7108:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    710a:	81 e0       	ldi	r24, 0x01	; 1
    710c:	80 93 cf 06 	sts	0x06CF, r24
}
    7110:	cf 91       	pop	r28
    7112:	df 91       	pop	r29
    7114:	08 95       	ret

00007116 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    7116:	df 93       	push	r29
    7118:	cf 93       	push	r28
    711a:	00 d0       	rcall	.+0      	; 0x711c <prvIdleTask+0x6>
    711c:	cd b7       	in	r28, 0x3d	; 61
    711e:	de b7       	in	r29, 0x3e	; 62
    7120:	9a 83       	std	Y+2, r25	; 0x02
    7122:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    7124:	0e 94 29 39 	call	0x7252	; 0x7252 <prvCheckTasksWaitingTermination>
    7128:	fd cf       	rjmp	.-6      	; 0x7124 <prvIdleTask+0xe>

0000712a <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    712a:	0f 93       	push	r16
    712c:	1f 93       	push	r17
    712e:	df 93       	push	r29
    7130:	cf 93       	push	r28
    7132:	cd b7       	in	r28, 0x3d	; 61
    7134:	de b7       	in	r29, 0x3e	; 62
    7136:	29 97       	sbiw	r28, 0x09	; 9
    7138:	0f b6       	in	r0, 0x3f	; 63
    713a:	f8 94       	cli
    713c:	de bf       	out	0x3e, r29	; 62
    713e:	0f be       	out	0x3f, r0	; 63
    7140:	cd bf       	out	0x3d, r28	; 61
    7142:	9a 83       	std	Y+2, r25	; 0x02
    7144:	89 83       	std	Y+1, r24	; 0x01
    7146:	7c 83       	std	Y+4, r23	; 0x04
    7148:	6b 83       	std	Y+3, r22	; 0x03
    714a:	4d 83       	std	Y+5, r20	; 0x05
    714c:	3f 83       	std	Y+7, r19	; 0x07
    714e:	2e 83       	std	Y+6, r18	; 0x06
    7150:	19 87       	std	Y+9, r17	; 0x09
    7152:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    7154:	89 81       	ldd	r24, Y+1	; 0x01
    7156:	9a 81       	ldd	r25, Y+2	; 0x02
    7158:	49 96       	adiw	r24, 0x19	; 25
    715a:	2b 81       	ldd	r18, Y+3	; 0x03
    715c:	3c 81       	ldd	r19, Y+4	; 0x04
    715e:	b9 01       	movw	r22, r18
    7160:	48 e0       	ldi	r20, 0x08	; 8
    7162:	50 e0       	ldi	r21, 0x00	; 0
    7164:	0e 94 71 3a 	call	0x74e2	; 0x74e2 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    7168:	e9 81       	ldd	r30, Y+1	; 0x01
    716a:	fa 81       	ldd	r31, Y+2	; 0x02
    716c:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    716e:	8d 81       	ldd	r24, Y+5	; 0x05
    7170:	85 30       	cpi	r24, 0x05	; 5
    7172:	10 f0       	brcs	.+4      	; 0x7178 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    7174:	84 e0       	ldi	r24, 0x04	; 4
    7176:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    7178:	e9 81       	ldd	r30, Y+1	; 0x01
    717a:	fa 81       	ldd	r31, Y+2	; 0x02
    717c:	8d 81       	ldd	r24, Y+5	; 0x05
    717e:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    7180:	89 81       	ldd	r24, Y+1	; 0x01
    7182:	9a 81       	ldd	r25, Y+2	; 0x02
    7184:	02 96       	adiw	r24, 0x02	; 2
    7186:	0e 94 c7 2a 	call	0x558e	; 0x558e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    718a:	89 81       	ldd	r24, Y+1	; 0x01
    718c:	9a 81       	ldd	r25, Y+2	; 0x02
    718e:	0c 96       	adiw	r24, 0x0c	; 12
    7190:	0e 94 c7 2a 	call	0x558e	; 0x558e <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    7194:	e9 81       	ldd	r30, Y+1	; 0x01
    7196:	fa 81       	ldd	r31, Y+2	; 0x02
    7198:	89 81       	ldd	r24, Y+1	; 0x01
    719a:	9a 81       	ldd	r25, Y+2	; 0x02
    719c:	91 87       	std	Z+9, r25	; 0x09
    719e:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    71a0:	8d 81       	ldd	r24, Y+5	; 0x05
    71a2:	28 2f       	mov	r18, r24
    71a4:	30 e0       	ldi	r19, 0x00	; 0
    71a6:	85 e0       	ldi	r24, 0x05	; 5
    71a8:	90 e0       	ldi	r25, 0x00	; 0
    71aa:	82 1b       	sub	r24, r18
    71ac:	93 0b       	sbc	r25, r19
    71ae:	e9 81       	ldd	r30, Y+1	; 0x01
    71b0:	fa 81       	ldd	r31, Y+2	; 0x02
    71b2:	95 87       	std	Z+13, r25	; 0x0d
    71b4:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    71b6:	e9 81       	ldd	r30, Y+1	; 0x01
    71b8:	fa 81       	ldd	r31, Y+2	; 0x02
    71ba:	89 81       	ldd	r24, Y+1	; 0x01
    71bc:	9a 81       	ldd	r25, Y+2	; 0x02
    71be:	93 8b       	std	Z+19, r25	; 0x13
    71c0:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    71c2:	29 96       	adiw	r28, 0x09	; 9
    71c4:	0f b6       	in	r0, 0x3f	; 63
    71c6:	f8 94       	cli
    71c8:	de bf       	out	0x3e, r29	; 62
    71ca:	0f be       	out	0x3f, r0	; 63
    71cc:	cd bf       	out	0x3d, r28	; 61
    71ce:	cf 91       	pop	r28
    71d0:	df 91       	pop	r29
    71d2:	1f 91       	pop	r17
    71d4:	0f 91       	pop	r16
    71d6:	08 95       	ret

000071d8 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    71d8:	df 93       	push	r29
    71da:	cf 93       	push	r28
    71dc:	0f 92       	push	r0
    71de:	cd b7       	in	r28, 0x3d	; 61
    71e0:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    71e2:	19 82       	std	Y+1, r1	; 0x01
    71e4:	13 c0       	rjmp	.+38     	; 0x720c <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    71e6:	89 81       	ldd	r24, Y+1	; 0x01
    71e8:	28 2f       	mov	r18, r24
    71ea:	30 e0       	ldi	r19, 0x00	; 0
    71ec:	c9 01       	movw	r24, r18
    71ee:	88 0f       	add	r24, r24
    71f0:	99 1f       	adc	r25, r25
    71f2:	88 0f       	add	r24, r24
    71f4:	99 1f       	adc	r25, r25
    71f6:	88 0f       	add	r24, r24
    71f8:	99 1f       	adc	r25, r25
    71fa:	82 0f       	add	r24, r18
    71fc:	93 1f       	adc	r25, r19
    71fe:	8e 52       	subi	r24, 0x2E	; 46
    7200:	99 4f       	sbci	r25, 0xF9	; 249
    7202:	0e 94 9d 2a 	call	0x553a	; 0x553a <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    7206:	89 81       	ldd	r24, Y+1	; 0x01
    7208:	8f 5f       	subi	r24, 0xFF	; 255
    720a:	89 83       	std	Y+1, r24	; 0x01
    720c:	89 81       	ldd	r24, Y+1	; 0x01
    720e:	85 30       	cpi	r24, 0x05	; 5
    7210:	50 f3       	brcs	.-44     	; 0x71e6 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    7212:	8f ef       	ldi	r24, 0xFF	; 255
    7214:	96 e0       	ldi	r25, 0x06	; 6
    7216:	0e 94 9d 2a 	call	0x553a	; 0x553a <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    721a:	88 e0       	ldi	r24, 0x08	; 8
    721c:	97 e0       	ldi	r25, 0x07	; 7
    721e:	0e 94 9d 2a 	call	0x553a	; 0x553a <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    7222:	85 e1       	ldi	r24, 0x15	; 21
    7224:	97 e0       	ldi	r25, 0x07	; 7
    7226:	0e 94 9d 2a 	call	0x553a	; 0x553a <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    722a:	8e e1       	ldi	r24, 0x1E	; 30
    722c:	97 e0       	ldi	r25, 0x07	; 7
    722e:	0e 94 9d 2a 	call	0x553a	; 0x553a <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    7232:	8f ef       	ldi	r24, 0xFF	; 255
    7234:	96 e0       	ldi	r25, 0x06	; 6
    7236:	90 93 12 07 	sts	0x0712, r25
    723a:	80 93 11 07 	sts	0x0711, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    723e:	88 e0       	ldi	r24, 0x08	; 8
    7240:	97 e0       	ldi	r25, 0x07	; 7
    7242:	90 93 14 07 	sts	0x0714, r25
    7246:	80 93 13 07 	sts	0x0713, r24
}
    724a:	0f 90       	pop	r0
    724c:	cf 91       	pop	r28
    724e:	df 91       	pop	r29
    7250:	08 95       	ret

00007252 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    7252:	df 93       	push	r29
    7254:	cf 93       	push	r28
    7256:	00 d0       	rcall	.+0      	; 0x7258 <prvCheckTasksWaitingTermination+0x6>
    7258:	0f 92       	push	r0
    725a:	cd b7       	in	r28, 0x3d	; 61
    725c:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    725e:	80 91 c6 06 	lds	r24, 0x06C6
    7262:	88 23       	and	r24, r24
    7264:	71 f1       	breq	.+92     	; 0x72c2 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    7266:	0e 94 67 35 	call	0x6ace	; 0x6ace <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    726a:	80 91 1e 07 	lds	r24, 0x071E
    726e:	1b 82       	std	Y+3, r1	; 0x03
    7270:	88 23       	and	r24, r24
    7272:	11 f4       	brne	.+4      	; 0x7278 <prvCheckTasksWaitingTermination+0x26>
    7274:	81 e0       	ldi	r24, 0x01	; 1
    7276:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    7278:	0e 94 73 35 	call	0x6ae6	; 0x6ae6 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    727c:	8b 81       	ldd	r24, Y+3	; 0x03
    727e:	88 23       	and	r24, r24
    7280:	01 f5       	brne	.+64     	; 0x72c2 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    7282:	0f b6       	in	r0, 0x3f	; 63
    7284:	f8 94       	cli
    7286:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    7288:	e0 91 23 07 	lds	r30, 0x0723
    728c:	f0 91 24 07 	lds	r31, 0x0724
    7290:	86 81       	ldd	r24, Z+6	; 0x06
    7292:	97 81       	ldd	r25, Z+7	; 0x07
    7294:	9a 83       	std	Y+2, r25	; 0x02
    7296:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    7298:	89 81       	ldd	r24, Y+1	; 0x01
    729a:	9a 81       	ldd	r25, Y+2	; 0x02
    729c:	02 96       	adiw	r24, 0x02	; 2
    729e:	0e 94 8f 2b 	call	0x571e	; 0x571e <vListRemove>
					--uxCurrentNumberOfTasks;
    72a2:	80 91 c7 06 	lds	r24, 0x06C7
    72a6:	81 50       	subi	r24, 0x01	; 1
    72a8:	80 93 c7 06 	sts	0x06C7, r24
					--uxTasksDeleted;
    72ac:	80 91 c6 06 	lds	r24, 0x06C6
    72b0:	81 50       	subi	r24, 0x01	; 1
    72b2:	80 93 c6 06 	sts	0x06C6, r24
				}
				taskEXIT_CRITICAL();
    72b6:	0f 90       	pop	r0
    72b8:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    72ba:	89 81       	ldd	r24, Y+1	; 0x01
    72bc:	9a 81       	ldd	r25, Y+2	; 0x02
    72be:	0e 94 00 3a 	call	0x7400	; 0x7400 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    72c2:	0f 90       	pop	r0
    72c4:	0f 90       	pop	r0
    72c6:	0f 90       	pop	r0
    72c8:	cf 91       	pop	r28
    72ca:	df 91       	pop	r29
    72cc:	08 95       	ret

000072ce <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    72ce:	df 93       	push	r29
    72d0:	cf 93       	push	r28
    72d2:	00 d0       	rcall	.+0      	; 0x72d4 <prvAddCurrentTaskToDelayedList+0x6>
    72d4:	cd b7       	in	r28, 0x3d	; 61
    72d6:	de b7       	in	r29, 0x3e	; 62
    72d8:	9a 83       	std	Y+2, r25	; 0x02
    72da:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    72dc:	e0 91 c4 06 	lds	r30, 0x06C4
    72e0:	f0 91 c5 06 	lds	r31, 0x06C5
    72e4:	89 81       	ldd	r24, Y+1	; 0x01
    72e6:	9a 81       	ldd	r25, Y+2	; 0x02
    72e8:	93 83       	std	Z+3, r25	; 0x03
    72ea:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    72ec:	20 91 c8 06 	lds	r18, 0x06C8
    72f0:	30 91 c9 06 	lds	r19, 0x06C9
    72f4:	89 81       	ldd	r24, Y+1	; 0x01
    72f6:	9a 81       	ldd	r25, Y+2	; 0x02
    72f8:	82 17       	cp	r24, r18
    72fa:	93 07       	cpc	r25, r19
    72fc:	70 f4       	brcc	.+28     	; 0x731a <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    72fe:	80 91 13 07 	lds	r24, 0x0713
    7302:	90 91 14 07 	lds	r25, 0x0714
    7306:	20 91 c4 06 	lds	r18, 0x06C4
    730a:	30 91 c5 06 	lds	r19, 0x06C5
    730e:	2e 5f       	subi	r18, 0xFE	; 254
    7310:	3f 4f       	sbci	r19, 0xFF	; 255
    7312:	b9 01       	movw	r22, r18
    7314:	0e 94 23 2b 	call	0x5646	; 0x5646 <vListInsert>
    7318:	1e c0       	rjmp	.+60     	; 0x7356 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    731a:	40 91 11 07 	lds	r20, 0x0711
    731e:	50 91 12 07 	lds	r21, 0x0712
    7322:	80 91 c4 06 	lds	r24, 0x06C4
    7326:	90 91 c5 06 	lds	r25, 0x06C5
    732a:	9c 01       	movw	r18, r24
    732c:	2e 5f       	subi	r18, 0xFE	; 254
    732e:	3f 4f       	sbci	r19, 0xFF	; 255
    7330:	ca 01       	movw	r24, r20
    7332:	b9 01       	movw	r22, r18
    7334:	0e 94 23 2b 	call	0x5646	; 0x5646 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    7338:	20 91 85 00 	lds	r18, 0x0085
    733c:	30 91 86 00 	lds	r19, 0x0086
    7340:	89 81       	ldd	r24, Y+1	; 0x01
    7342:	9a 81       	ldd	r25, Y+2	; 0x02
    7344:	82 17       	cp	r24, r18
    7346:	93 07       	cpc	r25, r19
    7348:	30 f4       	brcc	.+12     	; 0x7356 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    734a:	89 81       	ldd	r24, Y+1	; 0x01
    734c:	9a 81       	ldd	r25, Y+2	; 0x02
    734e:	90 93 86 00 	sts	0x0086, r25
    7352:	80 93 85 00 	sts	0x0085, r24
		}
	}
}
    7356:	0f 90       	pop	r0
    7358:	0f 90       	pop	r0
    735a:	cf 91       	pop	r28
    735c:	df 91       	pop	r29
    735e:	08 95       	ret

00007360 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    7360:	df 93       	push	r29
    7362:	cf 93       	push	r28
    7364:	cd b7       	in	r28, 0x3d	; 61
    7366:	de b7       	in	r29, 0x3e	; 62
    7368:	28 97       	sbiw	r28, 0x08	; 8
    736a:	0f b6       	in	r0, 0x3f	; 63
    736c:	f8 94       	cli
    736e:	de bf       	out	0x3e, r29	; 62
    7370:	0f be       	out	0x3f, r0	; 63
    7372:	cd bf       	out	0x3d, r28	; 61
    7374:	9c 83       	std	Y+4, r25	; 0x04
    7376:	8b 83       	std	Y+3, r24	; 0x03
    7378:	7e 83       	std	Y+6, r23	; 0x06
    737a:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    737c:	81 e2       	ldi	r24, 0x21	; 33
    737e:	90 e0       	ldi	r25, 0x00	; 0
    7380:	0e 94 31 2a 	call	0x5462	; 0x5462 <pvPortMalloc>
    7384:	9a 83       	std	Y+2, r25	; 0x02
    7386:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    7388:	89 81       	ldd	r24, Y+1	; 0x01
    738a:	9a 81       	ldd	r25, Y+2	; 0x02
    738c:	00 97       	sbiw	r24, 0x00	; 0
    738e:	69 f1       	breq	.+90     	; 0x73ea <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    7390:	8d 81       	ldd	r24, Y+5	; 0x05
    7392:	9e 81       	ldd	r25, Y+6	; 0x06
    7394:	00 97       	sbiw	r24, 0x00	; 0
    7396:	39 f4       	brne	.+14     	; 0x73a6 <prvAllocateTCBAndStack+0x46>
    7398:	8b 81       	ldd	r24, Y+3	; 0x03
    739a:	9c 81       	ldd	r25, Y+4	; 0x04
    739c:	0e 94 31 2a 	call	0x5462	; 0x5462 <pvPortMalloc>
    73a0:	98 87       	std	Y+8, r25	; 0x08
    73a2:	8f 83       	std	Y+7, r24	; 0x07
    73a4:	04 c0       	rjmp	.+8      	; 0x73ae <prvAllocateTCBAndStack+0x4e>
    73a6:	8d 81       	ldd	r24, Y+5	; 0x05
    73a8:	9e 81       	ldd	r25, Y+6	; 0x06
    73aa:	98 87       	std	Y+8, r25	; 0x08
    73ac:	8f 83       	std	Y+7, r24	; 0x07
    73ae:	e9 81       	ldd	r30, Y+1	; 0x01
    73b0:	fa 81       	ldd	r31, Y+2	; 0x02
    73b2:	8f 81       	ldd	r24, Y+7	; 0x07
    73b4:	98 85       	ldd	r25, Y+8	; 0x08
    73b6:	90 8f       	std	Z+24, r25	; 0x18
    73b8:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    73ba:	e9 81       	ldd	r30, Y+1	; 0x01
    73bc:	fa 81       	ldd	r31, Y+2	; 0x02
    73be:	87 89       	ldd	r24, Z+23	; 0x17
    73c0:	90 8d       	ldd	r25, Z+24	; 0x18
    73c2:	00 97       	sbiw	r24, 0x00	; 0
    73c4:	39 f4       	brne	.+14     	; 0x73d4 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    73c6:	89 81       	ldd	r24, Y+1	; 0x01
    73c8:	9a 81       	ldd	r25, Y+2	; 0x02
    73ca:	0e 94 77 2a 	call	0x54ee	; 0x54ee <vPortFree>
			pxNewTCB = NULL;
    73ce:	1a 82       	std	Y+2, r1	; 0x02
    73d0:	19 82       	std	Y+1, r1	; 0x01
    73d2:	0b c0       	rjmp	.+22     	; 0x73ea <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    73d4:	e9 81       	ldd	r30, Y+1	; 0x01
    73d6:	fa 81       	ldd	r31, Y+2	; 0x02
    73d8:	87 89       	ldd	r24, Z+23	; 0x17
    73da:	90 8d       	ldd	r25, Z+24	; 0x18
    73dc:	2b 81       	ldd	r18, Y+3	; 0x03
    73de:	3c 81       	ldd	r19, Y+4	; 0x04
    73e0:	65 ea       	ldi	r22, 0xA5	; 165
    73e2:	70 e0       	ldi	r23, 0x00	; 0
    73e4:	a9 01       	movw	r20, r18
    73e6:	0e 94 6a 3a 	call	0x74d4	; 0x74d4 <memset>
		}
	}

	return pxNewTCB;
    73ea:	89 81       	ldd	r24, Y+1	; 0x01
    73ec:	9a 81       	ldd	r25, Y+2	; 0x02
}
    73ee:	28 96       	adiw	r28, 0x08	; 8
    73f0:	0f b6       	in	r0, 0x3f	; 63
    73f2:	f8 94       	cli
    73f4:	de bf       	out	0x3e, r29	; 62
    73f6:	0f be       	out	0x3f, r0	; 63
    73f8:	cd bf       	out	0x3d, r28	; 61
    73fa:	cf 91       	pop	r28
    73fc:	df 91       	pop	r29
    73fe:	08 95       	ret

00007400 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    7400:	df 93       	push	r29
    7402:	cf 93       	push	r28
    7404:	00 d0       	rcall	.+0      	; 0x7406 <prvDeleteTCB+0x6>
    7406:	cd b7       	in	r28, 0x3d	; 61
    7408:	de b7       	in	r29, 0x3e	; 62
    740a:	9a 83       	std	Y+2, r25	; 0x02
    740c:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    740e:	e9 81       	ldd	r30, Y+1	; 0x01
    7410:	fa 81       	ldd	r31, Y+2	; 0x02
    7412:	87 89       	ldd	r24, Z+23	; 0x17
    7414:	90 8d       	ldd	r25, Z+24	; 0x18
    7416:	0e 94 77 2a 	call	0x54ee	; 0x54ee <vPortFree>
		vPortFree( pxTCB );
    741a:	89 81       	ldd	r24, Y+1	; 0x01
    741c:	9a 81       	ldd	r25, Y+2	; 0x02
    741e:	0e 94 77 2a 	call	0x54ee	; 0x54ee <vPortFree>
	}
    7422:	0f 90       	pop	r0
    7424:	0f 90       	pop	r0
    7426:	cf 91       	pop	r28
    7428:	df 91       	pop	r29
    742a:	08 95       	ret

0000742c <__udivmodhi4>:
    742c:	aa 1b       	sub	r26, r26
    742e:	bb 1b       	sub	r27, r27
    7430:	51 e1       	ldi	r21, 0x11	; 17
    7432:	07 c0       	rjmp	.+14     	; 0x7442 <__udivmodhi4_ep>

00007434 <__udivmodhi4_loop>:
    7434:	aa 1f       	adc	r26, r26
    7436:	bb 1f       	adc	r27, r27
    7438:	a6 17       	cp	r26, r22
    743a:	b7 07       	cpc	r27, r23
    743c:	10 f0       	brcs	.+4      	; 0x7442 <__udivmodhi4_ep>
    743e:	a6 1b       	sub	r26, r22
    7440:	b7 0b       	sbc	r27, r23

00007442 <__udivmodhi4_ep>:
    7442:	88 1f       	adc	r24, r24
    7444:	99 1f       	adc	r25, r25
    7446:	5a 95       	dec	r21
    7448:	a9 f7       	brne	.-22     	; 0x7434 <__udivmodhi4_loop>
    744a:	80 95       	com	r24
    744c:	90 95       	com	r25
    744e:	bc 01       	movw	r22, r24
    7450:	cd 01       	movw	r24, r26
    7452:	08 95       	ret

00007454 <__prologue_saves__>:
    7454:	2f 92       	push	r2
    7456:	3f 92       	push	r3
    7458:	4f 92       	push	r4
    745a:	5f 92       	push	r5
    745c:	6f 92       	push	r6
    745e:	7f 92       	push	r7
    7460:	8f 92       	push	r8
    7462:	9f 92       	push	r9
    7464:	af 92       	push	r10
    7466:	bf 92       	push	r11
    7468:	cf 92       	push	r12
    746a:	df 92       	push	r13
    746c:	ef 92       	push	r14
    746e:	ff 92       	push	r15
    7470:	0f 93       	push	r16
    7472:	1f 93       	push	r17
    7474:	cf 93       	push	r28
    7476:	df 93       	push	r29
    7478:	cd b7       	in	r28, 0x3d	; 61
    747a:	de b7       	in	r29, 0x3e	; 62
    747c:	ca 1b       	sub	r28, r26
    747e:	db 0b       	sbc	r29, r27
    7480:	0f b6       	in	r0, 0x3f	; 63
    7482:	f8 94       	cli
    7484:	de bf       	out	0x3e, r29	; 62
    7486:	0f be       	out	0x3f, r0	; 63
    7488:	cd bf       	out	0x3d, r28	; 61
    748a:	09 94       	ijmp

0000748c <__epilogue_restores__>:
    748c:	2a 88       	ldd	r2, Y+18	; 0x12
    748e:	39 88       	ldd	r3, Y+17	; 0x11
    7490:	48 88       	ldd	r4, Y+16	; 0x10
    7492:	5f 84       	ldd	r5, Y+15	; 0x0f
    7494:	6e 84       	ldd	r6, Y+14	; 0x0e
    7496:	7d 84       	ldd	r7, Y+13	; 0x0d
    7498:	8c 84       	ldd	r8, Y+12	; 0x0c
    749a:	9b 84       	ldd	r9, Y+11	; 0x0b
    749c:	aa 84       	ldd	r10, Y+10	; 0x0a
    749e:	b9 84       	ldd	r11, Y+9	; 0x09
    74a0:	c8 84       	ldd	r12, Y+8	; 0x08
    74a2:	df 80       	ldd	r13, Y+7	; 0x07
    74a4:	ee 80       	ldd	r14, Y+6	; 0x06
    74a6:	fd 80       	ldd	r15, Y+5	; 0x05
    74a8:	0c 81       	ldd	r16, Y+4	; 0x04
    74aa:	1b 81       	ldd	r17, Y+3	; 0x03
    74ac:	aa 81       	ldd	r26, Y+2	; 0x02
    74ae:	b9 81       	ldd	r27, Y+1	; 0x01
    74b0:	ce 0f       	add	r28, r30
    74b2:	d1 1d       	adc	r29, r1
    74b4:	0f b6       	in	r0, 0x3f	; 63
    74b6:	f8 94       	cli
    74b8:	de bf       	out	0x3e, r29	; 62
    74ba:	0f be       	out	0x3f, r0	; 63
    74bc:	cd bf       	out	0x3d, r28	; 61
    74be:	ed 01       	movw	r28, r26
    74c0:	08 95       	ret

000074c2 <memcpy>:
    74c2:	fb 01       	movw	r30, r22
    74c4:	dc 01       	movw	r26, r24
    74c6:	02 c0       	rjmp	.+4      	; 0x74cc <memcpy+0xa>
    74c8:	01 90       	ld	r0, Z+
    74ca:	0d 92       	st	X+, r0
    74cc:	41 50       	subi	r20, 0x01	; 1
    74ce:	50 40       	sbci	r21, 0x00	; 0
    74d0:	d8 f7       	brcc	.-10     	; 0x74c8 <memcpy+0x6>
    74d2:	08 95       	ret

000074d4 <memset>:
    74d4:	dc 01       	movw	r26, r24
    74d6:	01 c0       	rjmp	.+2      	; 0x74da <memset+0x6>
    74d8:	6d 93       	st	X+, r22
    74da:	41 50       	subi	r20, 0x01	; 1
    74dc:	50 40       	sbci	r21, 0x00	; 0
    74de:	e0 f7       	brcc	.-8      	; 0x74d8 <memset+0x4>
    74e0:	08 95       	ret

000074e2 <strncpy>:
    74e2:	fb 01       	movw	r30, r22
    74e4:	dc 01       	movw	r26, r24
    74e6:	41 50       	subi	r20, 0x01	; 1
    74e8:	50 40       	sbci	r21, 0x00	; 0
    74ea:	48 f0       	brcs	.+18     	; 0x74fe <strncpy+0x1c>
    74ec:	01 90       	ld	r0, Z+
    74ee:	0d 92       	st	X+, r0
    74f0:	00 20       	and	r0, r0
    74f2:	c9 f7       	brne	.-14     	; 0x74e6 <strncpy+0x4>
    74f4:	01 c0       	rjmp	.+2      	; 0x74f8 <strncpy+0x16>
    74f6:	1d 92       	st	X+, r1
    74f8:	41 50       	subi	r20, 0x01	; 1
    74fa:	50 40       	sbci	r21, 0x00	; 0
    74fc:	e0 f7       	brcc	.-8      	; 0x74f6 <strncpy+0x14>
    74fe:	08 95       	ret

00007500 <_exit>:
    7500:	f8 94       	cli

00007502 <__stop_program>:
    7502:	ff cf       	rjmp	.-2      	; 0x7502 <__stop_program>
