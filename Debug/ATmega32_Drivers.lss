
ATmega32_Drivers.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00008646  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000144  00800060  00008646  000086da  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000044  008001a4  008001a4  0000881e  2**0
                  ALLOC
  3 .stab         00007ecc  00000000  00000000  00008820  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003572  00000000  00000000  000106ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  00013c5e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001ef  00000000  00000000  00013dfe  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000298b  00000000  00000000  00013fed  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000013da  00000000  00000000  00016978  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000012ad  00000000  00000000  00017d52  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001c0  00000000  00000000  00019000  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000036b  00000000  00000000  000191c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000017fa  00000000  00000000  0001952b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000068  00000000  00000000  0001ad25  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 db 14 	jmp	0x29b6	; 0x29b6 <__vector_1>
       8:	0c 94 0e 15 	jmp	0x2a1c	; 0x2a1c <__vector_2>
       c:	0c 94 41 15 	jmp	0x2a82	; 0x2a82 <__vector_3>
      10:	0c 94 f4 38 	jmp	0x71e8	; 0x71e8 <__vector_4>
      14:	0c 94 c1 38 	jmp	0x7182	; 0x7182 <__vector_5>
      18:	0c 94 be 36 	jmp	0x6d7c	; 0x6d7c <__vector_6>
      1c:	0c 94 f1 36 	jmp	0x6de2	; 0x6de2 <__vector_7>
      20:	0c 94 24 37 	jmp	0x6e48	; 0x6e48 <__vector_8>
      24:	0c 94 57 37 	jmp	0x6eae	; 0x6eae <__vector_9>
      28:	0c 94 9b 32 	jmp	0x6536	; 0x6536 <__vector_10>
      2c:	0c 94 68 32 	jmp	0x64d0	; 0x64d0 <__vector_11>
      30:	0c 94 9d 2a 	jmp	0x553a	; 0x553a <__vector_12>
      34:	0c 94 6d 3c 	jmp	0x78da	; 0x78da <__vector_13>
      38:	0c 94 a0 3c 	jmp	0x7940	; 0x7940 <__vector_14>
      3c:	0c 94 d3 3c 	jmp	0x79a6	; 0x79a6 <__vector_15>
      40:	0c 94 ff 0d 	jmp	0x1bfe	; 0x1bfe <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 a7 3a 	jmp	0x754e	; 0x754e <__vector_19>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 e4       	ldi	r30, 0x46	; 70
      68:	f6 e8       	ldi	r31, 0x86	; 134
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 3a       	cpi	r26, 0xA4	; 164
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	11 e0       	ldi	r17, 0x01	; 1
      78:	a4 ea       	ldi	r26, 0xA4	; 164
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a8 3e       	cpi	r26, 0xE8	; 232
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 ea 3f 	call	0x7fd4	; 0x7fd4 <main>
      8a:	0c 94 21 43 	jmp	0x8642	; 0x8642 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__ashldi3>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	df 93       	push	r29
      9a:	cf 93       	push	r28
      9c:	cd b7       	in	r28, 0x3d	; 61
      9e:	de b7       	in	r29, 0x3e	; 62
      a0:	60 97       	sbiw	r28, 0x10	; 16
      a2:	0f b6       	in	r0, 0x3f	; 63
      a4:	f8 94       	cli
      a6:	de bf       	out	0x3e, r29	; 62
      a8:	0f be       	out	0x3f, r0	; 63
      aa:	cd bf       	out	0x3d, r28	; 61
      ac:	a8 2f       	mov	r26, r24
      ae:	00 23       	and	r16, r16
      b0:	09 f4       	brne	.+2      	; 0xb4 <__ashldi3+0x22>
      b2:	61 c0       	rjmp	.+194    	; 0x176 <__ashldi3+0xe4>
      b4:	7e 01       	movw	r14, r28
      b6:	08 94       	sec
      b8:	e1 1c       	adc	r14, r1
      ba:	f1 1c       	adc	r15, r1
      bc:	88 e0       	ldi	r24, 0x08	; 8
      be:	f7 01       	movw	r30, r14
      c0:	11 92       	st	Z+, r1
      c2:	8a 95       	dec	r24
      c4:	e9 f7       	brne	.-6      	; 0xc0 <__ashldi3+0x2e>
      c6:	29 83       	std	Y+1, r18	; 0x01
      c8:	3a 83       	std	Y+2, r19	; 0x02
      ca:	4b 83       	std	Y+3, r20	; 0x03
      cc:	5c 83       	std	Y+4, r21	; 0x04
      ce:	6d 83       	std	Y+5, r22	; 0x05
      d0:	7e 83       	std	Y+6, r23	; 0x06
      d2:	af 83       	std	Y+7, r26	; 0x07
      d4:	98 87       	std	Y+8, r25	; 0x08
      d6:	80 e2       	ldi	r24, 0x20	; 32
      d8:	80 1b       	sub	r24, r16
      da:	e8 2f       	mov	r30, r24
      dc:	ff 27       	eor	r31, r31
      de:	e7 fd       	sbrc	r30, 7
      e0:	f0 95       	com	r31
      e2:	49 81       	ldd	r20, Y+1	; 0x01
      e4:	5a 81       	ldd	r21, Y+2	; 0x02
      e6:	6b 81       	ldd	r22, Y+3	; 0x03
      e8:	7c 81       	ldd	r23, Y+4	; 0x04
      ea:	18 16       	cp	r1, r24
      ec:	84 f0       	brlt	.+32     	; 0x10e <__ashldi3+0x7c>
      ee:	19 86       	std	Y+9, r1	; 0x09
      f0:	1a 86       	std	Y+10, r1	; 0x0a
      f2:	1b 86       	std	Y+11, r1	; 0x0b
      f4:	1c 86       	std	Y+12, r1	; 0x0c
      f6:	88 27       	eor	r24, r24
      f8:	99 27       	eor	r25, r25
      fa:	8e 1b       	sub	r24, r30
      fc:	9f 0b       	sbc	r25, r31
      fe:	04 c0       	rjmp	.+8      	; 0x108 <__ashldi3+0x76>
     100:	44 0f       	add	r20, r20
     102:	55 1f       	adc	r21, r21
     104:	66 1f       	adc	r22, r22
     106:	77 1f       	adc	r23, r23
     108:	8a 95       	dec	r24
     10a:	d2 f7       	brpl	.-12     	; 0x100 <__ashldi3+0x6e>
     10c:	28 c0       	rjmp	.+80     	; 0x15e <__ashldi3+0xcc>
     10e:	20 2f       	mov	r18, r16
     110:	33 27       	eor	r19, r19
     112:	27 fd       	sbrc	r18, 7
     114:	30 95       	com	r19
     116:	db 01       	movw	r26, r22
     118:	ca 01       	movw	r24, r20
     11a:	02 2e       	mov	r0, r18
     11c:	04 c0       	rjmp	.+8      	; 0x126 <__ashldi3+0x94>
     11e:	88 0f       	add	r24, r24
     120:	99 1f       	adc	r25, r25
     122:	aa 1f       	adc	r26, r26
     124:	bb 1f       	adc	r27, r27
     126:	0a 94       	dec	r0
     128:	d2 f7       	brpl	.-12     	; 0x11e <__ashldi3+0x8c>
     12a:	89 87       	std	Y+9, r24	; 0x09
     12c:	9a 87       	std	Y+10, r25	; 0x0a
     12e:	ab 87       	std	Y+11, r26	; 0x0b
     130:	bc 87       	std	Y+12, r27	; 0x0c
     132:	04 c0       	rjmp	.+8      	; 0x13c <__ashldi3+0xaa>
     134:	76 95       	lsr	r23
     136:	67 95       	ror	r22
     138:	57 95       	ror	r21
     13a:	47 95       	ror	r20
     13c:	ea 95       	dec	r30
     13e:	d2 f7       	brpl	.-12     	; 0x134 <__ashldi3+0xa2>
     140:	8d 81       	ldd	r24, Y+5	; 0x05
     142:	9e 81       	ldd	r25, Y+6	; 0x06
     144:	af 81       	ldd	r26, Y+7	; 0x07
     146:	b8 85       	ldd	r27, Y+8	; 0x08
     148:	04 c0       	rjmp	.+8      	; 0x152 <__ashldi3+0xc0>
     14a:	88 0f       	add	r24, r24
     14c:	99 1f       	adc	r25, r25
     14e:	aa 1f       	adc	r26, r26
     150:	bb 1f       	adc	r27, r27
     152:	2a 95       	dec	r18
     154:	d2 f7       	brpl	.-12     	; 0x14a <__ashldi3+0xb8>
     156:	48 2b       	or	r20, r24
     158:	59 2b       	or	r21, r25
     15a:	6a 2b       	or	r22, r26
     15c:	7b 2b       	or	r23, r27
     15e:	4d 87       	std	Y+13, r20	; 0x0d
     160:	5e 87       	std	Y+14, r21	; 0x0e
     162:	6f 87       	std	Y+15, r22	; 0x0f
     164:	78 8b       	std	Y+16, r23	; 0x10
     166:	29 85       	ldd	r18, Y+9	; 0x09
     168:	3a 85       	ldd	r19, Y+10	; 0x0a
     16a:	4b 85       	ldd	r20, Y+11	; 0x0b
     16c:	5c 85       	ldd	r21, Y+12	; 0x0c
     16e:	6d 85       	ldd	r22, Y+13	; 0x0d
     170:	7e 85       	ldd	r23, Y+14	; 0x0e
     172:	af 85       	ldd	r26, Y+15	; 0x0f
     174:	98 89       	ldd	r25, Y+16	; 0x10
     176:	8a 2f       	mov	r24, r26
     178:	60 96       	adiw	r28, 0x10	; 16
     17a:	0f b6       	in	r0, 0x3f	; 63
     17c:	f8 94       	cli
     17e:	de bf       	out	0x3e, r29	; 62
     180:	0f be       	out	0x3f, r0	; 63
     182:	cd bf       	out	0x3d, r28	; 61
     184:	cf 91       	pop	r28
     186:	df 91       	pop	r29
     188:	0f 91       	pop	r16
     18a:	ff 90       	pop	r15
     18c:	ef 90       	pop	r14
     18e:	08 95       	ret

00000190 <__fixunssfsi>:
     190:	ef 92       	push	r14
     192:	ff 92       	push	r15
     194:	0f 93       	push	r16
     196:	1f 93       	push	r17
     198:	7b 01       	movw	r14, r22
     19a:	8c 01       	movw	r16, r24
     19c:	20 e0       	ldi	r18, 0x00	; 0
     19e:	30 e0       	ldi	r19, 0x00	; 0
     1a0:	40 e0       	ldi	r20, 0x00	; 0
     1a2:	5f e4       	ldi	r21, 0x4F	; 79
     1a4:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <__gesf2>
     1a8:	88 23       	and	r24, r24
     1aa:	8c f0       	brlt	.+34     	; 0x1ce <__fixunssfsi+0x3e>
     1ac:	c8 01       	movw	r24, r16
     1ae:	b7 01       	movw	r22, r14
     1b0:	20 e0       	ldi	r18, 0x00	; 0
     1b2:	30 e0       	ldi	r19, 0x00	; 0
     1b4:	40 e0       	ldi	r20, 0x00	; 0
     1b6:	5f e4       	ldi	r21, 0x4F	; 79
     1b8:	0e 94 b5 08 	call	0x116a	; 0x116a <__subsf3>
     1bc:	0e 94 49 0b 	call	0x1692	; 0x1692 <__fixsfsi>
     1c0:	9b 01       	movw	r18, r22
     1c2:	ac 01       	movw	r20, r24
     1c4:	20 50       	subi	r18, 0x00	; 0
     1c6:	30 40       	sbci	r19, 0x00	; 0
     1c8:	40 40       	sbci	r20, 0x00	; 0
     1ca:	50 48       	sbci	r21, 0x80	; 128
     1cc:	06 c0       	rjmp	.+12     	; 0x1da <__fixunssfsi+0x4a>
     1ce:	c8 01       	movw	r24, r16
     1d0:	b7 01       	movw	r22, r14
     1d2:	0e 94 49 0b 	call	0x1692	; 0x1692 <__fixsfsi>
     1d6:	9b 01       	movw	r18, r22
     1d8:	ac 01       	movw	r20, r24
     1da:	b9 01       	movw	r22, r18
     1dc:	ca 01       	movw	r24, r20
     1de:	1f 91       	pop	r17
     1e0:	0f 91       	pop	r16
     1e2:	ff 90       	pop	r15
     1e4:	ef 90       	pop	r14
     1e6:	08 95       	ret

000001e8 <__udivdi3>:
     1e8:	ae e5       	ldi	r26, 0x5E	; 94
     1ea:	b0 e0       	ldi	r27, 0x00	; 0
     1ec:	ea ef       	ldi	r30, 0xFA	; 250
     1ee:	f0 e0       	ldi	r31, 0x00	; 0
     1f0:	0c 94 ea 42 	jmp	0x85d4	; 0x85d4 <__prologue_saves__>
     1f4:	a8 e0       	ldi	r26, 0x08	; 8
     1f6:	4e 01       	movw	r8, r28
     1f8:	08 94       	sec
     1fa:	81 1c       	adc	r8, r1
     1fc:	91 1c       	adc	r9, r1
     1fe:	f4 01       	movw	r30, r8
     200:	6a 2e       	mov	r6, r26
     202:	11 92       	st	Z+, r1
     204:	6a 94       	dec	r6
     206:	e9 f7       	brne	.-6      	; 0x202 <__udivdi3+0x1a>
     208:	29 83       	std	Y+1, r18	; 0x01
     20a:	3a 83       	std	Y+2, r19	; 0x02
     20c:	4b 83       	std	Y+3, r20	; 0x03
     20e:	5c 83       	std	Y+4, r21	; 0x04
     210:	6d 83       	std	Y+5, r22	; 0x05
     212:	7e 83       	std	Y+6, r23	; 0x06
     214:	8f 83       	std	Y+7, r24	; 0x07
     216:	98 87       	std	Y+8, r25	; 0x08
     218:	ce 01       	movw	r24, r28
     21a:	09 96       	adiw	r24, 0x09	; 9
     21c:	fc 01       	movw	r30, r24
     21e:	11 92       	st	Z+, r1
     220:	aa 95       	dec	r26
     222:	e9 f7       	brne	.-6      	; 0x21e <__udivdi3+0x36>
     224:	a9 86       	std	Y+9, r10	; 0x09
     226:	ba 86       	std	Y+10, r11	; 0x0a
     228:	cb 86       	std	Y+11, r12	; 0x0b
     22a:	dc 86       	std	Y+12, r13	; 0x0c
     22c:	ed 86       	std	Y+13, r14	; 0x0d
     22e:	fe 86       	std	Y+14, r15	; 0x0e
     230:	0f 87       	std	Y+15, r16	; 0x0f
     232:	18 8b       	std	Y+16, r17	; 0x10
     234:	29 84       	ldd	r2, Y+9	; 0x09
     236:	3a 84       	ldd	r3, Y+10	; 0x0a
     238:	4b 84       	ldd	r4, Y+11	; 0x0b
     23a:	5c 84       	ldd	r5, Y+12	; 0x0c
     23c:	ed 84       	ldd	r14, Y+13	; 0x0d
     23e:	fe 84       	ldd	r15, Y+14	; 0x0e
     240:	0f 85       	ldd	r16, Y+15	; 0x0f
     242:	18 89       	ldd	r17, Y+16	; 0x10
     244:	69 80       	ldd	r6, Y+1	; 0x01
     246:	7a 80       	ldd	r7, Y+2	; 0x02
     248:	8b 80       	ldd	r8, Y+3	; 0x03
     24a:	9c 80       	ldd	r9, Y+4	; 0x04
     24c:	6d a6       	std	Y+45, r6	; 0x2d
     24e:	7e a6       	std	Y+46, r7	; 0x2e
     250:	8f a6       	std	Y+47, r8	; 0x2f
     252:	98 aa       	std	Y+48, r9	; 0x30
     254:	6d 80       	ldd	r6, Y+5	; 0x05
     256:	7e 80       	ldd	r7, Y+6	; 0x06
     258:	8f 80       	ldd	r8, Y+7	; 0x07
     25a:	98 84       	ldd	r9, Y+8	; 0x08
     25c:	e1 14       	cp	r14, r1
     25e:	f1 04       	cpc	r15, r1
     260:	01 05       	cpc	r16, r1
     262:	11 05       	cpc	r17, r1
     264:	09 f0       	breq	.+2      	; 0x268 <__udivdi3+0x80>
     266:	b3 c3       	rjmp	.+1894   	; 0x9ce <__stack+0x16f>
     268:	62 14       	cp	r6, r2
     26a:	73 04       	cpc	r7, r3
     26c:	84 04       	cpc	r8, r4
     26e:	95 04       	cpc	r9, r5
     270:	08 f0       	brcs	.+2      	; 0x274 <__udivdi3+0x8c>
     272:	3d c1       	rjmp	.+634    	; 0x4ee <__udivdi3+0x306>
     274:	00 e0       	ldi	r16, 0x00	; 0
     276:	20 16       	cp	r2, r16
     278:	00 e0       	ldi	r16, 0x00	; 0
     27a:	30 06       	cpc	r3, r16
     27c:	01 e0       	ldi	r16, 0x01	; 1
     27e:	40 06       	cpc	r4, r16
     280:	00 e0       	ldi	r16, 0x00	; 0
     282:	50 06       	cpc	r5, r16
     284:	88 f4       	brcc	.+34     	; 0x2a8 <__udivdi3+0xc0>
     286:	1f ef       	ldi	r17, 0xFF	; 255
     288:	21 16       	cp	r2, r17
     28a:	31 04       	cpc	r3, r1
     28c:	41 04       	cpc	r4, r1
     28e:	51 04       	cpc	r5, r1
     290:	39 f0       	breq	.+14     	; 0x2a0 <__udivdi3+0xb8>
     292:	30 f0       	brcs	.+12     	; 0x2a0 <__udivdi3+0xb8>
     294:	48 e0       	ldi	r20, 0x08	; 8
     296:	e4 2e       	mov	r14, r20
     298:	f1 2c       	mov	r15, r1
     29a:	01 2d       	mov	r16, r1
     29c:	11 2d       	mov	r17, r1
     29e:	18 c0       	rjmp	.+48     	; 0x2d0 <__udivdi3+0xe8>
     2a0:	ee 24       	eor	r14, r14
     2a2:	ff 24       	eor	r15, r15
     2a4:	87 01       	movw	r16, r14
     2a6:	14 c0       	rjmp	.+40     	; 0x2d0 <__udivdi3+0xe8>
     2a8:	20 e0       	ldi	r18, 0x00	; 0
     2aa:	22 16       	cp	r2, r18
     2ac:	20 e0       	ldi	r18, 0x00	; 0
     2ae:	32 06       	cpc	r3, r18
     2b0:	20 e0       	ldi	r18, 0x00	; 0
     2b2:	42 06       	cpc	r4, r18
     2b4:	21 e0       	ldi	r18, 0x01	; 1
     2b6:	52 06       	cpc	r5, r18
     2b8:	30 f0       	brcs	.+12     	; 0x2c6 <__udivdi3+0xde>
     2ba:	38 e1       	ldi	r19, 0x18	; 24
     2bc:	e3 2e       	mov	r14, r19
     2be:	f1 2c       	mov	r15, r1
     2c0:	01 2d       	mov	r16, r1
     2c2:	11 2d       	mov	r17, r1
     2c4:	05 c0       	rjmp	.+10     	; 0x2d0 <__udivdi3+0xe8>
     2c6:	20 e1       	ldi	r18, 0x10	; 16
     2c8:	e2 2e       	mov	r14, r18
     2ca:	f1 2c       	mov	r15, r1
     2cc:	01 2d       	mov	r16, r1
     2ce:	11 2d       	mov	r17, r1
     2d0:	d2 01       	movw	r26, r4
     2d2:	c1 01       	movw	r24, r2
     2d4:	0e 2c       	mov	r0, r14
     2d6:	04 c0       	rjmp	.+8      	; 0x2e0 <__udivdi3+0xf8>
     2d8:	b6 95       	lsr	r27
     2da:	a7 95       	ror	r26
     2dc:	97 95       	ror	r25
     2de:	87 95       	ror	r24
     2e0:	0a 94       	dec	r0
     2e2:	d2 f7       	brpl	.-12     	; 0x2d8 <__udivdi3+0xf0>
     2e4:	8c 58       	subi	r24, 0x8C	; 140
     2e6:	9f 4f       	sbci	r25, 0xFF	; 255
     2e8:	dc 01       	movw	r26, r24
     2ea:	2c 91       	ld	r18, X
     2ec:	80 e2       	ldi	r24, 0x20	; 32
     2ee:	90 e0       	ldi	r25, 0x00	; 0
     2f0:	a0 e0       	ldi	r26, 0x00	; 0
     2f2:	b0 e0       	ldi	r27, 0x00	; 0
     2f4:	8e 19       	sub	r24, r14
     2f6:	9f 09       	sbc	r25, r15
     2f8:	a0 0b       	sbc	r26, r16
     2fa:	b1 0b       	sbc	r27, r17
     2fc:	7c 01       	movw	r14, r24
     2fe:	8d 01       	movw	r16, r26
     300:	e2 1a       	sub	r14, r18
     302:	f1 08       	sbc	r15, r1
     304:	01 09       	sbc	r16, r1
     306:	11 09       	sbc	r17, r1
     308:	e1 14       	cp	r14, r1
     30a:	f1 04       	cpc	r15, r1
     30c:	01 05       	cpc	r16, r1
     30e:	11 05       	cpc	r17, r1
     310:	a1 f1       	breq	.+104    	; 0x37a <__udivdi3+0x192>
     312:	0e 2c       	mov	r0, r14
     314:	04 c0       	rjmp	.+8      	; 0x31e <__udivdi3+0x136>
     316:	22 0c       	add	r2, r2
     318:	33 1c       	adc	r3, r3
     31a:	44 1c       	adc	r4, r4
     31c:	55 1c       	adc	r5, r5
     31e:	0a 94       	dec	r0
     320:	d2 f7       	brpl	.-12     	; 0x316 <__udivdi3+0x12e>
     322:	a4 01       	movw	r20, r8
     324:	93 01       	movw	r18, r6
     326:	0e 2c       	mov	r0, r14
     328:	04 c0       	rjmp	.+8      	; 0x332 <__udivdi3+0x14a>
     32a:	22 0f       	add	r18, r18
     32c:	33 1f       	adc	r19, r19
     32e:	44 1f       	adc	r20, r20
     330:	55 1f       	adc	r21, r21
     332:	0a 94       	dec	r0
     334:	d2 f7       	brpl	.-12     	; 0x32a <__udivdi3+0x142>
     336:	80 e2       	ldi	r24, 0x20	; 32
     338:	90 e0       	ldi	r25, 0x00	; 0
     33a:	8e 19       	sub	r24, r14
     33c:	9f 09       	sbc	r25, r15
     33e:	6d a4       	ldd	r6, Y+45	; 0x2d
     340:	7e a4       	ldd	r7, Y+46	; 0x2e
     342:	8f a4       	ldd	r8, Y+47	; 0x2f
     344:	98 a8       	ldd	r9, Y+48	; 0x30
     346:	04 c0       	rjmp	.+8      	; 0x350 <__udivdi3+0x168>
     348:	96 94       	lsr	r9
     34a:	87 94       	ror	r8
     34c:	77 94       	ror	r7
     34e:	67 94       	ror	r6
     350:	8a 95       	dec	r24
     352:	d2 f7       	brpl	.-12     	; 0x348 <__udivdi3+0x160>
     354:	62 2a       	or	r6, r18
     356:	73 2a       	or	r7, r19
     358:	84 2a       	or	r8, r20
     35a:	95 2a       	or	r9, r21
     35c:	ad a4       	ldd	r10, Y+45	; 0x2d
     35e:	be a4       	ldd	r11, Y+46	; 0x2e
     360:	cf a4       	ldd	r12, Y+47	; 0x2f
     362:	d8 a8       	ldd	r13, Y+48	; 0x30
     364:	04 c0       	rjmp	.+8      	; 0x36e <__udivdi3+0x186>
     366:	aa 0c       	add	r10, r10
     368:	bb 1c       	adc	r11, r11
     36a:	cc 1c       	adc	r12, r12
     36c:	dd 1c       	adc	r13, r13
     36e:	ea 94       	dec	r14
     370:	d2 f7       	brpl	.-12     	; 0x366 <__udivdi3+0x17e>
     372:	ad a6       	std	Y+45, r10	; 0x2d
     374:	be a6       	std	Y+46, r11	; 0x2e
     376:	cf a6       	std	Y+47, r12	; 0x2f
     378:	d8 aa       	std	Y+48, r13	; 0x30
     37a:	62 01       	movw	r12, r4
     37c:	ee 24       	eor	r14, r14
     37e:	ff 24       	eor	r15, r15
     380:	cd aa       	std	Y+53, r12	; 0x35
     382:	de aa       	std	Y+54, r13	; 0x36
     384:	ef aa       	std	Y+55, r14	; 0x37
     386:	f8 ae       	std	Y+56, r15	; 0x38
     388:	92 01       	movw	r18, r4
     38a:	81 01       	movw	r16, r2
     38c:	20 70       	andi	r18, 0x00	; 0
     38e:	30 70       	andi	r19, 0x00	; 0
     390:	09 af       	std	Y+57, r16	; 0x39
     392:	1a af       	std	Y+58, r17	; 0x3a
     394:	2b af       	std	Y+59, r18	; 0x3b
     396:	3c af       	std	Y+60, r19	; 0x3c
     398:	c4 01       	movw	r24, r8
     39a:	b3 01       	movw	r22, r6
     39c:	a7 01       	movw	r20, r14
     39e:	96 01       	movw	r18, r12
     3a0:	0e 94 c8 42 	call	0x8590	; 0x8590 <__udivmodsi4>
     3a4:	7b 01       	movw	r14, r22
     3a6:	8c 01       	movw	r16, r24
     3a8:	c4 01       	movw	r24, r8
     3aa:	b3 01       	movw	r22, r6
     3ac:	2d a9       	ldd	r18, Y+53	; 0x35
     3ae:	3e a9       	ldd	r19, Y+54	; 0x36
     3b0:	4f a9       	ldd	r20, Y+55	; 0x37
     3b2:	58 ad       	ldd	r21, Y+56	; 0x38
     3b4:	0e 94 c8 42 	call	0x8590	; 0x8590 <__udivmodsi4>
     3b8:	c9 01       	movw	r24, r18
     3ba:	da 01       	movw	r26, r20
     3bc:	3c 01       	movw	r6, r24
     3be:	4d 01       	movw	r8, r26
     3c0:	c4 01       	movw	r24, r8
     3c2:	b3 01       	movw	r22, r6
     3c4:	29 ad       	ldd	r18, Y+57	; 0x39
     3c6:	3a ad       	ldd	r19, Y+58	; 0x3a
     3c8:	4b ad       	ldd	r20, Y+59	; 0x3b
     3ca:	5c ad       	ldd	r21, Y+60	; 0x3c
     3cc:	0e 94 95 42 	call	0x852a	; 0x852a <__mulsi3>
     3d0:	9b 01       	movw	r18, r22
     3d2:	ac 01       	movw	r20, r24
     3d4:	87 01       	movw	r16, r14
     3d6:	ff 24       	eor	r15, r15
     3d8:	ee 24       	eor	r14, r14
     3da:	ad a4       	ldd	r10, Y+45	; 0x2d
     3dc:	be a4       	ldd	r11, Y+46	; 0x2e
     3de:	cf a4       	ldd	r12, Y+47	; 0x2f
     3e0:	d8 a8       	ldd	r13, Y+48	; 0x30
     3e2:	c6 01       	movw	r24, r12
     3e4:	aa 27       	eor	r26, r26
     3e6:	bb 27       	eor	r27, r27
     3e8:	57 01       	movw	r10, r14
     3ea:	68 01       	movw	r12, r16
     3ec:	a8 2a       	or	r10, r24
     3ee:	b9 2a       	or	r11, r25
     3f0:	ca 2a       	or	r12, r26
     3f2:	db 2a       	or	r13, r27
     3f4:	a2 16       	cp	r10, r18
     3f6:	b3 06       	cpc	r11, r19
     3f8:	c4 06       	cpc	r12, r20
     3fa:	d5 06       	cpc	r13, r21
     3fc:	e0 f4       	brcc	.+56     	; 0x436 <__udivdi3+0x24e>
     3fe:	08 94       	sec
     400:	61 08       	sbc	r6, r1
     402:	71 08       	sbc	r7, r1
     404:	81 08       	sbc	r8, r1
     406:	91 08       	sbc	r9, r1
     408:	a2 0c       	add	r10, r2
     40a:	b3 1c       	adc	r11, r3
     40c:	c4 1c       	adc	r12, r4
     40e:	d5 1c       	adc	r13, r5
     410:	a2 14       	cp	r10, r2
     412:	b3 04       	cpc	r11, r3
     414:	c4 04       	cpc	r12, r4
     416:	d5 04       	cpc	r13, r5
     418:	70 f0       	brcs	.+28     	; 0x436 <__udivdi3+0x24e>
     41a:	a2 16       	cp	r10, r18
     41c:	b3 06       	cpc	r11, r19
     41e:	c4 06       	cpc	r12, r20
     420:	d5 06       	cpc	r13, r21
     422:	48 f4       	brcc	.+18     	; 0x436 <__udivdi3+0x24e>
     424:	08 94       	sec
     426:	61 08       	sbc	r6, r1
     428:	71 08       	sbc	r7, r1
     42a:	81 08       	sbc	r8, r1
     42c:	91 08       	sbc	r9, r1
     42e:	a2 0c       	add	r10, r2
     430:	b3 1c       	adc	r11, r3
     432:	c4 1c       	adc	r12, r4
     434:	d5 1c       	adc	r13, r5
     436:	a2 1a       	sub	r10, r18
     438:	b3 0a       	sbc	r11, r19
     43a:	c4 0a       	sbc	r12, r20
     43c:	d5 0a       	sbc	r13, r21
     43e:	c6 01       	movw	r24, r12
     440:	b5 01       	movw	r22, r10
     442:	2d a9       	ldd	r18, Y+53	; 0x35
     444:	3e a9       	ldd	r19, Y+54	; 0x36
     446:	4f a9       	ldd	r20, Y+55	; 0x37
     448:	58 ad       	ldd	r21, Y+56	; 0x38
     44a:	0e 94 c8 42 	call	0x8590	; 0x8590 <__udivmodsi4>
     44e:	7b 01       	movw	r14, r22
     450:	8c 01       	movw	r16, r24
     452:	c6 01       	movw	r24, r12
     454:	b5 01       	movw	r22, r10
     456:	2d a9       	ldd	r18, Y+53	; 0x35
     458:	3e a9       	ldd	r19, Y+54	; 0x36
     45a:	4f a9       	ldd	r20, Y+55	; 0x37
     45c:	58 ad       	ldd	r21, Y+56	; 0x38
     45e:	0e 94 c8 42 	call	0x8590	; 0x8590 <__udivmodsi4>
     462:	c9 01       	movw	r24, r18
     464:	da 01       	movw	r26, r20
     466:	5c 01       	movw	r10, r24
     468:	6d 01       	movw	r12, r26
     46a:	c6 01       	movw	r24, r12
     46c:	b5 01       	movw	r22, r10
     46e:	29 ad       	ldd	r18, Y+57	; 0x39
     470:	3a ad       	ldd	r19, Y+58	; 0x3a
     472:	4b ad       	ldd	r20, Y+59	; 0x3b
     474:	5c ad       	ldd	r21, Y+60	; 0x3c
     476:	0e 94 95 42 	call	0x852a	; 0x852a <__mulsi3>
     47a:	9b 01       	movw	r18, r22
     47c:	ac 01       	movw	r20, r24
     47e:	87 01       	movw	r16, r14
     480:	ff 24       	eor	r15, r15
     482:	ee 24       	eor	r14, r14
     484:	8d a5       	ldd	r24, Y+45	; 0x2d
     486:	9e a5       	ldd	r25, Y+46	; 0x2e
     488:	af a5       	ldd	r26, Y+47	; 0x2f
     48a:	b8 a9       	ldd	r27, Y+48	; 0x30
     48c:	a0 70       	andi	r26, 0x00	; 0
     48e:	b0 70       	andi	r27, 0x00	; 0
     490:	e8 2a       	or	r14, r24
     492:	f9 2a       	or	r15, r25
     494:	0a 2b       	or	r16, r26
     496:	1b 2b       	or	r17, r27
     498:	e2 16       	cp	r14, r18
     49a:	f3 06       	cpc	r15, r19
     49c:	04 07       	cpc	r16, r20
     49e:	15 07       	cpc	r17, r21
     4a0:	c0 f4       	brcc	.+48     	; 0x4d2 <__udivdi3+0x2ea>
     4a2:	08 94       	sec
     4a4:	a1 08       	sbc	r10, r1
     4a6:	b1 08       	sbc	r11, r1
     4a8:	c1 08       	sbc	r12, r1
     4aa:	d1 08       	sbc	r13, r1
     4ac:	e2 0c       	add	r14, r2
     4ae:	f3 1c       	adc	r15, r3
     4b0:	04 1d       	adc	r16, r4
     4b2:	15 1d       	adc	r17, r5
     4b4:	e2 14       	cp	r14, r2
     4b6:	f3 04       	cpc	r15, r3
     4b8:	04 05       	cpc	r16, r4
     4ba:	15 05       	cpc	r17, r5
     4bc:	50 f0       	brcs	.+20     	; 0x4d2 <__udivdi3+0x2ea>
     4be:	e2 16       	cp	r14, r18
     4c0:	f3 06       	cpc	r15, r19
     4c2:	04 07       	cpc	r16, r20
     4c4:	15 07       	cpc	r17, r21
     4c6:	28 f4       	brcc	.+10     	; 0x4d2 <__udivdi3+0x2ea>
     4c8:	08 94       	sec
     4ca:	a1 08       	sbc	r10, r1
     4cc:	b1 08       	sbc	r11, r1
     4ce:	c1 08       	sbc	r12, r1
     4d0:	d1 08       	sbc	r13, r1
     4d2:	d3 01       	movw	r26, r6
     4d4:	99 27       	eor	r25, r25
     4d6:	88 27       	eor	r24, r24
     4d8:	86 01       	movw	r16, r12
     4da:	75 01       	movw	r14, r10
     4dc:	e8 2a       	or	r14, r24
     4de:	f9 2a       	or	r15, r25
     4e0:	0a 2b       	or	r16, r26
     4e2:	1b 2b       	or	r17, r27
     4e4:	e9 aa       	std	Y+49, r14	; 0x31
     4e6:	fa aa       	std	Y+50, r15	; 0x32
     4e8:	0b ab       	std	Y+51, r16	; 0x33
     4ea:	1c ab       	std	Y+52, r17	; 0x34
     4ec:	cf c4       	rjmp	.+2462   	; 0xe8c <__stack+0x62d>
     4ee:	21 14       	cp	r2, r1
     4f0:	31 04       	cpc	r3, r1
     4f2:	41 04       	cpc	r4, r1
     4f4:	51 04       	cpc	r5, r1
     4f6:	71 f4       	brne	.+28     	; 0x514 <__udivdi3+0x32c>
     4f8:	61 e0       	ldi	r22, 0x01	; 1
     4fa:	70 e0       	ldi	r23, 0x00	; 0
     4fc:	80 e0       	ldi	r24, 0x00	; 0
     4fe:	90 e0       	ldi	r25, 0x00	; 0
     500:	20 e0       	ldi	r18, 0x00	; 0
     502:	30 e0       	ldi	r19, 0x00	; 0
     504:	40 e0       	ldi	r20, 0x00	; 0
     506:	50 e0       	ldi	r21, 0x00	; 0
     508:	0e 94 c8 42 	call	0x8590	; 0x8590 <__udivmodsi4>
     50c:	c9 01       	movw	r24, r18
     50e:	da 01       	movw	r26, r20
     510:	1c 01       	movw	r2, r24
     512:	2d 01       	movw	r4, r26
     514:	00 e0       	ldi	r16, 0x00	; 0
     516:	20 16       	cp	r2, r16
     518:	00 e0       	ldi	r16, 0x00	; 0
     51a:	30 06       	cpc	r3, r16
     51c:	01 e0       	ldi	r16, 0x01	; 1
     51e:	40 06       	cpc	r4, r16
     520:	00 e0       	ldi	r16, 0x00	; 0
     522:	50 06       	cpc	r5, r16
     524:	88 f4       	brcc	.+34     	; 0x548 <__udivdi3+0x360>
     526:	1f ef       	ldi	r17, 0xFF	; 255
     528:	21 16       	cp	r2, r17
     52a:	31 04       	cpc	r3, r1
     52c:	41 04       	cpc	r4, r1
     52e:	51 04       	cpc	r5, r1
     530:	31 f0       	breq	.+12     	; 0x53e <__udivdi3+0x356>
     532:	28 f0       	brcs	.+10     	; 0x53e <__udivdi3+0x356>
     534:	48 e0       	ldi	r20, 0x08	; 8
     536:	50 e0       	ldi	r21, 0x00	; 0
     538:	60 e0       	ldi	r22, 0x00	; 0
     53a:	70 e0       	ldi	r23, 0x00	; 0
     53c:	17 c0       	rjmp	.+46     	; 0x56c <__udivdi3+0x384>
     53e:	40 e0       	ldi	r20, 0x00	; 0
     540:	50 e0       	ldi	r21, 0x00	; 0
     542:	60 e0       	ldi	r22, 0x00	; 0
     544:	70 e0       	ldi	r23, 0x00	; 0
     546:	12 c0       	rjmp	.+36     	; 0x56c <__udivdi3+0x384>
     548:	20 e0       	ldi	r18, 0x00	; 0
     54a:	22 16       	cp	r2, r18
     54c:	20 e0       	ldi	r18, 0x00	; 0
     54e:	32 06       	cpc	r3, r18
     550:	20 e0       	ldi	r18, 0x00	; 0
     552:	42 06       	cpc	r4, r18
     554:	21 e0       	ldi	r18, 0x01	; 1
     556:	52 06       	cpc	r5, r18
     558:	28 f0       	brcs	.+10     	; 0x564 <__udivdi3+0x37c>
     55a:	48 e1       	ldi	r20, 0x18	; 24
     55c:	50 e0       	ldi	r21, 0x00	; 0
     55e:	60 e0       	ldi	r22, 0x00	; 0
     560:	70 e0       	ldi	r23, 0x00	; 0
     562:	04 c0       	rjmp	.+8      	; 0x56c <__udivdi3+0x384>
     564:	40 e1       	ldi	r20, 0x10	; 16
     566:	50 e0       	ldi	r21, 0x00	; 0
     568:	60 e0       	ldi	r22, 0x00	; 0
     56a:	70 e0       	ldi	r23, 0x00	; 0
     56c:	d2 01       	movw	r26, r4
     56e:	c1 01       	movw	r24, r2
     570:	04 2e       	mov	r0, r20
     572:	04 c0       	rjmp	.+8      	; 0x57c <__udivdi3+0x394>
     574:	b6 95       	lsr	r27
     576:	a7 95       	ror	r26
     578:	97 95       	ror	r25
     57a:	87 95       	ror	r24
     57c:	0a 94       	dec	r0
     57e:	d2 f7       	brpl	.-12     	; 0x574 <__udivdi3+0x38c>
     580:	8c 58       	subi	r24, 0x8C	; 140
     582:	9f 4f       	sbci	r25, 0xFF	; 255
     584:	dc 01       	movw	r26, r24
     586:	2c 91       	ld	r18, X
     588:	e0 e2       	ldi	r30, 0x20	; 32
     58a:	ee 2e       	mov	r14, r30
     58c:	f1 2c       	mov	r15, r1
     58e:	01 2d       	mov	r16, r1
     590:	11 2d       	mov	r17, r1
     592:	d8 01       	movw	r26, r16
     594:	c7 01       	movw	r24, r14
     596:	84 1b       	sub	r24, r20
     598:	95 0b       	sbc	r25, r21
     59a:	a6 0b       	sbc	r26, r22
     59c:	b7 0b       	sbc	r27, r23
     59e:	82 1b       	sub	r24, r18
     5a0:	91 09       	sbc	r25, r1
     5a2:	a1 09       	sbc	r26, r1
     5a4:	b1 09       	sbc	r27, r1
     5a6:	00 97       	sbiw	r24, 0x00	; 0
     5a8:	a1 05       	cpc	r26, r1
     5aa:	b1 05       	cpc	r27, r1
     5ac:	61 f4       	brne	.+24     	; 0x5c6 <__udivdi3+0x3de>
     5ae:	64 01       	movw	r12, r8
     5b0:	53 01       	movw	r10, r6
     5b2:	a2 18       	sub	r10, r2
     5b4:	b3 08       	sbc	r11, r3
     5b6:	c4 08       	sbc	r12, r4
     5b8:	d5 08       	sbc	r13, r5
     5ba:	31 e0       	ldi	r19, 0x01	; 1
     5bc:	63 2e       	mov	r6, r19
     5be:	71 2c       	mov	r7, r1
     5c0:	81 2c       	mov	r8, r1
     5c2:	91 2c       	mov	r9, r1
     5c4:	1e c1       	rjmp	.+572    	; 0x802 <__udivdi3+0x61a>
     5c6:	6f 96       	adiw	r28, 0x1f	; 31
     5c8:	8f af       	std	Y+63, r24	; 0x3f
     5ca:	6f 97       	sbiw	r28, 0x1f	; 31
     5cc:	08 2e       	mov	r0, r24
     5ce:	04 c0       	rjmp	.+8      	; 0x5d8 <__udivdi3+0x3f0>
     5d0:	22 0c       	add	r2, r2
     5d2:	33 1c       	adc	r3, r3
     5d4:	44 1c       	adc	r4, r4
     5d6:	55 1c       	adc	r5, r5
     5d8:	0a 94       	dec	r0
     5da:	d2 f7       	brpl	.-12     	; 0x5d0 <__udivdi3+0x3e8>
     5dc:	ee 2d       	mov	r30, r14
     5de:	e8 1b       	sub	r30, r24
     5e0:	64 01       	movw	r12, r8
     5e2:	53 01       	movw	r10, r6
     5e4:	0e 2e       	mov	r0, r30
     5e6:	04 c0       	rjmp	.+8      	; 0x5f0 <__udivdi3+0x408>
     5e8:	d6 94       	lsr	r13
     5ea:	c7 94       	ror	r12
     5ec:	b7 94       	ror	r11
     5ee:	a7 94       	ror	r10
     5f0:	0a 94       	dec	r0
     5f2:	d2 f7       	brpl	.-12     	; 0x5e8 <__udivdi3+0x400>
     5f4:	a4 01       	movw	r20, r8
     5f6:	93 01       	movw	r18, r6
     5f8:	6f 96       	adiw	r28, 0x1f	; 31
     5fa:	0f ac       	ldd	r0, Y+63	; 0x3f
     5fc:	6f 97       	sbiw	r28, 0x1f	; 31
     5fe:	04 c0       	rjmp	.+8      	; 0x608 <__udivdi3+0x420>
     600:	22 0f       	add	r18, r18
     602:	33 1f       	adc	r19, r19
     604:	44 1f       	adc	r20, r20
     606:	55 1f       	adc	r21, r21
     608:	0a 94       	dec	r0
     60a:	d2 f7       	brpl	.-12     	; 0x600 <__udivdi3+0x418>
     60c:	6d a4       	ldd	r6, Y+45	; 0x2d
     60e:	7e a4       	ldd	r7, Y+46	; 0x2e
     610:	8f a4       	ldd	r8, Y+47	; 0x2f
     612:	98 a8       	ldd	r9, Y+48	; 0x30
     614:	0e 2e       	mov	r0, r30
     616:	04 c0       	rjmp	.+8      	; 0x620 <__udivdi3+0x438>
     618:	96 94       	lsr	r9
     61a:	87 94       	ror	r8
     61c:	77 94       	ror	r7
     61e:	67 94       	ror	r6
     620:	0a 94       	dec	r0
     622:	d2 f7       	brpl	.-12     	; 0x618 <__udivdi3+0x430>
     624:	84 01       	movw	r16, r8
     626:	73 01       	movw	r14, r6
     628:	e2 2a       	or	r14, r18
     62a:	f3 2a       	or	r15, r19
     62c:	04 2b       	or	r16, r20
     62e:	15 2b       	or	r17, r21
     630:	e9 a6       	std	Y+41, r14	; 0x29
     632:	fa a6       	std	Y+42, r15	; 0x2a
     634:	0b a7       	std	Y+43, r16	; 0x2b
     636:	1c a7       	std	Y+44, r17	; 0x2c
     638:	32 01       	movw	r6, r4
     63a:	88 24       	eor	r8, r8
     63c:	99 24       	eor	r9, r9
     63e:	92 01       	movw	r18, r4
     640:	81 01       	movw	r16, r2
     642:	20 70       	andi	r18, 0x00	; 0
     644:	30 70       	andi	r19, 0x00	; 0
     646:	21 96       	adiw	r28, 0x01	; 1
     648:	0c af       	std	Y+60, r16	; 0x3c
     64a:	1d af       	std	Y+61, r17	; 0x3d
     64c:	2e af       	std	Y+62, r18	; 0x3e
     64e:	3f af       	std	Y+63, r19	; 0x3f
     650:	21 97       	sbiw	r28, 0x01	; 1
     652:	c6 01       	movw	r24, r12
     654:	b5 01       	movw	r22, r10
     656:	a4 01       	movw	r20, r8
     658:	93 01       	movw	r18, r6
     65a:	0e 94 c8 42 	call	0x8590	; 0x8590 <__udivmodsi4>
     65e:	7b 01       	movw	r14, r22
     660:	8c 01       	movw	r16, r24
     662:	c6 01       	movw	r24, r12
     664:	b5 01       	movw	r22, r10
     666:	a4 01       	movw	r20, r8
     668:	93 01       	movw	r18, r6
     66a:	0e 94 c8 42 	call	0x8590	; 0x8590 <__udivmodsi4>
     66e:	c9 01       	movw	r24, r18
     670:	da 01       	movw	r26, r20
     672:	25 96       	adiw	r28, 0x05	; 5
     674:	8c af       	std	Y+60, r24	; 0x3c
     676:	9d af       	std	Y+61, r25	; 0x3d
     678:	ae af       	std	Y+62, r26	; 0x3e
     67a:	bf af       	std	Y+63, r27	; 0x3f
     67c:	25 97       	sbiw	r28, 0x05	; 5
     67e:	bc 01       	movw	r22, r24
     680:	cd 01       	movw	r24, r26
     682:	21 96       	adiw	r28, 0x01	; 1
     684:	2c ad       	ldd	r18, Y+60	; 0x3c
     686:	3d ad       	ldd	r19, Y+61	; 0x3d
     688:	4e ad       	ldd	r20, Y+62	; 0x3e
     68a:	5f ad       	ldd	r21, Y+63	; 0x3f
     68c:	21 97       	sbiw	r28, 0x01	; 1
     68e:	0e 94 95 42 	call	0x852a	; 0x852a <__mulsi3>
     692:	9b 01       	movw	r18, r22
     694:	ac 01       	movw	r20, r24
     696:	87 01       	movw	r16, r14
     698:	ff 24       	eor	r15, r15
     69a:	ee 24       	eor	r14, r14
     69c:	a9 a4       	ldd	r10, Y+41	; 0x29
     69e:	ba a4       	ldd	r11, Y+42	; 0x2a
     6a0:	cb a4       	ldd	r12, Y+43	; 0x2b
     6a2:	dc a4       	ldd	r13, Y+44	; 0x2c
     6a4:	c6 01       	movw	r24, r12
     6a6:	aa 27       	eor	r26, r26
     6a8:	bb 27       	eor	r27, r27
     6aa:	5c 01       	movw	r10, r24
     6ac:	6d 01       	movw	r12, r26
     6ae:	ae 28       	or	r10, r14
     6b0:	bf 28       	or	r11, r15
     6b2:	c0 2a       	or	r12, r16
     6b4:	d1 2a       	or	r13, r17
     6b6:	a2 16       	cp	r10, r18
     6b8:	b3 06       	cpc	r11, r19
     6ba:	c4 06       	cpc	r12, r20
     6bc:	d5 06       	cpc	r13, r21
     6be:	60 f5       	brcc	.+88     	; 0x718 <__udivdi3+0x530>
     6c0:	25 96       	adiw	r28, 0x05	; 5
     6c2:	6c ad       	ldd	r22, Y+60	; 0x3c
     6c4:	7d ad       	ldd	r23, Y+61	; 0x3d
     6c6:	8e ad       	ldd	r24, Y+62	; 0x3e
     6c8:	9f ad       	ldd	r25, Y+63	; 0x3f
     6ca:	25 97       	sbiw	r28, 0x05	; 5
     6cc:	61 50       	subi	r22, 0x01	; 1
     6ce:	70 40       	sbci	r23, 0x00	; 0
     6d0:	80 40       	sbci	r24, 0x00	; 0
     6d2:	90 40       	sbci	r25, 0x00	; 0
     6d4:	25 96       	adiw	r28, 0x05	; 5
     6d6:	6c af       	std	Y+60, r22	; 0x3c
     6d8:	7d af       	std	Y+61, r23	; 0x3d
     6da:	8e af       	std	Y+62, r24	; 0x3e
     6dc:	9f af       	std	Y+63, r25	; 0x3f
     6de:	25 97       	sbiw	r28, 0x05	; 5
     6e0:	a2 0c       	add	r10, r2
     6e2:	b3 1c       	adc	r11, r3
     6e4:	c4 1c       	adc	r12, r4
     6e6:	d5 1c       	adc	r13, r5
     6e8:	a2 14       	cp	r10, r2
     6ea:	b3 04       	cpc	r11, r3
     6ec:	c4 04       	cpc	r12, r4
     6ee:	d5 04       	cpc	r13, r5
     6f0:	98 f0       	brcs	.+38     	; 0x718 <__udivdi3+0x530>
     6f2:	a2 16       	cp	r10, r18
     6f4:	b3 06       	cpc	r11, r19
     6f6:	c4 06       	cpc	r12, r20
     6f8:	d5 06       	cpc	r13, r21
     6fa:	70 f4       	brcc	.+28     	; 0x718 <__udivdi3+0x530>
     6fc:	61 50       	subi	r22, 0x01	; 1
     6fe:	70 40       	sbci	r23, 0x00	; 0
     700:	80 40       	sbci	r24, 0x00	; 0
     702:	90 40       	sbci	r25, 0x00	; 0
     704:	25 96       	adiw	r28, 0x05	; 5
     706:	6c af       	std	Y+60, r22	; 0x3c
     708:	7d af       	std	Y+61, r23	; 0x3d
     70a:	8e af       	std	Y+62, r24	; 0x3e
     70c:	9f af       	std	Y+63, r25	; 0x3f
     70e:	25 97       	sbiw	r28, 0x05	; 5
     710:	a2 0c       	add	r10, r2
     712:	b3 1c       	adc	r11, r3
     714:	c4 1c       	adc	r12, r4
     716:	d5 1c       	adc	r13, r5
     718:	a2 1a       	sub	r10, r18
     71a:	b3 0a       	sbc	r11, r19
     71c:	c4 0a       	sbc	r12, r20
     71e:	d5 0a       	sbc	r13, r21
     720:	c6 01       	movw	r24, r12
     722:	b5 01       	movw	r22, r10
     724:	a4 01       	movw	r20, r8
     726:	93 01       	movw	r18, r6
     728:	0e 94 c8 42 	call	0x8590	; 0x8590 <__udivmodsi4>
     72c:	7b 01       	movw	r14, r22
     72e:	8c 01       	movw	r16, r24
     730:	c6 01       	movw	r24, r12
     732:	b5 01       	movw	r22, r10
     734:	a4 01       	movw	r20, r8
     736:	93 01       	movw	r18, r6
     738:	0e 94 c8 42 	call	0x8590	; 0x8590 <__udivmodsi4>
     73c:	c9 01       	movw	r24, r18
     73e:	da 01       	movw	r26, r20
     740:	3c 01       	movw	r6, r24
     742:	4d 01       	movw	r8, r26
     744:	c4 01       	movw	r24, r8
     746:	b3 01       	movw	r22, r6
     748:	21 96       	adiw	r28, 0x01	; 1
     74a:	2c ad       	ldd	r18, Y+60	; 0x3c
     74c:	3d ad       	ldd	r19, Y+61	; 0x3d
     74e:	4e ad       	ldd	r20, Y+62	; 0x3e
     750:	5f ad       	ldd	r21, Y+63	; 0x3f
     752:	21 97       	sbiw	r28, 0x01	; 1
     754:	0e 94 95 42 	call	0x852a	; 0x852a <__mulsi3>
     758:	9b 01       	movw	r18, r22
     75a:	ac 01       	movw	r20, r24
     75c:	87 01       	movw	r16, r14
     75e:	ff 24       	eor	r15, r15
     760:	ee 24       	eor	r14, r14
     762:	89 a5       	ldd	r24, Y+41	; 0x29
     764:	9a a5       	ldd	r25, Y+42	; 0x2a
     766:	ab a5       	ldd	r26, Y+43	; 0x2b
     768:	bc a5       	ldd	r27, Y+44	; 0x2c
     76a:	a0 70       	andi	r26, 0x00	; 0
     76c:	b0 70       	andi	r27, 0x00	; 0
     76e:	57 01       	movw	r10, r14
     770:	68 01       	movw	r12, r16
     772:	a8 2a       	or	r10, r24
     774:	b9 2a       	or	r11, r25
     776:	ca 2a       	or	r12, r26
     778:	db 2a       	or	r13, r27
     77a:	a2 16       	cp	r10, r18
     77c:	b3 06       	cpc	r11, r19
     77e:	c4 06       	cpc	r12, r20
     780:	d5 06       	cpc	r13, r21
     782:	e0 f4       	brcc	.+56     	; 0x7bc <__udivdi3+0x5d4>
     784:	08 94       	sec
     786:	61 08       	sbc	r6, r1
     788:	71 08       	sbc	r7, r1
     78a:	81 08       	sbc	r8, r1
     78c:	91 08       	sbc	r9, r1
     78e:	a2 0c       	add	r10, r2
     790:	b3 1c       	adc	r11, r3
     792:	c4 1c       	adc	r12, r4
     794:	d5 1c       	adc	r13, r5
     796:	a2 14       	cp	r10, r2
     798:	b3 04       	cpc	r11, r3
     79a:	c4 04       	cpc	r12, r4
     79c:	d5 04       	cpc	r13, r5
     79e:	70 f0       	brcs	.+28     	; 0x7bc <__udivdi3+0x5d4>
     7a0:	a2 16       	cp	r10, r18
     7a2:	b3 06       	cpc	r11, r19
     7a4:	c4 06       	cpc	r12, r20
     7a6:	d5 06       	cpc	r13, r21
     7a8:	48 f4       	brcc	.+18     	; 0x7bc <__udivdi3+0x5d4>
     7aa:	08 94       	sec
     7ac:	61 08       	sbc	r6, r1
     7ae:	71 08       	sbc	r7, r1
     7b0:	81 08       	sbc	r8, r1
     7b2:	91 08       	sbc	r9, r1
     7b4:	a2 0c       	add	r10, r2
     7b6:	b3 1c       	adc	r11, r3
     7b8:	c4 1c       	adc	r12, r4
     7ba:	d5 1c       	adc	r13, r5
     7bc:	8d a5       	ldd	r24, Y+45	; 0x2d
     7be:	9e a5       	ldd	r25, Y+46	; 0x2e
     7c0:	af a5       	ldd	r26, Y+47	; 0x2f
     7c2:	b8 a9       	ldd	r27, Y+48	; 0x30
     7c4:	6f 96       	adiw	r28, 0x1f	; 31
     7c6:	0f ac       	ldd	r0, Y+63	; 0x3f
     7c8:	6f 97       	sbiw	r28, 0x1f	; 31
     7ca:	04 c0       	rjmp	.+8      	; 0x7d4 <__udivdi3+0x5ec>
     7cc:	88 0f       	add	r24, r24
     7ce:	99 1f       	adc	r25, r25
     7d0:	aa 1f       	adc	r26, r26
     7d2:	bb 1f       	adc	r27, r27
     7d4:	0a 94       	dec	r0
     7d6:	d2 f7       	brpl	.-12     	; 0x7cc <__udivdi3+0x5e4>
     7d8:	8d a7       	std	Y+45, r24	; 0x2d
     7da:	9e a7       	std	Y+46, r25	; 0x2e
     7dc:	af a7       	std	Y+47, r26	; 0x2f
     7de:	b8 ab       	std	Y+48, r27	; 0x30
     7e0:	a2 1a       	sub	r10, r18
     7e2:	b3 0a       	sbc	r11, r19
     7e4:	c4 0a       	sbc	r12, r20
     7e6:	d5 0a       	sbc	r13, r21
     7e8:	25 96       	adiw	r28, 0x05	; 5
     7ea:	ec ac       	ldd	r14, Y+60	; 0x3c
     7ec:	fd ac       	ldd	r15, Y+61	; 0x3d
     7ee:	0e ad       	ldd	r16, Y+62	; 0x3e
     7f0:	1f ad       	ldd	r17, Y+63	; 0x3f
     7f2:	25 97       	sbiw	r28, 0x05	; 5
     7f4:	d7 01       	movw	r26, r14
     7f6:	99 27       	eor	r25, r25
     7f8:	88 27       	eor	r24, r24
     7fa:	68 2a       	or	r6, r24
     7fc:	79 2a       	or	r7, r25
     7fe:	8a 2a       	or	r8, r26
     800:	9b 2a       	or	r9, r27
     802:	82 01       	movw	r16, r4
     804:	22 27       	eor	r18, r18
     806:	33 27       	eor	r19, r19
     808:	29 96       	adiw	r28, 0x09	; 9
     80a:	0c af       	std	Y+60, r16	; 0x3c
     80c:	1d af       	std	Y+61, r17	; 0x3d
     80e:	2e af       	std	Y+62, r18	; 0x3e
     810:	3f af       	std	Y+63, r19	; 0x3f
     812:	29 97       	sbiw	r28, 0x09	; 9
     814:	a2 01       	movw	r20, r4
     816:	91 01       	movw	r18, r2
     818:	40 70       	andi	r20, 0x00	; 0
     81a:	50 70       	andi	r21, 0x00	; 0
     81c:	2d 96       	adiw	r28, 0x0d	; 13
     81e:	2c af       	std	Y+60, r18	; 0x3c
     820:	3d af       	std	Y+61, r19	; 0x3d
     822:	4e af       	std	Y+62, r20	; 0x3e
     824:	5f af       	std	Y+63, r21	; 0x3f
     826:	2d 97       	sbiw	r28, 0x0d	; 13
     828:	c6 01       	movw	r24, r12
     82a:	b5 01       	movw	r22, r10
     82c:	29 96       	adiw	r28, 0x09	; 9
     82e:	2c ad       	ldd	r18, Y+60	; 0x3c
     830:	3d ad       	ldd	r19, Y+61	; 0x3d
     832:	4e ad       	ldd	r20, Y+62	; 0x3e
     834:	5f ad       	ldd	r21, Y+63	; 0x3f
     836:	29 97       	sbiw	r28, 0x09	; 9
     838:	0e 94 c8 42 	call	0x8590	; 0x8590 <__udivmodsi4>
     83c:	7b 01       	movw	r14, r22
     83e:	8c 01       	movw	r16, r24
     840:	c6 01       	movw	r24, r12
     842:	b5 01       	movw	r22, r10
     844:	29 96       	adiw	r28, 0x09	; 9
     846:	2c ad       	ldd	r18, Y+60	; 0x3c
     848:	3d ad       	ldd	r19, Y+61	; 0x3d
     84a:	4e ad       	ldd	r20, Y+62	; 0x3e
     84c:	5f ad       	ldd	r21, Y+63	; 0x3f
     84e:	29 97       	sbiw	r28, 0x09	; 9
     850:	0e 94 c8 42 	call	0x8590	; 0x8590 <__udivmodsi4>
     854:	c9 01       	movw	r24, r18
     856:	da 01       	movw	r26, r20
     858:	61 96       	adiw	r28, 0x11	; 17
     85a:	8c af       	std	Y+60, r24	; 0x3c
     85c:	9d af       	std	Y+61, r25	; 0x3d
     85e:	ae af       	std	Y+62, r26	; 0x3e
     860:	bf af       	std	Y+63, r27	; 0x3f
     862:	61 97       	sbiw	r28, 0x11	; 17
     864:	bc 01       	movw	r22, r24
     866:	cd 01       	movw	r24, r26
     868:	2d 96       	adiw	r28, 0x0d	; 13
     86a:	2c ad       	ldd	r18, Y+60	; 0x3c
     86c:	3d ad       	ldd	r19, Y+61	; 0x3d
     86e:	4e ad       	ldd	r20, Y+62	; 0x3e
     870:	5f ad       	ldd	r21, Y+63	; 0x3f
     872:	2d 97       	sbiw	r28, 0x0d	; 13
     874:	0e 94 95 42 	call	0x852a	; 0x852a <__mulsi3>
     878:	9b 01       	movw	r18, r22
     87a:	ac 01       	movw	r20, r24
     87c:	87 01       	movw	r16, r14
     87e:	ff 24       	eor	r15, r15
     880:	ee 24       	eor	r14, r14
     882:	ad a4       	ldd	r10, Y+45	; 0x2d
     884:	be a4       	ldd	r11, Y+46	; 0x2e
     886:	cf a4       	ldd	r12, Y+47	; 0x2f
     888:	d8 a8       	ldd	r13, Y+48	; 0x30
     88a:	c6 01       	movw	r24, r12
     88c:	aa 27       	eor	r26, r26
     88e:	bb 27       	eor	r27, r27
     890:	57 01       	movw	r10, r14
     892:	68 01       	movw	r12, r16
     894:	a8 2a       	or	r10, r24
     896:	b9 2a       	or	r11, r25
     898:	ca 2a       	or	r12, r26
     89a:	db 2a       	or	r13, r27
     89c:	a2 16       	cp	r10, r18
     89e:	b3 06       	cpc	r11, r19
     8a0:	c4 06       	cpc	r12, r20
     8a2:	d5 06       	cpc	r13, r21
     8a4:	60 f5       	brcc	.+88     	; 0x8fe <__stack+0x9f>
     8a6:	61 96       	adiw	r28, 0x11	; 17
     8a8:	6c ad       	ldd	r22, Y+60	; 0x3c
     8aa:	7d ad       	ldd	r23, Y+61	; 0x3d
     8ac:	8e ad       	ldd	r24, Y+62	; 0x3e
     8ae:	9f ad       	ldd	r25, Y+63	; 0x3f
     8b0:	61 97       	sbiw	r28, 0x11	; 17
     8b2:	61 50       	subi	r22, 0x01	; 1
     8b4:	70 40       	sbci	r23, 0x00	; 0
     8b6:	80 40       	sbci	r24, 0x00	; 0
     8b8:	90 40       	sbci	r25, 0x00	; 0
     8ba:	61 96       	adiw	r28, 0x11	; 17
     8bc:	6c af       	std	Y+60, r22	; 0x3c
     8be:	7d af       	std	Y+61, r23	; 0x3d
     8c0:	8e af       	std	Y+62, r24	; 0x3e
     8c2:	9f af       	std	Y+63, r25	; 0x3f
     8c4:	61 97       	sbiw	r28, 0x11	; 17
     8c6:	a2 0c       	add	r10, r2
     8c8:	b3 1c       	adc	r11, r3
     8ca:	c4 1c       	adc	r12, r4
     8cc:	d5 1c       	adc	r13, r5
     8ce:	a2 14       	cp	r10, r2
     8d0:	b3 04       	cpc	r11, r3
     8d2:	c4 04       	cpc	r12, r4
     8d4:	d5 04       	cpc	r13, r5
     8d6:	98 f0       	brcs	.+38     	; 0x8fe <__stack+0x9f>
     8d8:	a2 16       	cp	r10, r18
     8da:	b3 06       	cpc	r11, r19
     8dc:	c4 06       	cpc	r12, r20
     8de:	d5 06       	cpc	r13, r21
     8e0:	70 f4       	brcc	.+28     	; 0x8fe <__stack+0x9f>
     8e2:	61 50       	subi	r22, 0x01	; 1
     8e4:	70 40       	sbci	r23, 0x00	; 0
     8e6:	80 40       	sbci	r24, 0x00	; 0
     8e8:	90 40       	sbci	r25, 0x00	; 0
     8ea:	61 96       	adiw	r28, 0x11	; 17
     8ec:	6c af       	std	Y+60, r22	; 0x3c
     8ee:	7d af       	std	Y+61, r23	; 0x3d
     8f0:	8e af       	std	Y+62, r24	; 0x3e
     8f2:	9f af       	std	Y+63, r25	; 0x3f
     8f4:	61 97       	sbiw	r28, 0x11	; 17
     8f6:	a2 0c       	add	r10, r2
     8f8:	b3 1c       	adc	r11, r3
     8fa:	c4 1c       	adc	r12, r4
     8fc:	d5 1c       	adc	r13, r5
     8fe:	a2 1a       	sub	r10, r18
     900:	b3 0a       	sbc	r11, r19
     902:	c4 0a       	sbc	r12, r20
     904:	d5 0a       	sbc	r13, r21
     906:	c6 01       	movw	r24, r12
     908:	b5 01       	movw	r22, r10
     90a:	29 96       	adiw	r28, 0x09	; 9
     90c:	2c ad       	ldd	r18, Y+60	; 0x3c
     90e:	3d ad       	ldd	r19, Y+61	; 0x3d
     910:	4e ad       	ldd	r20, Y+62	; 0x3e
     912:	5f ad       	ldd	r21, Y+63	; 0x3f
     914:	29 97       	sbiw	r28, 0x09	; 9
     916:	0e 94 c8 42 	call	0x8590	; 0x8590 <__udivmodsi4>
     91a:	7b 01       	movw	r14, r22
     91c:	8c 01       	movw	r16, r24
     91e:	c6 01       	movw	r24, r12
     920:	b5 01       	movw	r22, r10
     922:	29 96       	adiw	r28, 0x09	; 9
     924:	2c ad       	ldd	r18, Y+60	; 0x3c
     926:	3d ad       	ldd	r19, Y+61	; 0x3d
     928:	4e ad       	ldd	r20, Y+62	; 0x3e
     92a:	5f ad       	ldd	r21, Y+63	; 0x3f
     92c:	29 97       	sbiw	r28, 0x09	; 9
     92e:	0e 94 c8 42 	call	0x8590	; 0x8590 <__udivmodsi4>
     932:	c9 01       	movw	r24, r18
     934:	da 01       	movw	r26, r20
     936:	5c 01       	movw	r10, r24
     938:	6d 01       	movw	r12, r26
     93a:	c6 01       	movw	r24, r12
     93c:	b5 01       	movw	r22, r10
     93e:	2d 96       	adiw	r28, 0x0d	; 13
     940:	2c ad       	ldd	r18, Y+60	; 0x3c
     942:	3d ad       	ldd	r19, Y+61	; 0x3d
     944:	4e ad       	ldd	r20, Y+62	; 0x3e
     946:	5f ad       	ldd	r21, Y+63	; 0x3f
     948:	2d 97       	sbiw	r28, 0x0d	; 13
     94a:	0e 94 95 42 	call	0x852a	; 0x852a <__mulsi3>
     94e:	9b 01       	movw	r18, r22
     950:	ac 01       	movw	r20, r24
     952:	87 01       	movw	r16, r14
     954:	ff 24       	eor	r15, r15
     956:	ee 24       	eor	r14, r14
     958:	8d a5       	ldd	r24, Y+45	; 0x2d
     95a:	9e a5       	ldd	r25, Y+46	; 0x2e
     95c:	af a5       	ldd	r26, Y+47	; 0x2f
     95e:	b8 a9       	ldd	r27, Y+48	; 0x30
     960:	a0 70       	andi	r26, 0x00	; 0
     962:	b0 70       	andi	r27, 0x00	; 0
     964:	e8 2a       	or	r14, r24
     966:	f9 2a       	or	r15, r25
     968:	0a 2b       	or	r16, r26
     96a:	1b 2b       	or	r17, r27
     96c:	e2 16       	cp	r14, r18
     96e:	f3 06       	cpc	r15, r19
     970:	04 07       	cpc	r16, r20
     972:	15 07       	cpc	r17, r21
     974:	c0 f4       	brcc	.+48     	; 0x9a6 <__stack+0x147>
     976:	08 94       	sec
     978:	a1 08       	sbc	r10, r1
     97a:	b1 08       	sbc	r11, r1
     97c:	c1 08       	sbc	r12, r1
     97e:	d1 08       	sbc	r13, r1
     980:	e2 0c       	add	r14, r2
     982:	f3 1c       	adc	r15, r3
     984:	04 1d       	adc	r16, r4
     986:	15 1d       	adc	r17, r5
     988:	e2 14       	cp	r14, r2
     98a:	f3 04       	cpc	r15, r3
     98c:	04 05       	cpc	r16, r4
     98e:	15 05       	cpc	r17, r5
     990:	50 f0       	brcs	.+20     	; 0x9a6 <__stack+0x147>
     992:	e2 16       	cp	r14, r18
     994:	f3 06       	cpc	r15, r19
     996:	04 07       	cpc	r16, r20
     998:	15 07       	cpc	r17, r21
     99a:	28 f4       	brcc	.+10     	; 0x9a6 <__stack+0x147>
     99c:	08 94       	sec
     99e:	a1 08       	sbc	r10, r1
     9a0:	b1 08       	sbc	r11, r1
     9a2:	c1 08       	sbc	r12, r1
     9a4:	d1 08       	sbc	r13, r1
     9a6:	61 96       	adiw	r28, 0x11	; 17
     9a8:	ec ac       	ldd	r14, Y+60	; 0x3c
     9aa:	fd ac       	ldd	r15, Y+61	; 0x3d
     9ac:	0e ad       	ldd	r16, Y+62	; 0x3e
     9ae:	1f ad       	ldd	r17, Y+63	; 0x3f
     9b0:	61 97       	sbiw	r28, 0x11	; 17
     9b2:	d7 01       	movw	r26, r14
     9b4:	99 27       	eor	r25, r25
     9b6:	88 27       	eor	r24, r24
     9b8:	96 01       	movw	r18, r12
     9ba:	85 01       	movw	r16, r10
     9bc:	08 2b       	or	r16, r24
     9be:	19 2b       	or	r17, r25
     9c0:	2a 2b       	or	r18, r26
     9c2:	3b 2b       	or	r19, r27
     9c4:	09 ab       	std	Y+49, r16	; 0x31
     9c6:	1a ab       	std	Y+50, r17	; 0x32
     9c8:	2b ab       	std	Y+51, r18	; 0x33
     9ca:	3c ab       	std	Y+52, r19	; 0x34
     9cc:	62 c2       	rjmp	.+1220   	; 0xe92 <__stack+0x633>
     9ce:	6e 14       	cp	r6, r14
     9d0:	7f 04       	cpc	r7, r15
     9d2:	80 06       	cpc	r8, r16
     9d4:	91 06       	cpc	r9, r17
     9d6:	08 f4       	brcc	.+2      	; 0x9da <__stack+0x17b>
     9d8:	51 c2       	rjmp	.+1186   	; 0xe7c <__stack+0x61d>
     9da:	20 e0       	ldi	r18, 0x00	; 0
     9dc:	e2 16       	cp	r14, r18
     9de:	20 e0       	ldi	r18, 0x00	; 0
     9e0:	f2 06       	cpc	r15, r18
     9e2:	21 e0       	ldi	r18, 0x01	; 1
     9e4:	02 07       	cpc	r16, r18
     9e6:	20 e0       	ldi	r18, 0x00	; 0
     9e8:	12 07       	cpc	r17, r18
     9ea:	88 f4       	brcc	.+34     	; 0xa0e <__stack+0x1af>
     9ec:	3f ef       	ldi	r19, 0xFF	; 255
     9ee:	e3 16       	cp	r14, r19
     9f0:	f1 04       	cpc	r15, r1
     9f2:	01 05       	cpc	r16, r1
     9f4:	11 05       	cpc	r17, r1
     9f6:	31 f0       	breq	.+12     	; 0xa04 <__stack+0x1a5>
     9f8:	28 f0       	brcs	.+10     	; 0xa04 <__stack+0x1a5>
     9fa:	48 e0       	ldi	r20, 0x08	; 8
     9fc:	50 e0       	ldi	r21, 0x00	; 0
     9fe:	60 e0       	ldi	r22, 0x00	; 0
     a00:	70 e0       	ldi	r23, 0x00	; 0
     a02:	17 c0       	rjmp	.+46     	; 0xa32 <__stack+0x1d3>
     a04:	40 e0       	ldi	r20, 0x00	; 0
     a06:	50 e0       	ldi	r21, 0x00	; 0
     a08:	60 e0       	ldi	r22, 0x00	; 0
     a0a:	70 e0       	ldi	r23, 0x00	; 0
     a0c:	12 c0       	rjmp	.+36     	; 0xa32 <__stack+0x1d3>
     a0e:	40 e0       	ldi	r20, 0x00	; 0
     a10:	e4 16       	cp	r14, r20
     a12:	40 e0       	ldi	r20, 0x00	; 0
     a14:	f4 06       	cpc	r15, r20
     a16:	40 e0       	ldi	r20, 0x00	; 0
     a18:	04 07       	cpc	r16, r20
     a1a:	41 e0       	ldi	r20, 0x01	; 1
     a1c:	14 07       	cpc	r17, r20
     a1e:	28 f0       	brcs	.+10     	; 0xa2a <__stack+0x1cb>
     a20:	48 e1       	ldi	r20, 0x18	; 24
     a22:	50 e0       	ldi	r21, 0x00	; 0
     a24:	60 e0       	ldi	r22, 0x00	; 0
     a26:	70 e0       	ldi	r23, 0x00	; 0
     a28:	04 c0       	rjmp	.+8      	; 0xa32 <__stack+0x1d3>
     a2a:	40 e1       	ldi	r20, 0x10	; 16
     a2c:	50 e0       	ldi	r21, 0x00	; 0
     a2e:	60 e0       	ldi	r22, 0x00	; 0
     a30:	70 e0       	ldi	r23, 0x00	; 0
     a32:	d8 01       	movw	r26, r16
     a34:	c7 01       	movw	r24, r14
     a36:	04 2e       	mov	r0, r20
     a38:	04 c0       	rjmp	.+8      	; 0xa42 <__stack+0x1e3>
     a3a:	b6 95       	lsr	r27
     a3c:	a7 95       	ror	r26
     a3e:	97 95       	ror	r25
     a40:	87 95       	ror	r24
     a42:	0a 94       	dec	r0
     a44:	d2 f7       	brpl	.-12     	; 0xa3a <__stack+0x1db>
     a46:	8c 58       	subi	r24, 0x8C	; 140
     a48:	9f 4f       	sbci	r25, 0xFF	; 255
     a4a:	dc 01       	movw	r26, r24
     a4c:	2c 91       	ld	r18, X
     a4e:	30 e2       	ldi	r19, 0x20	; 32
     a50:	a3 2e       	mov	r10, r19
     a52:	b1 2c       	mov	r11, r1
     a54:	c1 2c       	mov	r12, r1
     a56:	d1 2c       	mov	r13, r1
     a58:	d6 01       	movw	r26, r12
     a5a:	c5 01       	movw	r24, r10
     a5c:	84 1b       	sub	r24, r20
     a5e:	95 0b       	sbc	r25, r21
     a60:	a6 0b       	sbc	r26, r22
     a62:	b7 0b       	sbc	r27, r23
     a64:	82 1b       	sub	r24, r18
     a66:	91 09       	sbc	r25, r1
     a68:	a1 09       	sbc	r26, r1
     a6a:	b1 09       	sbc	r27, r1
     a6c:	00 97       	sbiw	r24, 0x00	; 0
     a6e:	a1 05       	cpc	r26, r1
     a70:	b1 05       	cpc	r27, r1
     a72:	89 f4       	brne	.+34     	; 0xa96 <__stack+0x237>
     a74:	e6 14       	cp	r14, r6
     a76:	f7 04       	cpc	r15, r7
     a78:	08 05       	cpc	r16, r8
     a7a:	19 05       	cpc	r17, r9
     a7c:	08 f4       	brcc	.+2      	; 0xa80 <__stack+0x221>
     a7e:	f2 c1       	rjmp	.+996    	; 0xe64 <__stack+0x605>
     a80:	6d a4       	ldd	r6, Y+45	; 0x2d
     a82:	7e a4       	ldd	r7, Y+46	; 0x2e
     a84:	8f a4       	ldd	r8, Y+47	; 0x2f
     a86:	98 a8       	ldd	r9, Y+48	; 0x30
     a88:	62 14       	cp	r6, r2
     a8a:	73 04       	cpc	r7, r3
     a8c:	84 04       	cpc	r8, r4
     a8e:	95 04       	cpc	r9, r5
     a90:	08 f0       	brcs	.+2      	; 0xa94 <__stack+0x235>
     a92:	e8 c1       	rjmp	.+976    	; 0xe64 <__stack+0x605>
     a94:	f3 c1       	rjmp	.+998    	; 0xe7c <__stack+0x61d>
     a96:	6e 96       	adiw	r28, 0x1e	; 30
     a98:	8f af       	std	Y+63, r24	; 0x3f
     a9a:	6e 97       	sbiw	r28, 0x1e	; 30
     a9c:	08 2e       	mov	r0, r24
     a9e:	04 c0       	rjmp	.+8      	; 0xaa8 <__stack+0x249>
     aa0:	ee 0c       	add	r14, r14
     aa2:	ff 1c       	adc	r15, r15
     aa4:	00 1f       	adc	r16, r16
     aa6:	11 1f       	adc	r17, r17
     aa8:	0a 94       	dec	r0
     aaa:	d2 f7       	brpl	.-12     	; 0xaa0 <__stack+0x241>
     aac:	6a 2d       	mov	r22, r10
     aae:	68 1b       	sub	r22, r24
     ab0:	d2 01       	movw	r26, r4
     ab2:	c1 01       	movw	r24, r2
     ab4:	06 2e       	mov	r0, r22
     ab6:	04 c0       	rjmp	.+8      	; 0xac0 <__stack+0x261>
     ab8:	b6 95       	lsr	r27
     aba:	a7 95       	ror	r26
     abc:	97 95       	ror	r25
     abe:	87 95       	ror	r24
     ac0:	0a 94       	dec	r0
     ac2:	d2 f7       	brpl	.-12     	; 0xab8 <__stack+0x259>
     ac4:	5c 01       	movw	r10, r24
     ac6:	6d 01       	movw	r12, r26
     ac8:	ae 28       	or	r10, r14
     aca:	bf 28       	or	r11, r15
     acc:	c0 2a       	or	r12, r16
     ace:	d1 2a       	or	r13, r17
     ad0:	ad a2       	std	Y+37, r10	; 0x25
     ad2:	be a2       	std	Y+38, r11	; 0x26
     ad4:	cf a2       	std	Y+39, r12	; 0x27
     ad6:	d8 a6       	std	Y+40, r13	; 0x28
     ad8:	72 01       	movw	r14, r4
     ada:	61 01       	movw	r12, r2
     adc:	6e 96       	adiw	r28, 0x1e	; 30
     ade:	0f ac       	ldd	r0, Y+63	; 0x3f
     ae0:	6e 97       	sbiw	r28, 0x1e	; 30
     ae2:	04 c0       	rjmp	.+8      	; 0xaec <__stack+0x28d>
     ae4:	cc 0c       	add	r12, r12
     ae6:	dd 1c       	adc	r13, r13
     ae8:	ee 1c       	adc	r14, r14
     aea:	ff 1c       	adc	r15, r15
     aec:	0a 94       	dec	r0
     aee:	d2 f7       	brpl	.-12     	; 0xae4 <__stack+0x285>
     af0:	c9 a2       	std	Y+33, r12	; 0x21
     af2:	da a2       	std	Y+34, r13	; 0x22
     af4:	eb a2       	std	Y+35, r14	; 0x23
     af6:	fc a2       	std	Y+36, r15	; 0x24
     af8:	64 01       	movw	r12, r8
     afa:	53 01       	movw	r10, r6
     afc:	06 2e       	mov	r0, r22
     afe:	04 c0       	rjmp	.+8      	; 0xb08 <__stack+0x2a9>
     b00:	d6 94       	lsr	r13
     b02:	c7 94       	ror	r12
     b04:	b7 94       	ror	r11
     b06:	a7 94       	ror	r10
     b08:	0a 94       	dec	r0
     b0a:	d2 f7       	brpl	.-12     	; 0xb00 <__stack+0x2a1>
     b0c:	d4 01       	movw	r26, r8
     b0e:	c3 01       	movw	r24, r6
     b10:	6e 96       	adiw	r28, 0x1e	; 30
     b12:	0f ac       	ldd	r0, Y+63	; 0x3f
     b14:	6e 97       	sbiw	r28, 0x1e	; 30
     b16:	04 c0       	rjmp	.+8      	; 0xb20 <__stack+0x2c1>
     b18:	88 0f       	add	r24, r24
     b1a:	99 1f       	adc	r25, r25
     b1c:	aa 1f       	adc	r26, r26
     b1e:	bb 1f       	adc	r27, r27
     b20:	0a 94       	dec	r0
     b22:	d2 f7       	brpl	.-12     	; 0xb18 <__stack+0x2b9>
     b24:	ed a4       	ldd	r14, Y+45	; 0x2d
     b26:	fe a4       	ldd	r15, Y+46	; 0x2e
     b28:	0f a5       	ldd	r16, Y+47	; 0x2f
     b2a:	18 a9       	ldd	r17, Y+48	; 0x30
     b2c:	04 c0       	rjmp	.+8      	; 0xb36 <__stack+0x2d7>
     b2e:	16 95       	lsr	r17
     b30:	07 95       	ror	r16
     b32:	f7 94       	ror	r15
     b34:	e7 94       	ror	r14
     b36:	6a 95       	dec	r22
     b38:	d2 f7       	brpl	.-12     	; 0xb2e <__stack+0x2cf>
     b3a:	37 01       	movw	r6, r14
     b3c:	48 01       	movw	r8, r16
     b3e:	68 2a       	or	r6, r24
     b40:	79 2a       	or	r7, r25
     b42:	8a 2a       	or	r8, r26
     b44:	9b 2a       	or	r9, r27
     b46:	6d 8e       	std	Y+29, r6	; 0x1d
     b48:	7e 8e       	std	Y+30, r7	; 0x1e
     b4a:	8f 8e       	std	Y+31, r8	; 0x1f
     b4c:	98 a2       	std	Y+32, r9	; 0x20
     b4e:	ed a0       	ldd	r14, Y+37	; 0x25
     b50:	fe a0       	ldd	r15, Y+38	; 0x26
     b52:	0f a1       	ldd	r16, Y+39	; 0x27
     b54:	18 a5       	ldd	r17, Y+40	; 0x28
     b56:	38 01       	movw	r6, r16
     b58:	88 24       	eor	r8, r8
     b5a:	99 24       	eor	r9, r9
     b5c:	98 01       	movw	r18, r16
     b5e:	87 01       	movw	r16, r14
     b60:	20 70       	andi	r18, 0x00	; 0
     b62:	30 70       	andi	r19, 0x00	; 0
     b64:	65 96       	adiw	r28, 0x15	; 21
     b66:	0c af       	std	Y+60, r16	; 0x3c
     b68:	1d af       	std	Y+61, r17	; 0x3d
     b6a:	2e af       	std	Y+62, r18	; 0x3e
     b6c:	3f af       	std	Y+63, r19	; 0x3f
     b6e:	65 97       	sbiw	r28, 0x15	; 21
     b70:	c6 01       	movw	r24, r12
     b72:	b5 01       	movw	r22, r10
     b74:	a4 01       	movw	r20, r8
     b76:	93 01       	movw	r18, r6
     b78:	0e 94 c8 42 	call	0x8590	; 0x8590 <__udivmodsi4>
     b7c:	7b 01       	movw	r14, r22
     b7e:	8c 01       	movw	r16, r24
     b80:	c6 01       	movw	r24, r12
     b82:	b5 01       	movw	r22, r10
     b84:	a4 01       	movw	r20, r8
     b86:	93 01       	movw	r18, r6
     b88:	0e 94 c8 42 	call	0x8590	; 0x8590 <__udivmodsi4>
     b8c:	c9 01       	movw	r24, r18
     b8e:	da 01       	movw	r26, r20
     b90:	1c 01       	movw	r2, r24
     b92:	2d 01       	movw	r4, r26
     b94:	c2 01       	movw	r24, r4
     b96:	b1 01       	movw	r22, r2
     b98:	65 96       	adiw	r28, 0x15	; 21
     b9a:	2c ad       	ldd	r18, Y+60	; 0x3c
     b9c:	3d ad       	ldd	r19, Y+61	; 0x3d
     b9e:	4e ad       	ldd	r20, Y+62	; 0x3e
     ba0:	5f ad       	ldd	r21, Y+63	; 0x3f
     ba2:	65 97       	sbiw	r28, 0x15	; 21
     ba4:	0e 94 95 42 	call	0x852a	; 0x852a <__mulsi3>
     ba8:	9b 01       	movw	r18, r22
     baa:	ac 01       	movw	r20, r24
     bac:	87 01       	movw	r16, r14
     bae:	ff 24       	eor	r15, r15
     bb0:	ee 24       	eor	r14, r14
     bb2:	ad 8c       	ldd	r10, Y+29	; 0x1d
     bb4:	be 8c       	ldd	r11, Y+30	; 0x1e
     bb6:	cf 8c       	ldd	r12, Y+31	; 0x1f
     bb8:	d8 a0       	ldd	r13, Y+32	; 0x20
     bba:	c6 01       	movw	r24, r12
     bbc:	aa 27       	eor	r26, r26
     bbe:	bb 27       	eor	r27, r27
     bc0:	57 01       	movw	r10, r14
     bc2:	68 01       	movw	r12, r16
     bc4:	a8 2a       	or	r10, r24
     bc6:	b9 2a       	or	r11, r25
     bc8:	ca 2a       	or	r12, r26
     bca:	db 2a       	or	r13, r27
     bcc:	a2 16       	cp	r10, r18
     bce:	b3 06       	cpc	r11, r19
     bd0:	c4 06       	cpc	r12, r20
     bd2:	d5 06       	cpc	r13, r21
     bd4:	00 f5       	brcc	.+64     	; 0xc16 <__stack+0x3b7>
     bd6:	08 94       	sec
     bd8:	21 08       	sbc	r2, r1
     bda:	31 08       	sbc	r3, r1
     bdc:	41 08       	sbc	r4, r1
     bde:	51 08       	sbc	r5, r1
     be0:	ed a0       	ldd	r14, Y+37	; 0x25
     be2:	fe a0       	ldd	r15, Y+38	; 0x26
     be4:	0f a1       	ldd	r16, Y+39	; 0x27
     be6:	18 a5       	ldd	r17, Y+40	; 0x28
     be8:	ae 0c       	add	r10, r14
     bea:	bf 1c       	adc	r11, r15
     bec:	c0 1e       	adc	r12, r16
     bee:	d1 1e       	adc	r13, r17
     bf0:	ae 14       	cp	r10, r14
     bf2:	bf 04       	cpc	r11, r15
     bf4:	c0 06       	cpc	r12, r16
     bf6:	d1 06       	cpc	r13, r17
     bf8:	70 f0       	brcs	.+28     	; 0xc16 <__stack+0x3b7>
     bfa:	a2 16       	cp	r10, r18
     bfc:	b3 06       	cpc	r11, r19
     bfe:	c4 06       	cpc	r12, r20
     c00:	d5 06       	cpc	r13, r21
     c02:	48 f4       	brcc	.+18     	; 0xc16 <__stack+0x3b7>
     c04:	08 94       	sec
     c06:	21 08       	sbc	r2, r1
     c08:	31 08       	sbc	r3, r1
     c0a:	41 08       	sbc	r4, r1
     c0c:	51 08       	sbc	r5, r1
     c0e:	ae 0c       	add	r10, r14
     c10:	bf 1c       	adc	r11, r15
     c12:	c0 1e       	adc	r12, r16
     c14:	d1 1e       	adc	r13, r17
     c16:	a2 1a       	sub	r10, r18
     c18:	b3 0a       	sbc	r11, r19
     c1a:	c4 0a       	sbc	r12, r20
     c1c:	d5 0a       	sbc	r13, r21
     c1e:	c6 01       	movw	r24, r12
     c20:	b5 01       	movw	r22, r10
     c22:	a4 01       	movw	r20, r8
     c24:	93 01       	movw	r18, r6
     c26:	0e 94 c8 42 	call	0x8590	; 0x8590 <__udivmodsi4>
     c2a:	7b 01       	movw	r14, r22
     c2c:	8c 01       	movw	r16, r24
     c2e:	c6 01       	movw	r24, r12
     c30:	b5 01       	movw	r22, r10
     c32:	a4 01       	movw	r20, r8
     c34:	93 01       	movw	r18, r6
     c36:	0e 94 c8 42 	call	0x8590	; 0x8590 <__udivmodsi4>
     c3a:	c9 01       	movw	r24, r18
     c3c:	da 01       	movw	r26, r20
     c3e:	3c 01       	movw	r6, r24
     c40:	4d 01       	movw	r8, r26
     c42:	c4 01       	movw	r24, r8
     c44:	b3 01       	movw	r22, r6
     c46:	65 96       	adiw	r28, 0x15	; 21
     c48:	2c ad       	ldd	r18, Y+60	; 0x3c
     c4a:	3d ad       	ldd	r19, Y+61	; 0x3d
     c4c:	4e ad       	ldd	r20, Y+62	; 0x3e
     c4e:	5f ad       	ldd	r21, Y+63	; 0x3f
     c50:	65 97       	sbiw	r28, 0x15	; 21
     c52:	0e 94 95 42 	call	0x852a	; 0x852a <__mulsi3>
     c56:	9b 01       	movw	r18, r22
     c58:	ac 01       	movw	r20, r24
     c5a:	87 01       	movw	r16, r14
     c5c:	ff 24       	eor	r15, r15
     c5e:	ee 24       	eor	r14, r14
     c60:	8d 8d       	ldd	r24, Y+29	; 0x1d
     c62:	9e 8d       	ldd	r25, Y+30	; 0x1e
     c64:	af 8d       	ldd	r26, Y+31	; 0x1f
     c66:	b8 a1       	ldd	r27, Y+32	; 0x20
     c68:	a0 70       	andi	r26, 0x00	; 0
     c6a:	b0 70       	andi	r27, 0x00	; 0
     c6c:	57 01       	movw	r10, r14
     c6e:	68 01       	movw	r12, r16
     c70:	a8 2a       	or	r10, r24
     c72:	b9 2a       	or	r11, r25
     c74:	ca 2a       	or	r12, r26
     c76:	db 2a       	or	r13, r27
     c78:	a2 16       	cp	r10, r18
     c7a:	b3 06       	cpc	r11, r19
     c7c:	c4 06       	cpc	r12, r20
     c7e:	d5 06       	cpc	r13, r21
     c80:	00 f5       	brcc	.+64     	; 0xcc2 <__stack+0x463>
     c82:	08 94       	sec
     c84:	61 08       	sbc	r6, r1
     c86:	71 08       	sbc	r7, r1
     c88:	81 08       	sbc	r8, r1
     c8a:	91 08       	sbc	r9, r1
     c8c:	6d a1       	ldd	r22, Y+37	; 0x25
     c8e:	7e a1       	ldd	r23, Y+38	; 0x26
     c90:	8f a1       	ldd	r24, Y+39	; 0x27
     c92:	98 a5       	ldd	r25, Y+40	; 0x28
     c94:	a6 0e       	add	r10, r22
     c96:	b7 1e       	adc	r11, r23
     c98:	c8 1e       	adc	r12, r24
     c9a:	d9 1e       	adc	r13, r25
     c9c:	a6 16       	cp	r10, r22
     c9e:	b7 06       	cpc	r11, r23
     ca0:	c8 06       	cpc	r12, r24
     ca2:	d9 06       	cpc	r13, r25
     ca4:	70 f0       	brcs	.+28     	; 0xcc2 <__stack+0x463>
     ca6:	a2 16       	cp	r10, r18
     ca8:	b3 06       	cpc	r11, r19
     caa:	c4 06       	cpc	r12, r20
     cac:	d5 06       	cpc	r13, r21
     cae:	48 f4       	brcc	.+18     	; 0xcc2 <__stack+0x463>
     cb0:	08 94       	sec
     cb2:	61 08       	sbc	r6, r1
     cb4:	71 08       	sbc	r7, r1
     cb6:	81 08       	sbc	r8, r1
     cb8:	91 08       	sbc	r9, r1
     cba:	a6 0e       	add	r10, r22
     cbc:	b7 1e       	adc	r11, r23
     cbe:	c8 1e       	adc	r12, r24
     cc0:	d9 1e       	adc	r13, r25
     cc2:	d6 01       	movw	r26, r12
     cc4:	c5 01       	movw	r24, r10
     cc6:	82 1b       	sub	r24, r18
     cc8:	93 0b       	sbc	r25, r19
     cca:	a4 0b       	sbc	r26, r20
     ccc:	b5 0b       	sbc	r27, r21
     cce:	89 8f       	std	Y+25, r24	; 0x19
     cd0:	9a 8f       	std	Y+26, r25	; 0x1a
     cd2:	ab 8f       	std	Y+27, r26	; 0x1b
     cd4:	bc 8f       	std	Y+28, r27	; 0x1c
     cd6:	d1 01       	movw	r26, r2
     cd8:	99 27       	eor	r25, r25
     cda:	88 27       	eor	r24, r24
     cdc:	64 01       	movw	r12, r8
     cde:	53 01       	movw	r10, r6
     ce0:	a8 2a       	or	r10, r24
     ce2:	b9 2a       	or	r11, r25
     ce4:	ca 2a       	or	r12, r26
     ce6:	db 2a       	or	r13, r27
     ce8:	a9 aa       	std	Y+49, r10	; 0x31
     cea:	ba aa       	std	Y+50, r11	; 0x32
     cec:	cb aa       	std	Y+51, r12	; 0x33
     cee:	dc aa       	std	Y+52, r13	; 0x34
     cf0:	86 01       	movw	r16, r12
     cf2:	75 01       	movw	r14, r10
     cf4:	2f ef       	ldi	r18, 0xFF	; 255
     cf6:	3f ef       	ldi	r19, 0xFF	; 255
     cf8:	40 e0       	ldi	r20, 0x00	; 0
     cfa:	50 e0       	ldi	r21, 0x00	; 0
     cfc:	e2 22       	and	r14, r18
     cfe:	f3 22       	and	r15, r19
     d00:	04 23       	and	r16, r20
     d02:	15 23       	and	r17, r21
     d04:	a6 01       	movw	r20, r12
     d06:	66 27       	eor	r22, r22
     d08:	77 27       	eor	r23, r23
     d0a:	6d 96       	adiw	r28, 0x1d	; 29
     d0c:	4c af       	std	Y+60, r20	; 0x3c
     d0e:	5d af       	std	Y+61, r21	; 0x3d
     d10:	6e af       	std	Y+62, r22	; 0x3e
     d12:	7f af       	std	Y+63, r23	; 0x3f
     d14:	6d 97       	sbiw	r28, 0x1d	; 29
     d16:	a9 a0       	ldd	r10, Y+33	; 0x21
     d18:	ba a0       	ldd	r11, Y+34	; 0x22
     d1a:	cb a0       	ldd	r12, Y+35	; 0x23
     d1c:	dc a0       	ldd	r13, Y+36	; 0x24
     d1e:	6f ef       	ldi	r22, 0xFF	; 255
     d20:	7f ef       	ldi	r23, 0xFF	; 255
     d22:	80 e0       	ldi	r24, 0x00	; 0
     d24:	90 e0       	ldi	r25, 0x00	; 0
     d26:	a6 22       	and	r10, r22
     d28:	b7 22       	and	r11, r23
     d2a:	c8 22       	and	r12, r24
     d2c:	d9 22       	and	r13, r25
     d2e:	89 a1       	ldd	r24, Y+33	; 0x21
     d30:	9a a1       	ldd	r25, Y+34	; 0x22
     d32:	ab a1       	ldd	r26, Y+35	; 0x23
     d34:	bc a1       	ldd	r27, Y+36	; 0x24
     d36:	1d 01       	movw	r2, r26
     d38:	44 24       	eor	r4, r4
     d3a:	55 24       	eor	r5, r5
     d3c:	c8 01       	movw	r24, r16
     d3e:	b7 01       	movw	r22, r14
     d40:	a6 01       	movw	r20, r12
     d42:	95 01       	movw	r18, r10
     d44:	0e 94 95 42 	call	0x852a	; 0x852a <__mulsi3>
     d48:	69 96       	adiw	r28, 0x19	; 25
     d4a:	6c af       	std	Y+60, r22	; 0x3c
     d4c:	7d af       	std	Y+61, r23	; 0x3d
     d4e:	8e af       	std	Y+62, r24	; 0x3e
     d50:	9f af       	std	Y+63, r25	; 0x3f
     d52:	69 97       	sbiw	r28, 0x19	; 25
     d54:	c8 01       	movw	r24, r16
     d56:	b7 01       	movw	r22, r14
     d58:	a2 01       	movw	r20, r4
     d5a:	91 01       	movw	r18, r2
     d5c:	0e 94 95 42 	call	0x852a	; 0x852a <__mulsi3>
     d60:	3b 01       	movw	r6, r22
     d62:	4c 01       	movw	r8, r24
     d64:	6d 96       	adiw	r28, 0x1d	; 29
     d66:	6c ad       	ldd	r22, Y+60	; 0x3c
     d68:	7d ad       	ldd	r23, Y+61	; 0x3d
     d6a:	8e ad       	ldd	r24, Y+62	; 0x3e
     d6c:	9f ad       	ldd	r25, Y+63	; 0x3f
     d6e:	6d 97       	sbiw	r28, 0x1d	; 29
     d70:	a6 01       	movw	r20, r12
     d72:	95 01       	movw	r18, r10
     d74:	0e 94 95 42 	call	0x852a	; 0x852a <__mulsi3>
     d78:	7b 01       	movw	r14, r22
     d7a:	8c 01       	movw	r16, r24
     d7c:	6d 96       	adiw	r28, 0x1d	; 29
     d7e:	6c ad       	ldd	r22, Y+60	; 0x3c
     d80:	7d ad       	ldd	r23, Y+61	; 0x3d
     d82:	8e ad       	ldd	r24, Y+62	; 0x3e
     d84:	9f ad       	ldd	r25, Y+63	; 0x3f
     d86:	6d 97       	sbiw	r28, 0x1d	; 29
     d88:	a2 01       	movw	r20, r4
     d8a:	91 01       	movw	r18, r2
     d8c:	0e 94 95 42 	call	0x852a	; 0x852a <__mulsi3>
     d90:	5b 01       	movw	r10, r22
     d92:	6c 01       	movw	r12, r24
     d94:	a8 01       	movw	r20, r16
     d96:	97 01       	movw	r18, r14
     d98:	26 0d       	add	r18, r6
     d9a:	37 1d       	adc	r19, r7
     d9c:	48 1d       	adc	r20, r8
     d9e:	59 1d       	adc	r21, r9
     da0:	69 96       	adiw	r28, 0x19	; 25
     da2:	6c ac       	ldd	r6, Y+60	; 0x3c
     da4:	7d ac       	ldd	r7, Y+61	; 0x3d
     da6:	8e ac       	ldd	r8, Y+62	; 0x3e
     da8:	9f ac       	ldd	r9, Y+63	; 0x3f
     daa:	69 97       	sbiw	r28, 0x19	; 25
     dac:	c4 01       	movw	r24, r8
     dae:	aa 27       	eor	r26, r26
     db0:	bb 27       	eor	r27, r27
     db2:	28 0f       	add	r18, r24
     db4:	39 1f       	adc	r19, r25
     db6:	4a 1f       	adc	r20, r26
     db8:	5b 1f       	adc	r21, r27
     dba:	2e 15       	cp	r18, r14
     dbc:	3f 05       	cpc	r19, r15
     dbe:	40 07       	cpc	r20, r16
     dc0:	51 07       	cpc	r21, r17
     dc2:	48 f4       	brcc	.+18     	; 0xdd6 <__stack+0x577>
     dc4:	e1 2c       	mov	r14, r1
     dc6:	f1 2c       	mov	r15, r1
     dc8:	61 e0       	ldi	r22, 0x01	; 1
     dca:	06 2f       	mov	r16, r22
     dcc:	11 2d       	mov	r17, r1
     dce:	ae 0c       	add	r10, r14
     dd0:	bf 1c       	adc	r11, r15
     dd2:	c0 1e       	adc	r12, r16
     dd4:	d1 1e       	adc	r13, r17
     dd6:	ca 01       	movw	r24, r20
     dd8:	aa 27       	eor	r26, r26
     dda:	bb 27       	eor	r27, r27
     ddc:	bc 01       	movw	r22, r24
     dde:	cd 01       	movw	r24, r26
     de0:	6a 0d       	add	r22, r10
     de2:	7b 1d       	adc	r23, r11
     de4:	8c 1d       	adc	r24, r12
     de6:	9d 1d       	adc	r25, r13
     de8:	69 8c       	ldd	r6, Y+25	; 0x19
     dea:	7a 8c       	ldd	r7, Y+26	; 0x1a
     dec:	8b 8c       	ldd	r8, Y+27	; 0x1b
     dee:	9c 8c       	ldd	r9, Y+28	; 0x1c
     df0:	66 16       	cp	r6, r22
     df2:	77 06       	cpc	r7, r23
     df4:	88 06       	cpc	r8, r24
     df6:	99 06       	cpc	r9, r25
     df8:	40 f1       	brcs	.+80     	; 0xe4a <__stack+0x5eb>
     dfa:	66 15       	cp	r22, r6
     dfc:	77 05       	cpc	r23, r7
     dfe:	88 05       	cpc	r24, r8
     e00:	99 05       	cpc	r25, r9
     e02:	09 f0       	breq	.+2      	; 0xe06 <__stack+0x5a7>
     e04:	43 c0       	rjmp	.+134    	; 0xe8c <__stack+0x62d>
     e06:	d9 01       	movw	r26, r18
     e08:	99 27       	eor	r25, r25
     e0a:	88 27       	eor	r24, r24
     e0c:	69 96       	adiw	r28, 0x19	; 25
     e0e:	2c ad       	ldd	r18, Y+60	; 0x3c
     e10:	3d ad       	ldd	r19, Y+61	; 0x3d
     e12:	4e ad       	ldd	r20, Y+62	; 0x3e
     e14:	5f ad       	ldd	r21, Y+63	; 0x3f
     e16:	69 97       	sbiw	r28, 0x19	; 25
     e18:	40 70       	andi	r20, 0x00	; 0
     e1a:	50 70       	andi	r21, 0x00	; 0
     e1c:	82 0f       	add	r24, r18
     e1e:	93 1f       	adc	r25, r19
     e20:	a4 1f       	adc	r26, r20
     e22:	b5 1f       	adc	r27, r21
     e24:	2d a5       	ldd	r18, Y+45	; 0x2d
     e26:	3e a5       	ldd	r19, Y+46	; 0x2e
     e28:	4f a5       	ldd	r20, Y+47	; 0x2f
     e2a:	58 a9       	ldd	r21, Y+48	; 0x30
     e2c:	6e 96       	adiw	r28, 0x1e	; 30
     e2e:	0f ac       	ldd	r0, Y+63	; 0x3f
     e30:	6e 97       	sbiw	r28, 0x1e	; 30
     e32:	04 c0       	rjmp	.+8      	; 0xe3c <__stack+0x5dd>
     e34:	22 0f       	add	r18, r18
     e36:	33 1f       	adc	r19, r19
     e38:	44 1f       	adc	r20, r20
     e3a:	55 1f       	adc	r21, r21
     e3c:	0a 94       	dec	r0
     e3e:	d2 f7       	brpl	.-12     	; 0xe34 <__stack+0x5d5>
     e40:	28 17       	cp	r18, r24
     e42:	39 07       	cpc	r19, r25
     e44:	4a 07       	cpc	r20, r26
     e46:	5b 07       	cpc	r21, r27
     e48:	08 f5       	brcc	.+66     	; 0xe8c <__stack+0x62d>
     e4a:	09 a9       	ldd	r16, Y+49	; 0x31
     e4c:	1a a9       	ldd	r17, Y+50	; 0x32
     e4e:	2b a9       	ldd	r18, Y+51	; 0x33
     e50:	3c a9       	ldd	r19, Y+52	; 0x34
     e52:	01 50       	subi	r16, 0x01	; 1
     e54:	10 40       	sbci	r17, 0x00	; 0
     e56:	20 40       	sbci	r18, 0x00	; 0
     e58:	30 40       	sbci	r19, 0x00	; 0
     e5a:	09 ab       	std	Y+49, r16	; 0x31
     e5c:	1a ab       	std	Y+50, r17	; 0x32
     e5e:	2b ab       	std	Y+51, r18	; 0x33
     e60:	3c ab       	std	Y+52, r19	; 0x34
     e62:	14 c0       	rjmp	.+40     	; 0xe8c <__stack+0x62d>
     e64:	66 24       	eor	r6, r6
     e66:	77 24       	eor	r7, r7
     e68:	43 01       	movw	r8, r6
     e6a:	21 e0       	ldi	r18, 0x01	; 1
     e6c:	30 e0       	ldi	r19, 0x00	; 0
     e6e:	40 e0       	ldi	r20, 0x00	; 0
     e70:	50 e0       	ldi	r21, 0x00	; 0
     e72:	29 ab       	std	Y+49, r18	; 0x31
     e74:	3a ab       	std	Y+50, r19	; 0x32
     e76:	4b ab       	std	Y+51, r20	; 0x33
     e78:	5c ab       	std	Y+52, r21	; 0x34
     e7a:	0b c0       	rjmp	.+22     	; 0xe92 <__stack+0x633>
     e7c:	66 24       	eor	r6, r6
     e7e:	77 24       	eor	r7, r7
     e80:	43 01       	movw	r8, r6
     e82:	19 aa       	std	Y+49, r1	; 0x31
     e84:	1a aa       	std	Y+50, r1	; 0x32
     e86:	1b aa       	std	Y+51, r1	; 0x33
     e88:	1c aa       	std	Y+52, r1	; 0x34
     e8a:	03 c0       	rjmp	.+6      	; 0xe92 <__stack+0x633>
     e8c:	66 24       	eor	r6, r6
     e8e:	77 24       	eor	r7, r7
     e90:	43 01       	movw	r8, r6
     e92:	fe 01       	movw	r30, r28
     e94:	71 96       	adiw	r30, 0x11	; 17
     e96:	88 e0       	ldi	r24, 0x08	; 8
     e98:	df 01       	movw	r26, r30
     e9a:	1d 92       	st	X+, r1
     e9c:	8a 95       	dec	r24
     e9e:	e9 f7       	brne	.-6      	; 0xe9a <__stack+0x63b>
     ea0:	a9 a8       	ldd	r10, Y+49	; 0x31
     ea2:	ba a8       	ldd	r11, Y+50	; 0x32
     ea4:	cb a8       	ldd	r12, Y+51	; 0x33
     ea6:	dc a8       	ldd	r13, Y+52	; 0x34
     ea8:	a9 8a       	std	Y+17, r10	; 0x11
     eaa:	ba 8a       	std	Y+18, r11	; 0x12
     eac:	cb 8a       	std	Y+19, r12	; 0x13
     eae:	dc 8a       	std	Y+20, r13	; 0x14
     eb0:	6d 8a       	std	Y+21, r6	; 0x15
     eb2:	7e 8a       	std	Y+22, r7	; 0x16
     eb4:	8f 8a       	std	Y+23, r8	; 0x17
     eb6:	98 8e       	std	Y+24, r9	; 0x18
     eb8:	29 a9       	ldd	r18, Y+49	; 0x31
     eba:	3a 89       	ldd	r19, Y+18	; 0x12
     ebc:	4b 89       	ldd	r20, Y+19	; 0x13
     ebe:	5c 89       	ldd	r21, Y+20	; 0x14
     ec0:	66 2d       	mov	r22, r6
     ec2:	7e 89       	ldd	r23, Y+22	; 0x16
     ec4:	8f 89       	ldd	r24, Y+23	; 0x17
     ec6:	98 8d       	ldd	r25, Y+24	; 0x18
     ec8:	c2 5a       	subi	r28, 0xA2	; 162
     eca:	df 4f       	sbci	r29, 0xFF	; 255
     ecc:	e2 e1       	ldi	r30, 0x12	; 18
     ece:	0c 94 06 43 	jmp	0x860c	; 0x860c <__epilogue_restores__>

00000ed2 <_fpadd_parts>:
     ed2:	a0 e0       	ldi	r26, 0x00	; 0
     ed4:	b0 e0       	ldi	r27, 0x00	; 0
     ed6:	ef e6       	ldi	r30, 0x6F	; 111
     ed8:	f7 e0       	ldi	r31, 0x07	; 7
     eda:	0c 94 ea 42 	jmp	0x85d4	; 0x85d4 <__prologue_saves__>
     ede:	dc 01       	movw	r26, r24
     ee0:	2b 01       	movw	r4, r22
     ee2:	fa 01       	movw	r30, r20
     ee4:	9c 91       	ld	r25, X
     ee6:	92 30       	cpi	r25, 0x02	; 2
     ee8:	08 f4       	brcc	.+2      	; 0xeec <_fpadd_parts+0x1a>
     eea:	39 c1       	rjmp	.+626    	; 0x115e <_fpadd_parts+0x28c>
     eec:	eb 01       	movw	r28, r22
     eee:	88 81       	ld	r24, Y
     ef0:	82 30       	cpi	r24, 0x02	; 2
     ef2:	08 f4       	brcc	.+2      	; 0xef6 <_fpadd_parts+0x24>
     ef4:	33 c1       	rjmp	.+614    	; 0x115c <_fpadd_parts+0x28a>
     ef6:	94 30       	cpi	r25, 0x04	; 4
     ef8:	69 f4       	brne	.+26     	; 0xf14 <_fpadd_parts+0x42>
     efa:	84 30       	cpi	r24, 0x04	; 4
     efc:	09 f0       	breq	.+2      	; 0xf00 <_fpadd_parts+0x2e>
     efe:	2f c1       	rjmp	.+606    	; 0x115e <_fpadd_parts+0x28c>
     f00:	11 96       	adiw	r26, 0x01	; 1
     f02:	9c 91       	ld	r25, X
     f04:	11 97       	sbiw	r26, 0x01	; 1
     f06:	89 81       	ldd	r24, Y+1	; 0x01
     f08:	98 17       	cp	r25, r24
     f0a:	09 f4       	brne	.+2      	; 0xf0e <_fpadd_parts+0x3c>
     f0c:	28 c1       	rjmp	.+592    	; 0x115e <_fpadd_parts+0x28c>
     f0e:	ac e6       	ldi	r26, 0x6C	; 108
     f10:	b0 e0       	ldi	r27, 0x00	; 0
     f12:	25 c1       	rjmp	.+586    	; 0x115e <_fpadd_parts+0x28c>
     f14:	84 30       	cpi	r24, 0x04	; 4
     f16:	09 f4       	brne	.+2      	; 0xf1a <_fpadd_parts+0x48>
     f18:	21 c1       	rjmp	.+578    	; 0x115c <_fpadd_parts+0x28a>
     f1a:	82 30       	cpi	r24, 0x02	; 2
     f1c:	a9 f4       	brne	.+42     	; 0xf48 <_fpadd_parts+0x76>
     f1e:	92 30       	cpi	r25, 0x02	; 2
     f20:	09 f0       	breq	.+2      	; 0xf24 <_fpadd_parts+0x52>
     f22:	1d c1       	rjmp	.+570    	; 0x115e <_fpadd_parts+0x28c>
     f24:	9a 01       	movw	r18, r20
     f26:	ad 01       	movw	r20, r26
     f28:	88 e0       	ldi	r24, 0x08	; 8
     f2a:	ea 01       	movw	r28, r20
     f2c:	09 90       	ld	r0, Y+
     f2e:	ae 01       	movw	r20, r28
     f30:	e9 01       	movw	r28, r18
     f32:	09 92       	st	Y+, r0
     f34:	9e 01       	movw	r18, r28
     f36:	81 50       	subi	r24, 0x01	; 1
     f38:	c1 f7       	brne	.-16     	; 0xf2a <_fpadd_parts+0x58>
     f3a:	e2 01       	movw	r28, r4
     f3c:	89 81       	ldd	r24, Y+1	; 0x01
     f3e:	11 96       	adiw	r26, 0x01	; 1
     f40:	9c 91       	ld	r25, X
     f42:	89 23       	and	r24, r25
     f44:	81 83       	std	Z+1, r24	; 0x01
     f46:	08 c1       	rjmp	.+528    	; 0x1158 <_fpadd_parts+0x286>
     f48:	92 30       	cpi	r25, 0x02	; 2
     f4a:	09 f4       	brne	.+2      	; 0xf4e <_fpadd_parts+0x7c>
     f4c:	07 c1       	rjmp	.+526    	; 0x115c <_fpadd_parts+0x28a>
     f4e:	12 96       	adiw	r26, 0x02	; 2
     f50:	2d 90       	ld	r2, X+
     f52:	3c 90       	ld	r3, X
     f54:	13 97       	sbiw	r26, 0x03	; 3
     f56:	eb 01       	movw	r28, r22
     f58:	8a 81       	ldd	r24, Y+2	; 0x02
     f5a:	9b 81       	ldd	r25, Y+3	; 0x03
     f5c:	14 96       	adiw	r26, 0x04	; 4
     f5e:	ad 90       	ld	r10, X+
     f60:	bd 90       	ld	r11, X+
     f62:	cd 90       	ld	r12, X+
     f64:	dc 90       	ld	r13, X
     f66:	17 97       	sbiw	r26, 0x07	; 7
     f68:	ec 80       	ldd	r14, Y+4	; 0x04
     f6a:	fd 80       	ldd	r15, Y+5	; 0x05
     f6c:	0e 81       	ldd	r16, Y+6	; 0x06
     f6e:	1f 81       	ldd	r17, Y+7	; 0x07
     f70:	91 01       	movw	r18, r2
     f72:	28 1b       	sub	r18, r24
     f74:	39 0b       	sbc	r19, r25
     f76:	b9 01       	movw	r22, r18
     f78:	37 ff       	sbrs	r19, 7
     f7a:	04 c0       	rjmp	.+8      	; 0xf84 <_fpadd_parts+0xb2>
     f7c:	66 27       	eor	r22, r22
     f7e:	77 27       	eor	r23, r23
     f80:	62 1b       	sub	r22, r18
     f82:	73 0b       	sbc	r23, r19
     f84:	60 32       	cpi	r22, 0x20	; 32
     f86:	71 05       	cpc	r23, r1
     f88:	0c f0       	brlt	.+2      	; 0xf8c <_fpadd_parts+0xba>
     f8a:	61 c0       	rjmp	.+194    	; 0x104e <_fpadd_parts+0x17c>
     f8c:	12 16       	cp	r1, r18
     f8e:	13 06       	cpc	r1, r19
     f90:	6c f5       	brge	.+90     	; 0xfec <_fpadd_parts+0x11a>
     f92:	37 01       	movw	r6, r14
     f94:	48 01       	movw	r8, r16
     f96:	06 2e       	mov	r0, r22
     f98:	04 c0       	rjmp	.+8      	; 0xfa2 <_fpadd_parts+0xd0>
     f9a:	96 94       	lsr	r9
     f9c:	87 94       	ror	r8
     f9e:	77 94       	ror	r7
     fa0:	67 94       	ror	r6
     fa2:	0a 94       	dec	r0
     fa4:	d2 f7       	brpl	.-12     	; 0xf9a <_fpadd_parts+0xc8>
     fa6:	21 e0       	ldi	r18, 0x01	; 1
     fa8:	30 e0       	ldi	r19, 0x00	; 0
     faa:	40 e0       	ldi	r20, 0x00	; 0
     fac:	50 e0       	ldi	r21, 0x00	; 0
     fae:	04 c0       	rjmp	.+8      	; 0xfb8 <_fpadd_parts+0xe6>
     fb0:	22 0f       	add	r18, r18
     fb2:	33 1f       	adc	r19, r19
     fb4:	44 1f       	adc	r20, r20
     fb6:	55 1f       	adc	r21, r21
     fb8:	6a 95       	dec	r22
     fba:	d2 f7       	brpl	.-12     	; 0xfb0 <_fpadd_parts+0xde>
     fbc:	21 50       	subi	r18, 0x01	; 1
     fbe:	30 40       	sbci	r19, 0x00	; 0
     fc0:	40 40       	sbci	r20, 0x00	; 0
     fc2:	50 40       	sbci	r21, 0x00	; 0
     fc4:	2e 21       	and	r18, r14
     fc6:	3f 21       	and	r19, r15
     fc8:	40 23       	and	r20, r16
     fca:	51 23       	and	r21, r17
     fcc:	21 15       	cp	r18, r1
     fce:	31 05       	cpc	r19, r1
     fd0:	41 05       	cpc	r20, r1
     fd2:	51 05       	cpc	r21, r1
     fd4:	21 f0       	breq	.+8      	; 0xfde <_fpadd_parts+0x10c>
     fd6:	21 e0       	ldi	r18, 0x01	; 1
     fd8:	30 e0       	ldi	r19, 0x00	; 0
     fda:	40 e0       	ldi	r20, 0x00	; 0
     fdc:	50 e0       	ldi	r21, 0x00	; 0
     fde:	79 01       	movw	r14, r18
     fe0:	8a 01       	movw	r16, r20
     fe2:	e6 28       	or	r14, r6
     fe4:	f7 28       	or	r15, r7
     fe6:	08 29       	or	r16, r8
     fe8:	19 29       	or	r17, r9
     fea:	3c c0       	rjmp	.+120    	; 0x1064 <_fpadd_parts+0x192>
     fec:	23 2b       	or	r18, r19
     fee:	d1 f1       	breq	.+116    	; 0x1064 <_fpadd_parts+0x192>
     ff0:	26 0e       	add	r2, r22
     ff2:	37 1e       	adc	r3, r23
     ff4:	35 01       	movw	r6, r10
     ff6:	46 01       	movw	r8, r12
     ff8:	06 2e       	mov	r0, r22
     ffa:	04 c0       	rjmp	.+8      	; 0x1004 <_fpadd_parts+0x132>
     ffc:	96 94       	lsr	r9
     ffe:	87 94       	ror	r8
    1000:	77 94       	ror	r7
    1002:	67 94       	ror	r6
    1004:	0a 94       	dec	r0
    1006:	d2 f7       	brpl	.-12     	; 0xffc <_fpadd_parts+0x12a>
    1008:	21 e0       	ldi	r18, 0x01	; 1
    100a:	30 e0       	ldi	r19, 0x00	; 0
    100c:	40 e0       	ldi	r20, 0x00	; 0
    100e:	50 e0       	ldi	r21, 0x00	; 0
    1010:	04 c0       	rjmp	.+8      	; 0x101a <_fpadd_parts+0x148>
    1012:	22 0f       	add	r18, r18
    1014:	33 1f       	adc	r19, r19
    1016:	44 1f       	adc	r20, r20
    1018:	55 1f       	adc	r21, r21
    101a:	6a 95       	dec	r22
    101c:	d2 f7       	brpl	.-12     	; 0x1012 <_fpadd_parts+0x140>
    101e:	21 50       	subi	r18, 0x01	; 1
    1020:	30 40       	sbci	r19, 0x00	; 0
    1022:	40 40       	sbci	r20, 0x00	; 0
    1024:	50 40       	sbci	r21, 0x00	; 0
    1026:	2a 21       	and	r18, r10
    1028:	3b 21       	and	r19, r11
    102a:	4c 21       	and	r20, r12
    102c:	5d 21       	and	r21, r13
    102e:	21 15       	cp	r18, r1
    1030:	31 05       	cpc	r19, r1
    1032:	41 05       	cpc	r20, r1
    1034:	51 05       	cpc	r21, r1
    1036:	21 f0       	breq	.+8      	; 0x1040 <_fpadd_parts+0x16e>
    1038:	21 e0       	ldi	r18, 0x01	; 1
    103a:	30 e0       	ldi	r19, 0x00	; 0
    103c:	40 e0       	ldi	r20, 0x00	; 0
    103e:	50 e0       	ldi	r21, 0x00	; 0
    1040:	59 01       	movw	r10, r18
    1042:	6a 01       	movw	r12, r20
    1044:	a6 28       	or	r10, r6
    1046:	b7 28       	or	r11, r7
    1048:	c8 28       	or	r12, r8
    104a:	d9 28       	or	r13, r9
    104c:	0b c0       	rjmp	.+22     	; 0x1064 <_fpadd_parts+0x192>
    104e:	82 15       	cp	r24, r2
    1050:	93 05       	cpc	r25, r3
    1052:	2c f0       	brlt	.+10     	; 0x105e <_fpadd_parts+0x18c>
    1054:	1c 01       	movw	r2, r24
    1056:	aa 24       	eor	r10, r10
    1058:	bb 24       	eor	r11, r11
    105a:	65 01       	movw	r12, r10
    105c:	03 c0       	rjmp	.+6      	; 0x1064 <_fpadd_parts+0x192>
    105e:	ee 24       	eor	r14, r14
    1060:	ff 24       	eor	r15, r15
    1062:	87 01       	movw	r16, r14
    1064:	11 96       	adiw	r26, 0x01	; 1
    1066:	9c 91       	ld	r25, X
    1068:	d2 01       	movw	r26, r4
    106a:	11 96       	adiw	r26, 0x01	; 1
    106c:	8c 91       	ld	r24, X
    106e:	98 17       	cp	r25, r24
    1070:	09 f4       	brne	.+2      	; 0x1074 <_fpadd_parts+0x1a2>
    1072:	45 c0       	rjmp	.+138    	; 0x10fe <_fpadd_parts+0x22c>
    1074:	99 23       	and	r25, r25
    1076:	39 f0       	breq	.+14     	; 0x1086 <_fpadd_parts+0x1b4>
    1078:	a8 01       	movw	r20, r16
    107a:	97 01       	movw	r18, r14
    107c:	2a 19       	sub	r18, r10
    107e:	3b 09       	sbc	r19, r11
    1080:	4c 09       	sbc	r20, r12
    1082:	5d 09       	sbc	r21, r13
    1084:	06 c0       	rjmp	.+12     	; 0x1092 <_fpadd_parts+0x1c0>
    1086:	a6 01       	movw	r20, r12
    1088:	95 01       	movw	r18, r10
    108a:	2e 19       	sub	r18, r14
    108c:	3f 09       	sbc	r19, r15
    108e:	40 0b       	sbc	r20, r16
    1090:	51 0b       	sbc	r21, r17
    1092:	57 fd       	sbrc	r21, 7
    1094:	08 c0       	rjmp	.+16     	; 0x10a6 <_fpadd_parts+0x1d4>
    1096:	11 82       	std	Z+1, r1	; 0x01
    1098:	33 82       	std	Z+3, r3	; 0x03
    109a:	22 82       	std	Z+2, r2	; 0x02
    109c:	24 83       	std	Z+4, r18	; 0x04
    109e:	35 83       	std	Z+5, r19	; 0x05
    10a0:	46 83       	std	Z+6, r20	; 0x06
    10a2:	57 83       	std	Z+7, r21	; 0x07
    10a4:	1d c0       	rjmp	.+58     	; 0x10e0 <_fpadd_parts+0x20e>
    10a6:	81 e0       	ldi	r24, 0x01	; 1
    10a8:	81 83       	std	Z+1, r24	; 0x01
    10aa:	33 82       	std	Z+3, r3	; 0x03
    10ac:	22 82       	std	Z+2, r2	; 0x02
    10ae:	88 27       	eor	r24, r24
    10b0:	99 27       	eor	r25, r25
    10b2:	dc 01       	movw	r26, r24
    10b4:	82 1b       	sub	r24, r18
    10b6:	93 0b       	sbc	r25, r19
    10b8:	a4 0b       	sbc	r26, r20
    10ba:	b5 0b       	sbc	r27, r21
    10bc:	84 83       	std	Z+4, r24	; 0x04
    10be:	95 83       	std	Z+5, r25	; 0x05
    10c0:	a6 83       	std	Z+6, r26	; 0x06
    10c2:	b7 83       	std	Z+7, r27	; 0x07
    10c4:	0d c0       	rjmp	.+26     	; 0x10e0 <_fpadd_parts+0x20e>
    10c6:	22 0f       	add	r18, r18
    10c8:	33 1f       	adc	r19, r19
    10ca:	44 1f       	adc	r20, r20
    10cc:	55 1f       	adc	r21, r21
    10ce:	24 83       	std	Z+4, r18	; 0x04
    10d0:	35 83       	std	Z+5, r19	; 0x05
    10d2:	46 83       	std	Z+6, r20	; 0x06
    10d4:	57 83       	std	Z+7, r21	; 0x07
    10d6:	82 81       	ldd	r24, Z+2	; 0x02
    10d8:	93 81       	ldd	r25, Z+3	; 0x03
    10da:	01 97       	sbiw	r24, 0x01	; 1
    10dc:	93 83       	std	Z+3, r25	; 0x03
    10de:	82 83       	std	Z+2, r24	; 0x02
    10e0:	24 81       	ldd	r18, Z+4	; 0x04
    10e2:	35 81       	ldd	r19, Z+5	; 0x05
    10e4:	46 81       	ldd	r20, Z+6	; 0x06
    10e6:	57 81       	ldd	r21, Z+7	; 0x07
    10e8:	da 01       	movw	r26, r20
    10ea:	c9 01       	movw	r24, r18
    10ec:	01 97       	sbiw	r24, 0x01	; 1
    10ee:	a1 09       	sbc	r26, r1
    10f0:	b1 09       	sbc	r27, r1
    10f2:	8f 5f       	subi	r24, 0xFF	; 255
    10f4:	9f 4f       	sbci	r25, 0xFF	; 255
    10f6:	af 4f       	sbci	r26, 0xFF	; 255
    10f8:	bf 43       	sbci	r27, 0x3F	; 63
    10fa:	28 f3       	brcs	.-54     	; 0x10c6 <_fpadd_parts+0x1f4>
    10fc:	0b c0       	rjmp	.+22     	; 0x1114 <_fpadd_parts+0x242>
    10fe:	91 83       	std	Z+1, r25	; 0x01
    1100:	33 82       	std	Z+3, r3	; 0x03
    1102:	22 82       	std	Z+2, r2	; 0x02
    1104:	ea 0c       	add	r14, r10
    1106:	fb 1c       	adc	r15, r11
    1108:	0c 1d       	adc	r16, r12
    110a:	1d 1d       	adc	r17, r13
    110c:	e4 82       	std	Z+4, r14	; 0x04
    110e:	f5 82       	std	Z+5, r15	; 0x05
    1110:	06 83       	std	Z+6, r16	; 0x06
    1112:	17 83       	std	Z+7, r17	; 0x07
    1114:	83 e0       	ldi	r24, 0x03	; 3
    1116:	80 83       	st	Z, r24
    1118:	24 81       	ldd	r18, Z+4	; 0x04
    111a:	35 81       	ldd	r19, Z+5	; 0x05
    111c:	46 81       	ldd	r20, Z+6	; 0x06
    111e:	57 81       	ldd	r21, Z+7	; 0x07
    1120:	57 ff       	sbrs	r21, 7
    1122:	1a c0       	rjmp	.+52     	; 0x1158 <_fpadd_parts+0x286>
    1124:	c9 01       	movw	r24, r18
    1126:	aa 27       	eor	r26, r26
    1128:	97 fd       	sbrc	r25, 7
    112a:	a0 95       	com	r26
    112c:	ba 2f       	mov	r27, r26
    112e:	81 70       	andi	r24, 0x01	; 1
    1130:	90 70       	andi	r25, 0x00	; 0
    1132:	a0 70       	andi	r26, 0x00	; 0
    1134:	b0 70       	andi	r27, 0x00	; 0
    1136:	56 95       	lsr	r21
    1138:	47 95       	ror	r20
    113a:	37 95       	ror	r19
    113c:	27 95       	ror	r18
    113e:	82 2b       	or	r24, r18
    1140:	93 2b       	or	r25, r19
    1142:	a4 2b       	or	r26, r20
    1144:	b5 2b       	or	r27, r21
    1146:	84 83       	std	Z+4, r24	; 0x04
    1148:	95 83       	std	Z+5, r25	; 0x05
    114a:	a6 83       	std	Z+6, r26	; 0x06
    114c:	b7 83       	std	Z+7, r27	; 0x07
    114e:	82 81       	ldd	r24, Z+2	; 0x02
    1150:	93 81       	ldd	r25, Z+3	; 0x03
    1152:	01 96       	adiw	r24, 0x01	; 1
    1154:	93 83       	std	Z+3, r25	; 0x03
    1156:	82 83       	std	Z+2, r24	; 0x02
    1158:	df 01       	movw	r26, r30
    115a:	01 c0       	rjmp	.+2      	; 0x115e <_fpadd_parts+0x28c>
    115c:	d2 01       	movw	r26, r4
    115e:	cd 01       	movw	r24, r26
    1160:	cd b7       	in	r28, 0x3d	; 61
    1162:	de b7       	in	r29, 0x3e	; 62
    1164:	e2 e1       	ldi	r30, 0x12	; 18
    1166:	0c 94 06 43 	jmp	0x860c	; 0x860c <__epilogue_restores__>

0000116a <__subsf3>:
    116a:	a0 e2       	ldi	r26, 0x20	; 32
    116c:	b0 e0       	ldi	r27, 0x00	; 0
    116e:	eb eb       	ldi	r30, 0xBB	; 187
    1170:	f8 e0       	ldi	r31, 0x08	; 8
    1172:	0c 94 f6 42 	jmp	0x85ec	; 0x85ec <__prologue_saves__+0x18>
    1176:	69 83       	std	Y+1, r22	; 0x01
    1178:	7a 83       	std	Y+2, r23	; 0x02
    117a:	8b 83       	std	Y+3, r24	; 0x03
    117c:	9c 83       	std	Y+4, r25	; 0x04
    117e:	2d 83       	std	Y+5, r18	; 0x05
    1180:	3e 83       	std	Y+6, r19	; 0x06
    1182:	4f 83       	std	Y+7, r20	; 0x07
    1184:	58 87       	std	Y+8, r21	; 0x08
    1186:	e9 e0       	ldi	r30, 0x09	; 9
    1188:	ee 2e       	mov	r14, r30
    118a:	f1 2c       	mov	r15, r1
    118c:	ec 0e       	add	r14, r28
    118e:	fd 1e       	adc	r15, r29
    1190:	ce 01       	movw	r24, r28
    1192:	01 96       	adiw	r24, 0x01	; 1
    1194:	b7 01       	movw	r22, r14
    1196:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <__unpack_f>
    119a:	8e 01       	movw	r16, r28
    119c:	0f 5e       	subi	r16, 0xEF	; 239
    119e:	1f 4f       	sbci	r17, 0xFF	; 255
    11a0:	ce 01       	movw	r24, r28
    11a2:	05 96       	adiw	r24, 0x05	; 5
    11a4:	b8 01       	movw	r22, r16
    11a6:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <__unpack_f>
    11aa:	8a 89       	ldd	r24, Y+18	; 0x12
    11ac:	91 e0       	ldi	r25, 0x01	; 1
    11ae:	89 27       	eor	r24, r25
    11b0:	8a 8b       	std	Y+18, r24	; 0x12
    11b2:	c7 01       	movw	r24, r14
    11b4:	b8 01       	movw	r22, r16
    11b6:	ae 01       	movw	r20, r28
    11b8:	47 5e       	subi	r20, 0xE7	; 231
    11ba:	5f 4f       	sbci	r21, 0xFF	; 255
    11bc:	0e 94 69 07 	call	0xed2	; 0xed2 <_fpadd_parts>
    11c0:	0e 94 9d 0b 	call	0x173a	; 0x173a <__pack_f>
    11c4:	a0 96       	adiw	r28, 0x20	; 32
    11c6:	e6 e0       	ldi	r30, 0x06	; 6
    11c8:	0c 94 12 43 	jmp	0x8624	; 0x8624 <__epilogue_restores__+0x18>

000011cc <__addsf3>:
    11cc:	a0 e2       	ldi	r26, 0x20	; 32
    11ce:	b0 e0       	ldi	r27, 0x00	; 0
    11d0:	ec ee       	ldi	r30, 0xEC	; 236
    11d2:	f8 e0       	ldi	r31, 0x08	; 8
    11d4:	0c 94 f6 42 	jmp	0x85ec	; 0x85ec <__prologue_saves__+0x18>
    11d8:	69 83       	std	Y+1, r22	; 0x01
    11da:	7a 83       	std	Y+2, r23	; 0x02
    11dc:	8b 83       	std	Y+3, r24	; 0x03
    11de:	9c 83       	std	Y+4, r25	; 0x04
    11e0:	2d 83       	std	Y+5, r18	; 0x05
    11e2:	3e 83       	std	Y+6, r19	; 0x06
    11e4:	4f 83       	std	Y+7, r20	; 0x07
    11e6:	58 87       	std	Y+8, r21	; 0x08
    11e8:	f9 e0       	ldi	r31, 0x09	; 9
    11ea:	ef 2e       	mov	r14, r31
    11ec:	f1 2c       	mov	r15, r1
    11ee:	ec 0e       	add	r14, r28
    11f0:	fd 1e       	adc	r15, r29
    11f2:	ce 01       	movw	r24, r28
    11f4:	01 96       	adiw	r24, 0x01	; 1
    11f6:	b7 01       	movw	r22, r14
    11f8:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <__unpack_f>
    11fc:	8e 01       	movw	r16, r28
    11fe:	0f 5e       	subi	r16, 0xEF	; 239
    1200:	1f 4f       	sbci	r17, 0xFF	; 255
    1202:	ce 01       	movw	r24, r28
    1204:	05 96       	adiw	r24, 0x05	; 5
    1206:	b8 01       	movw	r22, r16
    1208:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <__unpack_f>
    120c:	c7 01       	movw	r24, r14
    120e:	b8 01       	movw	r22, r16
    1210:	ae 01       	movw	r20, r28
    1212:	47 5e       	subi	r20, 0xE7	; 231
    1214:	5f 4f       	sbci	r21, 0xFF	; 255
    1216:	0e 94 69 07 	call	0xed2	; 0xed2 <_fpadd_parts>
    121a:	0e 94 9d 0b 	call	0x173a	; 0x173a <__pack_f>
    121e:	a0 96       	adiw	r28, 0x20	; 32
    1220:	e6 e0       	ldi	r30, 0x06	; 6
    1222:	0c 94 12 43 	jmp	0x8624	; 0x8624 <__epilogue_restores__+0x18>

00001226 <__mulsf3>:
    1226:	a0 e2       	ldi	r26, 0x20	; 32
    1228:	b0 e0       	ldi	r27, 0x00	; 0
    122a:	e9 e1       	ldi	r30, 0x19	; 25
    122c:	f9 e0       	ldi	r31, 0x09	; 9
    122e:	0c 94 ea 42 	jmp	0x85d4	; 0x85d4 <__prologue_saves__>
    1232:	69 83       	std	Y+1, r22	; 0x01
    1234:	7a 83       	std	Y+2, r23	; 0x02
    1236:	8b 83       	std	Y+3, r24	; 0x03
    1238:	9c 83       	std	Y+4, r25	; 0x04
    123a:	2d 83       	std	Y+5, r18	; 0x05
    123c:	3e 83       	std	Y+6, r19	; 0x06
    123e:	4f 83       	std	Y+7, r20	; 0x07
    1240:	58 87       	std	Y+8, r21	; 0x08
    1242:	ce 01       	movw	r24, r28
    1244:	01 96       	adiw	r24, 0x01	; 1
    1246:	be 01       	movw	r22, r28
    1248:	67 5f       	subi	r22, 0xF7	; 247
    124a:	7f 4f       	sbci	r23, 0xFF	; 255
    124c:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <__unpack_f>
    1250:	ce 01       	movw	r24, r28
    1252:	05 96       	adiw	r24, 0x05	; 5
    1254:	be 01       	movw	r22, r28
    1256:	6f 5e       	subi	r22, 0xEF	; 239
    1258:	7f 4f       	sbci	r23, 0xFF	; 255
    125a:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <__unpack_f>
    125e:	99 85       	ldd	r25, Y+9	; 0x09
    1260:	92 30       	cpi	r25, 0x02	; 2
    1262:	88 f0       	brcs	.+34     	; 0x1286 <__mulsf3+0x60>
    1264:	89 89       	ldd	r24, Y+17	; 0x11
    1266:	82 30       	cpi	r24, 0x02	; 2
    1268:	c8 f0       	brcs	.+50     	; 0x129c <__mulsf3+0x76>
    126a:	94 30       	cpi	r25, 0x04	; 4
    126c:	19 f4       	brne	.+6      	; 0x1274 <__mulsf3+0x4e>
    126e:	82 30       	cpi	r24, 0x02	; 2
    1270:	51 f4       	brne	.+20     	; 0x1286 <__mulsf3+0x60>
    1272:	04 c0       	rjmp	.+8      	; 0x127c <__mulsf3+0x56>
    1274:	84 30       	cpi	r24, 0x04	; 4
    1276:	29 f4       	brne	.+10     	; 0x1282 <__mulsf3+0x5c>
    1278:	92 30       	cpi	r25, 0x02	; 2
    127a:	81 f4       	brne	.+32     	; 0x129c <__mulsf3+0x76>
    127c:	8c e6       	ldi	r24, 0x6C	; 108
    127e:	90 e0       	ldi	r25, 0x00	; 0
    1280:	c6 c0       	rjmp	.+396    	; 0x140e <__mulsf3+0x1e8>
    1282:	92 30       	cpi	r25, 0x02	; 2
    1284:	49 f4       	brne	.+18     	; 0x1298 <__mulsf3+0x72>
    1286:	20 e0       	ldi	r18, 0x00	; 0
    1288:	9a 85       	ldd	r25, Y+10	; 0x0a
    128a:	8a 89       	ldd	r24, Y+18	; 0x12
    128c:	98 13       	cpse	r25, r24
    128e:	21 e0       	ldi	r18, 0x01	; 1
    1290:	2a 87       	std	Y+10, r18	; 0x0a
    1292:	ce 01       	movw	r24, r28
    1294:	09 96       	adiw	r24, 0x09	; 9
    1296:	bb c0       	rjmp	.+374    	; 0x140e <__mulsf3+0x1e8>
    1298:	82 30       	cpi	r24, 0x02	; 2
    129a:	49 f4       	brne	.+18     	; 0x12ae <__mulsf3+0x88>
    129c:	20 e0       	ldi	r18, 0x00	; 0
    129e:	9a 85       	ldd	r25, Y+10	; 0x0a
    12a0:	8a 89       	ldd	r24, Y+18	; 0x12
    12a2:	98 13       	cpse	r25, r24
    12a4:	21 e0       	ldi	r18, 0x01	; 1
    12a6:	2a 8b       	std	Y+18, r18	; 0x12
    12a8:	ce 01       	movw	r24, r28
    12aa:	41 96       	adiw	r24, 0x11	; 17
    12ac:	b0 c0       	rjmp	.+352    	; 0x140e <__mulsf3+0x1e8>
    12ae:	2d 84       	ldd	r2, Y+13	; 0x0d
    12b0:	3e 84       	ldd	r3, Y+14	; 0x0e
    12b2:	4f 84       	ldd	r4, Y+15	; 0x0f
    12b4:	58 88       	ldd	r5, Y+16	; 0x10
    12b6:	6d 88       	ldd	r6, Y+21	; 0x15
    12b8:	7e 88       	ldd	r7, Y+22	; 0x16
    12ba:	8f 88       	ldd	r8, Y+23	; 0x17
    12bc:	98 8c       	ldd	r9, Y+24	; 0x18
    12be:	ee 24       	eor	r14, r14
    12c0:	ff 24       	eor	r15, r15
    12c2:	87 01       	movw	r16, r14
    12c4:	aa 24       	eor	r10, r10
    12c6:	bb 24       	eor	r11, r11
    12c8:	65 01       	movw	r12, r10
    12ca:	40 e0       	ldi	r20, 0x00	; 0
    12cc:	50 e0       	ldi	r21, 0x00	; 0
    12ce:	60 e0       	ldi	r22, 0x00	; 0
    12d0:	70 e0       	ldi	r23, 0x00	; 0
    12d2:	e0 e0       	ldi	r30, 0x00	; 0
    12d4:	f0 e0       	ldi	r31, 0x00	; 0
    12d6:	c1 01       	movw	r24, r2
    12d8:	81 70       	andi	r24, 0x01	; 1
    12da:	90 70       	andi	r25, 0x00	; 0
    12dc:	89 2b       	or	r24, r25
    12de:	e9 f0       	breq	.+58     	; 0x131a <__mulsf3+0xf4>
    12e0:	e6 0c       	add	r14, r6
    12e2:	f7 1c       	adc	r15, r7
    12e4:	08 1d       	adc	r16, r8
    12e6:	19 1d       	adc	r17, r9
    12e8:	9a 01       	movw	r18, r20
    12ea:	ab 01       	movw	r20, r22
    12ec:	2a 0d       	add	r18, r10
    12ee:	3b 1d       	adc	r19, r11
    12f0:	4c 1d       	adc	r20, r12
    12f2:	5d 1d       	adc	r21, r13
    12f4:	80 e0       	ldi	r24, 0x00	; 0
    12f6:	90 e0       	ldi	r25, 0x00	; 0
    12f8:	a0 e0       	ldi	r26, 0x00	; 0
    12fa:	b0 e0       	ldi	r27, 0x00	; 0
    12fc:	e6 14       	cp	r14, r6
    12fe:	f7 04       	cpc	r15, r7
    1300:	08 05       	cpc	r16, r8
    1302:	19 05       	cpc	r17, r9
    1304:	20 f4       	brcc	.+8      	; 0x130e <__mulsf3+0xe8>
    1306:	81 e0       	ldi	r24, 0x01	; 1
    1308:	90 e0       	ldi	r25, 0x00	; 0
    130a:	a0 e0       	ldi	r26, 0x00	; 0
    130c:	b0 e0       	ldi	r27, 0x00	; 0
    130e:	ba 01       	movw	r22, r20
    1310:	a9 01       	movw	r20, r18
    1312:	48 0f       	add	r20, r24
    1314:	59 1f       	adc	r21, r25
    1316:	6a 1f       	adc	r22, r26
    1318:	7b 1f       	adc	r23, r27
    131a:	aa 0c       	add	r10, r10
    131c:	bb 1c       	adc	r11, r11
    131e:	cc 1c       	adc	r12, r12
    1320:	dd 1c       	adc	r13, r13
    1322:	97 fe       	sbrs	r9, 7
    1324:	08 c0       	rjmp	.+16     	; 0x1336 <__mulsf3+0x110>
    1326:	81 e0       	ldi	r24, 0x01	; 1
    1328:	90 e0       	ldi	r25, 0x00	; 0
    132a:	a0 e0       	ldi	r26, 0x00	; 0
    132c:	b0 e0       	ldi	r27, 0x00	; 0
    132e:	a8 2a       	or	r10, r24
    1330:	b9 2a       	or	r11, r25
    1332:	ca 2a       	or	r12, r26
    1334:	db 2a       	or	r13, r27
    1336:	31 96       	adiw	r30, 0x01	; 1
    1338:	e0 32       	cpi	r30, 0x20	; 32
    133a:	f1 05       	cpc	r31, r1
    133c:	49 f0       	breq	.+18     	; 0x1350 <__mulsf3+0x12a>
    133e:	66 0c       	add	r6, r6
    1340:	77 1c       	adc	r7, r7
    1342:	88 1c       	adc	r8, r8
    1344:	99 1c       	adc	r9, r9
    1346:	56 94       	lsr	r5
    1348:	47 94       	ror	r4
    134a:	37 94       	ror	r3
    134c:	27 94       	ror	r2
    134e:	c3 cf       	rjmp	.-122    	; 0x12d6 <__mulsf3+0xb0>
    1350:	fa 85       	ldd	r31, Y+10	; 0x0a
    1352:	ea 89       	ldd	r30, Y+18	; 0x12
    1354:	2b 89       	ldd	r18, Y+19	; 0x13
    1356:	3c 89       	ldd	r19, Y+20	; 0x14
    1358:	8b 85       	ldd	r24, Y+11	; 0x0b
    135a:	9c 85       	ldd	r25, Y+12	; 0x0c
    135c:	28 0f       	add	r18, r24
    135e:	39 1f       	adc	r19, r25
    1360:	2e 5f       	subi	r18, 0xFE	; 254
    1362:	3f 4f       	sbci	r19, 0xFF	; 255
    1364:	17 c0       	rjmp	.+46     	; 0x1394 <__mulsf3+0x16e>
    1366:	ca 01       	movw	r24, r20
    1368:	81 70       	andi	r24, 0x01	; 1
    136a:	90 70       	andi	r25, 0x00	; 0
    136c:	89 2b       	or	r24, r25
    136e:	61 f0       	breq	.+24     	; 0x1388 <__mulsf3+0x162>
    1370:	16 95       	lsr	r17
    1372:	07 95       	ror	r16
    1374:	f7 94       	ror	r15
    1376:	e7 94       	ror	r14
    1378:	80 e0       	ldi	r24, 0x00	; 0
    137a:	90 e0       	ldi	r25, 0x00	; 0
    137c:	a0 e0       	ldi	r26, 0x00	; 0
    137e:	b0 e8       	ldi	r27, 0x80	; 128
    1380:	e8 2a       	or	r14, r24
    1382:	f9 2a       	or	r15, r25
    1384:	0a 2b       	or	r16, r26
    1386:	1b 2b       	or	r17, r27
    1388:	76 95       	lsr	r23
    138a:	67 95       	ror	r22
    138c:	57 95       	ror	r21
    138e:	47 95       	ror	r20
    1390:	2f 5f       	subi	r18, 0xFF	; 255
    1392:	3f 4f       	sbci	r19, 0xFF	; 255
    1394:	77 fd       	sbrc	r23, 7
    1396:	e7 cf       	rjmp	.-50     	; 0x1366 <__mulsf3+0x140>
    1398:	0c c0       	rjmp	.+24     	; 0x13b2 <__mulsf3+0x18c>
    139a:	44 0f       	add	r20, r20
    139c:	55 1f       	adc	r21, r21
    139e:	66 1f       	adc	r22, r22
    13a0:	77 1f       	adc	r23, r23
    13a2:	17 fd       	sbrc	r17, 7
    13a4:	41 60       	ori	r20, 0x01	; 1
    13a6:	ee 0c       	add	r14, r14
    13a8:	ff 1c       	adc	r15, r15
    13aa:	00 1f       	adc	r16, r16
    13ac:	11 1f       	adc	r17, r17
    13ae:	21 50       	subi	r18, 0x01	; 1
    13b0:	30 40       	sbci	r19, 0x00	; 0
    13b2:	40 30       	cpi	r20, 0x00	; 0
    13b4:	90 e0       	ldi	r25, 0x00	; 0
    13b6:	59 07       	cpc	r21, r25
    13b8:	90 e0       	ldi	r25, 0x00	; 0
    13ba:	69 07       	cpc	r22, r25
    13bc:	90 e4       	ldi	r25, 0x40	; 64
    13be:	79 07       	cpc	r23, r25
    13c0:	60 f3       	brcs	.-40     	; 0x139a <__mulsf3+0x174>
    13c2:	2b 8f       	std	Y+27, r18	; 0x1b
    13c4:	3c 8f       	std	Y+28, r19	; 0x1c
    13c6:	db 01       	movw	r26, r22
    13c8:	ca 01       	movw	r24, r20
    13ca:	8f 77       	andi	r24, 0x7F	; 127
    13cc:	90 70       	andi	r25, 0x00	; 0
    13ce:	a0 70       	andi	r26, 0x00	; 0
    13d0:	b0 70       	andi	r27, 0x00	; 0
    13d2:	80 34       	cpi	r24, 0x40	; 64
    13d4:	91 05       	cpc	r25, r1
    13d6:	a1 05       	cpc	r26, r1
    13d8:	b1 05       	cpc	r27, r1
    13da:	61 f4       	brne	.+24     	; 0x13f4 <__mulsf3+0x1ce>
    13dc:	47 fd       	sbrc	r20, 7
    13de:	0a c0       	rjmp	.+20     	; 0x13f4 <__mulsf3+0x1ce>
    13e0:	e1 14       	cp	r14, r1
    13e2:	f1 04       	cpc	r15, r1
    13e4:	01 05       	cpc	r16, r1
    13e6:	11 05       	cpc	r17, r1
    13e8:	29 f0       	breq	.+10     	; 0x13f4 <__mulsf3+0x1ce>
    13ea:	40 5c       	subi	r20, 0xC0	; 192
    13ec:	5f 4f       	sbci	r21, 0xFF	; 255
    13ee:	6f 4f       	sbci	r22, 0xFF	; 255
    13f0:	7f 4f       	sbci	r23, 0xFF	; 255
    13f2:	40 78       	andi	r20, 0x80	; 128
    13f4:	1a 8e       	std	Y+26, r1	; 0x1a
    13f6:	fe 17       	cp	r31, r30
    13f8:	11 f0       	breq	.+4      	; 0x13fe <__mulsf3+0x1d8>
    13fa:	81 e0       	ldi	r24, 0x01	; 1
    13fc:	8a 8f       	std	Y+26, r24	; 0x1a
    13fe:	4d 8f       	std	Y+29, r20	; 0x1d
    1400:	5e 8f       	std	Y+30, r21	; 0x1e
    1402:	6f 8f       	std	Y+31, r22	; 0x1f
    1404:	78 a3       	std	Y+32, r23	; 0x20
    1406:	83 e0       	ldi	r24, 0x03	; 3
    1408:	89 8f       	std	Y+25, r24	; 0x19
    140a:	ce 01       	movw	r24, r28
    140c:	49 96       	adiw	r24, 0x19	; 25
    140e:	0e 94 9d 0b 	call	0x173a	; 0x173a <__pack_f>
    1412:	a0 96       	adiw	r28, 0x20	; 32
    1414:	e2 e1       	ldi	r30, 0x12	; 18
    1416:	0c 94 06 43 	jmp	0x860c	; 0x860c <__epilogue_restores__>

0000141a <__divsf3>:
    141a:	a8 e1       	ldi	r26, 0x18	; 24
    141c:	b0 e0       	ldi	r27, 0x00	; 0
    141e:	e3 e1       	ldi	r30, 0x13	; 19
    1420:	fa e0       	ldi	r31, 0x0A	; 10
    1422:	0c 94 f2 42 	jmp	0x85e4	; 0x85e4 <__prologue_saves__+0x10>
    1426:	69 83       	std	Y+1, r22	; 0x01
    1428:	7a 83       	std	Y+2, r23	; 0x02
    142a:	8b 83       	std	Y+3, r24	; 0x03
    142c:	9c 83       	std	Y+4, r25	; 0x04
    142e:	2d 83       	std	Y+5, r18	; 0x05
    1430:	3e 83       	std	Y+6, r19	; 0x06
    1432:	4f 83       	std	Y+7, r20	; 0x07
    1434:	58 87       	std	Y+8, r21	; 0x08
    1436:	b9 e0       	ldi	r27, 0x09	; 9
    1438:	eb 2e       	mov	r14, r27
    143a:	f1 2c       	mov	r15, r1
    143c:	ec 0e       	add	r14, r28
    143e:	fd 1e       	adc	r15, r29
    1440:	ce 01       	movw	r24, r28
    1442:	01 96       	adiw	r24, 0x01	; 1
    1444:	b7 01       	movw	r22, r14
    1446:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <__unpack_f>
    144a:	8e 01       	movw	r16, r28
    144c:	0f 5e       	subi	r16, 0xEF	; 239
    144e:	1f 4f       	sbci	r17, 0xFF	; 255
    1450:	ce 01       	movw	r24, r28
    1452:	05 96       	adiw	r24, 0x05	; 5
    1454:	b8 01       	movw	r22, r16
    1456:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <__unpack_f>
    145a:	29 85       	ldd	r18, Y+9	; 0x09
    145c:	22 30       	cpi	r18, 0x02	; 2
    145e:	08 f4       	brcc	.+2      	; 0x1462 <__divsf3+0x48>
    1460:	7e c0       	rjmp	.+252    	; 0x155e <__divsf3+0x144>
    1462:	39 89       	ldd	r19, Y+17	; 0x11
    1464:	32 30       	cpi	r19, 0x02	; 2
    1466:	10 f4       	brcc	.+4      	; 0x146c <__divsf3+0x52>
    1468:	b8 01       	movw	r22, r16
    146a:	7c c0       	rjmp	.+248    	; 0x1564 <__divsf3+0x14a>
    146c:	8a 85       	ldd	r24, Y+10	; 0x0a
    146e:	9a 89       	ldd	r25, Y+18	; 0x12
    1470:	89 27       	eor	r24, r25
    1472:	8a 87       	std	Y+10, r24	; 0x0a
    1474:	24 30       	cpi	r18, 0x04	; 4
    1476:	11 f0       	breq	.+4      	; 0x147c <__divsf3+0x62>
    1478:	22 30       	cpi	r18, 0x02	; 2
    147a:	31 f4       	brne	.+12     	; 0x1488 <__divsf3+0x6e>
    147c:	23 17       	cp	r18, r19
    147e:	09 f0       	breq	.+2      	; 0x1482 <__divsf3+0x68>
    1480:	6e c0       	rjmp	.+220    	; 0x155e <__divsf3+0x144>
    1482:	6c e6       	ldi	r22, 0x6C	; 108
    1484:	70 e0       	ldi	r23, 0x00	; 0
    1486:	6e c0       	rjmp	.+220    	; 0x1564 <__divsf3+0x14a>
    1488:	34 30       	cpi	r19, 0x04	; 4
    148a:	39 f4       	brne	.+14     	; 0x149a <__divsf3+0x80>
    148c:	1d 86       	std	Y+13, r1	; 0x0d
    148e:	1e 86       	std	Y+14, r1	; 0x0e
    1490:	1f 86       	std	Y+15, r1	; 0x0f
    1492:	18 8a       	std	Y+16, r1	; 0x10
    1494:	1c 86       	std	Y+12, r1	; 0x0c
    1496:	1b 86       	std	Y+11, r1	; 0x0b
    1498:	04 c0       	rjmp	.+8      	; 0x14a2 <__divsf3+0x88>
    149a:	32 30       	cpi	r19, 0x02	; 2
    149c:	21 f4       	brne	.+8      	; 0x14a6 <__divsf3+0x8c>
    149e:	84 e0       	ldi	r24, 0x04	; 4
    14a0:	89 87       	std	Y+9, r24	; 0x09
    14a2:	b7 01       	movw	r22, r14
    14a4:	5f c0       	rjmp	.+190    	; 0x1564 <__divsf3+0x14a>
    14a6:	2b 85       	ldd	r18, Y+11	; 0x0b
    14a8:	3c 85       	ldd	r19, Y+12	; 0x0c
    14aa:	8b 89       	ldd	r24, Y+19	; 0x13
    14ac:	9c 89       	ldd	r25, Y+20	; 0x14
    14ae:	28 1b       	sub	r18, r24
    14b0:	39 0b       	sbc	r19, r25
    14b2:	3c 87       	std	Y+12, r19	; 0x0c
    14b4:	2b 87       	std	Y+11, r18	; 0x0b
    14b6:	ed 84       	ldd	r14, Y+13	; 0x0d
    14b8:	fe 84       	ldd	r15, Y+14	; 0x0e
    14ba:	0f 85       	ldd	r16, Y+15	; 0x0f
    14bc:	18 89       	ldd	r17, Y+16	; 0x10
    14be:	ad 88       	ldd	r10, Y+21	; 0x15
    14c0:	be 88       	ldd	r11, Y+22	; 0x16
    14c2:	cf 88       	ldd	r12, Y+23	; 0x17
    14c4:	d8 8c       	ldd	r13, Y+24	; 0x18
    14c6:	ea 14       	cp	r14, r10
    14c8:	fb 04       	cpc	r15, r11
    14ca:	0c 05       	cpc	r16, r12
    14cc:	1d 05       	cpc	r17, r13
    14ce:	40 f4       	brcc	.+16     	; 0x14e0 <__divsf3+0xc6>
    14d0:	ee 0c       	add	r14, r14
    14d2:	ff 1c       	adc	r15, r15
    14d4:	00 1f       	adc	r16, r16
    14d6:	11 1f       	adc	r17, r17
    14d8:	21 50       	subi	r18, 0x01	; 1
    14da:	30 40       	sbci	r19, 0x00	; 0
    14dc:	3c 87       	std	Y+12, r19	; 0x0c
    14de:	2b 87       	std	Y+11, r18	; 0x0b
    14e0:	20 e0       	ldi	r18, 0x00	; 0
    14e2:	30 e0       	ldi	r19, 0x00	; 0
    14e4:	40 e0       	ldi	r20, 0x00	; 0
    14e6:	50 e0       	ldi	r21, 0x00	; 0
    14e8:	80 e0       	ldi	r24, 0x00	; 0
    14ea:	90 e0       	ldi	r25, 0x00	; 0
    14ec:	a0 e0       	ldi	r26, 0x00	; 0
    14ee:	b0 e4       	ldi	r27, 0x40	; 64
    14f0:	60 e0       	ldi	r22, 0x00	; 0
    14f2:	70 e0       	ldi	r23, 0x00	; 0
    14f4:	ea 14       	cp	r14, r10
    14f6:	fb 04       	cpc	r15, r11
    14f8:	0c 05       	cpc	r16, r12
    14fa:	1d 05       	cpc	r17, r13
    14fc:	40 f0       	brcs	.+16     	; 0x150e <__divsf3+0xf4>
    14fe:	28 2b       	or	r18, r24
    1500:	39 2b       	or	r19, r25
    1502:	4a 2b       	or	r20, r26
    1504:	5b 2b       	or	r21, r27
    1506:	ea 18       	sub	r14, r10
    1508:	fb 08       	sbc	r15, r11
    150a:	0c 09       	sbc	r16, r12
    150c:	1d 09       	sbc	r17, r13
    150e:	b6 95       	lsr	r27
    1510:	a7 95       	ror	r26
    1512:	97 95       	ror	r25
    1514:	87 95       	ror	r24
    1516:	ee 0c       	add	r14, r14
    1518:	ff 1c       	adc	r15, r15
    151a:	00 1f       	adc	r16, r16
    151c:	11 1f       	adc	r17, r17
    151e:	6f 5f       	subi	r22, 0xFF	; 255
    1520:	7f 4f       	sbci	r23, 0xFF	; 255
    1522:	6f 31       	cpi	r22, 0x1F	; 31
    1524:	71 05       	cpc	r23, r1
    1526:	31 f7       	brne	.-52     	; 0x14f4 <__divsf3+0xda>
    1528:	da 01       	movw	r26, r20
    152a:	c9 01       	movw	r24, r18
    152c:	8f 77       	andi	r24, 0x7F	; 127
    152e:	90 70       	andi	r25, 0x00	; 0
    1530:	a0 70       	andi	r26, 0x00	; 0
    1532:	b0 70       	andi	r27, 0x00	; 0
    1534:	80 34       	cpi	r24, 0x40	; 64
    1536:	91 05       	cpc	r25, r1
    1538:	a1 05       	cpc	r26, r1
    153a:	b1 05       	cpc	r27, r1
    153c:	61 f4       	brne	.+24     	; 0x1556 <__divsf3+0x13c>
    153e:	27 fd       	sbrc	r18, 7
    1540:	0a c0       	rjmp	.+20     	; 0x1556 <__divsf3+0x13c>
    1542:	e1 14       	cp	r14, r1
    1544:	f1 04       	cpc	r15, r1
    1546:	01 05       	cpc	r16, r1
    1548:	11 05       	cpc	r17, r1
    154a:	29 f0       	breq	.+10     	; 0x1556 <__divsf3+0x13c>
    154c:	20 5c       	subi	r18, 0xC0	; 192
    154e:	3f 4f       	sbci	r19, 0xFF	; 255
    1550:	4f 4f       	sbci	r20, 0xFF	; 255
    1552:	5f 4f       	sbci	r21, 0xFF	; 255
    1554:	20 78       	andi	r18, 0x80	; 128
    1556:	2d 87       	std	Y+13, r18	; 0x0d
    1558:	3e 87       	std	Y+14, r19	; 0x0e
    155a:	4f 87       	std	Y+15, r20	; 0x0f
    155c:	58 8b       	std	Y+16, r21	; 0x10
    155e:	be 01       	movw	r22, r28
    1560:	67 5f       	subi	r22, 0xF7	; 247
    1562:	7f 4f       	sbci	r23, 0xFF	; 255
    1564:	cb 01       	movw	r24, r22
    1566:	0e 94 9d 0b 	call	0x173a	; 0x173a <__pack_f>
    156a:	68 96       	adiw	r28, 0x18	; 24
    156c:	ea e0       	ldi	r30, 0x0A	; 10
    156e:	0c 94 0e 43 	jmp	0x861c	; 0x861c <__epilogue_restores__+0x10>

00001572 <__gtsf2>:
    1572:	a8 e1       	ldi	r26, 0x18	; 24
    1574:	b0 e0       	ldi	r27, 0x00	; 0
    1576:	ef eb       	ldi	r30, 0xBF	; 191
    1578:	fa e0       	ldi	r31, 0x0A	; 10
    157a:	0c 94 f6 42 	jmp	0x85ec	; 0x85ec <__prologue_saves__+0x18>
    157e:	69 83       	std	Y+1, r22	; 0x01
    1580:	7a 83       	std	Y+2, r23	; 0x02
    1582:	8b 83       	std	Y+3, r24	; 0x03
    1584:	9c 83       	std	Y+4, r25	; 0x04
    1586:	2d 83       	std	Y+5, r18	; 0x05
    1588:	3e 83       	std	Y+6, r19	; 0x06
    158a:	4f 83       	std	Y+7, r20	; 0x07
    158c:	58 87       	std	Y+8, r21	; 0x08
    158e:	89 e0       	ldi	r24, 0x09	; 9
    1590:	e8 2e       	mov	r14, r24
    1592:	f1 2c       	mov	r15, r1
    1594:	ec 0e       	add	r14, r28
    1596:	fd 1e       	adc	r15, r29
    1598:	ce 01       	movw	r24, r28
    159a:	01 96       	adiw	r24, 0x01	; 1
    159c:	b7 01       	movw	r22, r14
    159e:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <__unpack_f>
    15a2:	8e 01       	movw	r16, r28
    15a4:	0f 5e       	subi	r16, 0xEF	; 239
    15a6:	1f 4f       	sbci	r17, 0xFF	; 255
    15a8:	ce 01       	movw	r24, r28
    15aa:	05 96       	adiw	r24, 0x05	; 5
    15ac:	b8 01       	movw	r22, r16
    15ae:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <__unpack_f>
    15b2:	89 85       	ldd	r24, Y+9	; 0x09
    15b4:	82 30       	cpi	r24, 0x02	; 2
    15b6:	40 f0       	brcs	.+16     	; 0x15c8 <__gtsf2+0x56>
    15b8:	89 89       	ldd	r24, Y+17	; 0x11
    15ba:	82 30       	cpi	r24, 0x02	; 2
    15bc:	28 f0       	brcs	.+10     	; 0x15c8 <__gtsf2+0x56>
    15be:	c7 01       	movw	r24, r14
    15c0:	b8 01       	movw	r22, r16
    15c2:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <__fpcmp_parts_f>
    15c6:	01 c0       	rjmp	.+2      	; 0x15ca <__gtsf2+0x58>
    15c8:	8f ef       	ldi	r24, 0xFF	; 255
    15ca:	68 96       	adiw	r28, 0x18	; 24
    15cc:	e6 e0       	ldi	r30, 0x06	; 6
    15ce:	0c 94 12 43 	jmp	0x8624	; 0x8624 <__epilogue_restores__+0x18>

000015d2 <__gesf2>:
    15d2:	a8 e1       	ldi	r26, 0x18	; 24
    15d4:	b0 e0       	ldi	r27, 0x00	; 0
    15d6:	ef ee       	ldi	r30, 0xEF	; 239
    15d8:	fa e0       	ldi	r31, 0x0A	; 10
    15da:	0c 94 f6 42 	jmp	0x85ec	; 0x85ec <__prologue_saves__+0x18>
    15de:	69 83       	std	Y+1, r22	; 0x01
    15e0:	7a 83       	std	Y+2, r23	; 0x02
    15e2:	8b 83       	std	Y+3, r24	; 0x03
    15e4:	9c 83       	std	Y+4, r25	; 0x04
    15e6:	2d 83       	std	Y+5, r18	; 0x05
    15e8:	3e 83       	std	Y+6, r19	; 0x06
    15ea:	4f 83       	std	Y+7, r20	; 0x07
    15ec:	58 87       	std	Y+8, r21	; 0x08
    15ee:	89 e0       	ldi	r24, 0x09	; 9
    15f0:	e8 2e       	mov	r14, r24
    15f2:	f1 2c       	mov	r15, r1
    15f4:	ec 0e       	add	r14, r28
    15f6:	fd 1e       	adc	r15, r29
    15f8:	ce 01       	movw	r24, r28
    15fa:	01 96       	adiw	r24, 0x01	; 1
    15fc:	b7 01       	movw	r22, r14
    15fe:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <__unpack_f>
    1602:	8e 01       	movw	r16, r28
    1604:	0f 5e       	subi	r16, 0xEF	; 239
    1606:	1f 4f       	sbci	r17, 0xFF	; 255
    1608:	ce 01       	movw	r24, r28
    160a:	05 96       	adiw	r24, 0x05	; 5
    160c:	b8 01       	movw	r22, r16
    160e:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <__unpack_f>
    1612:	89 85       	ldd	r24, Y+9	; 0x09
    1614:	82 30       	cpi	r24, 0x02	; 2
    1616:	40 f0       	brcs	.+16     	; 0x1628 <__gesf2+0x56>
    1618:	89 89       	ldd	r24, Y+17	; 0x11
    161a:	82 30       	cpi	r24, 0x02	; 2
    161c:	28 f0       	brcs	.+10     	; 0x1628 <__gesf2+0x56>
    161e:	c7 01       	movw	r24, r14
    1620:	b8 01       	movw	r22, r16
    1622:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <__fpcmp_parts_f>
    1626:	01 c0       	rjmp	.+2      	; 0x162a <__gesf2+0x58>
    1628:	8f ef       	ldi	r24, 0xFF	; 255
    162a:	68 96       	adiw	r28, 0x18	; 24
    162c:	e6 e0       	ldi	r30, 0x06	; 6
    162e:	0c 94 12 43 	jmp	0x8624	; 0x8624 <__epilogue_restores__+0x18>

00001632 <__ltsf2>:
    1632:	a8 e1       	ldi	r26, 0x18	; 24
    1634:	b0 e0       	ldi	r27, 0x00	; 0
    1636:	ef e1       	ldi	r30, 0x1F	; 31
    1638:	fb e0       	ldi	r31, 0x0B	; 11
    163a:	0c 94 f6 42 	jmp	0x85ec	; 0x85ec <__prologue_saves__+0x18>
    163e:	69 83       	std	Y+1, r22	; 0x01
    1640:	7a 83       	std	Y+2, r23	; 0x02
    1642:	8b 83       	std	Y+3, r24	; 0x03
    1644:	9c 83       	std	Y+4, r25	; 0x04
    1646:	2d 83       	std	Y+5, r18	; 0x05
    1648:	3e 83       	std	Y+6, r19	; 0x06
    164a:	4f 83       	std	Y+7, r20	; 0x07
    164c:	58 87       	std	Y+8, r21	; 0x08
    164e:	89 e0       	ldi	r24, 0x09	; 9
    1650:	e8 2e       	mov	r14, r24
    1652:	f1 2c       	mov	r15, r1
    1654:	ec 0e       	add	r14, r28
    1656:	fd 1e       	adc	r15, r29
    1658:	ce 01       	movw	r24, r28
    165a:	01 96       	adiw	r24, 0x01	; 1
    165c:	b7 01       	movw	r22, r14
    165e:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <__unpack_f>
    1662:	8e 01       	movw	r16, r28
    1664:	0f 5e       	subi	r16, 0xEF	; 239
    1666:	1f 4f       	sbci	r17, 0xFF	; 255
    1668:	ce 01       	movw	r24, r28
    166a:	05 96       	adiw	r24, 0x05	; 5
    166c:	b8 01       	movw	r22, r16
    166e:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <__unpack_f>
    1672:	89 85       	ldd	r24, Y+9	; 0x09
    1674:	82 30       	cpi	r24, 0x02	; 2
    1676:	40 f0       	brcs	.+16     	; 0x1688 <__ltsf2+0x56>
    1678:	89 89       	ldd	r24, Y+17	; 0x11
    167a:	82 30       	cpi	r24, 0x02	; 2
    167c:	28 f0       	brcs	.+10     	; 0x1688 <__ltsf2+0x56>
    167e:	c7 01       	movw	r24, r14
    1680:	b8 01       	movw	r22, r16
    1682:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <__fpcmp_parts_f>
    1686:	01 c0       	rjmp	.+2      	; 0x168a <__ltsf2+0x58>
    1688:	81 e0       	ldi	r24, 0x01	; 1
    168a:	68 96       	adiw	r28, 0x18	; 24
    168c:	e6 e0       	ldi	r30, 0x06	; 6
    168e:	0c 94 12 43 	jmp	0x8624	; 0x8624 <__epilogue_restores__+0x18>

00001692 <__fixsfsi>:
    1692:	ac e0       	ldi	r26, 0x0C	; 12
    1694:	b0 e0       	ldi	r27, 0x00	; 0
    1696:	ef e4       	ldi	r30, 0x4F	; 79
    1698:	fb e0       	ldi	r31, 0x0B	; 11
    169a:	0c 94 fa 42 	jmp	0x85f4	; 0x85f4 <__prologue_saves__+0x20>
    169e:	69 83       	std	Y+1, r22	; 0x01
    16a0:	7a 83       	std	Y+2, r23	; 0x02
    16a2:	8b 83       	std	Y+3, r24	; 0x03
    16a4:	9c 83       	std	Y+4, r25	; 0x04
    16a6:	ce 01       	movw	r24, r28
    16a8:	01 96       	adiw	r24, 0x01	; 1
    16aa:	be 01       	movw	r22, r28
    16ac:	6b 5f       	subi	r22, 0xFB	; 251
    16ae:	7f 4f       	sbci	r23, 0xFF	; 255
    16b0:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <__unpack_f>
    16b4:	8d 81       	ldd	r24, Y+5	; 0x05
    16b6:	82 30       	cpi	r24, 0x02	; 2
    16b8:	61 f1       	breq	.+88     	; 0x1712 <__fixsfsi+0x80>
    16ba:	82 30       	cpi	r24, 0x02	; 2
    16bc:	50 f1       	brcs	.+84     	; 0x1712 <__fixsfsi+0x80>
    16be:	84 30       	cpi	r24, 0x04	; 4
    16c0:	21 f4       	brne	.+8      	; 0x16ca <__fixsfsi+0x38>
    16c2:	8e 81       	ldd	r24, Y+6	; 0x06
    16c4:	88 23       	and	r24, r24
    16c6:	51 f1       	breq	.+84     	; 0x171c <__fixsfsi+0x8a>
    16c8:	2e c0       	rjmp	.+92     	; 0x1726 <__fixsfsi+0x94>
    16ca:	2f 81       	ldd	r18, Y+7	; 0x07
    16cc:	38 85       	ldd	r19, Y+8	; 0x08
    16ce:	37 fd       	sbrc	r19, 7
    16d0:	20 c0       	rjmp	.+64     	; 0x1712 <__fixsfsi+0x80>
    16d2:	6e 81       	ldd	r22, Y+6	; 0x06
    16d4:	2f 31       	cpi	r18, 0x1F	; 31
    16d6:	31 05       	cpc	r19, r1
    16d8:	1c f0       	brlt	.+6      	; 0x16e0 <__fixsfsi+0x4e>
    16da:	66 23       	and	r22, r22
    16dc:	f9 f0       	breq	.+62     	; 0x171c <__fixsfsi+0x8a>
    16de:	23 c0       	rjmp	.+70     	; 0x1726 <__fixsfsi+0x94>
    16e0:	8e e1       	ldi	r24, 0x1E	; 30
    16e2:	90 e0       	ldi	r25, 0x00	; 0
    16e4:	82 1b       	sub	r24, r18
    16e6:	93 0b       	sbc	r25, r19
    16e8:	29 85       	ldd	r18, Y+9	; 0x09
    16ea:	3a 85       	ldd	r19, Y+10	; 0x0a
    16ec:	4b 85       	ldd	r20, Y+11	; 0x0b
    16ee:	5c 85       	ldd	r21, Y+12	; 0x0c
    16f0:	04 c0       	rjmp	.+8      	; 0x16fa <__fixsfsi+0x68>
    16f2:	56 95       	lsr	r21
    16f4:	47 95       	ror	r20
    16f6:	37 95       	ror	r19
    16f8:	27 95       	ror	r18
    16fa:	8a 95       	dec	r24
    16fc:	d2 f7       	brpl	.-12     	; 0x16f2 <__fixsfsi+0x60>
    16fe:	66 23       	and	r22, r22
    1700:	b1 f0       	breq	.+44     	; 0x172e <__fixsfsi+0x9c>
    1702:	50 95       	com	r21
    1704:	40 95       	com	r20
    1706:	30 95       	com	r19
    1708:	21 95       	neg	r18
    170a:	3f 4f       	sbci	r19, 0xFF	; 255
    170c:	4f 4f       	sbci	r20, 0xFF	; 255
    170e:	5f 4f       	sbci	r21, 0xFF	; 255
    1710:	0e c0       	rjmp	.+28     	; 0x172e <__fixsfsi+0x9c>
    1712:	20 e0       	ldi	r18, 0x00	; 0
    1714:	30 e0       	ldi	r19, 0x00	; 0
    1716:	40 e0       	ldi	r20, 0x00	; 0
    1718:	50 e0       	ldi	r21, 0x00	; 0
    171a:	09 c0       	rjmp	.+18     	; 0x172e <__fixsfsi+0x9c>
    171c:	2f ef       	ldi	r18, 0xFF	; 255
    171e:	3f ef       	ldi	r19, 0xFF	; 255
    1720:	4f ef       	ldi	r20, 0xFF	; 255
    1722:	5f e7       	ldi	r21, 0x7F	; 127
    1724:	04 c0       	rjmp	.+8      	; 0x172e <__fixsfsi+0x9c>
    1726:	20 e0       	ldi	r18, 0x00	; 0
    1728:	30 e0       	ldi	r19, 0x00	; 0
    172a:	40 e0       	ldi	r20, 0x00	; 0
    172c:	50 e8       	ldi	r21, 0x80	; 128
    172e:	b9 01       	movw	r22, r18
    1730:	ca 01       	movw	r24, r20
    1732:	2c 96       	adiw	r28, 0x0c	; 12
    1734:	e2 e0       	ldi	r30, 0x02	; 2
    1736:	0c 94 16 43 	jmp	0x862c	; 0x862c <__epilogue_restores__+0x20>

0000173a <__pack_f>:
    173a:	df 92       	push	r13
    173c:	ef 92       	push	r14
    173e:	ff 92       	push	r15
    1740:	0f 93       	push	r16
    1742:	1f 93       	push	r17
    1744:	fc 01       	movw	r30, r24
    1746:	e4 80       	ldd	r14, Z+4	; 0x04
    1748:	f5 80       	ldd	r15, Z+5	; 0x05
    174a:	06 81       	ldd	r16, Z+6	; 0x06
    174c:	17 81       	ldd	r17, Z+7	; 0x07
    174e:	d1 80       	ldd	r13, Z+1	; 0x01
    1750:	80 81       	ld	r24, Z
    1752:	82 30       	cpi	r24, 0x02	; 2
    1754:	48 f4       	brcc	.+18     	; 0x1768 <__pack_f+0x2e>
    1756:	80 e0       	ldi	r24, 0x00	; 0
    1758:	90 e0       	ldi	r25, 0x00	; 0
    175a:	a0 e1       	ldi	r26, 0x10	; 16
    175c:	b0 e0       	ldi	r27, 0x00	; 0
    175e:	e8 2a       	or	r14, r24
    1760:	f9 2a       	or	r15, r25
    1762:	0a 2b       	or	r16, r26
    1764:	1b 2b       	or	r17, r27
    1766:	a5 c0       	rjmp	.+330    	; 0x18b2 <__pack_f+0x178>
    1768:	84 30       	cpi	r24, 0x04	; 4
    176a:	09 f4       	brne	.+2      	; 0x176e <__pack_f+0x34>
    176c:	9f c0       	rjmp	.+318    	; 0x18ac <__pack_f+0x172>
    176e:	82 30       	cpi	r24, 0x02	; 2
    1770:	21 f4       	brne	.+8      	; 0x177a <__pack_f+0x40>
    1772:	ee 24       	eor	r14, r14
    1774:	ff 24       	eor	r15, r15
    1776:	87 01       	movw	r16, r14
    1778:	05 c0       	rjmp	.+10     	; 0x1784 <__pack_f+0x4a>
    177a:	e1 14       	cp	r14, r1
    177c:	f1 04       	cpc	r15, r1
    177e:	01 05       	cpc	r16, r1
    1780:	11 05       	cpc	r17, r1
    1782:	19 f4       	brne	.+6      	; 0x178a <__pack_f+0x50>
    1784:	e0 e0       	ldi	r30, 0x00	; 0
    1786:	f0 e0       	ldi	r31, 0x00	; 0
    1788:	96 c0       	rjmp	.+300    	; 0x18b6 <__pack_f+0x17c>
    178a:	62 81       	ldd	r22, Z+2	; 0x02
    178c:	73 81       	ldd	r23, Z+3	; 0x03
    178e:	9f ef       	ldi	r25, 0xFF	; 255
    1790:	62 38       	cpi	r22, 0x82	; 130
    1792:	79 07       	cpc	r23, r25
    1794:	0c f0       	brlt	.+2      	; 0x1798 <__pack_f+0x5e>
    1796:	5b c0       	rjmp	.+182    	; 0x184e <__pack_f+0x114>
    1798:	22 e8       	ldi	r18, 0x82	; 130
    179a:	3f ef       	ldi	r19, 0xFF	; 255
    179c:	26 1b       	sub	r18, r22
    179e:	37 0b       	sbc	r19, r23
    17a0:	2a 31       	cpi	r18, 0x1A	; 26
    17a2:	31 05       	cpc	r19, r1
    17a4:	2c f0       	brlt	.+10     	; 0x17b0 <__pack_f+0x76>
    17a6:	20 e0       	ldi	r18, 0x00	; 0
    17a8:	30 e0       	ldi	r19, 0x00	; 0
    17aa:	40 e0       	ldi	r20, 0x00	; 0
    17ac:	50 e0       	ldi	r21, 0x00	; 0
    17ae:	2a c0       	rjmp	.+84     	; 0x1804 <__pack_f+0xca>
    17b0:	b8 01       	movw	r22, r16
    17b2:	a7 01       	movw	r20, r14
    17b4:	02 2e       	mov	r0, r18
    17b6:	04 c0       	rjmp	.+8      	; 0x17c0 <__pack_f+0x86>
    17b8:	76 95       	lsr	r23
    17ba:	67 95       	ror	r22
    17bc:	57 95       	ror	r21
    17be:	47 95       	ror	r20
    17c0:	0a 94       	dec	r0
    17c2:	d2 f7       	brpl	.-12     	; 0x17b8 <__pack_f+0x7e>
    17c4:	81 e0       	ldi	r24, 0x01	; 1
    17c6:	90 e0       	ldi	r25, 0x00	; 0
    17c8:	a0 e0       	ldi	r26, 0x00	; 0
    17ca:	b0 e0       	ldi	r27, 0x00	; 0
    17cc:	04 c0       	rjmp	.+8      	; 0x17d6 <__pack_f+0x9c>
    17ce:	88 0f       	add	r24, r24
    17d0:	99 1f       	adc	r25, r25
    17d2:	aa 1f       	adc	r26, r26
    17d4:	bb 1f       	adc	r27, r27
    17d6:	2a 95       	dec	r18
    17d8:	d2 f7       	brpl	.-12     	; 0x17ce <__pack_f+0x94>
    17da:	01 97       	sbiw	r24, 0x01	; 1
    17dc:	a1 09       	sbc	r26, r1
    17de:	b1 09       	sbc	r27, r1
    17e0:	8e 21       	and	r24, r14
    17e2:	9f 21       	and	r25, r15
    17e4:	a0 23       	and	r26, r16
    17e6:	b1 23       	and	r27, r17
    17e8:	00 97       	sbiw	r24, 0x00	; 0
    17ea:	a1 05       	cpc	r26, r1
    17ec:	b1 05       	cpc	r27, r1
    17ee:	21 f0       	breq	.+8      	; 0x17f8 <__pack_f+0xbe>
    17f0:	81 e0       	ldi	r24, 0x01	; 1
    17f2:	90 e0       	ldi	r25, 0x00	; 0
    17f4:	a0 e0       	ldi	r26, 0x00	; 0
    17f6:	b0 e0       	ldi	r27, 0x00	; 0
    17f8:	9a 01       	movw	r18, r20
    17fa:	ab 01       	movw	r20, r22
    17fc:	28 2b       	or	r18, r24
    17fe:	39 2b       	or	r19, r25
    1800:	4a 2b       	or	r20, r26
    1802:	5b 2b       	or	r21, r27
    1804:	da 01       	movw	r26, r20
    1806:	c9 01       	movw	r24, r18
    1808:	8f 77       	andi	r24, 0x7F	; 127
    180a:	90 70       	andi	r25, 0x00	; 0
    180c:	a0 70       	andi	r26, 0x00	; 0
    180e:	b0 70       	andi	r27, 0x00	; 0
    1810:	80 34       	cpi	r24, 0x40	; 64
    1812:	91 05       	cpc	r25, r1
    1814:	a1 05       	cpc	r26, r1
    1816:	b1 05       	cpc	r27, r1
    1818:	39 f4       	brne	.+14     	; 0x1828 <__pack_f+0xee>
    181a:	27 ff       	sbrs	r18, 7
    181c:	09 c0       	rjmp	.+18     	; 0x1830 <__pack_f+0xf6>
    181e:	20 5c       	subi	r18, 0xC0	; 192
    1820:	3f 4f       	sbci	r19, 0xFF	; 255
    1822:	4f 4f       	sbci	r20, 0xFF	; 255
    1824:	5f 4f       	sbci	r21, 0xFF	; 255
    1826:	04 c0       	rjmp	.+8      	; 0x1830 <__pack_f+0xf6>
    1828:	21 5c       	subi	r18, 0xC1	; 193
    182a:	3f 4f       	sbci	r19, 0xFF	; 255
    182c:	4f 4f       	sbci	r20, 0xFF	; 255
    182e:	5f 4f       	sbci	r21, 0xFF	; 255
    1830:	e0 e0       	ldi	r30, 0x00	; 0
    1832:	f0 e0       	ldi	r31, 0x00	; 0
    1834:	20 30       	cpi	r18, 0x00	; 0
    1836:	a0 e0       	ldi	r26, 0x00	; 0
    1838:	3a 07       	cpc	r19, r26
    183a:	a0 e0       	ldi	r26, 0x00	; 0
    183c:	4a 07       	cpc	r20, r26
    183e:	a0 e4       	ldi	r26, 0x40	; 64
    1840:	5a 07       	cpc	r21, r26
    1842:	10 f0       	brcs	.+4      	; 0x1848 <__pack_f+0x10e>
    1844:	e1 e0       	ldi	r30, 0x01	; 1
    1846:	f0 e0       	ldi	r31, 0x00	; 0
    1848:	79 01       	movw	r14, r18
    184a:	8a 01       	movw	r16, r20
    184c:	27 c0       	rjmp	.+78     	; 0x189c <__pack_f+0x162>
    184e:	60 38       	cpi	r22, 0x80	; 128
    1850:	71 05       	cpc	r23, r1
    1852:	64 f5       	brge	.+88     	; 0x18ac <__pack_f+0x172>
    1854:	fb 01       	movw	r30, r22
    1856:	e1 58       	subi	r30, 0x81	; 129
    1858:	ff 4f       	sbci	r31, 0xFF	; 255
    185a:	d8 01       	movw	r26, r16
    185c:	c7 01       	movw	r24, r14
    185e:	8f 77       	andi	r24, 0x7F	; 127
    1860:	90 70       	andi	r25, 0x00	; 0
    1862:	a0 70       	andi	r26, 0x00	; 0
    1864:	b0 70       	andi	r27, 0x00	; 0
    1866:	80 34       	cpi	r24, 0x40	; 64
    1868:	91 05       	cpc	r25, r1
    186a:	a1 05       	cpc	r26, r1
    186c:	b1 05       	cpc	r27, r1
    186e:	39 f4       	brne	.+14     	; 0x187e <__pack_f+0x144>
    1870:	e7 fe       	sbrs	r14, 7
    1872:	0d c0       	rjmp	.+26     	; 0x188e <__pack_f+0x154>
    1874:	80 e4       	ldi	r24, 0x40	; 64
    1876:	90 e0       	ldi	r25, 0x00	; 0
    1878:	a0 e0       	ldi	r26, 0x00	; 0
    187a:	b0 e0       	ldi	r27, 0x00	; 0
    187c:	04 c0       	rjmp	.+8      	; 0x1886 <__pack_f+0x14c>
    187e:	8f e3       	ldi	r24, 0x3F	; 63
    1880:	90 e0       	ldi	r25, 0x00	; 0
    1882:	a0 e0       	ldi	r26, 0x00	; 0
    1884:	b0 e0       	ldi	r27, 0x00	; 0
    1886:	e8 0e       	add	r14, r24
    1888:	f9 1e       	adc	r15, r25
    188a:	0a 1f       	adc	r16, r26
    188c:	1b 1f       	adc	r17, r27
    188e:	17 ff       	sbrs	r17, 7
    1890:	05 c0       	rjmp	.+10     	; 0x189c <__pack_f+0x162>
    1892:	16 95       	lsr	r17
    1894:	07 95       	ror	r16
    1896:	f7 94       	ror	r15
    1898:	e7 94       	ror	r14
    189a:	31 96       	adiw	r30, 0x01	; 1
    189c:	87 e0       	ldi	r24, 0x07	; 7
    189e:	16 95       	lsr	r17
    18a0:	07 95       	ror	r16
    18a2:	f7 94       	ror	r15
    18a4:	e7 94       	ror	r14
    18a6:	8a 95       	dec	r24
    18a8:	d1 f7       	brne	.-12     	; 0x189e <__pack_f+0x164>
    18aa:	05 c0       	rjmp	.+10     	; 0x18b6 <__pack_f+0x17c>
    18ac:	ee 24       	eor	r14, r14
    18ae:	ff 24       	eor	r15, r15
    18b0:	87 01       	movw	r16, r14
    18b2:	ef ef       	ldi	r30, 0xFF	; 255
    18b4:	f0 e0       	ldi	r31, 0x00	; 0
    18b6:	6e 2f       	mov	r22, r30
    18b8:	67 95       	ror	r22
    18ba:	66 27       	eor	r22, r22
    18bc:	67 95       	ror	r22
    18be:	90 2f       	mov	r25, r16
    18c0:	9f 77       	andi	r25, 0x7F	; 127
    18c2:	d7 94       	ror	r13
    18c4:	dd 24       	eor	r13, r13
    18c6:	d7 94       	ror	r13
    18c8:	8e 2f       	mov	r24, r30
    18ca:	86 95       	lsr	r24
    18cc:	49 2f       	mov	r20, r25
    18ce:	46 2b       	or	r20, r22
    18d0:	58 2f       	mov	r21, r24
    18d2:	5d 29       	or	r21, r13
    18d4:	b7 01       	movw	r22, r14
    18d6:	ca 01       	movw	r24, r20
    18d8:	1f 91       	pop	r17
    18da:	0f 91       	pop	r16
    18dc:	ff 90       	pop	r15
    18de:	ef 90       	pop	r14
    18e0:	df 90       	pop	r13
    18e2:	08 95       	ret

000018e4 <__unpack_f>:
    18e4:	fc 01       	movw	r30, r24
    18e6:	db 01       	movw	r26, r22
    18e8:	40 81       	ld	r20, Z
    18ea:	51 81       	ldd	r21, Z+1	; 0x01
    18ec:	22 81       	ldd	r18, Z+2	; 0x02
    18ee:	62 2f       	mov	r22, r18
    18f0:	6f 77       	andi	r22, 0x7F	; 127
    18f2:	70 e0       	ldi	r23, 0x00	; 0
    18f4:	22 1f       	adc	r18, r18
    18f6:	22 27       	eor	r18, r18
    18f8:	22 1f       	adc	r18, r18
    18fa:	93 81       	ldd	r25, Z+3	; 0x03
    18fc:	89 2f       	mov	r24, r25
    18fe:	88 0f       	add	r24, r24
    1900:	82 2b       	or	r24, r18
    1902:	28 2f       	mov	r18, r24
    1904:	30 e0       	ldi	r19, 0x00	; 0
    1906:	99 1f       	adc	r25, r25
    1908:	99 27       	eor	r25, r25
    190a:	99 1f       	adc	r25, r25
    190c:	11 96       	adiw	r26, 0x01	; 1
    190e:	9c 93       	st	X, r25
    1910:	11 97       	sbiw	r26, 0x01	; 1
    1912:	21 15       	cp	r18, r1
    1914:	31 05       	cpc	r19, r1
    1916:	a9 f5       	brne	.+106    	; 0x1982 <__unpack_f+0x9e>
    1918:	41 15       	cp	r20, r1
    191a:	51 05       	cpc	r21, r1
    191c:	61 05       	cpc	r22, r1
    191e:	71 05       	cpc	r23, r1
    1920:	11 f4       	brne	.+4      	; 0x1926 <__unpack_f+0x42>
    1922:	82 e0       	ldi	r24, 0x02	; 2
    1924:	37 c0       	rjmp	.+110    	; 0x1994 <__unpack_f+0xb0>
    1926:	82 e8       	ldi	r24, 0x82	; 130
    1928:	9f ef       	ldi	r25, 0xFF	; 255
    192a:	13 96       	adiw	r26, 0x03	; 3
    192c:	9c 93       	st	X, r25
    192e:	8e 93       	st	-X, r24
    1930:	12 97       	sbiw	r26, 0x02	; 2
    1932:	9a 01       	movw	r18, r20
    1934:	ab 01       	movw	r20, r22
    1936:	67 e0       	ldi	r22, 0x07	; 7
    1938:	22 0f       	add	r18, r18
    193a:	33 1f       	adc	r19, r19
    193c:	44 1f       	adc	r20, r20
    193e:	55 1f       	adc	r21, r21
    1940:	6a 95       	dec	r22
    1942:	d1 f7       	brne	.-12     	; 0x1938 <__unpack_f+0x54>
    1944:	83 e0       	ldi	r24, 0x03	; 3
    1946:	8c 93       	st	X, r24
    1948:	0d c0       	rjmp	.+26     	; 0x1964 <__unpack_f+0x80>
    194a:	22 0f       	add	r18, r18
    194c:	33 1f       	adc	r19, r19
    194e:	44 1f       	adc	r20, r20
    1950:	55 1f       	adc	r21, r21
    1952:	12 96       	adiw	r26, 0x02	; 2
    1954:	8d 91       	ld	r24, X+
    1956:	9c 91       	ld	r25, X
    1958:	13 97       	sbiw	r26, 0x03	; 3
    195a:	01 97       	sbiw	r24, 0x01	; 1
    195c:	13 96       	adiw	r26, 0x03	; 3
    195e:	9c 93       	st	X, r25
    1960:	8e 93       	st	-X, r24
    1962:	12 97       	sbiw	r26, 0x02	; 2
    1964:	20 30       	cpi	r18, 0x00	; 0
    1966:	80 e0       	ldi	r24, 0x00	; 0
    1968:	38 07       	cpc	r19, r24
    196a:	80 e0       	ldi	r24, 0x00	; 0
    196c:	48 07       	cpc	r20, r24
    196e:	80 e4       	ldi	r24, 0x40	; 64
    1970:	58 07       	cpc	r21, r24
    1972:	58 f3       	brcs	.-42     	; 0x194a <__unpack_f+0x66>
    1974:	14 96       	adiw	r26, 0x04	; 4
    1976:	2d 93       	st	X+, r18
    1978:	3d 93       	st	X+, r19
    197a:	4d 93       	st	X+, r20
    197c:	5c 93       	st	X, r21
    197e:	17 97       	sbiw	r26, 0x07	; 7
    1980:	08 95       	ret
    1982:	2f 3f       	cpi	r18, 0xFF	; 255
    1984:	31 05       	cpc	r19, r1
    1986:	79 f4       	brne	.+30     	; 0x19a6 <__unpack_f+0xc2>
    1988:	41 15       	cp	r20, r1
    198a:	51 05       	cpc	r21, r1
    198c:	61 05       	cpc	r22, r1
    198e:	71 05       	cpc	r23, r1
    1990:	19 f4       	brne	.+6      	; 0x1998 <__unpack_f+0xb4>
    1992:	84 e0       	ldi	r24, 0x04	; 4
    1994:	8c 93       	st	X, r24
    1996:	08 95       	ret
    1998:	64 ff       	sbrs	r22, 4
    199a:	03 c0       	rjmp	.+6      	; 0x19a2 <__unpack_f+0xbe>
    199c:	81 e0       	ldi	r24, 0x01	; 1
    199e:	8c 93       	st	X, r24
    19a0:	12 c0       	rjmp	.+36     	; 0x19c6 <__unpack_f+0xe2>
    19a2:	1c 92       	st	X, r1
    19a4:	10 c0       	rjmp	.+32     	; 0x19c6 <__unpack_f+0xe2>
    19a6:	2f 57       	subi	r18, 0x7F	; 127
    19a8:	30 40       	sbci	r19, 0x00	; 0
    19aa:	13 96       	adiw	r26, 0x03	; 3
    19ac:	3c 93       	st	X, r19
    19ae:	2e 93       	st	-X, r18
    19b0:	12 97       	sbiw	r26, 0x02	; 2
    19b2:	83 e0       	ldi	r24, 0x03	; 3
    19b4:	8c 93       	st	X, r24
    19b6:	87 e0       	ldi	r24, 0x07	; 7
    19b8:	44 0f       	add	r20, r20
    19ba:	55 1f       	adc	r21, r21
    19bc:	66 1f       	adc	r22, r22
    19be:	77 1f       	adc	r23, r23
    19c0:	8a 95       	dec	r24
    19c2:	d1 f7       	brne	.-12     	; 0x19b8 <__unpack_f+0xd4>
    19c4:	70 64       	ori	r23, 0x40	; 64
    19c6:	14 96       	adiw	r26, 0x04	; 4
    19c8:	4d 93       	st	X+, r20
    19ca:	5d 93       	st	X+, r21
    19cc:	6d 93       	st	X+, r22
    19ce:	7c 93       	st	X, r23
    19d0:	17 97       	sbiw	r26, 0x07	; 7
    19d2:	08 95       	ret

000019d4 <__fpcmp_parts_f>:
    19d4:	1f 93       	push	r17
    19d6:	dc 01       	movw	r26, r24
    19d8:	fb 01       	movw	r30, r22
    19da:	9c 91       	ld	r25, X
    19dc:	92 30       	cpi	r25, 0x02	; 2
    19de:	08 f4       	brcc	.+2      	; 0x19e2 <__fpcmp_parts_f+0xe>
    19e0:	47 c0       	rjmp	.+142    	; 0x1a70 <__fpcmp_parts_f+0x9c>
    19e2:	80 81       	ld	r24, Z
    19e4:	82 30       	cpi	r24, 0x02	; 2
    19e6:	08 f4       	brcc	.+2      	; 0x19ea <__fpcmp_parts_f+0x16>
    19e8:	43 c0       	rjmp	.+134    	; 0x1a70 <__fpcmp_parts_f+0x9c>
    19ea:	94 30       	cpi	r25, 0x04	; 4
    19ec:	51 f4       	brne	.+20     	; 0x1a02 <__fpcmp_parts_f+0x2e>
    19ee:	11 96       	adiw	r26, 0x01	; 1
    19f0:	1c 91       	ld	r17, X
    19f2:	84 30       	cpi	r24, 0x04	; 4
    19f4:	99 f5       	brne	.+102    	; 0x1a5c <__fpcmp_parts_f+0x88>
    19f6:	81 81       	ldd	r24, Z+1	; 0x01
    19f8:	68 2f       	mov	r22, r24
    19fa:	70 e0       	ldi	r23, 0x00	; 0
    19fc:	61 1b       	sub	r22, r17
    19fe:	71 09       	sbc	r23, r1
    1a00:	3f c0       	rjmp	.+126    	; 0x1a80 <__fpcmp_parts_f+0xac>
    1a02:	84 30       	cpi	r24, 0x04	; 4
    1a04:	21 f0       	breq	.+8      	; 0x1a0e <__fpcmp_parts_f+0x3a>
    1a06:	92 30       	cpi	r25, 0x02	; 2
    1a08:	31 f4       	brne	.+12     	; 0x1a16 <__fpcmp_parts_f+0x42>
    1a0a:	82 30       	cpi	r24, 0x02	; 2
    1a0c:	b9 f1       	breq	.+110    	; 0x1a7c <__fpcmp_parts_f+0xa8>
    1a0e:	81 81       	ldd	r24, Z+1	; 0x01
    1a10:	88 23       	and	r24, r24
    1a12:	89 f1       	breq	.+98     	; 0x1a76 <__fpcmp_parts_f+0xa2>
    1a14:	2d c0       	rjmp	.+90     	; 0x1a70 <__fpcmp_parts_f+0x9c>
    1a16:	11 96       	adiw	r26, 0x01	; 1
    1a18:	1c 91       	ld	r17, X
    1a1a:	11 97       	sbiw	r26, 0x01	; 1
    1a1c:	82 30       	cpi	r24, 0x02	; 2
    1a1e:	f1 f0       	breq	.+60     	; 0x1a5c <__fpcmp_parts_f+0x88>
    1a20:	81 81       	ldd	r24, Z+1	; 0x01
    1a22:	18 17       	cp	r17, r24
    1a24:	d9 f4       	brne	.+54     	; 0x1a5c <__fpcmp_parts_f+0x88>
    1a26:	12 96       	adiw	r26, 0x02	; 2
    1a28:	2d 91       	ld	r18, X+
    1a2a:	3c 91       	ld	r19, X
    1a2c:	13 97       	sbiw	r26, 0x03	; 3
    1a2e:	82 81       	ldd	r24, Z+2	; 0x02
    1a30:	93 81       	ldd	r25, Z+3	; 0x03
    1a32:	82 17       	cp	r24, r18
    1a34:	93 07       	cpc	r25, r19
    1a36:	94 f0       	brlt	.+36     	; 0x1a5c <__fpcmp_parts_f+0x88>
    1a38:	28 17       	cp	r18, r24
    1a3a:	39 07       	cpc	r19, r25
    1a3c:	bc f0       	brlt	.+46     	; 0x1a6c <__fpcmp_parts_f+0x98>
    1a3e:	14 96       	adiw	r26, 0x04	; 4
    1a40:	8d 91       	ld	r24, X+
    1a42:	9d 91       	ld	r25, X+
    1a44:	0d 90       	ld	r0, X+
    1a46:	bc 91       	ld	r27, X
    1a48:	a0 2d       	mov	r26, r0
    1a4a:	24 81       	ldd	r18, Z+4	; 0x04
    1a4c:	35 81       	ldd	r19, Z+5	; 0x05
    1a4e:	46 81       	ldd	r20, Z+6	; 0x06
    1a50:	57 81       	ldd	r21, Z+7	; 0x07
    1a52:	28 17       	cp	r18, r24
    1a54:	39 07       	cpc	r19, r25
    1a56:	4a 07       	cpc	r20, r26
    1a58:	5b 07       	cpc	r21, r27
    1a5a:	18 f4       	brcc	.+6      	; 0x1a62 <__fpcmp_parts_f+0x8e>
    1a5c:	11 23       	and	r17, r17
    1a5e:	41 f0       	breq	.+16     	; 0x1a70 <__fpcmp_parts_f+0x9c>
    1a60:	0a c0       	rjmp	.+20     	; 0x1a76 <__fpcmp_parts_f+0xa2>
    1a62:	82 17       	cp	r24, r18
    1a64:	93 07       	cpc	r25, r19
    1a66:	a4 07       	cpc	r26, r20
    1a68:	b5 07       	cpc	r27, r21
    1a6a:	40 f4       	brcc	.+16     	; 0x1a7c <__fpcmp_parts_f+0xa8>
    1a6c:	11 23       	and	r17, r17
    1a6e:	19 f0       	breq	.+6      	; 0x1a76 <__fpcmp_parts_f+0xa2>
    1a70:	61 e0       	ldi	r22, 0x01	; 1
    1a72:	70 e0       	ldi	r23, 0x00	; 0
    1a74:	05 c0       	rjmp	.+10     	; 0x1a80 <__fpcmp_parts_f+0xac>
    1a76:	6f ef       	ldi	r22, 0xFF	; 255
    1a78:	7f ef       	ldi	r23, 0xFF	; 255
    1a7a:	02 c0       	rjmp	.+4      	; 0x1a80 <__fpcmp_parts_f+0xac>
    1a7c:	60 e0       	ldi	r22, 0x00	; 0
    1a7e:	70 e0       	ldi	r23, 0x00	; 0
    1a80:	cb 01       	movw	r24, r22
    1a82:	1f 91       	pop	r17
    1a84:	08 95       	ret

00001a86 <MADC_voidInit>:
#include "../Include/MCAL/ADC/ADC_Configurations.h"

static void (*ADC_CallBack)(void)=NULLPTR;

void MADC_voidInit(ADC_Prescaler Prescaler,REF_Voltage referance)
{
    1a86:	df 93       	push	r29
    1a88:	cf 93       	push	r28
    1a8a:	00 d0       	rcall	.+0      	; 0x1a8c <MADC_voidInit+0x6>
    1a8c:	cd b7       	in	r28, 0x3d	; 61
    1a8e:	de b7       	in	r29, 0x3e	; 62
    1a90:	89 83       	std	Y+1, r24	; 0x01
    1a92:	6a 83       	std	Y+2, r22	; 0x02
    //reference selection
    ADMUX&=~(0b11<<REFS0);
    1a94:	a7 e2       	ldi	r26, 0x27	; 39
    1a96:	b0 e0       	ldi	r27, 0x00	; 0
    1a98:	e7 e2       	ldi	r30, 0x27	; 39
    1a9a:	f0 e0       	ldi	r31, 0x00	; 0
    1a9c:	80 81       	ld	r24, Z
    1a9e:	8f 73       	andi	r24, 0x3F	; 63
    1aa0:	8c 93       	st	X, r24
    ADMUX|=(referance<<REFS0);
    1aa2:	a7 e2       	ldi	r26, 0x27	; 39
    1aa4:	b0 e0       	ldi	r27, 0x00	; 0
    1aa6:	e7 e2       	ldi	r30, 0x27	; 39
    1aa8:	f0 e0       	ldi	r31, 0x00	; 0
    1aaa:	80 81       	ld	r24, Z
    1aac:	28 2f       	mov	r18, r24
    1aae:	8a 81       	ldd	r24, Y+2	; 0x02
    1ab0:	88 2f       	mov	r24, r24
    1ab2:	90 e0       	ldi	r25, 0x00	; 0
    1ab4:	00 24       	eor	r0, r0
    1ab6:	96 95       	lsr	r25
    1ab8:	87 95       	ror	r24
    1aba:	07 94       	ror	r0
    1abc:	96 95       	lsr	r25
    1abe:	87 95       	ror	r24
    1ac0:	07 94       	ror	r0
    1ac2:	98 2f       	mov	r25, r24
    1ac4:	80 2d       	mov	r24, r0
    1ac6:	82 2b       	or	r24, r18
    1ac8:	8c 93       	st	X, r24

    //left or right adjust
    #if ADC_LEFT_ADJUST==TRUE
    SET_BIT(ADMUX,ADLAR);
    #else
    CLR_BIT(ADMUX,ADLAR);
    1aca:	a7 e2       	ldi	r26, 0x27	; 39
    1acc:	b0 e0       	ldi	r27, 0x00	; 0
    1ace:	e7 e2       	ldi	r30, 0x27	; 39
    1ad0:	f0 e0       	ldi	r31, 0x00	; 0
    1ad2:	80 81       	ld	r24, Z
    1ad4:	8f 7d       	andi	r24, 0xDF	; 223
    1ad6:	8c 93       	st	X, r24
    #endif

    //Making ADC enable
    SET_BIT(ADCSRA,ADEN);
    1ad8:	a6 e2       	ldi	r26, 0x26	; 38
    1ada:	b0 e0       	ldi	r27, 0x00	; 0
    1adc:	e6 e2       	ldi	r30, 0x26	; 38
    1ade:	f0 e0       	ldi	r31, 0x00	; 0
    1ae0:	80 81       	ld	r24, Z
    1ae2:	80 68       	ori	r24, 0x80	; 128
    1ae4:	8c 93       	st	X, r24
    
    //auto triggering
    #if AUTO_TRIGGERING == TRUE
    SET_BIT(ADCSRA,ADATE);
    #else
    CLR_BIT(ADCSRA,ADATE);
    1ae6:	a6 e2       	ldi	r26, 0x26	; 38
    1ae8:	b0 e0       	ldi	r27, 0x00	; 0
    1aea:	e6 e2       	ldi	r30, 0x26	; 38
    1aec:	f0 e0       	ldi	r31, 0x00	; 0
    1aee:	80 81       	ld	r24, Z
    1af0:	8f 7d       	andi	r24, 0xDF	; 223
    1af2:	8c 93       	st	X, r24
    #endif
    

    //prescaler division factor
    ADCSRA&=~(0b111<<ADPS0);
    1af4:	a6 e2       	ldi	r26, 0x26	; 38
    1af6:	b0 e0       	ldi	r27, 0x00	; 0
    1af8:	e6 e2       	ldi	r30, 0x26	; 38
    1afa:	f0 e0       	ldi	r31, 0x00	; 0
    1afc:	80 81       	ld	r24, Z
    1afe:	88 7f       	andi	r24, 0xF8	; 248
    1b00:	8c 93       	st	X, r24
    ADCSRA|=(Prescaler<<ADPS0);
    1b02:	a6 e2       	ldi	r26, 0x26	; 38
    1b04:	b0 e0       	ldi	r27, 0x00	; 0
    1b06:	e6 e2       	ldi	r30, 0x26	; 38
    1b08:	f0 e0       	ldi	r31, 0x00	; 0
    1b0a:	90 81       	ld	r25, Z
    1b0c:	89 81       	ldd	r24, Y+1	; 0x01
    1b0e:	89 2b       	or	r24, r25
    1b10:	8c 93       	st	X, r24

}
    1b12:	0f 90       	pop	r0
    1b14:	0f 90       	pop	r0
    1b16:	cf 91       	pop	r28
    1b18:	df 91       	pop	r29
    1b1a:	08 95       	ret

00001b1c <MADC_voidInterruptEnable>:

void MADC_voidInterruptEnable(void)
{
    1b1c:	df 93       	push	r29
    1b1e:	cf 93       	push	r28
    1b20:	cd b7       	in	r28, 0x3d	; 61
    1b22:	de b7       	in	r29, 0x3e	; 62
    SET_BIT(ADCSRA,ADIE);
    1b24:	a6 e2       	ldi	r26, 0x26	; 38
    1b26:	b0 e0       	ldi	r27, 0x00	; 0
    1b28:	e6 e2       	ldi	r30, 0x26	; 38
    1b2a:	f0 e0       	ldi	r31, 0x00	; 0
    1b2c:	80 81       	ld	r24, Z
    1b2e:	88 60       	ori	r24, 0x08	; 8
    1b30:	8c 93       	st	X, r24
}
    1b32:	cf 91       	pop	r28
    1b34:	df 91       	pop	r29
    1b36:	08 95       	ret

00001b38 <MADC_voidInterruptDisable>:

void MADC_voidInterruptDisable(void)
{
    1b38:	df 93       	push	r29
    1b3a:	cf 93       	push	r28
    1b3c:	cd b7       	in	r28, 0x3d	; 61
    1b3e:	de b7       	in	r29, 0x3e	; 62
    CLR_BIT(ADCSRA,ADIE);
    1b40:	a6 e2       	ldi	r26, 0x26	; 38
    1b42:	b0 e0       	ldi	r27, 0x00	; 0
    1b44:	e6 e2       	ldi	r30, 0x26	; 38
    1b46:	f0 e0       	ldi	r31, 0x00	; 0
    1b48:	80 81       	ld	r24, Z
    1b4a:	87 7f       	andi	r24, 0xF7	; 247
    1b4c:	8c 93       	st	X, r24
}
    1b4e:	cf 91       	pop	r28
    1b50:	df 91       	pop	r29
    1b52:	08 95       	ret

00001b54 <MADC_u16GetDigitalValue>:

u16 MADC_u16GetDigitalValue(ADC_Channel channel)
{
    1b54:	df 93       	push	r29
    1b56:	cf 93       	push	r28
    1b58:	00 d0       	rcall	.+0      	; 0x1b5a <MADC_u16GetDigitalValue+0x6>
    1b5a:	0f 92       	push	r0
    1b5c:	cd b7       	in	r28, 0x3d	; 61
    1b5e:	de b7       	in	r29, 0x3e	; 62
    1b60:	8b 83       	std	Y+3, r24	; 0x03

    u16 local_u16DigitalValue=0;
    1b62:	1a 82       	std	Y+2, r1	; 0x02
    1b64:	19 82       	std	Y+1, r1	; 0x01
    
    
    //chosing channel
    ADMUX&=~(0b11111<< MUX0);
    1b66:	a7 e2       	ldi	r26, 0x27	; 39
    1b68:	b0 e0       	ldi	r27, 0x00	; 0
    1b6a:	e7 e2       	ldi	r30, 0x27	; 39
    1b6c:	f0 e0       	ldi	r31, 0x00	; 0
    1b6e:	80 81       	ld	r24, Z
    1b70:	80 7e       	andi	r24, 0xE0	; 224
    1b72:	8c 93       	st	X, r24
    ADMUX|=(channel<< MUX0);
    1b74:	a7 e2       	ldi	r26, 0x27	; 39
    1b76:	b0 e0       	ldi	r27, 0x00	; 0
    1b78:	e7 e2       	ldi	r30, 0x27	; 39
    1b7a:	f0 e0       	ldi	r31, 0x00	; 0
    1b7c:	90 81       	ld	r25, Z
    1b7e:	8b 81       	ldd	r24, Y+3	; 0x03
    1b80:	89 2b       	or	r24, r25
    1b82:	8c 93       	st	X, r24

    //starting conversion
    SET_BIT(ADCSRA,ADCS);
    1b84:	a6 e2       	ldi	r26, 0x26	; 38
    1b86:	b0 e0       	ldi	r27, 0x00	; 0
    1b88:	e6 e2       	ldi	r30, 0x26	; 38
    1b8a:	f0 e0       	ldi	r31, 0x00	; 0
    1b8c:	80 81       	ld	r24, Z
    1b8e:	80 64       	ori	r24, 0x40	; 64
    1b90:	8c 93       	st	X, r24

    //polling on flag until the conversion is finished
    while(GET_BIT(ADCSRA,ADIF)==0);
    1b92:	e6 e2       	ldi	r30, 0x26	; 38
    1b94:	f0 e0       	ldi	r31, 0x00	; 0
    1b96:	80 81       	ld	r24, Z
    1b98:	88 2f       	mov	r24, r24
    1b9a:	90 e0       	ldi	r25, 0x00	; 0
    1b9c:	9c 01       	movw	r18, r24
    1b9e:	2f 7e       	andi	r18, 0xEF	; 239
    1ba0:	e6 e2       	ldi	r30, 0x26	; 38
    1ba2:	f0 e0       	ldi	r31, 0x00	; 0
    1ba4:	80 81       	ld	r24, Z
    1ba6:	88 2f       	mov	r24, r24
    1ba8:	90 e0       	ldi	r25, 0x00	; 0
    1baa:	28 17       	cp	r18, r24
    1bac:	39 07       	cpc	r19, r25
    1bae:	89 f3       	breq	.-30     	; 0x1b92 <MADC_u16GetDigitalValue+0x3e>
    //writing one to clear the flag
    SET_BIT(ADCSRA,ADIF);
    1bb0:	a6 e2       	ldi	r26, 0x26	; 38
    1bb2:	b0 e0       	ldi	r27, 0x00	; 0
    1bb4:	e6 e2       	ldi	r30, 0x26	; 38
    1bb6:	f0 e0       	ldi	r31, 0x00	; 0
    1bb8:	80 81       	ld	r24, Z
    1bba:	80 61       	ori	r24, 0x10	; 16
    1bbc:	8c 93       	st	X, r24
    //Read value
    local_u16DigitalValue=ADCLH;
    1bbe:	e4 e2       	ldi	r30, 0x24	; 36
    1bc0:	f0 e0       	ldi	r31, 0x00	; 0
    1bc2:	80 81       	ld	r24, Z
    1bc4:	91 81       	ldd	r25, Z+1	; 0x01
    1bc6:	9a 83       	std	Y+2, r25	; 0x02
    1bc8:	89 83       	std	Y+1, r24	; 0x01
    

    return local_u16DigitalValue;
    1bca:	89 81       	ldd	r24, Y+1	; 0x01
    1bcc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1bce:	0f 90       	pop	r0
    1bd0:	0f 90       	pop	r0
    1bd2:	0f 90       	pop	r0
    1bd4:	cf 91       	pop	r28
    1bd6:	df 91       	pop	r29
    1bd8:	08 95       	ret

00001bda <MADC_voidCallBack>:

void MADC_voidCallBack(void (*ptrToLocal)(void))
{
    1bda:	df 93       	push	r29
    1bdc:	cf 93       	push	r28
    1bde:	00 d0       	rcall	.+0      	; 0x1be0 <MADC_voidCallBack+0x6>
    1be0:	cd b7       	in	r28, 0x3d	; 61
    1be2:	de b7       	in	r29, 0x3e	; 62
    1be4:	9a 83       	std	Y+2, r25	; 0x02
    1be6:	89 83       	std	Y+1, r24	; 0x01
    ADC_CallBack=ptrToLocal;
    1be8:	89 81       	ldd	r24, Y+1	; 0x01
    1bea:	9a 81       	ldd	r25, Y+2	; 0x02
    1bec:	90 93 a5 01 	sts	0x01A5, r25
    1bf0:	80 93 a4 01 	sts	0x01A4, r24
}
    1bf4:	0f 90       	pop	r0
    1bf6:	0f 90       	pop	r0
    1bf8:	cf 91       	pop	r28
    1bfa:	df 91       	pop	r29
    1bfc:	08 95       	ret

00001bfe <__vector_16>:
ISR(ADC_VECT)
{
    1bfe:	1f 92       	push	r1
    1c00:	0f 92       	push	r0
    1c02:	0f b6       	in	r0, 0x3f	; 63
    1c04:	0f 92       	push	r0
    1c06:	11 24       	eor	r1, r1
    1c08:	2f 93       	push	r18
    1c0a:	3f 93       	push	r19
    1c0c:	4f 93       	push	r20
    1c0e:	5f 93       	push	r21
    1c10:	6f 93       	push	r22
    1c12:	7f 93       	push	r23
    1c14:	8f 93       	push	r24
    1c16:	9f 93       	push	r25
    1c18:	af 93       	push	r26
    1c1a:	bf 93       	push	r27
    1c1c:	ef 93       	push	r30
    1c1e:	ff 93       	push	r31
    1c20:	df 93       	push	r29
    1c22:	cf 93       	push	r28
    1c24:	cd b7       	in	r28, 0x3d	; 61
    1c26:	de b7       	in	r29, 0x3e	; 62
    if(ADC_CallBack != NULLPTR) ADC_CallBack();
    1c28:	80 91 a4 01 	lds	r24, 0x01A4
    1c2c:	90 91 a5 01 	lds	r25, 0x01A5
    1c30:	00 97       	sbiw	r24, 0x00	; 0
    1c32:	29 f0       	breq	.+10     	; 0x1c3e <__vector_16+0x40>
    1c34:	e0 91 a4 01 	lds	r30, 0x01A4
    1c38:	f0 91 a5 01 	lds	r31, 0x01A5
    1c3c:	09 95       	icall
    1c3e:	cf 91       	pop	r28
    1c40:	df 91       	pop	r29
    1c42:	ff 91       	pop	r31
    1c44:	ef 91       	pop	r30
    1c46:	bf 91       	pop	r27
    1c48:	af 91       	pop	r26
    1c4a:	9f 91       	pop	r25
    1c4c:	8f 91       	pop	r24
    1c4e:	7f 91       	pop	r23
    1c50:	6f 91       	pop	r22
    1c52:	5f 91       	pop	r21
    1c54:	4f 91       	pop	r20
    1c56:	3f 91       	pop	r19
    1c58:	2f 91       	pop	r18
    1c5a:	0f 90       	pop	r0
    1c5c:	0f be       	out	0x3f, r0	; 63
    1c5e:	0f 90       	pop	r0
    1c60:	1f 90       	pop	r1
    1c62:	18 95       	reti

00001c64 <HDCMOTOR_voidHBridge>:

#include <util/delay.h>

//H-bridge using 4npn transistors 2N2222
void HDCMOTOR_voidHBridge()
{
    1c64:	df 93       	push	r29
    1c66:	cf 93       	push	r28
    1c68:	cd b7       	in	r28, 0x3d	; 61
    1c6a:	de b7       	in	r29, 0x3e	; 62
    1c6c:	6c 97       	sbiw	r28, 0x1c	; 28
    1c6e:	0f b6       	in	r0, 0x3f	; 63
    1c70:	f8 94       	cli
    1c72:	de bf       	out	0x3e, r29	; 62
    1c74:	0f be       	out	0x3f, r0	; 63
    1c76:	cd bf       	out	0x3d, r28	; 61
    MDIO_voidSetPinValue(DC_MOTOR_PORT,DC_MOTOR_PIN1,PIN_HIGH);
    1c78:	80 e0       	ldi	r24, 0x00	; 0
    1c7a:	60 e0       	ldi	r22, 0x00	; 0
    1c7c:	41 e0       	ldi	r20, 0x01	; 1
    1c7e:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(DC_MOTOR_PORT,DC_MOTOR_PIN2,PIN_LOW);
    1c82:	80 e0       	ldi	r24, 0x00	; 0
    1c84:	61 e0       	ldi	r22, 0x01	; 1
    1c86:	40 e0       	ldi	r20, 0x00	; 0
    1c88:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    1c8c:	80 e0       	ldi	r24, 0x00	; 0
    1c8e:	90 e0       	ldi	r25, 0x00	; 0
    1c90:	aa e7       	ldi	r26, 0x7A	; 122
    1c92:	b4 e4       	ldi	r27, 0x44	; 68
    1c94:	89 8f       	std	Y+25, r24	; 0x19
    1c96:	9a 8f       	std	Y+26, r25	; 0x1a
    1c98:	ab 8f       	std	Y+27, r26	; 0x1b
    1c9a:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1c9c:	69 8d       	ldd	r22, Y+25	; 0x19
    1c9e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1ca0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1ca2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1ca4:	20 e0       	ldi	r18, 0x00	; 0
    1ca6:	30 e0       	ldi	r19, 0x00	; 0
    1ca8:	4a ef       	ldi	r20, 0xFA	; 250
    1caa:	54 e4       	ldi	r21, 0x44	; 68
    1cac:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    1cb0:	dc 01       	movw	r26, r24
    1cb2:	cb 01       	movw	r24, r22
    1cb4:	8d 8b       	std	Y+21, r24	; 0x15
    1cb6:	9e 8b       	std	Y+22, r25	; 0x16
    1cb8:	af 8b       	std	Y+23, r26	; 0x17
    1cba:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1cbc:	6d 89       	ldd	r22, Y+21	; 0x15
    1cbe:	7e 89       	ldd	r23, Y+22	; 0x16
    1cc0:	8f 89       	ldd	r24, Y+23	; 0x17
    1cc2:	98 8d       	ldd	r25, Y+24	; 0x18
    1cc4:	20 e0       	ldi	r18, 0x00	; 0
    1cc6:	30 e0       	ldi	r19, 0x00	; 0
    1cc8:	40 e8       	ldi	r20, 0x80	; 128
    1cca:	5f e3       	ldi	r21, 0x3F	; 63
    1ccc:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    1cd0:	88 23       	and	r24, r24
    1cd2:	2c f4       	brge	.+10     	; 0x1cde <HDCMOTOR_voidHBridge+0x7a>
		__ticks = 1;
    1cd4:	81 e0       	ldi	r24, 0x01	; 1
    1cd6:	90 e0       	ldi	r25, 0x00	; 0
    1cd8:	9c 8b       	std	Y+20, r25	; 0x14
    1cda:	8b 8b       	std	Y+19, r24	; 0x13
    1cdc:	3f c0       	rjmp	.+126    	; 0x1d5c <HDCMOTOR_voidHBridge+0xf8>
	else if (__tmp > 65535)
    1cde:	6d 89       	ldd	r22, Y+21	; 0x15
    1ce0:	7e 89       	ldd	r23, Y+22	; 0x16
    1ce2:	8f 89       	ldd	r24, Y+23	; 0x17
    1ce4:	98 8d       	ldd	r25, Y+24	; 0x18
    1ce6:	20 e0       	ldi	r18, 0x00	; 0
    1ce8:	3f ef       	ldi	r19, 0xFF	; 255
    1cea:	4f e7       	ldi	r20, 0x7F	; 127
    1cec:	57 e4       	ldi	r21, 0x47	; 71
    1cee:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    1cf2:	18 16       	cp	r1, r24
    1cf4:	4c f5       	brge	.+82     	; 0x1d48 <HDCMOTOR_voidHBridge+0xe4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1cf6:	69 8d       	ldd	r22, Y+25	; 0x19
    1cf8:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1cfa:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1cfc:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1cfe:	20 e0       	ldi	r18, 0x00	; 0
    1d00:	30 e0       	ldi	r19, 0x00	; 0
    1d02:	40 e2       	ldi	r20, 0x20	; 32
    1d04:	51 e4       	ldi	r21, 0x41	; 65
    1d06:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    1d0a:	dc 01       	movw	r26, r24
    1d0c:	cb 01       	movw	r24, r22
    1d0e:	bc 01       	movw	r22, r24
    1d10:	cd 01       	movw	r24, r26
    1d12:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    1d16:	dc 01       	movw	r26, r24
    1d18:	cb 01       	movw	r24, r22
    1d1a:	9c 8b       	std	Y+20, r25	; 0x14
    1d1c:	8b 8b       	std	Y+19, r24	; 0x13
    1d1e:	0f c0       	rjmp	.+30     	; 0x1d3e <HDCMOTOR_voidHBridge+0xda>
    1d20:	88 ec       	ldi	r24, 0xC8	; 200
    1d22:	90 e0       	ldi	r25, 0x00	; 0
    1d24:	9a 8b       	std	Y+18, r25	; 0x12
    1d26:	89 8b       	std	Y+17, r24	; 0x11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1d28:	89 89       	ldd	r24, Y+17	; 0x11
    1d2a:	9a 89       	ldd	r25, Y+18	; 0x12
    1d2c:	01 97       	sbiw	r24, 0x01	; 1
    1d2e:	f1 f7       	brne	.-4      	; 0x1d2c <HDCMOTOR_voidHBridge+0xc8>
    1d30:	9a 8b       	std	Y+18, r25	; 0x12
    1d32:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1d34:	8b 89       	ldd	r24, Y+19	; 0x13
    1d36:	9c 89       	ldd	r25, Y+20	; 0x14
    1d38:	01 97       	sbiw	r24, 0x01	; 1
    1d3a:	9c 8b       	std	Y+20, r25	; 0x14
    1d3c:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d3e:	8b 89       	ldd	r24, Y+19	; 0x13
    1d40:	9c 89       	ldd	r25, Y+20	; 0x14
    1d42:	00 97       	sbiw	r24, 0x00	; 0
    1d44:	69 f7       	brne	.-38     	; 0x1d20 <HDCMOTOR_voidHBridge+0xbc>
    1d46:	14 c0       	rjmp	.+40     	; 0x1d70 <HDCMOTOR_voidHBridge+0x10c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1d48:	6d 89       	ldd	r22, Y+21	; 0x15
    1d4a:	7e 89       	ldd	r23, Y+22	; 0x16
    1d4c:	8f 89       	ldd	r24, Y+23	; 0x17
    1d4e:	98 8d       	ldd	r25, Y+24	; 0x18
    1d50:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    1d54:	dc 01       	movw	r26, r24
    1d56:	cb 01       	movw	r24, r22
    1d58:	9c 8b       	std	Y+20, r25	; 0x14
    1d5a:	8b 8b       	std	Y+19, r24	; 0x13
    1d5c:	8b 89       	ldd	r24, Y+19	; 0x13
    1d5e:	9c 89       	ldd	r25, Y+20	; 0x14
    1d60:	98 8b       	std	Y+16, r25	; 0x10
    1d62:	8f 87       	std	Y+15, r24	; 0x0f
    1d64:	8f 85       	ldd	r24, Y+15	; 0x0f
    1d66:	98 89       	ldd	r25, Y+16	; 0x10
    1d68:	01 97       	sbiw	r24, 0x01	; 1
    1d6a:	f1 f7       	brne	.-4      	; 0x1d68 <HDCMOTOR_voidHBridge+0x104>
    1d6c:	98 8b       	std	Y+16, r25	; 0x10
    1d6e:	8f 87       	std	Y+15, r24	; 0x0f
    _delay_ms(INVERSE_MOTOR_DELAY);
    MDIO_voidSetPinValue(DC_MOTOR_PORT,DC_MOTOR_PIN1,PIN_LOW);
    1d70:	80 e0       	ldi	r24, 0x00	; 0
    1d72:	60 e0       	ldi	r22, 0x00	; 0
    1d74:	40 e0       	ldi	r20, 0x00	; 0
    1d76:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(DC_MOTOR_PORT,DC_MOTOR_PIN2,PIN_HIGH);
    1d7a:	80 e0       	ldi	r24, 0x00	; 0
    1d7c:	61 e0       	ldi	r22, 0x01	; 1
    1d7e:	41 e0       	ldi	r20, 0x01	; 1
    1d80:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    1d84:	80 e0       	ldi	r24, 0x00	; 0
    1d86:	90 e0       	ldi	r25, 0x00	; 0
    1d88:	aa e7       	ldi	r26, 0x7A	; 122
    1d8a:	b4 e4       	ldi	r27, 0x44	; 68
    1d8c:	8b 87       	std	Y+11, r24	; 0x0b
    1d8e:	9c 87       	std	Y+12, r25	; 0x0c
    1d90:	ad 87       	std	Y+13, r26	; 0x0d
    1d92:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1d94:	6b 85       	ldd	r22, Y+11	; 0x0b
    1d96:	7c 85       	ldd	r23, Y+12	; 0x0c
    1d98:	8d 85       	ldd	r24, Y+13	; 0x0d
    1d9a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1d9c:	20 e0       	ldi	r18, 0x00	; 0
    1d9e:	30 e0       	ldi	r19, 0x00	; 0
    1da0:	4a ef       	ldi	r20, 0xFA	; 250
    1da2:	54 e4       	ldi	r21, 0x44	; 68
    1da4:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    1da8:	dc 01       	movw	r26, r24
    1daa:	cb 01       	movw	r24, r22
    1dac:	8f 83       	std	Y+7, r24	; 0x07
    1dae:	98 87       	std	Y+8, r25	; 0x08
    1db0:	a9 87       	std	Y+9, r26	; 0x09
    1db2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1db4:	6f 81       	ldd	r22, Y+7	; 0x07
    1db6:	78 85       	ldd	r23, Y+8	; 0x08
    1db8:	89 85       	ldd	r24, Y+9	; 0x09
    1dba:	9a 85       	ldd	r25, Y+10	; 0x0a
    1dbc:	20 e0       	ldi	r18, 0x00	; 0
    1dbe:	30 e0       	ldi	r19, 0x00	; 0
    1dc0:	40 e8       	ldi	r20, 0x80	; 128
    1dc2:	5f e3       	ldi	r21, 0x3F	; 63
    1dc4:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    1dc8:	88 23       	and	r24, r24
    1dca:	2c f4       	brge	.+10     	; 0x1dd6 <HDCMOTOR_voidHBridge+0x172>
		__ticks = 1;
    1dcc:	81 e0       	ldi	r24, 0x01	; 1
    1dce:	90 e0       	ldi	r25, 0x00	; 0
    1dd0:	9e 83       	std	Y+6, r25	; 0x06
    1dd2:	8d 83       	std	Y+5, r24	; 0x05
    1dd4:	3f c0       	rjmp	.+126    	; 0x1e54 <HDCMOTOR_voidHBridge+0x1f0>
	else if (__tmp > 65535)
    1dd6:	6f 81       	ldd	r22, Y+7	; 0x07
    1dd8:	78 85       	ldd	r23, Y+8	; 0x08
    1dda:	89 85       	ldd	r24, Y+9	; 0x09
    1ddc:	9a 85       	ldd	r25, Y+10	; 0x0a
    1dde:	20 e0       	ldi	r18, 0x00	; 0
    1de0:	3f ef       	ldi	r19, 0xFF	; 255
    1de2:	4f e7       	ldi	r20, 0x7F	; 127
    1de4:	57 e4       	ldi	r21, 0x47	; 71
    1de6:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    1dea:	18 16       	cp	r1, r24
    1dec:	4c f5       	brge	.+82     	; 0x1e40 <HDCMOTOR_voidHBridge+0x1dc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1dee:	6b 85       	ldd	r22, Y+11	; 0x0b
    1df0:	7c 85       	ldd	r23, Y+12	; 0x0c
    1df2:	8d 85       	ldd	r24, Y+13	; 0x0d
    1df4:	9e 85       	ldd	r25, Y+14	; 0x0e
    1df6:	20 e0       	ldi	r18, 0x00	; 0
    1df8:	30 e0       	ldi	r19, 0x00	; 0
    1dfa:	40 e2       	ldi	r20, 0x20	; 32
    1dfc:	51 e4       	ldi	r21, 0x41	; 65
    1dfe:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    1e02:	dc 01       	movw	r26, r24
    1e04:	cb 01       	movw	r24, r22
    1e06:	bc 01       	movw	r22, r24
    1e08:	cd 01       	movw	r24, r26
    1e0a:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    1e0e:	dc 01       	movw	r26, r24
    1e10:	cb 01       	movw	r24, r22
    1e12:	9e 83       	std	Y+6, r25	; 0x06
    1e14:	8d 83       	std	Y+5, r24	; 0x05
    1e16:	0f c0       	rjmp	.+30     	; 0x1e36 <HDCMOTOR_voidHBridge+0x1d2>
    1e18:	88 ec       	ldi	r24, 0xC8	; 200
    1e1a:	90 e0       	ldi	r25, 0x00	; 0
    1e1c:	9c 83       	std	Y+4, r25	; 0x04
    1e1e:	8b 83       	std	Y+3, r24	; 0x03
    1e20:	8b 81       	ldd	r24, Y+3	; 0x03
    1e22:	9c 81       	ldd	r25, Y+4	; 0x04
    1e24:	01 97       	sbiw	r24, 0x01	; 1
    1e26:	f1 f7       	brne	.-4      	; 0x1e24 <HDCMOTOR_voidHBridge+0x1c0>
    1e28:	9c 83       	std	Y+4, r25	; 0x04
    1e2a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1e2c:	8d 81       	ldd	r24, Y+5	; 0x05
    1e2e:	9e 81       	ldd	r25, Y+6	; 0x06
    1e30:	01 97       	sbiw	r24, 0x01	; 1
    1e32:	9e 83       	std	Y+6, r25	; 0x06
    1e34:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e36:	8d 81       	ldd	r24, Y+5	; 0x05
    1e38:	9e 81       	ldd	r25, Y+6	; 0x06
    1e3a:	00 97       	sbiw	r24, 0x00	; 0
    1e3c:	69 f7       	brne	.-38     	; 0x1e18 <HDCMOTOR_voidHBridge+0x1b4>
    1e3e:	14 c0       	rjmp	.+40     	; 0x1e68 <HDCMOTOR_voidHBridge+0x204>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1e40:	6f 81       	ldd	r22, Y+7	; 0x07
    1e42:	78 85       	ldd	r23, Y+8	; 0x08
    1e44:	89 85       	ldd	r24, Y+9	; 0x09
    1e46:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e48:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    1e4c:	dc 01       	movw	r26, r24
    1e4e:	cb 01       	movw	r24, r22
    1e50:	9e 83       	std	Y+6, r25	; 0x06
    1e52:	8d 83       	std	Y+5, r24	; 0x05
    1e54:	8d 81       	ldd	r24, Y+5	; 0x05
    1e56:	9e 81       	ldd	r25, Y+6	; 0x06
    1e58:	9a 83       	std	Y+2, r25	; 0x02
    1e5a:	89 83       	std	Y+1, r24	; 0x01
    1e5c:	89 81       	ldd	r24, Y+1	; 0x01
    1e5e:	9a 81       	ldd	r25, Y+2	; 0x02
    1e60:	01 97       	sbiw	r24, 0x01	; 1
    1e62:	f1 f7       	brne	.-4      	; 0x1e60 <HDCMOTOR_voidHBridge+0x1fc>
    1e64:	9a 83       	std	Y+2, r25	; 0x02
    1e66:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(INVERSE_MOTOR_DELAY);
    
}
    1e68:	6c 96       	adiw	r28, 0x1c	; 28
    1e6a:	0f b6       	in	r0, 0x3f	; 63
    1e6c:	f8 94       	cli
    1e6e:	de bf       	out	0x3e, r29	; 62
    1e70:	0f be       	out	0x3f, r0	; 63
    1e72:	cd bf       	out	0x3d, r28	; 61
    1e74:	cf 91       	pop	r28
    1e76:	df 91       	pop	r29
    1e78:	08 95       	ret

00001e7a <MDIO_voidInit>:
#include "../Include/MCAL/DIO/DIO_Private.h"
#include "../Include/MCAL/DIO/DIO_Configuration.h"
#include "../Include/MCAL/DIO/DIO_Interface.h"

void MDIO_voidInit()
{
    1e7a:	df 93       	push	r29
    1e7c:	cf 93       	push	r28
    1e7e:	cd b7       	in	r28, 0x3d	; 61
    1e80:	de b7       	in	r29, 0x3e	; 62
    PORTA_REG=CONC_BIT(PORTA_PIN7_VALUE,PORTA_PIN6_VALUE,PORTA_PIN5_VALUE,PORTA_PIN4_VALUE,PORTA_PIN3_VALUE,PORTA_PIN2_VALUE,PORTA_PIN1_VALUE,PORTA_PIN0_VALUE);
    1e82:	eb e3       	ldi	r30, 0x3B	; 59
    1e84:	f0 e0       	ldi	r31, 0x00	; 0
    1e86:	10 82       	st	Z, r1
    PORTB_REG=CONC_BIT(PORTB_PIN7_VALUE,PORTB_PIN6_VALUE,PORTB_PIN5_VALUE,PORTB_PIN4_VALUE,PORTB_PIN3_VALUE,PORTB_PIN2_VALUE,PORTB_PIN1_VALUE,PORTB_PIN0_VALUE);
    1e88:	e8 e3       	ldi	r30, 0x38	; 56
    1e8a:	f0 e0       	ldi	r31, 0x00	; 0
    1e8c:	10 82       	st	Z, r1
    PORTC_REG=CONC_BIT(PORTC_PIN7_VALUE,PORTC_PIN6_VALUE,PORTC_PIN5_VALUE,PORTC_PIN4_VALUE,PORTC_PIN3_VALUE,PORTC_PIN2_VALUE,PORTC_PIN1_VALUE,PORTC_PIN0_VALUE);
    1e8e:	e5 e3       	ldi	r30, 0x35	; 53
    1e90:	f0 e0       	ldi	r31, 0x00	; 0
    1e92:	10 82       	st	Z, r1
    PORTD_REG=CONC_BIT(PORTD_PIN7_VALUE,PORTD_PIN6_VALUE,PORTD_PIN5_VALUE,PORTD_PIN4_VALUE,PORTD_PIN3_VALUE,PORTD_PIN2_VALUE,PORTD_PIN1_VALUE,PORTD_PIN0_VALUE);
    1e94:	e2 e3       	ldi	r30, 0x32	; 50
    1e96:	f0 e0       	ldi	r31, 0x00	; 0
    1e98:	10 82       	st	Z, r1
    
    DDRA_REG=CONC_BIT(DDRA_PIN7_DIRECTION,DDRA_PIN6_DIRECTION,DDRA_PIN5_DIRECTION,DDRA_PIN4_DIRECTION,DDRA_PIN3_DIRECTION,DDRA_PIN2_DIRECTION,DDRA_PIN1_DIRECTION,DDRA_PIN0_DIRECTION);
    1e9a:	ea e3       	ldi	r30, 0x3A	; 58
    1e9c:	f0 e0       	ldi	r31, 0x00	; 0
    1e9e:	8f ef       	ldi	r24, 0xFF	; 255
    1ea0:	80 83       	st	Z, r24
    DDRB_REG=CONC_BIT(DDRB_PIN7_DIRECTION,DDRB_PIN6_DIRECTION,DDRB_PIN5_DIRECTION,DDRB_PIN4_DIRECTION,DDRB_PIN3_DIRECTION,DDRB_PIN2_DIRECTION,DDRB_PIN1_DIRECTION,DDRB_PIN0_DIRECTION);
    1ea2:	e7 e3       	ldi	r30, 0x37	; 55
    1ea4:	f0 e0       	ldi	r31, 0x00	; 0
    1ea6:	8f ef       	ldi	r24, 0xFF	; 255
    1ea8:	80 83       	st	Z, r24
    DDRC_REG=CONC_BIT(DDRC_PIN7_DIRECTION,DDRC_PIN6_DIRECTION,DDRC_PIN5_DIRECTION,DDRC_PIN4_DIRECTION,DDRC_PIN3_DIRECTION,DDRC_PIN2_DIRECTION,DDRC_PIN1_DIRECTION,DDRC_PIN0_DIRECTION);
    1eaa:	e4 e3       	ldi	r30, 0x34	; 52
    1eac:	f0 e0       	ldi	r31, 0x00	; 0
    1eae:	8f ef       	ldi	r24, 0xFF	; 255
    1eb0:	80 83       	st	Z, r24
    DDRD_REG=CONC_BIT(DDRD_PIN7_DIRECTION,DDRD_PIN6_DIRECTION,DDRD_PIN5_DIRECTION,DDRD_PIN4_DIRECTION,DDRD_PIN3_DIRECTION,DDRD_PIN2_DIRECTION,DDRD_PIN1_DIRECTION,DDRD_PIN0_DIRECTION);
    1eb2:	e1 e3       	ldi	r30, 0x31	; 49
    1eb4:	f0 e0       	ldi	r31, 0x00	; 0
    1eb6:	8e ef       	ldi	r24, 0xFE	; 254
    1eb8:	80 83       	st	Z, r24

}
    1eba:	cf 91       	pop	r28
    1ebc:	df 91       	pop	r29
    1ebe:	08 95       	ret

00001ec0 <MDIO_u8GetPinValue>:

u8 MDIO_u8GetPinValue(u8 A_u8Port,u8 A_u8Pin)
{
    1ec0:	df 93       	push	r29
    1ec2:	cf 93       	push	r28
    1ec4:	00 d0       	rcall	.+0      	; 0x1ec6 <MDIO_u8GetPinValue+0x6>
    1ec6:	00 d0       	rcall	.+0      	; 0x1ec8 <MDIO_u8GetPinValue+0x8>
    1ec8:	0f 92       	push	r0
    1eca:	cd b7       	in	r28, 0x3d	; 61
    1ecc:	de b7       	in	r29, 0x3e	; 62
    1ece:	8a 83       	std	Y+2, r24	; 0x02
    1ed0:	6b 83       	std	Y+3, r22	; 0x03
    u8 local_u8Value;
    switch(A_u8Port)
    1ed2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ed4:	28 2f       	mov	r18, r24
    1ed6:	30 e0       	ldi	r19, 0x00	; 0
    1ed8:	3d 83       	std	Y+5, r19	; 0x05
    1eda:	2c 83       	std	Y+4, r18	; 0x04
    1edc:	8c 81       	ldd	r24, Y+4	; 0x04
    1ede:	9d 81       	ldd	r25, Y+5	; 0x05
    1ee0:	81 30       	cpi	r24, 0x01	; 1
    1ee2:	91 05       	cpc	r25, r1
    1ee4:	c1 f1       	breq	.+112    	; 0x1f56 <MDIO_u8GetPinValue+0x96>
    1ee6:	2c 81       	ldd	r18, Y+4	; 0x04
    1ee8:	3d 81       	ldd	r19, Y+5	; 0x05
    1eea:	22 30       	cpi	r18, 0x02	; 2
    1eec:	31 05       	cpc	r19, r1
    1eee:	2c f4       	brge	.+10     	; 0x1efa <MDIO_u8GetPinValue+0x3a>
    1ef0:	8c 81       	ldd	r24, Y+4	; 0x04
    1ef2:	9d 81       	ldd	r25, Y+5	; 0x05
    1ef4:	00 97       	sbiw	r24, 0x00	; 0
    1ef6:	71 f0       	breq	.+28     	; 0x1f14 <MDIO_u8GetPinValue+0x54>
    1ef8:	8e c0       	rjmp	.+284    	; 0x2016 <MDIO_u8GetPinValue+0x156>
    1efa:	2c 81       	ldd	r18, Y+4	; 0x04
    1efc:	3d 81       	ldd	r19, Y+5	; 0x05
    1efe:	22 30       	cpi	r18, 0x02	; 2
    1f00:	31 05       	cpc	r19, r1
    1f02:	09 f4       	brne	.+2      	; 0x1f06 <MDIO_u8GetPinValue+0x46>
    1f04:	49 c0       	rjmp	.+146    	; 0x1f98 <MDIO_u8GetPinValue+0xd8>
    1f06:	8c 81       	ldd	r24, Y+4	; 0x04
    1f08:	9d 81       	ldd	r25, Y+5	; 0x05
    1f0a:	83 30       	cpi	r24, 0x03	; 3
    1f0c:	91 05       	cpc	r25, r1
    1f0e:	09 f4       	brne	.+2      	; 0x1f12 <MDIO_u8GetPinValue+0x52>
    1f10:	63 c0       	rjmp	.+198    	; 0x1fd8 <MDIO_u8GetPinValue+0x118>
    1f12:	81 c0       	rjmp	.+258    	; 0x2016 <MDIO_u8GetPinValue+0x156>
    {
        case PORTA: local_u8Value=GET_BIT(PINA_REG,A_u8Pin);
    1f14:	e9 e3       	ldi	r30, 0x39	; 57
    1f16:	f0 e0       	ldi	r31, 0x00	; 0
    1f18:	80 81       	ld	r24, Z
    1f1a:	48 2f       	mov	r20, r24
    1f1c:	50 e0       	ldi	r21, 0x00	; 0
    1f1e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f20:	28 2f       	mov	r18, r24
    1f22:	30 e0       	ldi	r19, 0x00	; 0
    1f24:	81 e0       	ldi	r24, 0x01	; 1
    1f26:	90 e0       	ldi	r25, 0x00	; 0
    1f28:	02 c0       	rjmp	.+4      	; 0x1f2e <MDIO_u8GetPinValue+0x6e>
    1f2a:	88 0f       	add	r24, r24
    1f2c:	99 1f       	adc	r25, r25
    1f2e:	2a 95       	dec	r18
    1f30:	e2 f7       	brpl	.-8      	; 0x1f2a <MDIO_u8GetPinValue+0x6a>
    1f32:	80 95       	com	r24
    1f34:	90 95       	com	r25
    1f36:	9a 01       	movw	r18, r20
    1f38:	28 23       	and	r18, r24
    1f3a:	39 23       	and	r19, r25
    1f3c:	e9 e3       	ldi	r30, 0x39	; 57
    1f3e:	f0 e0       	ldi	r31, 0x00	; 0
    1f40:	80 81       	ld	r24, Z
    1f42:	88 2f       	mov	r24, r24
    1f44:	90 e0       	ldi	r25, 0x00	; 0
    1f46:	19 82       	std	Y+1, r1	; 0x01
    1f48:	28 17       	cp	r18, r24
    1f4a:	39 07       	cpc	r19, r25
    1f4c:	09 f4       	brne	.+2      	; 0x1f50 <MDIO_u8GetPinValue+0x90>
    1f4e:	63 c0       	rjmp	.+198    	; 0x2016 <MDIO_u8GetPinValue+0x156>
    1f50:	81 e0       	ldi	r24, 0x01	; 1
    1f52:	89 83       	std	Y+1, r24	; 0x01
    1f54:	60 c0       	rjmp	.+192    	; 0x2016 <MDIO_u8GetPinValue+0x156>
        break;
        case PORTB: local_u8Value=GET_BIT(PINB_REG,A_u8Pin);
    1f56:	e6 e3       	ldi	r30, 0x36	; 54
    1f58:	f0 e0       	ldi	r31, 0x00	; 0
    1f5a:	80 81       	ld	r24, Z
    1f5c:	48 2f       	mov	r20, r24
    1f5e:	50 e0       	ldi	r21, 0x00	; 0
    1f60:	8b 81       	ldd	r24, Y+3	; 0x03
    1f62:	28 2f       	mov	r18, r24
    1f64:	30 e0       	ldi	r19, 0x00	; 0
    1f66:	81 e0       	ldi	r24, 0x01	; 1
    1f68:	90 e0       	ldi	r25, 0x00	; 0
    1f6a:	02 c0       	rjmp	.+4      	; 0x1f70 <MDIO_u8GetPinValue+0xb0>
    1f6c:	88 0f       	add	r24, r24
    1f6e:	99 1f       	adc	r25, r25
    1f70:	2a 95       	dec	r18
    1f72:	e2 f7       	brpl	.-8      	; 0x1f6c <MDIO_u8GetPinValue+0xac>
    1f74:	80 95       	com	r24
    1f76:	90 95       	com	r25
    1f78:	9a 01       	movw	r18, r20
    1f7a:	28 23       	and	r18, r24
    1f7c:	39 23       	and	r19, r25
    1f7e:	e6 e3       	ldi	r30, 0x36	; 54
    1f80:	f0 e0       	ldi	r31, 0x00	; 0
    1f82:	80 81       	ld	r24, Z
    1f84:	88 2f       	mov	r24, r24
    1f86:	90 e0       	ldi	r25, 0x00	; 0
    1f88:	19 82       	std	Y+1, r1	; 0x01
    1f8a:	28 17       	cp	r18, r24
    1f8c:	39 07       	cpc	r19, r25
    1f8e:	09 f4       	brne	.+2      	; 0x1f92 <MDIO_u8GetPinValue+0xd2>
    1f90:	42 c0       	rjmp	.+132    	; 0x2016 <MDIO_u8GetPinValue+0x156>
    1f92:	81 e0       	ldi	r24, 0x01	; 1
    1f94:	89 83       	std	Y+1, r24	; 0x01
    1f96:	3f c0       	rjmp	.+126    	; 0x2016 <MDIO_u8GetPinValue+0x156>
        break;
        case PORTC: local_u8Value=GET_BIT(PINC_REG,A_u8Pin);
    1f98:	e3 e3       	ldi	r30, 0x33	; 51
    1f9a:	f0 e0       	ldi	r31, 0x00	; 0
    1f9c:	80 81       	ld	r24, Z
    1f9e:	48 2f       	mov	r20, r24
    1fa0:	50 e0       	ldi	r21, 0x00	; 0
    1fa2:	8b 81       	ldd	r24, Y+3	; 0x03
    1fa4:	28 2f       	mov	r18, r24
    1fa6:	30 e0       	ldi	r19, 0x00	; 0
    1fa8:	81 e0       	ldi	r24, 0x01	; 1
    1faa:	90 e0       	ldi	r25, 0x00	; 0
    1fac:	02 c0       	rjmp	.+4      	; 0x1fb2 <MDIO_u8GetPinValue+0xf2>
    1fae:	88 0f       	add	r24, r24
    1fb0:	99 1f       	adc	r25, r25
    1fb2:	2a 95       	dec	r18
    1fb4:	e2 f7       	brpl	.-8      	; 0x1fae <MDIO_u8GetPinValue+0xee>
    1fb6:	80 95       	com	r24
    1fb8:	90 95       	com	r25
    1fba:	9a 01       	movw	r18, r20
    1fbc:	28 23       	and	r18, r24
    1fbe:	39 23       	and	r19, r25
    1fc0:	e3 e3       	ldi	r30, 0x33	; 51
    1fc2:	f0 e0       	ldi	r31, 0x00	; 0
    1fc4:	80 81       	ld	r24, Z
    1fc6:	88 2f       	mov	r24, r24
    1fc8:	90 e0       	ldi	r25, 0x00	; 0
    1fca:	19 82       	std	Y+1, r1	; 0x01
    1fcc:	28 17       	cp	r18, r24
    1fce:	39 07       	cpc	r19, r25
    1fd0:	11 f1       	breq	.+68     	; 0x2016 <MDIO_u8GetPinValue+0x156>
    1fd2:	81 e0       	ldi	r24, 0x01	; 1
    1fd4:	89 83       	std	Y+1, r24	; 0x01
    1fd6:	1f c0       	rjmp	.+62     	; 0x2016 <MDIO_u8GetPinValue+0x156>
        break;
        case PORTD: local_u8Value=GET_BIT(PIND_REG,A_u8Pin);
    1fd8:	e0 e3       	ldi	r30, 0x30	; 48
    1fda:	f0 e0       	ldi	r31, 0x00	; 0
    1fdc:	80 81       	ld	r24, Z
    1fde:	48 2f       	mov	r20, r24
    1fe0:	50 e0       	ldi	r21, 0x00	; 0
    1fe2:	8b 81       	ldd	r24, Y+3	; 0x03
    1fe4:	28 2f       	mov	r18, r24
    1fe6:	30 e0       	ldi	r19, 0x00	; 0
    1fe8:	81 e0       	ldi	r24, 0x01	; 1
    1fea:	90 e0       	ldi	r25, 0x00	; 0
    1fec:	02 c0       	rjmp	.+4      	; 0x1ff2 <MDIO_u8GetPinValue+0x132>
    1fee:	88 0f       	add	r24, r24
    1ff0:	99 1f       	adc	r25, r25
    1ff2:	2a 95       	dec	r18
    1ff4:	e2 f7       	brpl	.-8      	; 0x1fee <MDIO_u8GetPinValue+0x12e>
    1ff6:	80 95       	com	r24
    1ff8:	90 95       	com	r25
    1ffa:	9a 01       	movw	r18, r20
    1ffc:	28 23       	and	r18, r24
    1ffe:	39 23       	and	r19, r25
    2000:	e0 e3       	ldi	r30, 0x30	; 48
    2002:	f0 e0       	ldi	r31, 0x00	; 0
    2004:	80 81       	ld	r24, Z
    2006:	88 2f       	mov	r24, r24
    2008:	90 e0       	ldi	r25, 0x00	; 0
    200a:	19 82       	std	Y+1, r1	; 0x01
    200c:	28 17       	cp	r18, r24
    200e:	39 07       	cpc	r19, r25
    2010:	11 f0       	breq	.+4      	; 0x2016 <MDIO_u8GetPinValue+0x156>
    2012:	81 e0       	ldi	r24, 0x01	; 1
    2014:	89 83       	std	Y+1, r24	; 0x01
        break;
    }
    return local_u8Value;
    2016:	89 81       	ldd	r24, Y+1	; 0x01
}
    2018:	0f 90       	pop	r0
    201a:	0f 90       	pop	r0
    201c:	0f 90       	pop	r0
    201e:	0f 90       	pop	r0
    2020:	0f 90       	pop	r0
    2022:	cf 91       	pop	r28
    2024:	df 91       	pop	r29
    2026:	08 95       	ret

00002028 <MDIO_voidSetPinValue>:

void MDIO_voidSetPinValue(u8 A_u8Port,u8 A_u8Pin, u8 A_u8Value)
{
    2028:	df 93       	push	r29
    202a:	cf 93       	push	r28
    202c:	cd b7       	in	r28, 0x3d	; 61
    202e:	de b7       	in	r29, 0x3e	; 62
    2030:	2d 97       	sbiw	r28, 0x0d	; 13
    2032:	0f b6       	in	r0, 0x3f	; 63
    2034:	f8 94       	cli
    2036:	de bf       	out	0x3e, r29	; 62
    2038:	0f be       	out	0x3f, r0	; 63
    203a:	cd bf       	out	0x3d, r28	; 61
    203c:	89 83       	std	Y+1, r24	; 0x01
    203e:	6a 83       	std	Y+2, r22	; 0x02
    2040:	4b 83       	std	Y+3, r20	; 0x03
    switch(A_u8Port)
    2042:	89 81       	ldd	r24, Y+1	; 0x01
    2044:	28 2f       	mov	r18, r24
    2046:	30 e0       	ldi	r19, 0x00	; 0
    2048:	3d 87       	std	Y+13, r19	; 0x0d
    204a:	2c 87       	std	Y+12, r18	; 0x0c
    204c:	8c 85       	ldd	r24, Y+12	; 0x0c
    204e:	9d 85       	ldd	r25, Y+13	; 0x0d
    2050:	81 30       	cpi	r24, 0x01	; 1
    2052:	91 05       	cpc	r25, r1
    2054:	09 f4       	brne	.+2      	; 0x2058 <MDIO_voidSetPinValue+0x30>
    2056:	4f c0       	rjmp	.+158    	; 0x20f6 <MDIO_voidSetPinValue+0xce>
    2058:	2c 85       	ldd	r18, Y+12	; 0x0c
    205a:	3d 85       	ldd	r19, Y+13	; 0x0d
    205c:	22 30       	cpi	r18, 0x02	; 2
    205e:	31 05       	cpc	r19, r1
    2060:	2c f4       	brge	.+10     	; 0x206c <MDIO_voidSetPinValue+0x44>
    2062:	8c 85       	ldd	r24, Y+12	; 0x0c
    2064:	9d 85       	ldd	r25, Y+13	; 0x0d
    2066:	00 97       	sbiw	r24, 0x00	; 0
    2068:	71 f0       	breq	.+28     	; 0x2086 <MDIO_voidSetPinValue+0x5e>
    206a:	eb c0       	rjmp	.+470    	; 0x2242 <MDIO_voidSetPinValue+0x21a>
    206c:	2c 85       	ldd	r18, Y+12	; 0x0c
    206e:	3d 85       	ldd	r19, Y+13	; 0x0d
    2070:	22 30       	cpi	r18, 0x02	; 2
    2072:	31 05       	cpc	r19, r1
    2074:	09 f4       	brne	.+2      	; 0x2078 <MDIO_voidSetPinValue+0x50>
    2076:	77 c0       	rjmp	.+238    	; 0x2166 <MDIO_voidSetPinValue+0x13e>
    2078:	8c 85       	ldd	r24, Y+12	; 0x0c
    207a:	9d 85       	ldd	r25, Y+13	; 0x0d
    207c:	83 30       	cpi	r24, 0x03	; 3
    207e:	91 05       	cpc	r25, r1
    2080:	09 f4       	brne	.+2      	; 0x2084 <MDIO_voidSetPinValue+0x5c>
    2082:	a9 c0       	rjmp	.+338    	; 0x21d6 <MDIO_voidSetPinValue+0x1ae>
    2084:	de c0       	rjmp	.+444    	; 0x2242 <MDIO_voidSetPinValue+0x21a>
    {
        case PORTA:
        switch (A_u8Value)
    2086:	8b 81       	ldd	r24, Y+3	; 0x03
    2088:	28 2f       	mov	r18, r24
    208a:	30 e0       	ldi	r19, 0x00	; 0
    208c:	3b 87       	std	Y+11, r19	; 0x0b
    208e:	2a 87       	std	Y+10, r18	; 0x0a
    2090:	8a 85       	ldd	r24, Y+10	; 0x0a
    2092:	9b 85       	ldd	r25, Y+11	; 0x0b
    2094:	00 97       	sbiw	r24, 0x00	; 0
    2096:	d1 f0       	breq	.+52     	; 0x20cc <MDIO_voidSetPinValue+0xa4>
    2098:	2a 85       	ldd	r18, Y+10	; 0x0a
    209a:	3b 85       	ldd	r19, Y+11	; 0x0b
    209c:	21 30       	cpi	r18, 0x01	; 1
    209e:	31 05       	cpc	r19, r1
    20a0:	09 f0       	breq	.+2      	; 0x20a4 <MDIO_voidSetPinValue+0x7c>
    20a2:	cf c0       	rjmp	.+414    	; 0x2242 <MDIO_voidSetPinValue+0x21a>
        {
            case PIN_HIGH: SET_BIT(PORTA_REG,A_u8Pin);
    20a4:	ab e3       	ldi	r26, 0x3B	; 59
    20a6:	b0 e0       	ldi	r27, 0x00	; 0
    20a8:	eb e3       	ldi	r30, 0x3B	; 59
    20aa:	f0 e0       	ldi	r31, 0x00	; 0
    20ac:	80 81       	ld	r24, Z
    20ae:	48 2f       	mov	r20, r24
    20b0:	8a 81       	ldd	r24, Y+2	; 0x02
    20b2:	28 2f       	mov	r18, r24
    20b4:	30 e0       	ldi	r19, 0x00	; 0
    20b6:	81 e0       	ldi	r24, 0x01	; 1
    20b8:	90 e0       	ldi	r25, 0x00	; 0
    20ba:	02 2e       	mov	r0, r18
    20bc:	02 c0       	rjmp	.+4      	; 0x20c2 <MDIO_voidSetPinValue+0x9a>
    20be:	88 0f       	add	r24, r24
    20c0:	99 1f       	adc	r25, r25
    20c2:	0a 94       	dec	r0
    20c4:	e2 f7       	brpl	.-8      	; 0x20be <MDIO_voidSetPinValue+0x96>
    20c6:	84 2b       	or	r24, r20
    20c8:	8c 93       	st	X, r24
    20ca:	bb c0       	rjmp	.+374    	; 0x2242 <MDIO_voidSetPinValue+0x21a>
            break;

            case PIN_LOW: CLR_BIT(PORTA_REG,A_u8Pin);
    20cc:	ab e3       	ldi	r26, 0x3B	; 59
    20ce:	b0 e0       	ldi	r27, 0x00	; 0
    20d0:	eb e3       	ldi	r30, 0x3B	; 59
    20d2:	f0 e0       	ldi	r31, 0x00	; 0
    20d4:	80 81       	ld	r24, Z
    20d6:	48 2f       	mov	r20, r24
    20d8:	8a 81       	ldd	r24, Y+2	; 0x02
    20da:	28 2f       	mov	r18, r24
    20dc:	30 e0       	ldi	r19, 0x00	; 0
    20de:	81 e0       	ldi	r24, 0x01	; 1
    20e0:	90 e0       	ldi	r25, 0x00	; 0
    20e2:	02 2e       	mov	r0, r18
    20e4:	02 c0       	rjmp	.+4      	; 0x20ea <MDIO_voidSetPinValue+0xc2>
    20e6:	88 0f       	add	r24, r24
    20e8:	99 1f       	adc	r25, r25
    20ea:	0a 94       	dec	r0
    20ec:	e2 f7       	brpl	.-8      	; 0x20e6 <MDIO_voidSetPinValue+0xbe>
    20ee:	80 95       	com	r24
    20f0:	84 23       	and	r24, r20
    20f2:	8c 93       	st	X, r24
    20f4:	a6 c0       	rjmp	.+332    	; 0x2242 <MDIO_voidSetPinValue+0x21a>
            break;
        };
        break;

        case PORTB:
        switch (A_u8Value)
    20f6:	8b 81       	ldd	r24, Y+3	; 0x03
    20f8:	28 2f       	mov	r18, r24
    20fa:	30 e0       	ldi	r19, 0x00	; 0
    20fc:	39 87       	std	Y+9, r19	; 0x09
    20fe:	28 87       	std	Y+8, r18	; 0x08
    2100:	88 85       	ldd	r24, Y+8	; 0x08
    2102:	99 85       	ldd	r25, Y+9	; 0x09
    2104:	00 97       	sbiw	r24, 0x00	; 0
    2106:	d1 f0       	breq	.+52     	; 0x213c <MDIO_voidSetPinValue+0x114>
    2108:	28 85       	ldd	r18, Y+8	; 0x08
    210a:	39 85       	ldd	r19, Y+9	; 0x09
    210c:	21 30       	cpi	r18, 0x01	; 1
    210e:	31 05       	cpc	r19, r1
    2110:	09 f0       	breq	.+2      	; 0x2114 <MDIO_voidSetPinValue+0xec>
    2112:	97 c0       	rjmp	.+302    	; 0x2242 <MDIO_voidSetPinValue+0x21a>
        {
            case PIN_HIGH: SET_BIT(PORTB_REG,A_u8Pin);
    2114:	a8 e3       	ldi	r26, 0x38	; 56
    2116:	b0 e0       	ldi	r27, 0x00	; 0
    2118:	e8 e3       	ldi	r30, 0x38	; 56
    211a:	f0 e0       	ldi	r31, 0x00	; 0
    211c:	80 81       	ld	r24, Z
    211e:	48 2f       	mov	r20, r24
    2120:	8a 81       	ldd	r24, Y+2	; 0x02
    2122:	28 2f       	mov	r18, r24
    2124:	30 e0       	ldi	r19, 0x00	; 0
    2126:	81 e0       	ldi	r24, 0x01	; 1
    2128:	90 e0       	ldi	r25, 0x00	; 0
    212a:	02 2e       	mov	r0, r18
    212c:	02 c0       	rjmp	.+4      	; 0x2132 <MDIO_voidSetPinValue+0x10a>
    212e:	88 0f       	add	r24, r24
    2130:	99 1f       	adc	r25, r25
    2132:	0a 94       	dec	r0
    2134:	e2 f7       	brpl	.-8      	; 0x212e <MDIO_voidSetPinValue+0x106>
    2136:	84 2b       	or	r24, r20
    2138:	8c 93       	st	X, r24
    213a:	83 c0       	rjmp	.+262    	; 0x2242 <MDIO_voidSetPinValue+0x21a>
            break;

            case PIN_LOW: CLR_BIT(PORTB_REG,A_u8Pin);
    213c:	a8 e3       	ldi	r26, 0x38	; 56
    213e:	b0 e0       	ldi	r27, 0x00	; 0
    2140:	e8 e3       	ldi	r30, 0x38	; 56
    2142:	f0 e0       	ldi	r31, 0x00	; 0
    2144:	80 81       	ld	r24, Z
    2146:	48 2f       	mov	r20, r24
    2148:	8a 81       	ldd	r24, Y+2	; 0x02
    214a:	28 2f       	mov	r18, r24
    214c:	30 e0       	ldi	r19, 0x00	; 0
    214e:	81 e0       	ldi	r24, 0x01	; 1
    2150:	90 e0       	ldi	r25, 0x00	; 0
    2152:	02 2e       	mov	r0, r18
    2154:	02 c0       	rjmp	.+4      	; 0x215a <MDIO_voidSetPinValue+0x132>
    2156:	88 0f       	add	r24, r24
    2158:	99 1f       	adc	r25, r25
    215a:	0a 94       	dec	r0
    215c:	e2 f7       	brpl	.-8      	; 0x2156 <MDIO_voidSetPinValue+0x12e>
    215e:	80 95       	com	r24
    2160:	84 23       	and	r24, r20
    2162:	8c 93       	st	X, r24
    2164:	6e c0       	rjmp	.+220    	; 0x2242 <MDIO_voidSetPinValue+0x21a>
            break;
        };
        break;

        case PORTC:
        switch (A_u8Value)
    2166:	8b 81       	ldd	r24, Y+3	; 0x03
    2168:	28 2f       	mov	r18, r24
    216a:	30 e0       	ldi	r19, 0x00	; 0
    216c:	3f 83       	std	Y+7, r19	; 0x07
    216e:	2e 83       	std	Y+6, r18	; 0x06
    2170:	8e 81       	ldd	r24, Y+6	; 0x06
    2172:	9f 81       	ldd	r25, Y+7	; 0x07
    2174:	00 97       	sbiw	r24, 0x00	; 0
    2176:	d1 f0       	breq	.+52     	; 0x21ac <MDIO_voidSetPinValue+0x184>
    2178:	2e 81       	ldd	r18, Y+6	; 0x06
    217a:	3f 81       	ldd	r19, Y+7	; 0x07
    217c:	21 30       	cpi	r18, 0x01	; 1
    217e:	31 05       	cpc	r19, r1
    2180:	09 f0       	breq	.+2      	; 0x2184 <MDIO_voidSetPinValue+0x15c>
    2182:	5f c0       	rjmp	.+190    	; 0x2242 <MDIO_voidSetPinValue+0x21a>
        {
            case PIN_HIGH: SET_BIT(PORTC_REG,A_u8Pin);
    2184:	a5 e3       	ldi	r26, 0x35	; 53
    2186:	b0 e0       	ldi	r27, 0x00	; 0
    2188:	e5 e3       	ldi	r30, 0x35	; 53
    218a:	f0 e0       	ldi	r31, 0x00	; 0
    218c:	80 81       	ld	r24, Z
    218e:	48 2f       	mov	r20, r24
    2190:	8a 81       	ldd	r24, Y+2	; 0x02
    2192:	28 2f       	mov	r18, r24
    2194:	30 e0       	ldi	r19, 0x00	; 0
    2196:	81 e0       	ldi	r24, 0x01	; 1
    2198:	90 e0       	ldi	r25, 0x00	; 0
    219a:	02 2e       	mov	r0, r18
    219c:	02 c0       	rjmp	.+4      	; 0x21a2 <MDIO_voidSetPinValue+0x17a>
    219e:	88 0f       	add	r24, r24
    21a0:	99 1f       	adc	r25, r25
    21a2:	0a 94       	dec	r0
    21a4:	e2 f7       	brpl	.-8      	; 0x219e <MDIO_voidSetPinValue+0x176>
    21a6:	84 2b       	or	r24, r20
    21a8:	8c 93       	st	X, r24
    21aa:	4b c0       	rjmp	.+150    	; 0x2242 <MDIO_voidSetPinValue+0x21a>
            break;

            case PIN_LOW: CLR_BIT(PORTC_REG,A_u8Pin);
    21ac:	a5 e3       	ldi	r26, 0x35	; 53
    21ae:	b0 e0       	ldi	r27, 0x00	; 0
    21b0:	e5 e3       	ldi	r30, 0x35	; 53
    21b2:	f0 e0       	ldi	r31, 0x00	; 0
    21b4:	80 81       	ld	r24, Z
    21b6:	48 2f       	mov	r20, r24
    21b8:	8a 81       	ldd	r24, Y+2	; 0x02
    21ba:	28 2f       	mov	r18, r24
    21bc:	30 e0       	ldi	r19, 0x00	; 0
    21be:	81 e0       	ldi	r24, 0x01	; 1
    21c0:	90 e0       	ldi	r25, 0x00	; 0
    21c2:	02 2e       	mov	r0, r18
    21c4:	02 c0       	rjmp	.+4      	; 0x21ca <MDIO_voidSetPinValue+0x1a2>
    21c6:	88 0f       	add	r24, r24
    21c8:	99 1f       	adc	r25, r25
    21ca:	0a 94       	dec	r0
    21cc:	e2 f7       	brpl	.-8      	; 0x21c6 <MDIO_voidSetPinValue+0x19e>
    21ce:	80 95       	com	r24
    21d0:	84 23       	and	r24, r20
    21d2:	8c 93       	st	X, r24
    21d4:	36 c0       	rjmp	.+108    	; 0x2242 <MDIO_voidSetPinValue+0x21a>
            break;
        };
        break;

        case PORTD:
        switch (A_u8Value)
    21d6:	8b 81       	ldd	r24, Y+3	; 0x03
    21d8:	28 2f       	mov	r18, r24
    21da:	30 e0       	ldi	r19, 0x00	; 0
    21dc:	3d 83       	std	Y+5, r19	; 0x05
    21de:	2c 83       	std	Y+4, r18	; 0x04
    21e0:	8c 81       	ldd	r24, Y+4	; 0x04
    21e2:	9d 81       	ldd	r25, Y+5	; 0x05
    21e4:	00 97       	sbiw	r24, 0x00	; 0
    21e6:	c9 f0       	breq	.+50     	; 0x221a <MDIO_voidSetPinValue+0x1f2>
    21e8:	2c 81       	ldd	r18, Y+4	; 0x04
    21ea:	3d 81       	ldd	r19, Y+5	; 0x05
    21ec:	21 30       	cpi	r18, 0x01	; 1
    21ee:	31 05       	cpc	r19, r1
    21f0:	41 f5       	brne	.+80     	; 0x2242 <MDIO_voidSetPinValue+0x21a>
        {
            case PIN_HIGH: SET_BIT(PORTD_REG,A_u8Pin);
    21f2:	a2 e3       	ldi	r26, 0x32	; 50
    21f4:	b0 e0       	ldi	r27, 0x00	; 0
    21f6:	e2 e3       	ldi	r30, 0x32	; 50
    21f8:	f0 e0       	ldi	r31, 0x00	; 0
    21fa:	80 81       	ld	r24, Z
    21fc:	48 2f       	mov	r20, r24
    21fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2200:	28 2f       	mov	r18, r24
    2202:	30 e0       	ldi	r19, 0x00	; 0
    2204:	81 e0       	ldi	r24, 0x01	; 1
    2206:	90 e0       	ldi	r25, 0x00	; 0
    2208:	02 2e       	mov	r0, r18
    220a:	02 c0       	rjmp	.+4      	; 0x2210 <MDIO_voidSetPinValue+0x1e8>
    220c:	88 0f       	add	r24, r24
    220e:	99 1f       	adc	r25, r25
    2210:	0a 94       	dec	r0
    2212:	e2 f7       	brpl	.-8      	; 0x220c <MDIO_voidSetPinValue+0x1e4>
    2214:	84 2b       	or	r24, r20
    2216:	8c 93       	st	X, r24
    2218:	14 c0       	rjmp	.+40     	; 0x2242 <MDIO_voidSetPinValue+0x21a>
            break;

            case PIN_LOW: CLR_BIT(PORTD_REG,A_u8Pin);
    221a:	a2 e3       	ldi	r26, 0x32	; 50
    221c:	b0 e0       	ldi	r27, 0x00	; 0
    221e:	e2 e3       	ldi	r30, 0x32	; 50
    2220:	f0 e0       	ldi	r31, 0x00	; 0
    2222:	80 81       	ld	r24, Z
    2224:	48 2f       	mov	r20, r24
    2226:	8a 81       	ldd	r24, Y+2	; 0x02
    2228:	28 2f       	mov	r18, r24
    222a:	30 e0       	ldi	r19, 0x00	; 0
    222c:	81 e0       	ldi	r24, 0x01	; 1
    222e:	90 e0       	ldi	r25, 0x00	; 0
    2230:	02 2e       	mov	r0, r18
    2232:	02 c0       	rjmp	.+4      	; 0x2238 <MDIO_voidSetPinValue+0x210>
    2234:	88 0f       	add	r24, r24
    2236:	99 1f       	adc	r25, r25
    2238:	0a 94       	dec	r0
    223a:	e2 f7       	brpl	.-8      	; 0x2234 <MDIO_voidSetPinValue+0x20c>
    223c:	80 95       	com	r24
    223e:	84 23       	and	r24, r20
    2240:	8c 93       	st	X, r24
            break;
        };
        break;
    }
}
    2242:	2d 96       	adiw	r28, 0x0d	; 13
    2244:	0f b6       	in	r0, 0x3f	; 63
    2246:	f8 94       	cli
    2248:	de bf       	out	0x3e, r29	; 62
    224a:	0f be       	out	0x3f, r0	; 63
    224c:	cd bf       	out	0x3d, r28	; 61
    224e:	cf 91       	pop	r28
    2250:	df 91       	pop	r29
    2252:	08 95       	ret

00002254 <MDIO_voidSetPinDirection>:

void MDIO_voidSetPinDirection(u8 A_u8Port,u8 A_u8Pin, u8 A_u8Value)
{
    2254:	df 93       	push	r29
    2256:	cf 93       	push	r28
    2258:	cd b7       	in	r28, 0x3d	; 61
    225a:	de b7       	in	r29, 0x3e	; 62
    225c:	2d 97       	sbiw	r28, 0x0d	; 13
    225e:	0f b6       	in	r0, 0x3f	; 63
    2260:	f8 94       	cli
    2262:	de bf       	out	0x3e, r29	; 62
    2264:	0f be       	out	0x3f, r0	; 63
    2266:	cd bf       	out	0x3d, r28	; 61
    2268:	89 83       	std	Y+1, r24	; 0x01
    226a:	6a 83       	std	Y+2, r22	; 0x02
    226c:	4b 83       	std	Y+3, r20	; 0x03
    switch(A_u8Port)
    226e:	89 81       	ldd	r24, Y+1	; 0x01
    2270:	28 2f       	mov	r18, r24
    2272:	30 e0       	ldi	r19, 0x00	; 0
    2274:	3d 87       	std	Y+13, r19	; 0x0d
    2276:	2c 87       	std	Y+12, r18	; 0x0c
    2278:	8c 85       	ldd	r24, Y+12	; 0x0c
    227a:	9d 85       	ldd	r25, Y+13	; 0x0d
    227c:	81 30       	cpi	r24, 0x01	; 1
    227e:	91 05       	cpc	r25, r1
    2280:	09 f4       	brne	.+2      	; 0x2284 <MDIO_voidSetPinDirection+0x30>
    2282:	4f c0       	rjmp	.+158    	; 0x2322 <MDIO_voidSetPinDirection+0xce>
    2284:	2c 85       	ldd	r18, Y+12	; 0x0c
    2286:	3d 85       	ldd	r19, Y+13	; 0x0d
    2288:	22 30       	cpi	r18, 0x02	; 2
    228a:	31 05       	cpc	r19, r1
    228c:	2c f4       	brge	.+10     	; 0x2298 <MDIO_voidSetPinDirection+0x44>
    228e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2290:	9d 85       	ldd	r25, Y+13	; 0x0d
    2292:	00 97       	sbiw	r24, 0x00	; 0
    2294:	71 f0       	breq	.+28     	; 0x22b2 <MDIO_voidSetPinDirection+0x5e>
    2296:	eb c0       	rjmp	.+470    	; 0x246e <MDIO_voidSetPinDirection+0x21a>
    2298:	2c 85       	ldd	r18, Y+12	; 0x0c
    229a:	3d 85       	ldd	r19, Y+13	; 0x0d
    229c:	22 30       	cpi	r18, 0x02	; 2
    229e:	31 05       	cpc	r19, r1
    22a0:	09 f4       	brne	.+2      	; 0x22a4 <MDIO_voidSetPinDirection+0x50>
    22a2:	77 c0       	rjmp	.+238    	; 0x2392 <MDIO_voidSetPinDirection+0x13e>
    22a4:	8c 85       	ldd	r24, Y+12	; 0x0c
    22a6:	9d 85       	ldd	r25, Y+13	; 0x0d
    22a8:	83 30       	cpi	r24, 0x03	; 3
    22aa:	91 05       	cpc	r25, r1
    22ac:	09 f4       	brne	.+2      	; 0x22b0 <MDIO_voidSetPinDirection+0x5c>
    22ae:	a9 c0       	rjmp	.+338    	; 0x2402 <MDIO_voidSetPinDirection+0x1ae>
    22b0:	de c0       	rjmp	.+444    	; 0x246e <MDIO_voidSetPinDirection+0x21a>
    {
        case PORTA:
        switch (A_u8Value)
    22b2:	8b 81       	ldd	r24, Y+3	; 0x03
    22b4:	28 2f       	mov	r18, r24
    22b6:	30 e0       	ldi	r19, 0x00	; 0
    22b8:	3b 87       	std	Y+11, r19	; 0x0b
    22ba:	2a 87       	std	Y+10, r18	; 0x0a
    22bc:	8a 85       	ldd	r24, Y+10	; 0x0a
    22be:	9b 85       	ldd	r25, Y+11	; 0x0b
    22c0:	00 97       	sbiw	r24, 0x00	; 0
    22c2:	d1 f0       	breq	.+52     	; 0x22f8 <MDIO_voidSetPinDirection+0xa4>
    22c4:	2a 85       	ldd	r18, Y+10	; 0x0a
    22c6:	3b 85       	ldd	r19, Y+11	; 0x0b
    22c8:	21 30       	cpi	r18, 0x01	; 1
    22ca:	31 05       	cpc	r19, r1
    22cc:	09 f0       	breq	.+2      	; 0x22d0 <MDIO_voidSetPinDirection+0x7c>
    22ce:	cf c0       	rjmp	.+414    	; 0x246e <MDIO_voidSetPinDirection+0x21a>
        {
            case PIN_OUTPUT: SET_BIT(DDRA_REG,A_u8Pin);
    22d0:	aa e3       	ldi	r26, 0x3A	; 58
    22d2:	b0 e0       	ldi	r27, 0x00	; 0
    22d4:	ea e3       	ldi	r30, 0x3A	; 58
    22d6:	f0 e0       	ldi	r31, 0x00	; 0
    22d8:	80 81       	ld	r24, Z
    22da:	48 2f       	mov	r20, r24
    22dc:	8a 81       	ldd	r24, Y+2	; 0x02
    22de:	28 2f       	mov	r18, r24
    22e0:	30 e0       	ldi	r19, 0x00	; 0
    22e2:	81 e0       	ldi	r24, 0x01	; 1
    22e4:	90 e0       	ldi	r25, 0x00	; 0
    22e6:	02 2e       	mov	r0, r18
    22e8:	02 c0       	rjmp	.+4      	; 0x22ee <MDIO_voidSetPinDirection+0x9a>
    22ea:	88 0f       	add	r24, r24
    22ec:	99 1f       	adc	r25, r25
    22ee:	0a 94       	dec	r0
    22f0:	e2 f7       	brpl	.-8      	; 0x22ea <MDIO_voidSetPinDirection+0x96>
    22f2:	84 2b       	or	r24, r20
    22f4:	8c 93       	st	X, r24
    22f6:	bb c0       	rjmp	.+374    	; 0x246e <MDIO_voidSetPinDirection+0x21a>
            break;

            case PIN_INPUT: CLR_BIT(DDRA_REG,A_u8Pin);
    22f8:	aa e3       	ldi	r26, 0x3A	; 58
    22fa:	b0 e0       	ldi	r27, 0x00	; 0
    22fc:	ea e3       	ldi	r30, 0x3A	; 58
    22fe:	f0 e0       	ldi	r31, 0x00	; 0
    2300:	80 81       	ld	r24, Z
    2302:	48 2f       	mov	r20, r24
    2304:	8a 81       	ldd	r24, Y+2	; 0x02
    2306:	28 2f       	mov	r18, r24
    2308:	30 e0       	ldi	r19, 0x00	; 0
    230a:	81 e0       	ldi	r24, 0x01	; 1
    230c:	90 e0       	ldi	r25, 0x00	; 0
    230e:	02 2e       	mov	r0, r18
    2310:	02 c0       	rjmp	.+4      	; 0x2316 <MDIO_voidSetPinDirection+0xc2>
    2312:	88 0f       	add	r24, r24
    2314:	99 1f       	adc	r25, r25
    2316:	0a 94       	dec	r0
    2318:	e2 f7       	brpl	.-8      	; 0x2312 <MDIO_voidSetPinDirection+0xbe>
    231a:	80 95       	com	r24
    231c:	84 23       	and	r24, r20
    231e:	8c 93       	st	X, r24
    2320:	a6 c0       	rjmp	.+332    	; 0x246e <MDIO_voidSetPinDirection+0x21a>
            break;
        };
        break;

        case PORTB:
        switch (A_u8Value)
    2322:	8b 81       	ldd	r24, Y+3	; 0x03
    2324:	28 2f       	mov	r18, r24
    2326:	30 e0       	ldi	r19, 0x00	; 0
    2328:	39 87       	std	Y+9, r19	; 0x09
    232a:	28 87       	std	Y+8, r18	; 0x08
    232c:	88 85       	ldd	r24, Y+8	; 0x08
    232e:	99 85       	ldd	r25, Y+9	; 0x09
    2330:	00 97       	sbiw	r24, 0x00	; 0
    2332:	d1 f0       	breq	.+52     	; 0x2368 <MDIO_voidSetPinDirection+0x114>
    2334:	28 85       	ldd	r18, Y+8	; 0x08
    2336:	39 85       	ldd	r19, Y+9	; 0x09
    2338:	21 30       	cpi	r18, 0x01	; 1
    233a:	31 05       	cpc	r19, r1
    233c:	09 f0       	breq	.+2      	; 0x2340 <MDIO_voidSetPinDirection+0xec>
    233e:	97 c0       	rjmp	.+302    	; 0x246e <MDIO_voidSetPinDirection+0x21a>
        {
            case PIN_OUTPUT: SET_BIT(DDRB_REG,A_u8Pin);
    2340:	a7 e3       	ldi	r26, 0x37	; 55
    2342:	b0 e0       	ldi	r27, 0x00	; 0
    2344:	e7 e3       	ldi	r30, 0x37	; 55
    2346:	f0 e0       	ldi	r31, 0x00	; 0
    2348:	80 81       	ld	r24, Z
    234a:	48 2f       	mov	r20, r24
    234c:	8a 81       	ldd	r24, Y+2	; 0x02
    234e:	28 2f       	mov	r18, r24
    2350:	30 e0       	ldi	r19, 0x00	; 0
    2352:	81 e0       	ldi	r24, 0x01	; 1
    2354:	90 e0       	ldi	r25, 0x00	; 0
    2356:	02 2e       	mov	r0, r18
    2358:	02 c0       	rjmp	.+4      	; 0x235e <MDIO_voidSetPinDirection+0x10a>
    235a:	88 0f       	add	r24, r24
    235c:	99 1f       	adc	r25, r25
    235e:	0a 94       	dec	r0
    2360:	e2 f7       	brpl	.-8      	; 0x235a <MDIO_voidSetPinDirection+0x106>
    2362:	84 2b       	or	r24, r20
    2364:	8c 93       	st	X, r24
    2366:	83 c0       	rjmp	.+262    	; 0x246e <MDIO_voidSetPinDirection+0x21a>
            break;

            case PIN_INPUT: CLR_BIT(DDRB_REG,A_u8Pin);
    2368:	a7 e3       	ldi	r26, 0x37	; 55
    236a:	b0 e0       	ldi	r27, 0x00	; 0
    236c:	e7 e3       	ldi	r30, 0x37	; 55
    236e:	f0 e0       	ldi	r31, 0x00	; 0
    2370:	80 81       	ld	r24, Z
    2372:	48 2f       	mov	r20, r24
    2374:	8a 81       	ldd	r24, Y+2	; 0x02
    2376:	28 2f       	mov	r18, r24
    2378:	30 e0       	ldi	r19, 0x00	; 0
    237a:	81 e0       	ldi	r24, 0x01	; 1
    237c:	90 e0       	ldi	r25, 0x00	; 0
    237e:	02 2e       	mov	r0, r18
    2380:	02 c0       	rjmp	.+4      	; 0x2386 <MDIO_voidSetPinDirection+0x132>
    2382:	88 0f       	add	r24, r24
    2384:	99 1f       	adc	r25, r25
    2386:	0a 94       	dec	r0
    2388:	e2 f7       	brpl	.-8      	; 0x2382 <MDIO_voidSetPinDirection+0x12e>
    238a:	80 95       	com	r24
    238c:	84 23       	and	r24, r20
    238e:	8c 93       	st	X, r24
    2390:	6e c0       	rjmp	.+220    	; 0x246e <MDIO_voidSetPinDirection+0x21a>
            break;
        };
        break;

        case PORTC:
        switch (A_u8Value)
    2392:	8b 81       	ldd	r24, Y+3	; 0x03
    2394:	28 2f       	mov	r18, r24
    2396:	30 e0       	ldi	r19, 0x00	; 0
    2398:	3f 83       	std	Y+7, r19	; 0x07
    239a:	2e 83       	std	Y+6, r18	; 0x06
    239c:	8e 81       	ldd	r24, Y+6	; 0x06
    239e:	9f 81       	ldd	r25, Y+7	; 0x07
    23a0:	00 97       	sbiw	r24, 0x00	; 0
    23a2:	d1 f0       	breq	.+52     	; 0x23d8 <MDIO_voidSetPinDirection+0x184>
    23a4:	2e 81       	ldd	r18, Y+6	; 0x06
    23a6:	3f 81       	ldd	r19, Y+7	; 0x07
    23a8:	21 30       	cpi	r18, 0x01	; 1
    23aa:	31 05       	cpc	r19, r1
    23ac:	09 f0       	breq	.+2      	; 0x23b0 <MDIO_voidSetPinDirection+0x15c>
    23ae:	5f c0       	rjmp	.+190    	; 0x246e <MDIO_voidSetPinDirection+0x21a>
        {
            case PIN_OUTPUT: SET_BIT(DDRC_REG,A_u8Pin);
    23b0:	a4 e3       	ldi	r26, 0x34	; 52
    23b2:	b0 e0       	ldi	r27, 0x00	; 0
    23b4:	e4 e3       	ldi	r30, 0x34	; 52
    23b6:	f0 e0       	ldi	r31, 0x00	; 0
    23b8:	80 81       	ld	r24, Z
    23ba:	48 2f       	mov	r20, r24
    23bc:	8a 81       	ldd	r24, Y+2	; 0x02
    23be:	28 2f       	mov	r18, r24
    23c0:	30 e0       	ldi	r19, 0x00	; 0
    23c2:	81 e0       	ldi	r24, 0x01	; 1
    23c4:	90 e0       	ldi	r25, 0x00	; 0
    23c6:	02 2e       	mov	r0, r18
    23c8:	02 c0       	rjmp	.+4      	; 0x23ce <MDIO_voidSetPinDirection+0x17a>
    23ca:	88 0f       	add	r24, r24
    23cc:	99 1f       	adc	r25, r25
    23ce:	0a 94       	dec	r0
    23d0:	e2 f7       	brpl	.-8      	; 0x23ca <MDIO_voidSetPinDirection+0x176>
    23d2:	84 2b       	or	r24, r20
    23d4:	8c 93       	st	X, r24
    23d6:	4b c0       	rjmp	.+150    	; 0x246e <MDIO_voidSetPinDirection+0x21a>
            break;

            case PIN_INPUT: CLR_BIT(DDRC_REG,A_u8Pin);
    23d8:	a4 e3       	ldi	r26, 0x34	; 52
    23da:	b0 e0       	ldi	r27, 0x00	; 0
    23dc:	e4 e3       	ldi	r30, 0x34	; 52
    23de:	f0 e0       	ldi	r31, 0x00	; 0
    23e0:	80 81       	ld	r24, Z
    23e2:	48 2f       	mov	r20, r24
    23e4:	8a 81       	ldd	r24, Y+2	; 0x02
    23e6:	28 2f       	mov	r18, r24
    23e8:	30 e0       	ldi	r19, 0x00	; 0
    23ea:	81 e0       	ldi	r24, 0x01	; 1
    23ec:	90 e0       	ldi	r25, 0x00	; 0
    23ee:	02 2e       	mov	r0, r18
    23f0:	02 c0       	rjmp	.+4      	; 0x23f6 <MDIO_voidSetPinDirection+0x1a2>
    23f2:	88 0f       	add	r24, r24
    23f4:	99 1f       	adc	r25, r25
    23f6:	0a 94       	dec	r0
    23f8:	e2 f7       	brpl	.-8      	; 0x23f2 <MDIO_voidSetPinDirection+0x19e>
    23fa:	80 95       	com	r24
    23fc:	84 23       	and	r24, r20
    23fe:	8c 93       	st	X, r24
    2400:	36 c0       	rjmp	.+108    	; 0x246e <MDIO_voidSetPinDirection+0x21a>
            break;
        };
        break;

        case PORTD:
        switch (A_u8Value)
    2402:	8b 81       	ldd	r24, Y+3	; 0x03
    2404:	28 2f       	mov	r18, r24
    2406:	30 e0       	ldi	r19, 0x00	; 0
    2408:	3d 83       	std	Y+5, r19	; 0x05
    240a:	2c 83       	std	Y+4, r18	; 0x04
    240c:	8c 81       	ldd	r24, Y+4	; 0x04
    240e:	9d 81       	ldd	r25, Y+5	; 0x05
    2410:	00 97       	sbiw	r24, 0x00	; 0
    2412:	c9 f0       	breq	.+50     	; 0x2446 <MDIO_voidSetPinDirection+0x1f2>
    2414:	2c 81       	ldd	r18, Y+4	; 0x04
    2416:	3d 81       	ldd	r19, Y+5	; 0x05
    2418:	21 30       	cpi	r18, 0x01	; 1
    241a:	31 05       	cpc	r19, r1
    241c:	41 f5       	brne	.+80     	; 0x246e <MDIO_voidSetPinDirection+0x21a>
        {
            case PIN_OUTPUT: SET_BIT(DDRD_REG,A_u8Pin);
    241e:	a1 e3       	ldi	r26, 0x31	; 49
    2420:	b0 e0       	ldi	r27, 0x00	; 0
    2422:	e1 e3       	ldi	r30, 0x31	; 49
    2424:	f0 e0       	ldi	r31, 0x00	; 0
    2426:	80 81       	ld	r24, Z
    2428:	48 2f       	mov	r20, r24
    242a:	8a 81       	ldd	r24, Y+2	; 0x02
    242c:	28 2f       	mov	r18, r24
    242e:	30 e0       	ldi	r19, 0x00	; 0
    2430:	81 e0       	ldi	r24, 0x01	; 1
    2432:	90 e0       	ldi	r25, 0x00	; 0
    2434:	02 2e       	mov	r0, r18
    2436:	02 c0       	rjmp	.+4      	; 0x243c <MDIO_voidSetPinDirection+0x1e8>
    2438:	88 0f       	add	r24, r24
    243a:	99 1f       	adc	r25, r25
    243c:	0a 94       	dec	r0
    243e:	e2 f7       	brpl	.-8      	; 0x2438 <MDIO_voidSetPinDirection+0x1e4>
    2440:	84 2b       	or	r24, r20
    2442:	8c 93       	st	X, r24
    2444:	14 c0       	rjmp	.+40     	; 0x246e <MDIO_voidSetPinDirection+0x21a>
            break;

            case PIN_INPUT: CLR_BIT(DDRD_REG,A_u8Pin);
    2446:	a1 e3       	ldi	r26, 0x31	; 49
    2448:	b0 e0       	ldi	r27, 0x00	; 0
    244a:	e1 e3       	ldi	r30, 0x31	; 49
    244c:	f0 e0       	ldi	r31, 0x00	; 0
    244e:	80 81       	ld	r24, Z
    2450:	48 2f       	mov	r20, r24
    2452:	8a 81       	ldd	r24, Y+2	; 0x02
    2454:	28 2f       	mov	r18, r24
    2456:	30 e0       	ldi	r19, 0x00	; 0
    2458:	81 e0       	ldi	r24, 0x01	; 1
    245a:	90 e0       	ldi	r25, 0x00	; 0
    245c:	02 2e       	mov	r0, r18
    245e:	02 c0       	rjmp	.+4      	; 0x2464 <MDIO_voidSetPinDirection+0x210>
    2460:	88 0f       	add	r24, r24
    2462:	99 1f       	adc	r25, r25
    2464:	0a 94       	dec	r0
    2466:	e2 f7       	brpl	.-8      	; 0x2460 <MDIO_voidSetPinDirection+0x20c>
    2468:	80 95       	com	r24
    246a:	84 23       	and	r24, r20
    246c:	8c 93       	st	X, r24
            break;
        };
        break;
    }
}
    246e:	2d 96       	adiw	r28, 0x0d	; 13
    2470:	0f b6       	in	r0, 0x3f	; 63
    2472:	f8 94       	cli
    2474:	de bf       	out	0x3e, r29	; 62
    2476:	0f be       	out	0x3f, r0	; 63
    2478:	cd bf       	out	0x3d, r28	; 61
    247a:	cf 91       	pop	r28
    247c:	df 91       	pop	r29
    247e:	08 95       	ret

00002480 <MDIO_voidSetPortValue>:


void MDIO_voidSetPortValue(u8 A_u8Port,u8 A_u8Value)
{
    2480:	df 93       	push	r29
    2482:	cf 93       	push	r28
    2484:	00 d0       	rcall	.+0      	; 0x2486 <MDIO_voidSetPortValue+0x6>
    2486:	00 d0       	rcall	.+0      	; 0x2488 <MDIO_voidSetPortValue+0x8>
    2488:	cd b7       	in	r28, 0x3d	; 61
    248a:	de b7       	in	r29, 0x3e	; 62
    248c:	89 83       	std	Y+1, r24	; 0x01
    248e:	6a 83       	std	Y+2, r22	; 0x02
    switch(A_u8Port)
    2490:	89 81       	ldd	r24, Y+1	; 0x01
    2492:	28 2f       	mov	r18, r24
    2494:	30 e0       	ldi	r19, 0x00	; 0
    2496:	3c 83       	std	Y+4, r19	; 0x04
    2498:	2b 83       	std	Y+3, r18	; 0x03
    249a:	8b 81       	ldd	r24, Y+3	; 0x03
    249c:	9c 81       	ldd	r25, Y+4	; 0x04
    249e:	81 30       	cpi	r24, 0x01	; 1
    24a0:	91 05       	cpc	r25, r1
    24a2:	d1 f0       	breq	.+52     	; 0x24d8 <MDIO_voidSetPortValue+0x58>
    24a4:	2b 81       	ldd	r18, Y+3	; 0x03
    24a6:	3c 81       	ldd	r19, Y+4	; 0x04
    24a8:	22 30       	cpi	r18, 0x02	; 2
    24aa:	31 05       	cpc	r19, r1
    24ac:	2c f4       	brge	.+10     	; 0x24b8 <MDIO_voidSetPortValue+0x38>
    24ae:	8b 81       	ldd	r24, Y+3	; 0x03
    24b0:	9c 81       	ldd	r25, Y+4	; 0x04
    24b2:	00 97       	sbiw	r24, 0x00	; 0
    24b4:	61 f0       	breq	.+24     	; 0x24ce <MDIO_voidSetPortValue+0x4e>
    24b6:	1e c0       	rjmp	.+60     	; 0x24f4 <MDIO_voidSetPortValue+0x74>
    24b8:	2b 81       	ldd	r18, Y+3	; 0x03
    24ba:	3c 81       	ldd	r19, Y+4	; 0x04
    24bc:	22 30       	cpi	r18, 0x02	; 2
    24be:	31 05       	cpc	r19, r1
    24c0:	81 f0       	breq	.+32     	; 0x24e2 <MDIO_voidSetPortValue+0x62>
    24c2:	8b 81       	ldd	r24, Y+3	; 0x03
    24c4:	9c 81       	ldd	r25, Y+4	; 0x04
    24c6:	83 30       	cpi	r24, 0x03	; 3
    24c8:	91 05       	cpc	r25, r1
    24ca:	81 f0       	breq	.+32     	; 0x24ec <MDIO_voidSetPortValue+0x6c>
    24cc:	13 c0       	rjmp	.+38     	; 0x24f4 <MDIO_voidSetPortValue+0x74>
    {
        case PORTA:PORTA_REG=A_u8Value;
    24ce:	eb e3       	ldi	r30, 0x3B	; 59
    24d0:	f0 e0       	ldi	r31, 0x00	; 0
    24d2:	8a 81       	ldd	r24, Y+2	; 0x02
    24d4:	80 83       	st	Z, r24
    24d6:	0e c0       	rjmp	.+28     	; 0x24f4 <MDIO_voidSetPortValue+0x74>
        break;
        case PORTB:PORTB_REG=A_u8Value;
    24d8:	e8 e3       	ldi	r30, 0x38	; 56
    24da:	f0 e0       	ldi	r31, 0x00	; 0
    24dc:	8a 81       	ldd	r24, Y+2	; 0x02
    24de:	80 83       	st	Z, r24
    24e0:	09 c0       	rjmp	.+18     	; 0x24f4 <MDIO_voidSetPortValue+0x74>
        break;
        case PORTC:PORTC_REG=A_u8Value;
    24e2:	e5 e3       	ldi	r30, 0x35	; 53
    24e4:	f0 e0       	ldi	r31, 0x00	; 0
    24e6:	8a 81       	ldd	r24, Y+2	; 0x02
    24e8:	80 83       	st	Z, r24
    24ea:	04 c0       	rjmp	.+8      	; 0x24f4 <MDIO_voidSetPortValue+0x74>
        break;
        case PORTD:PORTD_REG=A_u8Value;
    24ec:	e2 e3       	ldi	r30, 0x32	; 50
    24ee:	f0 e0       	ldi	r31, 0x00	; 0
    24f0:	8a 81       	ldd	r24, Y+2	; 0x02
    24f2:	80 83       	st	Z, r24
        break;
    }
}
    24f4:	0f 90       	pop	r0
    24f6:	0f 90       	pop	r0
    24f8:	0f 90       	pop	r0
    24fa:	0f 90       	pop	r0
    24fc:	cf 91       	pop	r28
    24fe:	df 91       	pop	r29
    2500:	08 95       	ret

00002502 <MDIO_voidSetPortDirection>:

void MDIO_voidSetPortDirection(u8 A_u8Port,u8 A_u8Value)
{
    2502:	df 93       	push	r29
    2504:	cf 93       	push	r28
    2506:	00 d0       	rcall	.+0      	; 0x2508 <MDIO_voidSetPortDirection+0x6>
    2508:	00 d0       	rcall	.+0      	; 0x250a <MDIO_voidSetPortDirection+0x8>
    250a:	cd b7       	in	r28, 0x3d	; 61
    250c:	de b7       	in	r29, 0x3e	; 62
    250e:	89 83       	std	Y+1, r24	; 0x01
    2510:	6a 83       	std	Y+2, r22	; 0x02
    switch(A_u8Port)
    2512:	89 81       	ldd	r24, Y+1	; 0x01
    2514:	28 2f       	mov	r18, r24
    2516:	30 e0       	ldi	r19, 0x00	; 0
    2518:	3c 83       	std	Y+4, r19	; 0x04
    251a:	2b 83       	std	Y+3, r18	; 0x03
    251c:	8b 81       	ldd	r24, Y+3	; 0x03
    251e:	9c 81       	ldd	r25, Y+4	; 0x04
    2520:	81 30       	cpi	r24, 0x01	; 1
    2522:	91 05       	cpc	r25, r1
    2524:	d1 f0       	breq	.+52     	; 0x255a <MDIO_voidSetPortDirection+0x58>
    2526:	2b 81       	ldd	r18, Y+3	; 0x03
    2528:	3c 81       	ldd	r19, Y+4	; 0x04
    252a:	22 30       	cpi	r18, 0x02	; 2
    252c:	31 05       	cpc	r19, r1
    252e:	2c f4       	brge	.+10     	; 0x253a <MDIO_voidSetPortDirection+0x38>
    2530:	8b 81       	ldd	r24, Y+3	; 0x03
    2532:	9c 81       	ldd	r25, Y+4	; 0x04
    2534:	00 97       	sbiw	r24, 0x00	; 0
    2536:	61 f0       	breq	.+24     	; 0x2550 <MDIO_voidSetPortDirection+0x4e>
    2538:	1e c0       	rjmp	.+60     	; 0x2576 <MDIO_voidSetPortDirection+0x74>
    253a:	2b 81       	ldd	r18, Y+3	; 0x03
    253c:	3c 81       	ldd	r19, Y+4	; 0x04
    253e:	22 30       	cpi	r18, 0x02	; 2
    2540:	31 05       	cpc	r19, r1
    2542:	81 f0       	breq	.+32     	; 0x2564 <MDIO_voidSetPortDirection+0x62>
    2544:	8b 81       	ldd	r24, Y+3	; 0x03
    2546:	9c 81       	ldd	r25, Y+4	; 0x04
    2548:	83 30       	cpi	r24, 0x03	; 3
    254a:	91 05       	cpc	r25, r1
    254c:	81 f0       	breq	.+32     	; 0x256e <MDIO_voidSetPortDirection+0x6c>
    254e:	13 c0       	rjmp	.+38     	; 0x2576 <MDIO_voidSetPortDirection+0x74>
    {
        case PORTA:DDRA_REG=A_u8Value;
    2550:	ea e3       	ldi	r30, 0x3A	; 58
    2552:	f0 e0       	ldi	r31, 0x00	; 0
    2554:	8a 81       	ldd	r24, Y+2	; 0x02
    2556:	80 83       	st	Z, r24
    2558:	0e c0       	rjmp	.+28     	; 0x2576 <MDIO_voidSetPortDirection+0x74>
        break;
        case PORTB:DDRB_REG=A_u8Value;
    255a:	e7 e3       	ldi	r30, 0x37	; 55
    255c:	f0 e0       	ldi	r31, 0x00	; 0
    255e:	8a 81       	ldd	r24, Y+2	; 0x02
    2560:	80 83       	st	Z, r24
    2562:	09 c0       	rjmp	.+18     	; 0x2576 <MDIO_voidSetPortDirection+0x74>
        break;
        case PORTC:DDRC_REG=A_u8Value;
    2564:	e4 e3       	ldi	r30, 0x34	; 52
    2566:	f0 e0       	ldi	r31, 0x00	; 0
    2568:	8a 81       	ldd	r24, Y+2	; 0x02
    256a:	80 83       	st	Z, r24
    256c:	04 c0       	rjmp	.+8      	; 0x2576 <MDIO_voidSetPortDirection+0x74>
        break;
        case PORTD:DDRD_REG=A_u8Value;
    256e:	e1 e3       	ldi	r30, 0x31	; 49
    2570:	f0 e0       	ldi	r31, 0x00	; 0
    2572:	8a 81       	ldd	r24, Y+2	; 0x02
    2574:	80 83       	st	Z, r24
        break;
    }
    2576:	0f 90       	pop	r0
    2578:	0f 90       	pop	r0
    257a:	0f 90       	pop	r0
    257c:	0f 90       	pop	r0
    257e:	cf 91       	pop	r28
    2580:	df 91       	pop	r29
    2582:	08 95       	ret

00002584 <HEEPROM_voidWriteInit>:
    A1 & A0: they will be addressed using hardware also but to express software address

*/

TWI_STATUS HEEPROM_voidWriteInit(u8 A_u8MemoryNumber, u16 A_u8MemoryAdress)
{
    2584:	df 93       	push	r29
    2586:	cf 93       	push	r28
    2588:	00 d0       	rcall	.+0      	; 0x258a <HEEPROM_voidWriteInit+0x6>
    258a:	00 d0       	rcall	.+0      	; 0x258c <HEEPROM_voidWriteInit+0x8>
    258c:	00 d0       	rcall	.+0      	; 0x258e <HEEPROM_voidWriteInit+0xa>
    258e:	cd b7       	in	r28, 0x3d	; 61
    2590:	de b7       	in	r29, 0x3e	; 62
    2592:	8b 83       	std	Y+3, r24	; 0x03
    2594:	7d 83       	std	Y+5, r23	; 0x05
    2596:	6c 83       	std	Y+4, r22	; 0x04
    TWI_STATUS stuatus = TWI_OK;
    2598:	1a 82       	std	Y+2, r1	; 0x02
    // A_u8MemoryNumber: it could be 0 or 1 only
    // A_u8MemoryAdress: 0b 98 7654 3210
    u8 local_u8slaveAddress = EEPROM_ADD_MASK | (A_u8MemoryAdress >> 7) | (A_u8MemoryNumber);
    259a:	8c 81       	ldd	r24, Y+4	; 0x04
    259c:	9d 81       	ldd	r25, Y+5	; 0x05
    259e:	88 0f       	add	r24, r24
    25a0:	89 2f       	mov	r24, r25
    25a2:	88 1f       	adc	r24, r24
    25a4:	99 0b       	sbc	r25, r25
    25a6:	91 95       	neg	r25
    25a8:	98 2f       	mov	r25, r24
    25aa:	8b 81       	ldd	r24, Y+3	; 0x03
    25ac:	89 2b       	or	r24, r25
    25ae:	80 65       	ori	r24, 0x50	; 80
    25b0:	89 83       	std	Y+1, r24	; 0x01
    // 01- Send START condition
    stuatus = MTWI_u8Start();
    25b2:	0e 94 41 39 	call	0x7282	; 0x7282 <MTWI_u8Start>
    25b6:	8a 83       	std	Y+2, r24	; 0x02
    if (stuatus != TWI_OK)
    25b8:	8a 81       	ldd	r24, Y+2	; 0x02
    25ba:	88 23       	and	r24, r24
    25bc:	19 f0       	breq	.+6      	; 0x25c4 <HEEPROM_voidWriteInit+0x40>
        return stuatus;
    25be:	8a 81       	ldd	r24, Y+2	; 0x02
    25c0:	8e 83       	std	Y+6, r24	; 0x06
    25c2:	16 c0       	rjmp	.+44     	; 0x25f0 <HEEPROM_voidWriteInit+0x6c>

    // 02- Send Slave Address
    stuatus = MTWI_u8SendSlaveAddWrite(local_u8slaveAddress); // A2:0 A1:0 A:0
    25c4:	89 81       	ldd	r24, Y+1	; 0x01
    25c6:	0e 94 6c 39 	call	0x72d8	; 0x72d8 <MTWI_u8SendSlaveAddWrite>
    25ca:	8a 83       	std	Y+2, r24	; 0x02
    if (stuatus != TWI_OK)
    25cc:	8a 81       	ldd	r24, Y+2	; 0x02
    25ce:	88 23       	and	r24, r24
    25d0:	19 f0       	breq	.+6      	; 0x25d8 <HEEPROM_voidWriteInit+0x54>
        return stuatus;
    25d2:	8a 81       	ldd	r24, Y+2	; 0x02
    25d4:	8e 83       	std	Y+6, r24	; 0x06
    25d6:	0c c0       	rjmp	.+24     	; 0x25f0 <HEEPROM_voidWriteInit+0x6c>

    // 03- send the rest of address
    stuatus = MTWI_u8SendData((u8)A_u8MemoryAdress);
    25d8:	8c 81       	ldd	r24, Y+4	; 0x04
    25da:	0e 94 9d 39 	call	0x733a	; 0x733a <MTWI_u8SendData>
    25de:	8a 83       	std	Y+2, r24	; 0x02
    if (stuatus != TWI_OK)
    25e0:	8a 81       	ldd	r24, Y+2	; 0x02
    25e2:	88 23       	and	r24, r24
    25e4:	19 f0       	breq	.+6      	; 0x25ec <HEEPROM_voidWriteInit+0x68>
        return stuatus;
    25e6:	8a 81       	ldd	r24, Y+2	; 0x02
    25e8:	8e 83       	std	Y+6, r24	; 0x06
    25ea:	02 c0       	rjmp	.+4      	; 0x25f0 <HEEPROM_voidWriteInit+0x6c>
    return stuatus;
    25ec:	8a 81       	ldd	r24, Y+2	; 0x02
    25ee:	8e 83       	std	Y+6, r24	; 0x06
    25f0:	8e 81       	ldd	r24, Y+6	; 0x06
}
    25f2:	26 96       	adiw	r28, 0x06	; 6
    25f4:	0f b6       	in	r0, 0x3f	; 63
    25f6:	f8 94       	cli
    25f8:	de bf       	out	0x3e, r29	; 62
    25fa:	0f be       	out	0x3f, r0	; 63
    25fc:	cd bf       	out	0x3d, r28	; 61
    25fe:	cf 91       	pop	r28
    2600:	df 91       	pop	r29
    2602:	08 95       	ret

00002604 <HEEPROM_voidSendData>:

TWI_STATUS HEEPROM_voidSendData(u8 A_u8Data)
{
    2604:	df 93       	push	r29
    2606:	cf 93       	push	r28
    2608:	00 d0       	rcall	.+0      	; 0x260a <HEEPROM_voidSendData+0x6>
    260a:	cd b7       	in	r28, 0x3d	; 61
    260c:	de b7       	in	r29, 0x3e	; 62
    260e:	8a 83       	std	Y+2, r24	; 0x02
    TWI_STATUS stuatus = TWI_OK;
    2610:	19 82       	std	Y+1, r1	; 0x01
    // 04- sned byte
    stuatus = MTWI_u8SendData(A_u8Data);
    2612:	8a 81       	ldd	r24, Y+2	; 0x02
    2614:	0e 94 9d 39 	call	0x733a	; 0x733a <MTWI_u8SendData>
    2618:	89 83       	std	Y+1, r24	; 0x01
    return stuatus;
    261a:	89 81       	ldd	r24, Y+1	; 0x01
}
    261c:	0f 90       	pop	r0
    261e:	0f 90       	pop	r0
    2620:	cf 91       	pop	r28
    2622:	df 91       	pop	r29
    2624:	08 95       	ret

00002626 <HEEPROM_voidReadInit>:

TWI_STATUS HEEPROM_voidReadInit(u8 A_u8MemoryNumber, u16 A_u8MemoryAdress)
{
    2626:	df 93       	push	r29
    2628:	cf 93       	push	r28
    262a:	00 d0       	rcall	.+0      	; 0x262c <HEEPROM_voidReadInit+0x6>
    262c:	00 d0       	rcall	.+0      	; 0x262e <HEEPROM_voidReadInit+0x8>
    262e:	00 d0       	rcall	.+0      	; 0x2630 <HEEPROM_voidReadInit+0xa>
    2630:	cd b7       	in	r28, 0x3d	; 61
    2632:	de b7       	in	r29, 0x3e	; 62
    2634:	8b 83       	std	Y+3, r24	; 0x03
    2636:	7d 83       	std	Y+5, r23	; 0x05
    2638:	6c 83       	std	Y+4, r22	; 0x04
    TWI_STATUS stuatus = TWI_OK;
    263a:	1a 82       	std	Y+2, r1	; 0x02
    // A_u8MemoryNumber: it could be 0 or 1 only
    // A_u8MemoryAdress: 0b 98 7654 3210
    u8 local_u8slaveAddress = 0b01010000 | (A_u8MemoryAdress >> 7) | (A_u8MemoryNumber);
    263c:	8c 81       	ldd	r24, Y+4	; 0x04
    263e:	9d 81       	ldd	r25, Y+5	; 0x05
    2640:	88 0f       	add	r24, r24
    2642:	89 2f       	mov	r24, r25
    2644:	88 1f       	adc	r24, r24
    2646:	99 0b       	sbc	r25, r25
    2648:	91 95       	neg	r25
    264a:	98 2f       	mov	r25, r24
    264c:	8b 81       	ldd	r24, Y+3	; 0x03
    264e:	89 2b       	or	r24, r25
    2650:	80 65       	ori	r24, 0x50	; 80
    2652:	89 83       	std	Y+1, r24	; 0x01

    // 01- Send START condition
    stuatus = MTWI_u8Start();
    2654:	0e 94 41 39 	call	0x7282	; 0x7282 <MTWI_u8Start>
    2658:	8a 83       	std	Y+2, r24	; 0x02
    if (stuatus != TWI_OK)
    265a:	8a 81       	ldd	r24, Y+2	; 0x02
    265c:	88 23       	and	r24, r24
    265e:	19 f0       	breq	.+6      	; 0x2666 <HEEPROM_voidReadInit+0x40>
        return stuatus;
    2660:	8a 81       	ldd	r24, Y+2	; 0x02
    2662:	8e 83       	std	Y+6, r24	; 0x06
    2664:	29 c0       	rjmp	.+82     	; 0x26b8 <HEEPROM_voidReadInit+0x92>

    // 02- Send Slave Address
    stuatus = MTWI_u8SendSlaveAddWrite(local_u8slaveAddress); // A2:0 A1:0 A:0
    2666:	89 81       	ldd	r24, Y+1	; 0x01
    2668:	0e 94 6c 39 	call	0x72d8	; 0x72d8 <MTWI_u8SendSlaveAddWrite>
    266c:	8a 83       	std	Y+2, r24	; 0x02
    if (stuatus != TWI_OK)
    266e:	8a 81       	ldd	r24, Y+2	; 0x02
    2670:	88 23       	and	r24, r24
    2672:	19 f0       	breq	.+6      	; 0x267a <HEEPROM_voidReadInit+0x54>
        return stuatus;
    2674:	8a 81       	ldd	r24, Y+2	; 0x02
    2676:	8e 83       	std	Y+6, r24	; 0x06
    2678:	1f c0       	rjmp	.+62     	; 0x26b8 <HEEPROM_voidReadInit+0x92>

    // 03- send the rest of address
    stuatus = MTWI_u8SendData((u8)A_u8MemoryAdress);
    267a:	8c 81       	ldd	r24, Y+4	; 0x04
    267c:	0e 94 9d 39 	call	0x733a	; 0x733a <MTWI_u8SendData>
    2680:	8a 83       	std	Y+2, r24	; 0x02
    if (stuatus != TWI_OK)
    2682:	8a 81       	ldd	r24, Y+2	; 0x02
    2684:	88 23       	and	r24, r24
    2686:	19 f0       	breq	.+6      	; 0x268e <HEEPROM_voidReadInit+0x68>
        return stuatus;
    2688:	8a 81       	ldd	r24, Y+2	; 0x02
    268a:	8e 83       	std	Y+6, r24	; 0x06
    268c:	15 c0       	rjmp	.+42     	; 0x26b8 <HEEPROM_voidReadInit+0x92>

    // 04-Repeated Start to Initate
    stuatus = MTWI_u8SendReStart();
    268e:	0e 94 ce 39 	call	0x739c	; 0x739c <MTWI_u8SendReStart>
    2692:	8a 83       	std	Y+2, r24	; 0x02
    if (stuatus != TWI_OK)
    2694:	8a 81       	ldd	r24, Y+2	; 0x02
    2696:	88 23       	and	r24, r24
    2698:	19 f0       	breq	.+6      	; 0x26a0 <HEEPROM_voidReadInit+0x7a>
        return stuatus;
    269a:	8a 81       	ldd	r24, Y+2	; 0x02
    269c:	8e 83       	std	Y+6, r24	; 0x06
    269e:	0c c0       	rjmp	.+24     	; 0x26b8 <HEEPROM_voidReadInit+0x92>

    // 05- send slave address again but with read command
    stuatus = MTWI_u8SendSlaveAddRead(local_u8slaveAddress);
    26a0:	89 81       	ldd	r24, Y+1	; 0x01
    26a2:	0e 94 f9 39 	call	0x73f2	; 0x73f2 <MTWI_u8SendSlaveAddRead>
    26a6:	8a 83       	std	Y+2, r24	; 0x02
    if (stuatus != TWI_OK)
    26a8:	8a 81       	ldd	r24, Y+2	; 0x02
    26aa:	88 23       	and	r24, r24
    26ac:	19 f0       	breq	.+6      	; 0x26b4 <HEEPROM_voidReadInit+0x8e>
        return stuatus;
    26ae:	8a 81       	ldd	r24, Y+2	; 0x02
    26b0:	8e 83       	std	Y+6, r24	; 0x06
    26b2:	02 c0       	rjmp	.+4      	; 0x26b8 <HEEPROM_voidReadInit+0x92>
    return stuatus;
    26b4:	8a 81       	ldd	r24, Y+2	; 0x02
    26b6:	8e 83       	std	Y+6, r24	; 0x06
    26b8:	8e 81       	ldd	r24, Y+6	; 0x06
}
    26ba:	26 96       	adiw	r28, 0x06	; 6
    26bc:	0f b6       	in	r0, 0x3f	; 63
    26be:	f8 94       	cli
    26c0:	de bf       	out	0x3e, r29	; 62
    26c2:	0f be       	out	0x3f, r0	; 63
    26c4:	cd bf       	out	0x3d, r28	; 61
    26c6:	cf 91       	pop	r28
    26c8:	df 91       	pop	r29
    26ca:	08 95       	ret

000026cc <HEEPROM_u8ReadData>:

TWI_STATUS HEEPROM_u8ReadData(u8 *A_u8Data, u8 ack)
{
    26cc:	df 93       	push	r29
    26ce:	cf 93       	push	r28
    26d0:	00 d0       	rcall	.+0      	; 0x26d2 <HEEPROM_u8ReadData+0x6>
    26d2:	00 d0       	rcall	.+0      	; 0x26d4 <HEEPROM_u8ReadData+0x8>
    26d4:	cd b7       	in	r28, 0x3d	; 61
    26d6:	de b7       	in	r29, 0x3e	; 62
    26d8:	9b 83       	std	Y+3, r25	; 0x03
    26da:	8a 83       	std	Y+2, r24	; 0x02
    26dc:	6c 83       	std	Y+4, r22	; 0x04
    TWI_STATUS stuatus = TWI_OK;
    26de:	19 82       	std	Y+1, r1	; 0x01
    // 04- sned byte
    stuatus = MTWI_u8ReadData(ack, &A_u8Data);
    26e0:	9e 01       	movw	r18, r28
    26e2:	2e 5f       	subi	r18, 0xFE	; 254
    26e4:	3f 4f       	sbci	r19, 0xFF	; 255
    26e6:	8c 81       	ldd	r24, Y+4	; 0x04
    26e8:	b9 01       	movw	r22, r18
    26ea:	0e 94 2f 3a 	call	0x745e	; 0x745e <MTWI_u8ReadData>
    26ee:	89 83       	std	Y+1, r24	; 0x01
    return stuatus;
    26f0:	89 81       	ldd	r24, Y+1	; 0x01
}
    26f2:	0f 90       	pop	r0
    26f4:	0f 90       	pop	r0
    26f6:	0f 90       	pop	r0
    26f8:	0f 90       	pop	r0
    26fa:	cf 91       	pop	r28
    26fc:	df 91       	pop	r29
    26fe:	08 95       	ret

00002700 <HEEPROM_voidSendStop>:

void HEEPROM_voidSendStop()
{
    2700:	df 93       	push	r29
    2702:	cf 93       	push	r28
    2704:	cd b7       	in	r28, 0x3d	; 61
    2706:	de b7       	in	r29, 0x3e	; 62
    MTWI_voidStop();
    2708:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <MTWI_voidStop>
    270c:	cf 91       	pop	r28
    270e:	df 91       	pop	r29
    2710:	08 95       	ret

00002712 <MEXTI_voidConfig>:
static void (*EXTI0_CallBack)(void)=NULLPTR;
static void (*EXTI1_CallBack)(void)=NULLPTR;
static void (*EXTI2_CallBack)(void)=NULLPTR;

void MEXTI_voidConfig(u8 A_u8EXTINo,u8 A_u8SenseMode)
{
    2712:	df 93       	push	r29
    2714:	cf 93       	push	r28
    2716:	00 d0       	rcall	.+0      	; 0x2718 <MEXTI_voidConfig+0x6>
    2718:	00 d0       	rcall	.+0      	; 0x271a <MEXTI_voidConfig+0x8>
    271a:	00 d0       	rcall	.+0      	; 0x271c <MEXTI_voidConfig+0xa>
    271c:	cd b7       	in	r28, 0x3d	; 61
    271e:	de b7       	in	r29, 0x3e	; 62
    2720:	89 83       	std	Y+1, r24	; 0x01
    2722:	6a 83       	std	Y+2, r22	; 0x02
    if(A_u8SenseMode <4)
    2724:	8a 81       	ldd	r24, Y+2	; 0x02
    2726:	84 30       	cpi	r24, 0x04	; 4
    2728:	08 f0       	brcs	.+2      	; 0x272c <MEXTI_voidConfig+0x1a>
    272a:	5a c0       	rjmp	.+180    	; 0x27e0 <MEXTI_voidConfig+0xce>
    {
        switch (A_u8EXTINo)
    272c:	89 81       	ldd	r24, Y+1	; 0x01
    272e:	28 2f       	mov	r18, r24
    2730:	30 e0       	ldi	r19, 0x00	; 0
    2732:	3e 83       	std	Y+6, r19	; 0x06
    2734:	2d 83       	std	Y+5, r18	; 0x05
    2736:	8d 81       	ldd	r24, Y+5	; 0x05
    2738:	9e 81       	ldd	r25, Y+6	; 0x06
    273a:	81 30       	cpi	r24, 0x01	; 1
    273c:	91 05       	cpc	r25, r1
    273e:	d1 f0       	breq	.+52     	; 0x2774 <MEXTI_voidConfig+0x62>
    2740:	2d 81       	ldd	r18, Y+5	; 0x05
    2742:	3e 81       	ldd	r19, Y+6	; 0x06
    2744:	22 30       	cpi	r18, 0x02	; 2
    2746:	31 05       	cpc	r19, r1
    2748:	61 f1       	breq	.+88     	; 0x27a2 <MEXTI_voidConfig+0x90>
    274a:	8d 81       	ldd	r24, Y+5	; 0x05
    274c:	9e 81       	ldd	r25, Y+6	; 0x06
    274e:	00 97       	sbiw	r24, 0x00	; 0
    2750:	09 f0       	breq	.+2      	; 0x2754 <MEXTI_voidConfig+0x42>
    2752:	46 c0       	rjmp	.+140    	; 0x27e0 <MEXTI_voidConfig+0xce>
        {
            case EXTI0:
            MCUCR &=~(SENSE_MODE_MASK<<ISC00); //clearing bits
    2754:	a5 e5       	ldi	r26, 0x55	; 85
    2756:	b0 e0       	ldi	r27, 0x00	; 0
    2758:	e5 e5       	ldi	r30, 0x55	; 85
    275a:	f0 e0       	ldi	r31, 0x00	; 0
    275c:	80 81       	ld	r24, Z
    275e:	8c 7f       	andi	r24, 0xFC	; 252
    2760:	8c 93       	st	X, r24
            MCUCR |=(A_u8SenseMode<<ISC00); //puting values
    2762:	a5 e5       	ldi	r26, 0x55	; 85
    2764:	b0 e0       	ldi	r27, 0x00	; 0
    2766:	e5 e5       	ldi	r30, 0x55	; 85
    2768:	f0 e0       	ldi	r31, 0x00	; 0
    276a:	90 81       	ld	r25, Z
    276c:	8a 81       	ldd	r24, Y+2	; 0x02
    276e:	89 2b       	or	r24, r25
    2770:	8c 93       	st	X, r24
    2772:	36 c0       	rjmp	.+108    	; 0x27e0 <MEXTI_voidConfig+0xce>
            break;

            case EXTI1:
            MCUCR &=~(SENSE_MODE_MASK<<ISC10); //clearing bits
    2774:	a5 e5       	ldi	r26, 0x55	; 85
    2776:	b0 e0       	ldi	r27, 0x00	; 0
    2778:	e5 e5       	ldi	r30, 0x55	; 85
    277a:	f0 e0       	ldi	r31, 0x00	; 0
    277c:	80 81       	ld	r24, Z
    277e:	83 7f       	andi	r24, 0xF3	; 243
    2780:	8c 93       	st	X, r24
            MCUCR |=(A_u8SenseMode<<ISC10); //puting values
    2782:	a5 e5       	ldi	r26, 0x55	; 85
    2784:	b0 e0       	ldi	r27, 0x00	; 0
    2786:	e5 e5       	ldi	r30, 0x55	; 85
    2788:	f0 e0       	ldi	r31, 0x00	; 0
    278a:	80 81       	ld	r24, Z
    278c:	28 2f       	mov	r18, r24
    278e:	8a 81       	ldd	r24, Y+2	; 0x02
    2790:	88 2f       	mov	r24, r24
    2792:	90 e0       	ldi	r25, 0x00	; 0
    2794:	88 0f       	add	r24, r24
    2796:	99 1f       	adc	r25, r25
    2798:	88 0f       	add	r24, r24
    279a:	99 1f       	adc	r25, r25
    279c:	82 2b       	or	r24, r18
    279e:	8c 93       	st	X, r24
    27a0:	1f c0       	rjmp	.+62     	; 0x27e0 <MEXTI_voidConfig+0xce>
            break;
        
            case EXTI2:
            switch (A_u8SenseMode)
    27a2:	8a 81       	ldd	r24, Y+2	; 0x02
    27a4:	28 2f       	mov	r18, r24
    27a6:	30 e0       	ldi	r19, 0x00	; 0
    27a8:	3c 83       	std	Y+4, r19	; 0x04
    27aa:	2b 83       	std	Y+3, r18	; 0x03
    27ac:	8b 81       	ldd	r24, Y+3	; 0x03
    27ae:	9c 81       	ldd	r25, Y+4	; 0x04
    27b0:	82 30       	cpi	r24, 0x02	; 2
    27b2:	91 05       	cpc	r25, r1
    27b4:	31 f0       	breq	.+12     	; 0x27c2 <MEXTI_voidConfig+0xb0>
    27b6:	2b 81       	ldd	r18, Y+3	; 0x03
    27b8:	3c 81       	ldd	r19, Y+4	; 0x04
    27ba:	23 30       	cpi	r18, 0x03	; 3
    27bc:	31 05       	cpc	r19, r1
    27be:	49 f0       	breq	.+18     	; 0x27d2 <MEXTI_voidConfig+0xc0>
    27c0:	0f c0       	rjmp	.+30     	; 0x27e0 <MEXTI_voidConfig+0xce>
            {
                case FALLING_EDGE:CLR_BIT(MCUCSR,ISC2);
    27c2:	a4 e5       	ldi	r26, 0x54	; 84
    27c4:	b0 e0       	ldi	r27, 0x00	; 0
    27c6:	e4 e5       	ldi	r30, 0x54	; 84
    27c8:	f0 e0       	ldi	r31, 0x00	; 0
    27ca:	80 81       	ld	r24, Z
    27cc:	8f 7b       	andi	r24, 0xBF	; 191
    27ce:	8c 93       	st	X, r24
    27d0:	07 c0       	rjmp	.+14     	; 0x27e0 <MEXTI_voidConfig+0xce>
                break;

                case RISING_EDGE:SET_BIT(MCUCSR,ISC2);
    27d2:	a4 e5       	ldi	r26, 0x54	; 84
    27d4:	b0 e0       	ldi	r27, 0x00	; 0
    27d6:	e4 e5       	ldi	r30, 0x54	; 84
    27d8:	f0 e0       	ldi	r31, 0x00	; 0
    27da:	80 81       	ld	r24, Z
    27dc:	80 64       	ori	r24, 0x40	; 64
    27de:	8c 93       	st	X, r24
        
        default:
            break;
        }
    }
}
    27e0:	26 96       	adiw	r28, 0x06	; 6
    27e2:	0f b6       	in	r0, 0x3f	; 63
    27e4:	f8 94       	cli
    27e6:	de bf       	out	0x3e, r29	; 62
    27e8:	0f be       	out	0x3f, r0	; 63
    27ea:	cd bf       	out	0x3d, r28	; 61
    27ec:	cf 91       	pop	r28
    27ee:	df 91       	pop	r29
    27f0:	08 95       	ret

000027f2 <MEXTI_voidEnable>:

void MEXTI_voidEnable(u8 A_u8EXTI)
{
    27f2:	df 93       	push	r29
    27f4:	cf 93       	push	r28
    27f6:	00 d0       	rcall	.+0      	; 0x27f8 <MEXTI_voidEnable+0x6>
    27f8:	0f 92       	push	r0
    27fa:	cd b7       	in	r28, 0x3d	; 61
    27fc:	de b7       	in	r29, 0x3e	; 62
    27fe:	89 83       	std	Y+1, r24	; 0x01
    switch(A_u8EXTI)
    2800:	89 81       	ldd	r24, Y+1	; 0x01
    2802:	28 2f       	mov	r18, r24
    2804:	30 e0       	ldi	r19, 0x00	; 0
    2806:	3b 83       	std	Y+3, r19	; 0x03
    2808:	2a 83       	std	Y+2, r18	; 0x02
    280a:	8a 81       	ldd	r24, Y+2	; 0x02
    280c:	9b 81       	ldd	r25, Y+3	; 0x03
    280e:	81 30       	cpi	r24, 0x01	; 1
    2810:	91 05       	cpc	r25, r1
    2812:	89 f0       	breq	.+34     	; 0x2836 <MEXTI_voidEnable+0x44>
    2814:	2a 81       	ldd	r18, Y+2	; 0x02
    2816:	3b 81       	ldd	r19, Y+3	; 0x03
    2818:	22 30       	cpi	r18, 0x02	; 2
    281a:	31 05       	cpc	r19, r1
    281c:	a1 f0       	breq	.+40     	; 0x2846 <MEXTI_voidEnable+0x54>
    281e:	8a 81       	ldd	r24, Y+2	; 0x02
    2820:	9b 81       	ldd	r25, Y+3	; 0x03
    2822:	00 97       	sbiw	r24, 0x00	; 0
    2824:	b9 f4       	brne	.+46     	; 0x2854 <MEXTI_voidEnable+0x62>
    {
        case EXTI0: SET_BIT(GICR,INT0);
    2826:	ab e5       	ldi	r26, 0x5B	; 91
    2828:	b0 e0       	ldi	r27, 0x00	; 0
    282a:	eb e5       	ldi	r30, 0x5B	; 91
    282c:	f0 e0       	ldi	r31, 0x00	; 0
    282e:	80 81       	ld	r24, Z
    2830:	80 64       	ori	r24, 0x40	; 64
    2832:	8c 93       	st	X, r24
    2834:	0f c0       	rjmp	.+30     	; 0x2854 <MEXTI_voidEnable+0x62>
        break;
        case EXTI1: SET_BIT(GICR,INT1);
    2836:	ab e5       	ldi	r26, 0x5B	; 91
    2838:	b0 e0       	ldi	r27, 0x00	; 0
    283a:	eb e5       	ldi	r30, 0x5B	; 91
    283c:	f0 e0       	ldi	r31, 0x00	; 0
    283e:	80 81       	ld	r24, Z
    2840:	80 68       	ori	r24, 0x80	; 128
    2842:	8c 93       	st	X, r24
    2844:	07 c0       	rjmp	.+14     	; 0x2854 <MEXTI_voidEnable+0x62>
        break;
        case EXTI2: SET_BIT(GICR,INT2);
    2846:	ab e5       	ldi	r26, 0x5B	; 91
    2848:	b0 e0       	ldi	r27, 0x00	; 0
    284a:	eb e5       	ldi	r30, 0x5B	; 91
    284c:	f0 e0       	ldi	r31, 0x00	; 0
    284e:	80 81       	ld	r24, Z
    2850:	80 62       	ori	r24, 0x20	; 32
    2852:	8c 93       	st	X, r24
        break;
    }
}
    2854:	0f 90       	pop	r0
    2856:	0f 90       	pop	r0
    2858:	0f 90       	pop	r0
    285a:	cf 91       	pop	r28
    285c:	df 91       	pop	r29
    285e:	08 95       	ret

00002860 <MEXTI_voidDisable>:

void MEXTI_voidDisable(u8 A_u8EXTI)
{
    2860:	df 93       	push	r29
    2862:	cf 93       	push	r28
    2864:	00 d0       	rcall	.+0      	; 0x2866 <MEXTI_voidDisable+0x6>
    2866:	0f 92       	push	r0
    2868:	cd b7       	in	r28, 0x3d	; 61
    286a:	de b7       	in	r29, 0x3e	; 62
    286c:	89 83       	std	Y+1, r24	; 0x01
    switch(A_u8EXTI)
    286e:	89 81       	ldd	r24, Y+1	; 0x01
    2870:	28 2f       	mov	r18, r24
    2872:	30 e0       	ldi	r19, 0x00	; 0
    2874:	3b 83       	std	Y+3, r19	; 0x03
    2876:	2a 83       	std	Y+2, r18	; 0x02
    2878:	8a 81       	ldd	r24, Y+2	; 0x02
    287a:	9b 81       	ldd	r25, Y+3	; 0x03
    287c:	81 30       	cpi	r24, 0x01	; 1
    287e:	91 05       	cpc	r25, r1
    2880:	89 f0       	breq	.+34     	; 0x28a4 <MEXTI_voidDisable+0x44>
    2882:	2a 81       	ldd	r18, Y+2	; 0x02
    2884:	3b 81       	ldd	r19, Y+3	; 0x03
    2886:	22 30       	cpi	r18, 0x02	; 2
    2888:	31 05       	cpc	r19, r1
    288a:	a1 f0       	breq	.+40     	; 0x28b4 <MEXTI_voidDisable+0x54>
    288c:	8a 81       	ldd	r24, Y+2	; 0x02
    288e:	9b 81       	ldd	r25, Y+3	; 0x03
    2890:	00 97       	sbiw	r24, 0x00	; 0
    2892:	b9 f4       	brne	.+46     	; 0x28c2 <MEXTI_voidDisable+0x62>
    {
        case EXTI0: CLR_BIT(GICR,INT0);
    2894:	ab e5       	ldi	r26, 0x5B	; 91
    2896:	b0 e0       	ldi	r27, 0x00	; 0
    2898:	eb e5       	ldi	r30, 0x5B	; 91
    289a:	f0 e0       	ldi	r31, 0x00	; 0
    289c:	80 81       	ld	r24, Z
    289e:	8f 7b       	andi	r24, 0xBF	; 191
    28a0:	8c 93       	st	X, r24
    28a2:	0f c0       	rjmp	.+30     	; 0x28c2 <MEXTI_voidDisable+0x62>
        break;
        case EXTI1: CLR_BIT(GICR,INT1);
    28a4:	ab e5       	ldi	r26, 0x5B	; 91
    28a6:	b0 e0       	ldi	r27, 0x00	; 0
    28a8:	eb e5       	ldi	r30, 0x5B	; 91
    28aa:	f0 e0       	ldi	r31, 0x00	; 0
    28ac:	80 81       	ld	r24, Z
    28ae:	8f 77       	andi	r24, 0x7F	; 127
    28b0:	8c 93       	st	X, r24
    28b2:	07 c0       	rjmp	.+14     	; 0x28c2 <MEXTI_voidDisable+0x62>
        break;
        case EXTI2: CLR_BIT(GICR,INT2);
    28b4:	ab e5       	ldi	r26, 0x5B	; 91
    28b6:	b0 e0       	ldi	r27, 0x00	; 0
    28b8:	eb e5       	ldi	r30, 0x5B	; 91
    28ba:	f0 e0       	ldi	r31, 0x00	; 0
    28bc:	80 81       	ld	r24, Z
    28be:	8f 7d       	andi	r24, 0xDF	; 223
    28c0:	8c 93       	st	X, r24
        break;
    }
}
    28c2:	0f 90       	pop	r0
    28c4:	0f 90       	pop	r0
    28c6:	0f 90       	pop	r0
    28c8:	cf 91       	pop	r28
    28ca:	df 91       	pop	r29
    28cc:	08 95       	ret

000028ce <MEXTI_voidClearFlag>:

void MEXTI_voidClearFlag(u8 A_u8EXTI)
{
    28ce:	df 93       	push	r29
    28d0:	cf 93       	push	r28
    28d2:	00 d0       	rcall	.+0      	; 0x28d4 <MEXTI_voidClearFlag+0x6>
    28d4:	0f 92       	push	r0
    28d6:	cd b7       	in	r28, 0x3d	; 61
    28d8:	de b7       	in	r29, 0x3e	; 62
    28da:	89 83       	std	Y+1, r24	; 0x01
    switch(A_u8EXTI)
    28dc:	89 81       	ldd	r24, Y+1	; 0x01
    28de:	28 2f       	mov	r18, r24
    28e0:	30 e0       	ldi	r19, 0x00	; 0
    28e2:	3b 83       	std	Y+3, r19	; 0x03
    28e4:	2a 83       	std	Y+2, r18	; 0x02
    28e6:	8a 81       	ldd	r24, Y+2	; 0x02
    28e8:	9b 81       	ldd	r25, Y+3	; 0x03
    28ea:	81 30       	cpi	r24, 0x01	; 1
    28ec:	91 05       	cpc	r25, r1
    28ee:	89 f0       	breq	.+34     	; 0x2912 <MEXTI_voidClearFlag+0x44>
    28f0:	2a 81       	ldd	r18, Y+2	; 0x02
    28f2:	3b 81       	ldd	r19, Y+3	; 0x03
    28f4:	22 30       	cpi	r18, 0x02	; 2
    28f6:	31 05       	cpc	r19, r1
    28f8:	a1 f0       	breq	.+40     	; 0x2922 <MEXTI_voidClearFlag+0x54>
    28fa:	8a 81       	ldd	r24, Y+2	; 0x02
    28fc:	9b 81       	ldd	r25, Y+3	; 0x03
    28fe:	00 97       	sbiw	r24, 0x00	; 0
    2900:	b9 f4       	brne	.+46     	; 0x2930 <MEXTI_voidClearFlag+0x62>
    {
        case EXTI0: SET_BIT(GIFR,INTF0);
    2902:	aa e5       	ldi	r26, 0x5A	; 90
    2904:	b0 e0       	ldi	r27, 0x00	; 0
    2906:	ea e5       	ldi	r30, 0x5A	; 90
    2908:	f0 e0       	ldi	r31, 0x00	; 0
    290a:	80 81       	ld	r24, Z
    290c:	80 64       	ori	r24, 0x40	; 64
    290e:	8c 93       	st	X, r24
    2910:	0f c0       	rjmp	.+30     	; 0x2930 <MEXTI_voidClearFlag+0x62>
        break;
        case EXTI1: SET_BIT(GIFR,INTF1);
    2912:	aa e5       	ldi	r26, 0x5A	; 90
    2914:	b0 e0       	ldi	r27, 0x00	; 0
    2916:	ea e5       	ldi	r30, 0x5A	; 90
    2918:	f0 e0       	ldi	r31, 0x00	; 0
    291a:	80 81       	ld	r24, Z
    291c:	80 68       	ori	r24, 0x80	; 128
    291e:	8c 93       	st	X, r24
    2920:	07 c0       	rjmp	.+14     	; 0x2930 <MEXTI_voidClearFlag+0x62>
        break;
        case EXTI2: SET_BIT(GIFR,INTF2);
    2922:	aa e5       	ldi	r26, 0x5A	; 90
    2924:	b0 e0       	ldi	r27, 0x00	; 0
    2926:	ea e5       	ldi	r30, 0x5A	; 90
    2928:	f0 e0       	ldi	r31, 0x00	; 0
    292a:	80 81       	ld	r24, Z
    292c:	80 62       	ori	r24, 0x20	; 32
    292e:	8c 93       	st	X, r24
        break;
    }
}
    2930:	0f 90       	pop	r0
    2932:	0f 90       	pop	r0
    2934:	0f 90       	pop	r0
    2936:	cf 91       	pop	r28
    2938:	df 91       	pop	r29
    293a:	08 95       	ret

0000293c <MEXTI_voidSetCallBack>:

void MEXTI_voidSetCallBack(u8 A_u8EXTI,void (*ptrToFunc)(void))
{
    293c:	df 93       	push	r29
    293e:	cf 93       	push	r28
    2940:	00 d0       	rcall	.+0      	; 0x2942 <MEXTI_voidSetCallBack+0x6>
    2942:	00 d0       	rcall	.+0      	; 0x2944 <MEXTI_voidSetCallBack+0x8>
    2944:	0f 92       	push	r0
    2946:	cd b7       	in	r28, 0x3d	; 61
    2948:	de b7       	in	r29, 0x3e	; 62
    294a:	89 83       	std	Y+1, r24	; 0x01
    294c:	7b 83       	std	Y+3, r23	; 0x03
    294e:	6a 83       	std	Y+2, r22	; 0x02
    if(ptrToFunc!=NULL)
    2950:	8a 81       	ldd	r24, Y+2	; 0x02
    2952:	9b 81       	ldd	r25, Y+3	; 0x03
    2954:	00 97       	sbiw	r24, 0x00	; 0
    2956:	39 f1       	breq	.+78     	; 0x29a6 <MEXTI_voidSetCallBack+0x6a>
    {
        switch (A_u8EXTI)
    2958:	89 81       	ldd	r24, Y+1	; 0x01
    295a:	28 2f       	mov	r18, r24
    295c:	30 e0       	ldi	r19, 0x00	; 0
    295e:	3d 83       	std	Y+5, r19	; 0x05
    2960:	2c 83       	std	Y+4, r18	; 0x04
    2962:	8c 81       	ldd	r24, Y+4	; 0x04
    2964:	9d 81       	ldd	r25, Y+5	; 0x05
    2966:	81 30       	cpi	r24, 0x01	; 1
    2968:	91 05       	cpc	r25, r1
    296a:	81 f0       	breq	.+32     	; 0x298c <MEXTI_voidSetCallBack+0x50>
    296c:	2c 81       	ldd	r18, Y+4	; 0x04
    296e:	3d 81       	ldd	r19, Y+5	; 0x05
    2970:	22 30       	cpi	r18, 0x02	; 2
    2972:	31 05       	cpc	r19, r1
    2974:	91 f0       	breq	.+36     	; 0x299a <MEXTI_voidSetCallBack+0x5e>
    2976:	8c 81       	ldd	r24, Y+4	; 0x04
    2978:	9d 81       	ldd	r25, Y+5	; 0x05
    297a:	00 97       	sbiw	r24, 0x00	; 0
    297c:	a1 f4       	brne	.+40     	; 0x29a6 <MEXTI_voidSetCallBack+0x6a>
        {
            case EXTI0:EXTI0_CallBack=ptrToFunc;break;
    297e:	8a 81       	ldd	r24, Y+2	; 0x02
    2980:	9b 81       	ldd	r25, Y+3	; 0x03
    2982:	90 93 a7 01 	sts	0x01A7, r25
    2986:	80 93 a6 01 	sts	0x01A6, r24
    298a:	0d c0       	rjmp	.+26     	; 0x29a6 <MEXTI_voidSetCallBack+0x6a>
            case EXTI1:EXTI1_CallBack=ptrToFunc;break;
    298c:	8a 81       	ldd	r24, Y+2	; 0x02
    298e:	9b 81       	ldd	r25, Y+3	; 0x03
    2990:	90 93 a9 01 	sts	0x01A9, r25
    2994:	80 93 a8 01 	sts	0x01A8, r24
    2998:	06 c0       	rjmp	.+12     	; 0x29a6 <MEXTI_voidSetCallBack+0x6a>
            case EXTI2:EXTI2_CallBack=ptrToFunc;break;
    299a:	8a 81       	ldd	r24, Y+2	; 0x02
    299c:	9b 81       	ldd	r25, Y+3	; 0x03
    299e:	90 93 ab 01 	sts	0x01AB, r25
    29a2:	80 93 aa 01 	sts	0x01AA, r24
            default: break;
        }
    }
}
    29a6:	0f 90       	pop	r0
    29a8:	0f 90       	pop	r0
    29aa:	0f 90       	pop	r0
    29ac:	0f 90       	pop	r0
    29ae:	0f 90       	pop	r0
    29b0:	cf 91       	pop	r28
    29b2:	df 91       	pop	r29
    29b4:	08 95       	ret

000029b6 <__vector_1>:
        switch when interrupt happen so we have to make push and pop the shared registers 
        & status register to & from stack
*/

ISR(EXTI0_VECT)
{
    29b6:	1f 92       	push	r1
    29b8:	0f 92       	push	r0
    29ba:	0f b6       	in	r0, 0x3f	; 63
    29bc:	0f 92       	push	r0
    29be:	11 24       	eor	r1, r1
    29c0:	2f 93       	push	r18
    29c2:	3f 93       	push	r19
    29c4:	4f 93       	push	r20
    29c6:	5f 93       	push	r21
    29c8:	6f 93       	push	r22
    29ca:	7f 93       	push	r23
    29cc:	8f 93       	push	r24
    29ce:	9f 93       	push	r25
    29d0:	af 93       	push	r26
    29d2:	bf 93       	push	r27
    29d4:	ef 93       	push	r30
    29d6:	ff 93       	push	r31
    29d8:	df 93       	push	r29
    29da:	cf 93       	push	r28
    29dc:	cd b7       	in	r28, 0x3d	; 61
    29de:	de b7       	in	r29, 0x3e	; 62
    if(EXTI0_CallBack!=NULLPTR) EXTI0_CallBack();
    29e0:	80 91 a6 01 	lds	r24, 0x01A6
    29e4:	90 91 a7 01 	lds	r25, 0x01A7
    29e8:	00 97       	sbiw	r24, 0x00	; 0
    29ea:	29 f0       	breq	.+10     	; 0x29f6 <__vector_1+0x40>
    29ec:	e0 91 a6 01 	lds	r30, 0x01A6
    29f0:	f0 91 a7 01 	lds	r31, 0x01A7
    29f4:	09 95       	icall
}
    29f6:	cf 91       	pop	r28
    29f8:	df 91       	pop	r29
    29fa:	ff 91       	pop	r31
    29fc:	ef 91       	pop	r30
    29fe:	bf 91       	pop	r27
    2a00:	af 91       	pop	r26
    2a02:	9f 91       	pop	r25
    2a04:	8f 91       	pop	r24
    2a06:	7f 91       	pop	r23
    2a08:	6f 91       	pop	r22
    2a0a:	5f 91       	pop	r21
    2a0c:	4f 91       	pop	r20
    2a0e:	3f 91       	pop	r19
    2a10:	2f 91       	pop	r18
    2a12:	0f 90       	pop	r0
    2a14:	0f be       	out	0x3f, r0	; 63
    2a16:	0f 90       	pop	r0
    2a18:	1f 90       	pop	r1
    2a1a:	18 95       	reti

00002a1c <__vector_2>:

ISR(EXTI1_VECT)
{
    2a1c:	1f 92       	push	r1
    2a1e:	0f 92       	push	r0
    2a20:	0f b6       	in	r0, 0x3f	; 63
    2a22:	0f 92       	push	r0
    2a24:	11 24       	eor	r1, r1
    2a26:	2f 93       	push	r18
    2a28:	3f 93       	push	r19
    2a2a:	4f 93       	push	r20
    2a2c:	5f 93       	push	r21
    2a2e:	6f 93       	push	r22
    2a30:	7f 93       	push	r23
    2a32:	8f 93       	push	r24
    2a34:	9f 93       	push	r25
    2a36:	af 93       	push	r26
    2a38:	bf 93       	push	r27
    2a3a:	ef 93       	push	r30
    2a3c:	ff 93       	push	r31
    2a3e:	df 93       	push	r29
    2a40:	cf 93       	push	r28
    2a42:	cd b7       	in	r28, 0x3d	; 61
    2a44:	de b7       	in	r29, 0x3e	; 62
    if(EXTI1_CallBack!=NULLPTR) EXTI1_CallBack();
    2a46:	80 91 a8 01 	lds	r24, 0x01A8
    2a4a:	90 91 a9 01 	lds	r25, 0x01A9
    2a4e:	00 97       	sbiw	r24, 0x00	; 0
    2a50:	29 f0       	breq	.+10     	; 0x2a5c <__vector_2+0x40>
    2a52:	e0 91 a8 01 	lds	r30, 0x01A8
    2a56:	f0 91 a9 01 	lds	r31, 0x01A9
    2a5a:	09 95       	icall
}
    2a5c:	cf 91       	pop	r28
    2a5e:	df 91       	pop	r29
    2a60:	ff 91       	pop	r31
    2a62:	ef 91       	pop	r30
    2a64:	bf 91       	pop	r27
    2a66:	af 91       	pop	r26
    2a68:	9f 91       	pop	r25
    2a6a:	8f 91       	pop	r24
    2a6c:	7f 91       	pop	r23
    2a6e:	6f 91       	pop	r22
    2a70:	5f 91       	pop	r21
    2a72:	4f 91       	pop	r20
    2a74:	3f 91       	pop	r19
    2a76:	2f 91       	pop	r18
    2a78:	0f 90       	pop	r0
    2a7a:	0f be       	out	0x3f, r0	; 63
    2a7c:	0f 90       	pop	r0
    2a7e:	1f 90       	pop	r1
    2a80:	18 95       	reti

00002a82 <__vector_3>:

ISR(EXTI2_VECT)
{
    2a82:	1f 92       	push	r1
    2a84:	0f 92       	push	r0
    2a86:	0f b6       	in	r0, 0x3f	; 63
    2a88:	0f 92       	push	r0
    2a8a:	11 24       	eor	r1, r1
    2a8c:	2f 93       	push	r18
    2a8e:	3f 93       	push	r19
    2a90:	4f 93       	push	r20
    2a92:	5f 93       	push	r21
    2a94:	6f 93       	push	r22
    2a96:	7f 93       	push	r23
    2a98:	8f 93       	push	r24
    2a9a:	9f 93       	push	r25
    2a9c:	af 93       	push	r26
    2a9e:	bf 93       	push	r27
    2aa0:	ef 93       	push	r30
    2aa2:	ff 93       	push	r31
    2aa4:	df 93       	push	r29
    2aa6:	cf 93       	push	r28
    2aa8:	cd b7       	in	r28, 0x3d	; 61
    2aaa:	de b7       	in	r29, 0x3e	; 62
    if(EXTI2_CallBack!=NULLPTR) EXTI2_CallBack();
    2aac:	80 91 aa 01 	lds	r24, 0x01AA
    2ab0:	90 91 ab 01 	lds	r25, 0x01AB
    2ab4:	00 97       	sbiw	r24, 0x00	; 0
    2ab6:	29 f0       	breq	.+10     	; 0x2ac2 <__vector_3+0x40>
    2ab8:	e0 91 aa 01 	lds	r30, 0x01AA
    2abc:	f0 91 ab 01 	lds	r31, 0x01AB
    2ac0:	09 95       	icall
    2ac2:	cf 91       	pop	r28
    2ac4:	df 91       	pop	r29
    2ac6:	ff 91       	pop	r31
    2ac8:	ef 91       	pop	r30
    2aca:	bf 91       	pop	r27
    2acc:	af 91       	pop	r26
    2ace:	9f 91       	pop	r25
    2ad0:	8f 91       	pop	r24
    2ad2:	7f 91       	pop	r23
    2ad4:	6f 91       	pop	r22
    2ad6:	5f 91       	pop	r21
    2ad8:	4f 91       	pop	r20
    2ada:	3f 91       	pop	r19
    2adc:	2f 91       	pop	r18
    2ade:	0f 90       	pop	r0
    2ae0:	0f be       	out	0x3f, r0	; 63
    2ae2:	0f 90       	pop	r0
    2ae4:	1f 90       	pop	r1
    2ae6:	18 95       	reti

00002ae8 <MGI_voidEnable>:
#include "../Include/MCAL/GI/GI_Configuration.h"



void MGI_voidEnable()
{
    2ae8:	df 93       	push	r29
    2aea:	cf 93       	push	r28
    2aec:	cd b7       	in	r28, 0x3d	; 61
    2aee:	de b7       	in	r29, 0x3e	; 62
    SET_BIT(SREG,I_BIT);
    2af0:	af e5       	ldi	r26, 0x5F	; 95
    2af2:	b0 e0       	ldi	r27, 0x00	; 0
    2af4:	ef e5       	ldi	r30, 0x5F	; 95
    2af6:	f0 e0       	ldi	r31, 0x00	; 0
    2af8:	80 81       	ld	r24, Z
    2afa:	80 68       	ori	r24, 0x80	; 128
    2afc:	8c 93       	st	X, r24
}
    2afe:	cf 91       	pop	r28
    2b00:	df 91       	pop	r29
    2b02:	08 95       	ret

00002b04 <MGI_voidDisable>:

void MGI_voidDisable()
{
    2b04:	df 93       	push	r29
    2b06:	cf 93       	push	r28
    2b08:	cd b7       	in	r28, 0x3d	; 61
    2b0a:	de b7       	in	r29, 0x3e	; 62
    
    CLR_BIT(SREG,I_BIT);
    2b0c:	af e5       	ldi	r26, 0x5F	; 95
    2b0e:	b0 e0       	ldi	r27, 0x00	; 0
    2b10:	ef e5       	ldi	r30, 0x5F	; 95
    2b12:	f0 e0       	ldi	r31, 0x00	; 0
    2b14:	80 81       	ld	r24, Z
    2b16:	8f 77       	andi	r24, 0x7F	; 127
    2b18:	8c 93       	st	X, r24
    2b1a:	cf 91       	pop	r28
    2b1c:	df 91       	pop	r29
    2b1e:	08 95       	ret

00002b20 <HKEYPAD_u8GetPressedKey>:
u8 keypadRow[ROWS_NUMBER]=ROW_PINS;
u8 keypadCol[COLS_NUMBER]=COL_PINS;


u8 HKEYPAD_u8GetPressedKey()
{
    2b20:	df 93       	push	r29
    2b22:	cf 93       	push	r28
    2b24:	cd b7       	in	r28, 0x3d	; 61
    2b26:	de b7       	in	r29, 0x3e	; 62
    2b28:	62 97       	sbiw	r28, 0x12	; 18
    2b2a:	0f b6       	in	r0, 0x3f	; 63
    2b2c:	f8 94       	cli
    2b2e:	de bf       	out	0x3e, r29	; 62
    2b30:	0f be       	out	0x3f, r0	; 63
    2b32:	cd bf       	out	0x3d, r28	; 61
    u8 local_u8RowCounter,local_u8ColCounter,local_u8Flag=FLAG_DOWN,local_u8PressedKey=KEY_NOT_PRESSED;
    2b34:	18 8a       	std	Y+16, r1	; 0x10
    2b36:	8f ef       	ldi	r24, 0xFF	; 255
    2b38:	8f 87       	std	Y+15, r24	; 0x0f
    
    for(local_u8RowCounter=0;local_u8RowCounter<ROWS_NUMBER;local_u8RowCounter++)
    2b3a:	1a 8a       	std	Y+18, r1	; 0x12
    2b3c:	c9 c0       	rjmp	.+402    	; 0x2cd0 <HKEYPAD_u8GetPressedKey+0x1b0>
    {
        MDIO_voidSetPinValue(KEYPAD_PORT,keypadRow[local_u8RowCounter],PIN_LOW);
    2b3e:	8a 89       	ldd	r24, Y+18	; 0x12
    2b40:	88 2f       	mov	r24, r24
    2b42:	90 e0       	ldi	r25, 0x00	; 0
    2b44:	fc 01       	movw	r30, r24
    2b46:	ec 57       	subi	r30, 0x7C	; 124
    2b48:	fe 4f       	sbci	r31, 0xFE	; 254
    2b4a:	90 81       	ld	r25, Z
    2b4c:	80 e0       	ldi	r24, 0x00	; 0
    2b4e:	69 2f       	mov	r22, r25
    2b50:	40 e0       	ldi	r20, 0x00	; 0
    2b52:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
        for(local_u8ColCounter=0;local_u8ColCounter<COLS_NUMBER;local_u8ColCounter++)
    2b56:	19 8a       	std	Y+17, r1	; 0x11
    2b58:	a5 c0       	rjmp	.+330    	; 0x2ca4 <HKEYPAD_u8GetPressedKey+0x184>
        {
            if (MDIO_u8GetPinValue(KEYPAD_PORT,keypadCol[local_u8ColCounter])==PIN_LOW)
    2b5a:	89 89       	ldd	r24, Y+17	; 0x11
    2b5c:	88 2f       	mov	r24, r24
    2b5e:	90 e0       	ldi	r25, 0x00	; 0
    2b60:	fc 01       	movw	r30, r24
    2b62:	e8 57       	subi	r30, 0x78	; 120
    2b64:	fe 4f       	sbci	r31, 0xFE	; 254
    2b66:	90 81       	ld	r25, Z
    2b68:	80 e0       	ldi	r24, 0x00	; 0
    2b6a:	69 2f       	mov	r22, r25
    2b6c:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <MDIO_u8GetPinValue>
    2b70:	88 23       	and	r24, r24
    2b72:	09 f0       	breq	.+2      	; 0x2b76 <HKEYPAD_u8GetPressedKey+0x56>
    2b74:	94 c0       	rjmp	.+296    	; 0x2c9e <HKEYPAD_u8GetPressedKey+0x17e>
    2b76:	80 e0       	ldi	r24, 0x00	; 0
    2b78:	90 e0       	ldi	r25, 0x00	; 0
    2b7a:	a6 e1       	ldi	r26, 0x16	; 22
    2b7c:	b3 e4       	ldi	r27, 0x43	; 67
    2b7e:	8b 87       	std	Y+11, r24	; 0x0b
    2b80:	9c 87       	std	Y+12, r25	; 0x0c
    2b82:	ad 87       	std	Y+13, r26	; 0x0d
    2b84:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2b86:	6b 85       	ldd	r22, Y+11	; 0x0b
    2b88:	7c 85       	ldd	r23, Y+12	; 0x0c
    2b8a:	8d 85       	ldd	r24, Y+13	; 0x0d
    2b8c:	9e 85       	ldd	r25, Y+14	; 0x0e
    2b8e:	20 e0       	ldi	r18, 0x00	; 0
    2b90:	30 e0       	ldi	r19, 0x00	; 0
    2b92:	4a ef       	ldi	r20, 0xFA	; 250
    2b94:	54 e4       	ldi	r21, 0x44	; 68
    2b96:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    2b9a:	dc 01       	movw	r26, r24
    2b9c:	cb 01       	movw	r24, r22
    2b9e:	8f 83       	std	Y+7, r24	; 0x07
    2ba0:	98 87       	std	Y+8, r25	; 0x08
    2ba2:	a9 87       	std	Y+9, r26	; 0x09
    2ba4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2ba6:	6f 81       	ldd	r22, Y+7	; 0x07
    2ba8:	78 85       	ldd	r23, Y+8	; 0x08
    2baa:	89 85       	ldd	r24, Y+9	; 0x09
    2bac:	9a 85       	ldd	r25, Y+10	; 0x0a
    2bae:	20 e0       	ldi	r18, 0x00	; 0
    2bb0:	30 e0       	ldi	r19, 0x00	; 0
    2bb2:	40 e8       	ldi	r20, 0x80	; 128
    2bb4:	5f e3       	ldi	r21, 0x3F	; 63
    2bb6:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    2bba:	88 23       	and	r24, r24
    2bbc:	2c f4       	brge	.+10     	; 0x2bc8 <HKEYPAD_u8GetPressedKey+0xa8>
		__ticks = 1;
    2bbe:	81 e0       	ldi	r24, 0x01	; 1
    2bc0:	90 e0       	ldi	r25, 0x00	; 0
    2bc2:	9e 83       	std	Y+6, r25	; 0x06
    2bc4:	8d 83       	std	Y+5, r24	; 0x05
    2bc6:	3f c0       	rjmp	.+126    	; 0x2c46 <HKEYPAD_u8GetPressedKey+0x126>
	else if (__tmp > 65535)
    2bc8:	6f 81       	ldd	r22, Y+7	; 0x07
    2bca:	78 85       	ldd	r23, Y+8	; 0x08
    2bcc:	89 85       	ldd	r24, Y+9	; 0x09
    2bce:	9a 85       	ldd	r25, Y+10	; 0x0a
    2bd0:	20 e0       	ldi	r18, 0x00	; 0
    2bd2:	3f ef       	ldi	r19, 0xFF	; 255
    2bd4:	4f e7       	ldi	r20, 0x7F	; 127
    2bd6:	57 e4       	ldi	r21, 0x47	; 71
    2bd8:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    2bdc:	18 16       	cp	r1, r24
    2bde:	4c f5       	brge	.+82     	; 0x2c32 <HKEYPAD_u8GetPressedKey+0x112>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2be0:	6b 85       	ldd	r22, Y+11	; 0x0b
    2be2:	7c 85       	ldd	r23, Y+12	; 0x0c
    2be4:	8d 85       	ldd	r24, Y+13	; 0x0d
    2be6:	9e 85       	ldd	r25, Y+14	; 0x0e
    2be8:	20 e0       	ldi	r18, 0x00	; 0
    2bea:	30 e0       	ldi	r19, 0x00	; 0
    2bec:	40 e2       	ldi	r20, 0x20	; 32
    2bee:	51 e4       	ldi	r21, 0x41	; 65
    2bf0:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    2bf4:	dc 01       	movw	r26, r24
    2bf6:	cb 01       	movw	r24, r22
    2bf8:	bc 01       	movw	r22, r24
    2bfa:	cd 01       	movw	r24, r26
    2bfc:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    2c00:	dc 01       	movw	r26, r24
    2c02:	cb 01       	movw	r24, r22
    2c04:	9e 83       	std	Y+6, r25	; 0x06
    2c06:	8d 83       	std	Y+5, r24	; 0x05
    2c08:	0f c0       	rjmp	.+30     	; 0x2c28 <HKEYPAD_u8GetPressedKey+0x108>
    2c0a:	88 ec       	ldi	r24, 0xC8	; 200
    2c0c:	90 e0       	ldi	r25, 0x00	; 0
    2c0e:	9c 83       	std	Y+4, r25	; 0x04
    2c10:	8b 83       	std	Y+3, r24	; 0x03
    2c12:	8b 81       	ldd	r24, Y+3	; 0x03
    2c14:	9c 81       	ldd	r25, Y+4	; 0x04
    2c16:	01 97       	sbiw	r24, 0x01	; 1
    2c18:	f1 f7       	brne	.-4      	; 0x2c16 <HKEYPAD_u8GetPressedKey+0xf6>
    2c1a:	9c 83       	std	Y+4, r25	; 0x04
    2c1c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2c1e:	8d 81       	ldd	r24, Y+5	; 0x05
    2c20:	9e 81       	ldd	r25, Y+6	; 0x06
    2c22:	01 97       	sbiw	r24, 0x01	; 1
    2c24:	9e 83       	std	Y+6, r25	; 0x06
    2c26:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2c28:	8d 81       	ldd	r24, Y+5	; 0x05
    2c2a:	9e 81       	ldd	r25, Y+6	; 0x06
    2c2c:	00 97       	sbiw	r24, 0x00	; 0
    2c2e:	69 f7       	brne	.-38     	; 0x2c0a <HKEYPAD_u8GetPressedKey+0xea>
    2c30:	14 c0       	rjmp	.+40     	; 0x2c5a <HKEYPAD_u8GetPressedKey+0x13a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2c32:	6f 81       	ldd	r22, Y+7	; 0x07
    2c34:	78 85       	ldd	r23, Y+8	; 0x08
    2c36:	89 85       	ldd	r24, Y+9	; 0x09
    2c38:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c3a:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    2c3e:	dc 01       	movw	r26, r24
    2c40:	cb 01       	movw	r24, r22
    2c42:	9e 83       	std	Y+6, r25	; 0x06
    2c44:	8d 83       	std	Y+5, r24	; 0x05
    2c46:	8d 81       	ldd	r24, Y+5	; 0x05
    2c48:	9e 81       	ldd	r25, Y+6	; 0x06
    2c4a:	9a 83       	std	Y+2, r25	; 0x02
    2c4c:	89 83       	std	Y+1, r24	; 0x01
    2c4e:	89 81       	ldd	r24, Y+1	; 0x01
    2c50:	9a 81       	ldd	r25, Y+2	; 0x02
    2c52:	01 97       	sbiw	r24, 0x01	; 1
    2c54:	f1 f7       	brne	.-4      	; 0x2c52 <HKEYPAD_u8GetPressedKey+0x132>
    2c56:	9a 83       	std	Y+2, r25	; 0x02
    2c58:	89 83       	std	Y+1, r24	; 0x01
            {
                //to avoid "debounce effect"
                _delay_ms(DEBOUNCING_DELAY);
                local_u8Flag=FLAG_UP;
    2c5a:	81 e0       	ldi	r24, 0x01	; 1
    2c5c:	88 8b       	std	Y+16, r24	; 0x10
                //to make sure it will not print the character more than once if the user still press the button
                while(MDIO_u8GetPinValue(KEYPAD_PORT,keypadCol[local_u8ColCounter])==PIN_LOW);
    2c5e:	89 89       	ldd	r24, Y+17	; 0x11
    2c60:	88 2f       	mov	r24, r24
    2c62:	90 e0       	ldi	r25, 0x00	; 0
    2c64:	fc 01       	movw	r30, r24
    2c66:	e8 57       	subi	r30, 0x78	; 120
    2c68:	fe 4f       	sbci	r31, 0xFE	; 254
    2c6a:	90 81       	ld	r25, Z
    2c6c:	80 e0       	ldi	r24, 0x00	; 0
    2c6e:	69 2f       	mov	r22, r25
    2c70:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <MDIO_u8GetPinValue>
    2c74:	88 23       	and	r24, r24
    2c76:	99 f3       	breq	.-26     	; 0x2c5e <HKEYPAD_u8GetPressedKey+0x13e>
                local_u8PressedKey=KeypadArr[local_u8RowCounter][local_u8ColCounter];
    2c78:	8a 89       	ldd	r24, Y+18	; 0x12
    2c7a:	48 2f       	mov	r20, r24
    2c7c:	50 e0       	ldi	r21, 0x00	; 0
    2c7e:	89 89       	ldd	r24, Y+17	; 0x11
    2c80:	28 2f       	mov	r18, r24
    2c82:	30 e0       	ldi	r19, 0x00	; 0
    2c84:	ca 01       	movw	r24, r20
    2c86:	88 0f       	add	r24, r24
    2c88:	99 1f       	adc	r25, r25
    2c8a:	88 0f       	add	r24, r24
    2c8c:	99 1f       	adc	r25, r25
    2c8e:	82 0f       	add	r24, r18
    2c90:	93 1f       	adc	r25, r19
    2c92:	fc 01       	movw	r30, r24
    2c94:	ec 58       	subi	r30, 0x8C	; 140
    2c96:	fe 4f       	sbci	r31, 0xFE	; 254
    2c98:	80 81       	ld	r24, Z
    2c9a:	8f 87       	std	Y+15, r24	; 0x0f
    2c9c:	07 c0       	rjmp	.+14     	; 0x2cac <HKEYPAD_u8GetPressedKey+0x18c>
    u8 local_u8RowCounter,local_u8ColCounter,local_u8Flag=FLAG_DOWN,local_u8PressedKey=KEY_NOT_PRESSED;
    
    for(local_u8RowCounter=0;local_u8RowCounter<ROWS_NUMBER;local_u8RowCounter++)
    {
        MDIO_voidSetPinValue(KEYPAD_PORT,keypadRow[local_u8RowCounter],PIN_LOW);
        for(local_u8ColCounter=0;local_u8ColCounter<COLS_NUMBER;local_u8ColCounter++)
    2c9e:	89 89       	ldd	r24, Y+17	; 0x11
    2ca0:	8f 5f       	subi	r24, 0xFF	; 255
    2ca2:	89 8b       	std	Y+17, r24	; 0x11
    2ca4:	89 89       	ldd	r24, Y+17	; 0x11
    2ca6:	84 30       	cpi	r24, 0x04	; 4
    2ca8:	08 f4       	brcc	.+2      	; 0x2cac <HKEYPAD_u8GetPressedKey+0x18c>
    2caa:	57 cf       	rjmp	.-338    	; 0x2b5a <HKEYPAD_u8GetPressedKey+0x3a>
                while(MDIO_u8GetPinValue(KEYPAD_PORT,keypadCol[local_u8ColCounter])==PIN_LOW);
                local_u8PressedKey=KeypadArr[local_u8RowCounter][local_u8ColCounter];
                break;
            }
        }
        MDIO_voidSetPinValue(KEYPAD_PORT,keypadRow[local_u8RowCounter],PIN_HIGH);
    2cac:	8a 89       	ldd	r24, Y+18	; 0x12
    2cae:	88 2f       	mov	r24, r24
    2cb0:	90 e0       	ldi	r25, 0x00	; 0
    2cb2:	fc 01       	movw	r30, r24
    2cb4:	ec 57       	subi	r30, 0x7C	; 124
    2cb6:	fe 4f       	sbci	r31, 0xFE	; 254
    2cb8:	90 81       	ld	r25, Z
    2cba:	80 e0       	ldi	r24, 0x00	; 0
    2cbc:	69 2f       	mov	r22, r25
    2cbe:	41 e0       	ldi	r20, 0x01	; 1
    2cc0:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
        if(local_u8Flag)
    2cc4:	88 89       	ldd	r24, Y+16	; 0x10
    2cc6:	88 23       	and	r24, r24
    2cc8:	39 f4       	brne	.+14     	; 0x2cd8 <HKEYPAD_u8GetPressedKey+0x1b8>

u8 HKEYPAD_u8GetPressedKey()
{
    u8 local_u8RowCounter,local_u8ColCounter,local_u8Flag=FLAG_DOWN,local_u8PressedKey=KEY_NOT_PRESSED;
    
    for(local_u8RowCounter=0;local_u8RowCounter<ROWS_NUMBER;local_u8RowCounter++)
    2cca:	8a 89       	ldd	r24, Y+18	; 0x12
    2ccc:	8f 5f       	subi	r24, 0xFF	; 255
    2cce:	8a 8b       	std	Y+18, r24	; 0x12
    2cd0:	8a 89       	ldd	r24, Y+18	; 0x12
    2cd2:	84 30       	cpi	r24, 0x04	; 4
    2cd4:	08 f4       	brcc	.+2      	; 0x2cd8 <HKEYPAD_u8GetPressedKey+0x1b8>
    2cd6:	33 cf       	rjmp	.-410    	; 0x2b3e <HKEYPAD_u8GetPressedKey+0x1e>
        if(local_u8Flag)
        {
            break;
        }
    }
    return local_u8PressedKey;
    2cd8:	8f 85       	ldd	r24, Y+15	; 0x0f
}
    2cda:	62 96       	adiw	r28, 0x12	; 18
    2cdc:	0f b6       	in	r0, 0x3f	; 63
    2cde:	f8 94       	cli
    2ce0:	de bf       	out	0x3e, r29	; 62
    2ce2:	0f be       	out	0x3f, r0	; 63
    2ce4:	cd bf       	out	0x3d, r28	; 61
    2ce6:	cf 91       	pop	r28
    2ce8:	df 91       	pop	r29
    2cea:	08 95       	ret

00002cec <HLCD4_voidSendCommand>:


static u8 global_u8Init=0;

void HLCD4_voidSendCommand(u8 A_u8Command)
{
    2cec:	df 93       	push	r29
    2cee:	cf 93       	push	r28
    2cf0:	cd b7       	in	r28, 0x3d	; 61
    2cf2:	de b7       	in	r29, 0x3e	; 62
    2cf4:	ab 97       	sbiw	r28, 0x2b	; 43
    2cf6:	0f b6       	in	r0, 0x3f	; 63
    2cf8:	f8 94       	cli
    2cfa:	de bf       	out	0x3e, r29	; 62
    2cfc:	0f be       	out	0x3f, r0	; 63
    2cfe:	cd bf       	out	0x3d, r28	; 61
    2d00:	8b a7       	std	Y+43, r24	; 0x2b
    //RS=0 RW=0
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,RS_PIN,PIN_LOW);
    2d02:	82 e0       	ldi	r24, 0x02	; 2
    2d04:	60 e0       	ldi	r22, 0x00	; 0
    2d06:	40 e0       	ldi	r20, 0x00	; 0
    2d08:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,RW_PIN,PIN_LOW);
    2d0c:	82 e0       	ldi	r24, 0x02	; 2
    2d0e:	61 e0       	ldi	r22, 0x01	; 1
    2d10:	40 e0       	ldi	r20, 0x00	; 0
    2d12:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>

    //send UPPER Bits (B7 to B4)
    MDIO_voidSetPortValue(LCD_DATA_PORT,A_u8Command);
    2d16:	83 e0       	ldi	r24, 0x03	; 3
    2d18:	6b a5       	ldd	r22, Y+43	; 0x2b
    2d1a:	0e 94 40 12 	call	0x2480	; 0x2480 <MDIO_voidSetPortValue>


    //pulse HIGH to LOW to ENABLE PIN
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_HIGH);
    2d1e:	82 e0       	ldi	r24, 0x02	; 2
    2d20:	62 e0       	ldi	r22, 0x02	; 2
    2d22:	41 e0       	ldi	r20, 0x01	; 1
    2d24:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    2d28:	80 e0       	ldi	r24, 0x00	; 0
    2d2a:	90 e0       	ldi	r25, 0x00	; 0
    2d2c:	a0 e8       	ldi	r26, 0x80	; 128
    2d2e:	bf e3       	ldi	r27, 0x3F	; 63
    2d30:	8f a3       	std	Y+39, r24	; 0x27
    2d32:	98 a7       	std	Y+40, r25	; 0x28
    2d34:	a9 a7       	std	Y+41, r26	; 0x29
    2d36:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2d38:	6f a1       	ldd	r22, Y+39	; 0x27
    2d3a:	78 a5       	ldd	r23, Y+40	; 0x28
    2d3c:	89 a5       	ldd	r24, Y+41	; 0x29
    2d3e:	9a a5       	ldd	r25, Y+42	; 0x2a
    2d40:	20 e0       	ldi	r18, 0x00	; 0
    2d42:	30 e0       	ldi	r19, 0x00	; 0
    2d44:	4a ef       	ldi	r20, 0xFA	; 250
    2d46:	54 e4       	ldi	r21, 0x44	; 68
    2d48:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    2d4c:	dc 01       	movw	r26, r24
    2d4e:	cb 01       	movw	r24, r22
    2d50:	8b a3       	std	Y+35, r24	; 0x23
    2d52:	9c a3       	std	Y+36, r25	; 0x24
    2d54:	ad a3       	std	Y+37, r26	; 0x25
    2d56:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    2d58:	6b a1       	ldd	r22, Y+35	; 0x23
    2d5a:	7c a1       	ldd	r23, Y+36	; 0x24
    2d5c:	8d a1       	ldd	r24, Y+37	; 0x25
    2d5e:	9e a1       	ldd	r25, Y+38	; 0x26
    2d60:	20 e0       	ldi	r18, 0x00	; 0
    2d62:	30 e0       	ldi	r19, 0x00	; 0
    2d64:	40 e8       	ldi	r20, 0x80	; 128
    2d66:	5f e3       	ldi	r21, 0x3F	; 63
    2d68:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    2d6c:	88 23       	and	r24, r24
    2d6e:	2c f4       	brge	.+10     	; 0x2d7a <HLCD4_voidSendCommand+0x8e>
		__ticks = 1;
    2d70:	81 e0       	ldi	r24, 0x01	; 1
    2d72:	90 e0       	ldi	r25, 0x00	; 0
    2d74:	9a a3       	std	Y+34, r25	; 0x22
    2d76:	89 a3       	std	Y+33, r24	; 0x21
    2d78:	3f c0       	rjmp	.+126    	; 0x2df8 <HLCD4_voidSendCommand+0x10c>
	else if (__tmp > 65535)
    2d7a:	6b a1       	ldd	r22, Y+35	; 0x23
    2d7c:	7c a1       	ldd	r23, Y+36	; 0x24
    2d7e:	8d a1       	ldd	r24, Y+37	; 0x25
    2d80:	9e a1       	ldd	r25, Y+38	; 0x26
    2d82:	20 e0       	ldi	r18, 0x00	; 0
    2d84:	3f ef       	ldi	r19, 0xFF	; 255
    2d86:	4f e7       	ldi	r20, 0x7F	; 127
    2d88:	57 e4       	ldi	r21, 0x47	; 71
    2d8a:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    2d8e:	18 16       	cp	r1, r24
    2d90:	4c f5       	brge	.+82     	; 0x2de4 <HLCD4_voidSendCommand+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2d92:	6f a1       	ldd	r22, Y+39	; 0x27
    2d94:	78 a5       	ldd	r23, Y+40	; 0x28
    2d96:	89 a5       	ldd	r24, Y+41	; 0x29
    2d98:	9a a5       	ldd	r25, Y+42	; 0x2a
    2d9a:	20 e0       	ldi	r18, 0x00	; 0
    2d9c:	30 e0       	ldi	r19, 0x00	; 0
    2d9e:	40 e2       	ldi	r20, 0x20	; 32
    2da0:	51 e4       	ldi	r21, 0x41	; 65
    2da2:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    2da6:	dc 01       	movw	r26, r24
    2da8:	cb 01       	movw	r24, r22
    2daa:	bc 01       	movw	r22, r24
    2dac:	cd 01       	movw	r24, r26
    2dae:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    2db2:	dc 01       	movw	r26, r24
    2db4:	cb 01       	movw	r24, r22
    2db6:	9a a3       	std	Y+34, r25	; 0x22
    2db8:	89 a3       	std	Y+33, r24	; 0x21
    2dba:	0f c0       	rjmp	.+30     	; 0x2dda <HLCD4_voidSendCommand+0xee>
    2dbc:	88 ec       	ldi	r24, 0xC8	; 200
    2dbe:	90 e0       	ldi	r25, 0x00	; 0
    2dc0:	98 a3       	std	Y+32, r25	; 0x20
    2dc2:	8f 8f       	std	Y+31, r24	; 0x1f
    2dc4:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2dc6:	98 a1       	ldd	r25, Y+32	; 0x20
    2dc8:	01 97       	sbiw	r24, 0x01	; 1
    2dca:	f1 f7       	brne	.-4      	; 0x2dc8 <HLCD4_voidSendCommand+0xdc>
    2dcc:	98 a3       	std	Y+32, r25	; 0x20
    2dce:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2dd0:	89 a1       	ldd	r24, Y+33	; 0x21
    2dd2:	9a a1       	ldd	r25, Y+34	; 0x22
    2dd4:	01 97       	sbiw	r24, 0x01	; 1
    2dd6:	9a a3       	std	Y+34, r25	; 0x22
    2dd8:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2dda:	89 a1       	ldd	r24, Y+33	; 0x21
    2ddc:	9a a1       	ldd	r25, Y+34	; 0x22
    2dde:	00 97       	sbiw	r24, 0x00	; 0
    2de0:	69 f7       	brne	.-38     	; 0x2dbc <HLCD4_voidSendCommand+0xd0>
    2de2:	14 c0       	rjmp	.+40     	; 0x2e0c <HLCD4_voidSendCommand+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2de4:	6b a1       	ldd	r22, Y+35	; 0x23
    2de6:	7c a1       	ldd	r23, Y+36	; 0x24
    2de8:	8d a1       	ldd	r24, Y+37	; 0x25
    2dea:	9e a1       	ldd	r25, Y+38	; 0x26
    2dec:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    2df0:	dc 01       	movw	r26, r24
    2df2:	cb 01       	movw	r24, r22
    2df4:	9a a3       	std	Y+34, r25	; 0x22
    2df6:	89 a3       	std	Y+33, r24	; 0x21
    2df8:	89 a1       	ldd	r24, Y+33	; 0x21
    2dfa:	9a a1       	ldd	r25, Y+34	; 0x22
    2dfc:	9e 8f       	std	Y+30, r25	; 0x1e
    2dfe:	8d 8f       	std	Y+29, r24	; 0x1d
    2e00:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2e02:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2e04:	01 97       	sbiw	r24, 0x01	; 1
    2e06:	f1 f7       	brne	.-4      	; 0x2e04 <HLCD4_voidSendCommand+0x118>
    2e08:	9e 8f       	std	Y+30, r25	; 0x1e
    2e0a:	8d 8f       	std	Y+29, r24	; 0x1d
    _delay_ms(1);
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_LOW);
    2e0c:	82 e0       	ldi	r24, 0x02	; 2
    2e0e:	62 e0       	ldi	r22, 0x02	; 2
    2e10:	40 e0       	ldi	r20, 0x00	; 0
    2e12:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>

    if(global_u8Init)
    2e16:	80 91 ac 01 	lds	r24, 0x01AC
    2e1a:	88 23       	and	r24, r24
    2e1c:	09 f4       	brne	.+2      	; 0x2e20 <HLCD4_voidSendCommand+0x134>
    2e1e:	84 c0       	rjmp	.+264    	; 0x2f28 <HLCD4_voidSendCommand+0x23c>
    {

        //send LOWR Bits (B3 to B0)
        MDIO_voidSetPortValue(LCD_DATA_PORT,A_u8Command<<4);
    2e20:	8b a5       	ldd	r24, Y+43	; 0x2b
    2e22:	98 2f       	mov	r25, r24
    2e24:	92 95       	swap	r25
    2e26:	90 7f       	andi	r25, 0xF0	; 240
    2e28:	83 e0       	ldi	r24, 0x03	; 3
    2e2a:	69 2f       	mov	r22, r25
    2e2c:	0e 94 40 12 	call	0x2480	; 0x2480 <MDIO_voidSetPortValue>

        //pulse HIGH to LOW to ENABLE PIN
        MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_HIGH);
    2e30:	82 e0       	ldi	r24, 0x02	; 2
    2e32:	62 e0       	ldi	r22, 0x02	; 2
    2e34:	41 e0       	ldi	r20, 0x01	; 1
    2e36:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    2e3a:	80 e0       	ldi	r24, 0x00	; 0
    2e3c:	90 e0       	ldi	r25, 0x00	; 0
    2e3e:	a0 e8       	ldi	r26, 0x80	; 128
    2e40:	bf e3       	ldi	r27, 0x3F	; 63
    2e42:	89 8f       	std	Y+25, r24	; 0x19
    2e44:	9a 8f       	std	Y+26, r25	; 0x1a
    2e46:	ab 8f       	std	Y+27, r26	; 0x1b
    2e48:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2e4a:	69 8d       	ldd	r22, Y+25	; 0x19
    2e4c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2e4e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2e50:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2e52:	20 e0       	ldi	r18, 0x00	; 0
    2e54:	30 e0       	ldi	r19, 0x00	; 0
    2e56:	4a ef       	ldi	r20, 0xFA	; 250
    2e58:	54 e4       	ldi	r21, 0x44	; 68
    2e5a:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    2e5e:	dc 01       	movw	r26, r24
    2e60:	cb 01       	movw	r24, r22
    2e62:	8d 8b       	std	Y+21, r24	; 0x15
    2e64:	9e 8b       	std	Y+22, r25	; 0x16
    2e66:	af 8b       	std	Y+23, r26	; 0x17
    2e68:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2e6a:	6d 89       	ldd	r22, Y+21	; 0x15
    2e6c:	7e 89       	ldd	r23, Y+22	; 0x16
    2e6e:	8f 89       	ldd	r24, Y+23	; 0x17
    2e70:	98 8d       	ldd	r25, Y+24	; 0x18
    2e72:	20 e0       	ldi	r18, 0x00	; 0
    2e74:	30 e0       	ldi	r19, 0x00	; 0
    2e76:	40 e8       	ldi	r20, 0x80	; 128
    2e78:	5f e3       	ldi	r21, 0x3F	; 63
    2e7a:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    2e7e:	88 23       	and	r24, r24
    2e80:	2c f4       	brge	.+10     	; 0x2e8c <HLCD4_voidSendCommand+0x1a0>
		__ticks = 1;
    2e82:	81 e0       	ldi	r24, 0x01	; 1
    2e84:	90 e0       	ldi	r25, 0x00	; 0
    2e86:	9c 8b       	std	Y+20, r25	; 0x14
    2e88:	8b 8b       	std	Y+19, r24	; 0x13
    2e8a:	3f c0       	rjmp	.+126    	; 0x2f0a <HLCD4_voidSendCommand+0x21e>
	else if (__tmp > 65535)
    2e8c:	6d 89       	ldd	r22, Y+21	; 0x15
    2e8e:	7e 89       	ldd	r23, Y+22	; 0x16
    2e90:	8f 89       	ldd	r24, Y+23	; 0x17
    2e92:	98 8d       	ldd	r25, Y+24	; 0x18
    2e94:	20 e0       	ldi	r18, 0x00	; 0
    2e96:	3f ef       	ldi	r19, 0xFF	; 255
    2e98:	4f e7       	ldi	r20, 0x7F	; 127
    2e9a:	57 e4       	ldi	r21, 0x47	; 71
    2e9c:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    2ea0:	18 16       	cp	r1, r24
    2ea2:	4c f5       	brge	.+82     	; 0x2ef6 <HLCD4_voidSendCommand+0x20a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2ea4:	69 8d       	ldd	r22, Y+25	; 0x19
    2ea6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2ea8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2eaa:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2eac:	20 e0       	ldi	r18, 0x00	; 0
    2eae:	30 e0       	ldi	r19, 0x00	; 0
    2eb0:	40 e2       	ldi	r20, 0x20	; 32
    2eb2:	51 e4       	ldi	r21, 0x41	; 65
    2eb4:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    2eb8:	dc 01       	movw	r26, r24
    2eba:	cb 01       	movw	r24, r22
    2ebc:	bc 01       	movw	r22, r24
    2ebe:	cd 01       	movw	r24, r26
    2ec0:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    2ec4:	dc 01       	movw	r26, r24
    2ec6:	cb 01       	movw	r24, r22
    2ec8:	9c 8b       	std	Y+20, r25	; 0x14
    2eca:	8b 8b       	std	Y+19, r24	; 0x13
    2ecc:	0f c0       	rjmp	.+30     	; 0x2eec <HLCD4_voidSendCommand+0x200>
    2ece:	88 ec       	ldi	r24, 0xC8	; 200
    2ed0:	90 e0       	ldi	r25, 0x00	; 0
    2ed2:	9a 8b       	std	Y+18, r25	; 0x12
    2ed4:	89 8b       	std	Y+17, r24	; 0x11
    2ed6:	89 89       	ldd	r24, Y+17	; 0x11
    2ed8:	9a 89       	ldd	r25, Y+18	; 0x12
    2eda:	01 97       	sbiw	r24, 0x01	; 1
    2edc:	f1 f7       	brne	.-4      	; 0x2eda <HLCD4_voidSendCommand+0x1ee>
    2ede:	9a 8b       	std	Y+18, r25	; 0x12
    2ee0:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2ee2:	8b 89       	ldd	r24, Y+19	; 0x13
    2ee4:	9c 89       	ldd	r25, Y+20	; 0x14
    2ee6:	01 97       	sbiw	r24, 0x01	; 1
    2ee8:	9c 8b       	std	Y+20, r25	; 0x14
    2eea:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2eec:	8b 89       	ldd	r24, Y+19	; 0x13
    2eee:	9c 89       	ldd	r25, Y+20	; 0x14
    2ef0:	00 97       	sbiw	r24, 0x00	; 0
    2ef2:	69 f7       	brne	.-38     	; 0x2ece <HLCD4_voidSendCommand+0x1e2>
    2ef4:	14 c0       	rjmp	.+40     	; 0x2f1e <HLCD4_voidSendCommand+0x232>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2ef6:	6d 89       	ldd	r22, Y+21	; 0x15
    2ef8:	7e 89       	ldd	r23, Y+22	; 0x16
    2efa:	8f 89       	ldd	r24, Y+23	; 0x17
    2efc:	98 8d       	ldd	r25, Y+24	; 0x18
    2efe:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    2f02:	dc 01       	movw	r26, r24
    2f04:	cb 01       	movw	r24, r22
    2f06:	9c 8b       	std	Y+20, r25	; 0x14
    2f08:	8b 8b       	std	Y+19, r24	; 0x13
    2f0a:	8b 89       	ldd	r24, Y+19	; 0x13
    2f0c:	9c 89       	ldd	r25, Y+20	; 0x14
    2f0e:	98 8b       	std	Y+16, r25	; 0x10
    2f10:	8f 87       	std	Y+15, r24	; 0x0f
    2f12:	8f 85       	ldd	r24, Y+15	; 0x0f
    2f14:	98 89       	ldd	r25, Y+16	; 0x10
    2f16:	01 97       	sbiw	r24, 0x01	; 1
    2f18:	f1 f7       	brne	.-4      	; 0x2f16 <HLCD4_voidSendCommand+0x22a>
    2f1a:	98 8b       	std	Y+16, r25	; 0x10
    2f1c:	8f 87       	std	Y+15, r24	; 0x0f
        _delay_ms(1);
        MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_LOW);
    2f1e:	82 e0       	ldi	r24, 0x02	; 2
    2f20:	62 e0       	ldi	r22, 0x02	; 2
    2f22:	40 e0       	ldi	r20, 0x00	; 0
    2f24:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    2f28:	80 e0       	ldi	r24, 0x00	; 0
    2f2a:	90 e0       	ldi	r25, 0x00	; 0
    2f2c:	a0 e0       	ldi	r26, 0x00	; 0
    2f2e:	b0 e4       	ldi	r27, 0x40	; 64
    2f30:	8b 87       	std	Y+11, r24	; 0x0b
    2f32:	9c 87       	std	Y+12, r25	; 0x0c
    2f34:	ad 87       	std	Y+13, r26	; 0x0d
    2f36:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2f38:	6b 85       	ldd	r22, Y+11	; 0x0b
    2f3a:	7c 85       	ldd	r23, Y+12	; 0x0c
    2f3c:	8d 85       	ldd	r24, Y+13	; 0x0d
    2f3e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2f40:	20 e0       	ldi	r18, 0x00	; 0
    2f42:	30 e0       	ldi	r19, 0x00	; 0
    2f44:	4a ef       	ldi	r20, 0xFA	; 250
    2f46:	54 e4       	ldi	r21, 0x44	; 68
    2f48:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    2f4c:	dc 01       	movw	r26, r24
    2f4e:	cb 01       	movw	r24, r22
    2f50:	8f 83       	std	Y+7, r24	; 0x07
    2f52:	98 87       	std	Y+8, r25	; 0x08
    2f54:	a9 87       	std	Y+9, r26	; 0x09
    2f56:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2f58:	6f 81       	ldd	r22, Y+7	; 0x07
    2f5a:	78 85       	ldd	r23, Y+8	; 0x08
    2f5c:	89 85       	ldd	r24, Y+9	; 0x09
    2f5e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2f60:	20 e0       	ldi	r18, 0x00	; 0
    2f62:	30 e0       	ldi	r19, 0x00	; 0
    2f64:	40 e8       	ldi	r20, 0x80	; 128
    2f66:	5f e3       	ldi	r21, 0x3F	; 63
    2f68:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    2f6c:	88 23       	and	r24, r24
    2f6e:	2c f4       	brge	.+10     	; 0x2f7a <HLCD4_voidSendCommand+0x28e>
		__ticks = 1;
    2f70:	81 e0       	ldi	r24, 0x01	; 1
    2f72:	90 e0       	ldi	r25, 0x00	; 0
    2f74:	9e 83       	std	Y+6, r25	; 0x06
    2f76:	8d 83       	std	Y+5, r24	; 0x05
    2f78:	3f c0       	rjmp	.+126    	; 0x2ff8 <HLCD4_voidSendCommand+0x30c>
	else if (__tmp > 65535)
    2f7a:	6f 81       	ldd	r22, Y+7	; 0x07
    2f7c:	78 85       	ldd	r23, Y+8	; 0x08
    2f7e:	89 85       	ldd	r24, Y+9	; 0x09
    2f80:	9a 85       	ldd	r25, Y+10	; 0x0a
    2f82:	20 e0       	ldi	r18, 0x00	; 0
    2f84:	3f ef       	ldi	r19, 0xFF	; 255
    2f86:	4f e7       	ldi	r20, 0x7F	; 127
    2f88:	57 e4       	ldi	r21, 0x47	; 71
    2f8a:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    2f8e:	18 16       	cp	r1, r24
    2f90:	4c f5       	brge	.+82     	; 0x2fe4 <HLCD4_voidSendCommand+0x2f8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2f92:	6b 85       	ldd	r22, Y+11	; 0x0b
    2f94:	7c 85       	ldd	r23, Y+12	; 0x0c
    2f96:	8d 85       	ldd	r24, Y+13	; 0x0d
    2f98:	9e 85       	ldd	r25, Y+14	; 0x0e
    2f9a:	20 e0       	ldi	r18, 0x00	; 0
    2f9c:	30 e0       	ldi	r19, 0x00	; 0
    2f9e:	40 e2       	ldi	r20, 0x20	; 32
    2fa0:	51 e4       	ldi	r21, 0x41	; 65
    2fa2:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    2fa6:	dc 01       	movw	r26, r24
    2fa8:	cb 01       	movw	r24, r22
    2faa:	bc 01       	movw	r22, r24
    2fac:	cd 01       	movw	r24, r26
    2fae:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    2fb2:	dc 01       	movw	r26, r24
    2fb4:	cb 01       	movw	r24, r22
    2fb6:	9e 83       	std	Y+6, r25	; 0x06
    2fb8:	8d 83       	std	Y+5, r24	; 0x05
    2fba:	0f c0       	rjmp	.+30     	; 0x2fda <HLCD4_voidSendCommand+0x2ee>
    2fbc:	88 ec       	ldi	r24, 0xC8	; 200
    2fbe:	90 e0       	ldi	r25, 0x00	; 0
    2fc0:	9c 83       	std	Y+4, r25	; 0x04
    2fc2:	8b 83       	std	Y+3, r24	; 0x03
    2fc4:	8b 81       	ldd	r24, Y+3	; 0x03
    2fc6:	9c 81       	ldd	r25, Y+4	; 0x04
    2fc8:	01 97       	sbiw	r24, 0x01	; 1
    2fca:	f1 f7       	brne	.-4      	; 0x2fc8 <HLCD4_voidSendCommand+0x2dc>
    2fcc:	9c 83       	std	Y+4, r25	; 0x04
    2fce:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2fd0:	8d 81       	ldd	r24, Y+5	; 0x05
    2fd2:	9e 81       	ldd	r25, Y+6	; 0x06
    2fd4:	01 97       	sbiw	r24, 0x01	; 1
    2fd6:	9e 83       	std	Y+6, r25	; 0x06
    2fd8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2fda:	8d 81       	ldd	r24, Y+5	; 0x05
    2fdc:	9e 81       	ldd	r25, Y+6	; 0x06
    2fde:	00 97       	sbiw	r24, 0x00	; 0
    2fe0:	69 f7       	brne	.-38     	; 0x2fbc <HLCD4_voidSendCommand+0x2d0>
    2fe2:	14 c0       	rjmp	.+40     	; 0x300c <HLCD4_voidSendCommand+0x320>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2fe4:	6f 81       	ldd	r22, Y+7	; 0x07
    2fe6:	78 85       	ldd	r23, Y+8	; 0x08
    2fe8:	89 85       	ldd	r24, Y+9	; 0x09
    2fea:	9a 85       	ldd	r25, Y+10	; 0x0a
    2fec:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    2ff0:	dc 01       	movw	r26, r24
    2ff2:	cb 01       	movw	r24, r22
    2ff4:	9e 83       	std	Y+6, r25	; 0x06
    2ff6:	8d 83       	std	Y+5, r24	; 0x05
    2ff8:	8d 81       	ldd	r24, Y+5	; 0x05
    2ffa:	9e 81       	ldd	r25, Y+6	; 0x06
    2ffc:	9a 83       	std	Y+2, r25	; 0x02
    2ffe:	89 83       	std	Y+1, r24	; 0x01
    3000:	89 81       	ldd	r24, Y+1	; 0x01
    3002:	9a 81       	ldd	r25, Y+2	; 0x02
    3004:	01 97       	sbiw	r24, 0x01	; 1
    3006:	f1 f7       	brne	.-4      	; 0x3004 <HLCD4_voidSendCommand+0x318>
    3008:	9a 83       	std	Y+2, r25	; 0x02
    300a:	89 83       	std	Y+1, r24	; 0x01
    }
    _delay_ms(2);
}
    300c:	ab 96       	adiw	r28, 0x2b	; 43
    300e:	0f b6       	in	r0, 0x3f	; 63
    3010:	f8 94       	cli
    3012:	de bf       	out	0x3e, r29	; 62
    3014:	0f be       	out	0x3f, r0	; 63
    3016:	cd bf       	out	0x3d, r28	; 61
    3018:	cf 91       	pop	r28
    301a:	df 91       	pop	r29
    301c:	08 95       	ret

0000301e <HLCD4_voidSendData>:


void HLCD4_voidSendData(u8 A_u8Data)
{
    301e:	df 93       	push	r29
    3020:	cf 93       	push	r28
    3022:	cd b7       	in	r28, 0x3d	; 61
    3024:	de b7       	in	r29, 0x3e	; 62
    3026:	ab 97       	sbiw	r28, 0x2b	; 43
    3028:	0f b6       	in	r0, 0x3f	; 63
    302a:	f8 94       	cli
    302c:	de bf       	out	0x3e, r29	; 62
    302e:	0f be       	out	0x3f, r0	; 63
    3030:	cd bf       	out	0x3d, r28	; 61
    3032:	8b a7       	std	Y+43, r24	; 0x2b
    //RS=1 RW=0
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,RS_PIN,PIN_HIGH);
    3034:	82 e0       	ldi	r24, 0x02	; 2
    3036:	60 e0       	ldi	r22, 0x00	; 0
    3038:	41 e0       	ldi	r20, 0x01	; 1
    303a:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,RW_PIN,PIN_LOW);
    303e:	82 e0       	ldi	r24, 0x02	; 2
    3040:	61 e0       	ldi	r22, 0x01	; 1
    3042:	40 e0       	ldi	r20, 0x00	; 0
    3044:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>

	MDIO_voidSetPortValue(LCD_DATA_PORT,A_u8Data);
    3048:	83 e0       	ldi	r24, 0x03	; 3
    304a:	6b a5       	ldd	r22, Y+43	; 0x2b
    304c:	0e 94 40 12 	call	0x2480	; 0x2480 <MDIO_voidSetPortValue>


    MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_HIGH);
    3050:	82 e0       	ldi	r24, 0x02	; 2
    3052:	62 e0       	ldi	r22, 0x02	; 2
    3054:	41 e0       	ldi	r20, 0x01	; 1
    3056:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    305a:	80 e0       	ldi	r24, 0x00	; 0
    305c:	90 e0       	ldi	r25, 0x00	; 0
    305e:	a0 e8       	ldi	r26, 0x80	; 128
    3060:	bf e3       	ldi	r27, 0x3F	; 63
    3062:	8f a3       	std	Y+39, r24	; 0x27
    3064:	98 a7       	std	Y+40, r25	; 0x28
    3066:	a9 a7       	std	Y+41, r26	; 0x29
    3068:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    306a:	6f a1       	ldd	r22, Y+39	; 0x27
    306c:	78 a5       	ldd	r23, Y+40	; 0x28
    306e:	89 a5       	ldd	r24, Y+41	; 0x29
    3070:	9a a5       	ldd	r25, Y+42	; 0x2a
    3072:	20 e0       	ldi	r18, 0x00	; 0
    3074:	30 e0       	ldi	r19, 0x00	; 0
    3076:	4a ef       	ldi	r20, 0xFA	; 250
    3078:	54 e4       	ldi	r21, 0x44	; 68
    307a:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    307e:	dc 01       	movw	r26, r24
    3080:	cb 01       	movw	r24, r22
    3082:	8b a3       	std	Y+35, r24	; 0x23
    3084:	9c a3       	std	Y+36, r25	; 0x24
    3086:	ad a3       	std	Y+37, r26	; 0x25
    3088:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    308a:	6b a1       	ldd	r22, Y+35	; 0x23
    308c:	7c a1       	ldd	r23, Y+36	; 0x24
    308e:	8d a1       	ldd	r24, Y+37	; 0x25
    3090:	9e a1       	ldd	r25, Y+38	; 0x26
    3092:	20 e0       	ldi	r18, 0x00	; 0
    3094:	30 e0       	ldi	r19, 0x00	; 0
    3096:	40 e8       	ldi	r20, 0x80	; 128
    3098:	5f e3       	ldi	r21, 0x3F	; 63
    309a:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    309e:	88 23       	and	r24, r24
    30a0:	2c f4       	brge	.+10     	; 0x30ac <HLCD4_voidSendData+0x8e>
		__ticks = 1;
    30a2:	81 e0       	ldi	r24, 0x01	; 1
    30a4:	90 e0       	ldi	r25, 0x00	; 0
    30a6:	9a a3       	std	Y+34, r25	; 0x22
    30a8:	89 a3       	std	Y+33, r24	; 0x21
    30aa:	3f c0       	rjmp	.+126    	; 0x312a <HLCD4_voidSendData+0x10c>
	else if (__tmp > 65535)
    30ac:	6b a1       	ldd	r22, Y+35	; 0x23
    30ae:	7c a1       	ldd	r23, Y+36	; 0x24
    30b0:	8d a1       	ldd	r24, Y+37	; 0x25
    30b2:	9e a1       	ldd	r25, Y+38	; 0x26
    30b4:	20 e0       	ldi	r18, 0x00	; 0
    30b6:	3f ef       	ldi	r19, 0xFF	; 255
    30b8:	4f e7       	ldi	r20, 0x7F	; 127
    30ba:	57 e4       	ldi	r21, 0x47	; 71
    30bc:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    30c0:	18 16       	cp	r1, r24
    30c2:	4c f5       	brge	.+82     	; 0x3116 <HLCD4_voidSendData+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    30c4:	6f a1       	ldd	r22, Y+39	; 0x27
    30c6:	78 a5       	ldd	r23, Y+40	; 0x28
    30c8:	89 a5       	ldd	r24, Y+41	; 0x29
    30ca:	9a a5       	ldd	r25, Y+42	; 0x2a
    30cc:	20 e0       	ldi	r18, 0x00	; 0
    30ce:	30 e0       	ldi	r19, 0x00	; 0
    30d0:	40 e2       	ldi	r20, 0x20	; 32
    30d2:	51 e4       	ldi	r21, 0x41	; 65
    30d4:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    30d8:	dc 01       	movw	r26, r24
    30da:	cb 01       	movw	r24, r22
    30dc:	bc 01       	movw	r22, r24
    30de:	cd 01       	movw	r24, r26
    30e0:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    30e4:	dc 01       	movw	r26, r24
    30e6:	cb 01       	movw	r24, r22
    30e8:	9a a3       	std	Y+34, r25	; 0x22
    30ea:	89 a3       	std	Y+33, r24	; 0x21
    30ec:	0f c0       	rjmp	.+30     	; 0x310c <HLCD4_voidSendData+0xee>
    30ee:	88 ec       	ldi	r24, 0xC8	; 200
    30f0:	90 e0       	ldi	r25, 0x00	; 0
    30f2:	98 a3       	std	Y+32, r25	; 0x20
    30f4:	8f 8f       	std	Y+31, r24	; 0x1f
    30f6:	8f 8d       	ldd	r24, Y+31	; 0x1f
    30f8:	98 a1       	ldd	r25, Y+32	; 0x20
    30fa:	01 97       	sbiw	r24, 0x01	; 1
    30fc:	f1 f7       	brne	.-4      	; 0x30fa <HLCD4_voidSendData+0xdc>
    30fe:	98 a3       	std	Y+32, r25	; 0x20
    3100:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3102:	89 a1       	ldd	r24, Y+33	; 0x21
    3104:	9a a1       	ldd	r25, Y+34	; 0x22
    3106:	01 97       	sbiw	r24, 0x01	; 1
    3108:	9a a3       	std	Y+34, r25	; 0x22
    310a:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    310c:	89 a1       	ldd	r24, Y+33	; 0x21
    310e:	9a a1       	ldd	r25, Y+34	; 0x22
    3110:	00 97       	sbiw	r24, 0x00	; 0
    3112:	69 f7       	brne	.-38     	; 0x30ee <HLCD4_voidSendData+0xd0>
    3114:	14 c0       	rjmp	.+40     	; 0x313e <HLCD4_voidSendData+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3116:	6b a1       	ldd	r22, Y+35	; 0x23
    3118:	7c a1       	ldd	r23, Y+36	; 0x24
    311a:	8d a1       	ldd	r24, Y+37	; 0x25
    311c:	9e a1       	ldd	r25, Y+38	; 0x26
    311e:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    3122:	dc 01       	movw	r26, r24
    3124:	cb 01       	movw	r24, r22
    3126:	9a a3       	std	Y+34, r25	; 0x22
    3128:	89 a3       	std	Y+33, r24	; 0x21
    312a:	89 a1       	ldd	r24, Y+33	; 0x21
    312c:	9a a1       	ldd	r25, Y+34	; 0x22
    312e:	9e 8f       	std	Y+30, r25	; 0x1e
    3130:	8d 8f       	std	Y+29, r24	; 0x1d
    3132:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3134:	9e 8d       	ldd	r25, Y+30	; 0x1e
    3136:	01 97       	sbiw	r24, 0x01	; 1
    3138:	f1 f7       	brne	.-4      	; 0x3136 <HLCD4_voidSendData+0x118>
    313a:	9e 8f       	std	Y+30, r25	; 0x1e
    313c:	8d 8f       	std	Y+29, r24	; 0x1d
    _delay_ms(1);
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_LOW);
    313e:	82 e0       	ldi	r24, 0x02	; 2
    3140:	62 e0       	ldi	r22, 0x02	; 2
    3142:	40 e0       	ldi	r20, 0x00	; 0
    3144:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>

    MDIO_voidSetPortValue(LCD_DATA_PORT,A_u8Data<<4);
    3148:	8b a5       	ldd	r24, Y+43	; 0x2b
    314a:	98 2f       	mov	r25, r24
    314c:	92 95       	swap	r25
    314e:	90 7f       	andi	r25, 0xF0	; 240
    3150:	83 e0       	ldi	r24, 0x03	; 3
    3152:	69 2f       	mov	r22, r25
    3154:	0e 94 40 12 	call	0x2480	; 0x2480 <MDIO_voidSetPortValue>


    MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_HIGH);
    3158:	82 e0       	ldi	r24, 0x02	; 2
    315a:	62 e0       	ldi	r22, 0x02	; 2
    315c:	41 e0       	ldi	r20, 0x01	; 1
    315e:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    3162:	80 e0       	ldi	r24, 0x00	; 0
    3164:	90 e0       	ldi	r25, 0x00	; 0
    3166:	a0 e8       	ldi	r26, 0x80	; 128
    3168:	bf e3       	ldi	r27, 0x3F	; 63
    316a:	89 8f       	std	Y+25, r24	; 0x19
    316c:	9a 8f       	std	Y+26, r25	; 0x1a
    316e:	ab 8f       	std	Y+27, r26	; 0x1b
    3170:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3172:	69 8d       	ldd	r22, Y+25	; 0x19
    3174:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3176:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3178:	9c 8d       	ldd	r25, Y+28	; 0x1c
    317a:	20 e0       	ldi	r18, 0x00	; 0
    317c:	30 e0       	ldi	r19, 0x00	; 0
    317e:	4a ef       	ldi	r20, 0xFA	; 250
    3180:	54 e4       	ldi	r21, 0x44	; 68
    3182:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    3186:	dc 01       	movw	r26, r24
    3188:	cb 01       	movw	r24, r22
    318a:	8d 8b       	std	Y+21, r24	; 0x15
    318c:	9e 8b       	std	Y+22, r25	; 0x16
    318e:	af 8b       	std	Y+23, r26	; 0x17
    3190:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    3192:	6d 89       	ldd	r22, Y+21	; 0x15
    3194:	7e 89       	ldd	r23, Y+22	; 0x16
    3196:	8f 89       	ldd	r24, Y+23	; 0x17
    3198:	98 8d       	ldd	r25, Y+24	; 0x18
    319a:	20 e0       	ldi	r18, 0x00	; 0
    319c:	30 e0       	ldi	r19, 0x00	; 0
    319e:	40 e8       	ldi	r20, 0x80	; 128
    31a0:	5f e3       	ldi	r21, 0x3F	; 63
    31a2:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    31a6:	88 23       	and	r24, r24
    31a8:	2c f4       	brge	.+10     	; 0x31b4 <HLCD4_voidSendData+0x196>
		__ticks = 1;
    31aa:	81 e0       	ldi	r24, 0x01	; 1
    31ac:	90 e0       	ldi	r25, 0x00	; 0
    31ae:	9c 8b       	std	Y+20, r25	; 0x14
    31b0:	8b 8b       	std	Y+19, r24	; 0x13
    31b2:	3f c0       	rjmp	.+126    	; 0x3232 <HLCD4_voidSendData+0x214>
	else if (__tmp > 65535)
    31b4:	6d 89       	ldd	r22, Y+21	; 0x15
    31b6:	7e 89       	ldd	r23, Y+22	; 0x16
    31b8:	8f 89       	ldd	r24, Y+23	; 0x17
    31ba:	98 8d       	ldd	r25, Y+24	; 0x18
    31bc:	20 e0       	ldi	r18, 0x00	; 0
    31be:	3f ef       	ldi	r19, 0xFF	; 255
    31c0:	4f e7       	ldi	r20, 0x7F	; 127
    31c2:	57 e4       	ldi	r21, 0x47	; 71
    31c4:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    31c8:	18 16       	cp	r1, r24
    31ca:	4c f5       	brge	.+82     	; 0x321e <HLCD4_voidSendData+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    31cc:	69 8d       	ldd	r22, Y+25	; 0x19
    31ce:	7a 8d       	ldd	r23, Y+26	; 0x1a
    31d0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    31d2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    31d4:	20 e0       	ldi	r18, 0x00	; 0
    31d6:	30 e0       	ldi	r19, 0x00	; 0
    31d8:	40 e2       	ldi	r20, 0x20	; 32
    31da:	51 e4       	ldi	r21, 0x41	; 65
    31dc:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    31e0:	dc 01       	movw	r26, r24
    31e2:	cb 01       	movw	r24, r22
    31e4:	bc 01       	movw	r22, r24
    31e6:	cd 01       	movw	r24, r26
    31e8:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    31ec:	dc 01       	movw	r26, r24
    31ee:	cb 01       	movw	r24, r22
    31f0:	9c 8b       	std	Y+20, r25	; 0x14
    31f2:	8b 8b       	std	Y+19, r24	; 0x13
    31f4:	0f c0       	rjmp	.+30     	; 0x3214 <HLCD4_voidSendData+0x1f6>
    31f6:	88 ec       	ldi	r24, 0xC8	; 200
    31f8:	90 e0       	ldi	r25, 0x00	; 0
    31fa:	9a 8b       	std	Y+18, r25	; 0x12
    31fc:	89 8b       	std	Y+17, r24	; 0x11
    31fe:	89 89       	ldd	r24, Y+17	; 0x11
    3200:	9a 89       	ldd	r25, Y+18	; 0x12
    3202:	01 97       	sbiw	r24, 0x01	; 1
    3204:	f1 f7       	brne	.-4      	; 0x3202 <HLCD4_voidSendData+0x1e4>
    3206:	9a 8b       	std	Y+18, r25	; 0x12
    3208:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    320a:	8b 89       	ldd	r24, Y+19	; 0x13
    320c:	9c 89       	ldd	r25, Y+20	; 0x14
    320e:	01 97       	sbiw	r24, 0x01	; 1
    3210:	9c 8b       	std	Y+20, r25	; 0x14
    3212:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3214:	8b 89       	ldd	r24, Y+19	; 0x13
    3216:	9c 89       	ldd	r25, Y+20	; 0x14
    3218:	00 97       	sbiw	r24, 0x00	; 0
    321a:	69 f7       	brne	.-38     	; 0x31f6 <HLCD4_voidSendData+0x1d8>
    321c:	14 c0       	rjmp	.+40     	; 0x3246 <HLCD4_voidSendData+0x228>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    321e:	6d 89       	ldd	r22, Y+21	; 0x15
    3220:	7e 89       	ldd	r23, Y+22	; 0x16
    3222:	8f 89       	ldd	r24, Y+23	; 0x17
    3224:	98 8d       	ldd	r25, Y+24	; 0x18
    3226:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    322a:	dc 01       	movw	r26, r24
    322c:	cb 01       	movw	r24, r22
    322e:	9c 8b       	std	Y+20, r25	; 0x14
    3230:	8b 8b       	std	Y+19, r24	; 0x13
    3232:	8b 89       	ldd	r24, Y+19	; 0x13
    3234:	9c 89       	ldd	r25, Y+20	; 0x14
    3236:	98 8b       	std	Y+16, r25	; 0x10
    3238:	8f 87       	std	Y+15, r24	; 0x0f
    323a:	8f 85       	ldd	r24, Y+15	; 0x0f
    323c:	98 89       	ldd	r25, Y+16	; 0x10
    323e:	01 97       	sbiw	r24, 0x01	; 1
    3240:	f1 f7       	brne	.-4      	; 0x323e <HLCD4_voidSendData+0x220>
    3242:	98 8b       	std	Y+16, r25	; 0x10
    3244:	8f 87       	std	Y+15, r24	; 0x0f
    _delay_ms(1);
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_LOW);
    3246:	82 e0       	ldi	r24, 0x02	; 2
    3248:	62 e0       	ldi	r22, 0x02	; 2
    324a:	40 e0       	ldi	r20, 0x00	; 0
    324c:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    3250:	80 e0       	ldi	r24, 0x00	; 0
    3252:	90 e0       	ldi	r25, 0x00	; 0
    3254:	a0 e0       	ldi	r26, 0x00	; 0
    3256:	b0 e4       	ldi	r27, 0x40	; 64
    3258:	8b 87       	std	Y+11, r24	; 0x0b
    325a:	9c 87       	std	Y+12, r25	; 0x0c
    325c:	ad 87       	std	Y+13, r26	; 0x0d
    325e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3260:	6b 85       	ldd	r22, Y+11	; 0x0b
    3262:	7c 85       	ldd	r23, Y+12	; 0x0c
    3264:	8d 85       	ldd	r24, Y+13	; 0x0d
    3266:	9e 85       	ldd	r25, Y+14	; 0x0e
    3268:	20 e0       	ldi	r18, 0x00	; 0
    326a:	30 e0       	ldi	r19, 0x00	; 0
    326c:	4a ef       	ldi	r20, 0xFA	; 250
    326e:	54 e4       	ldi	r21, 0x44	; 68
    3270:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    3274:	dc 01       	movw	r26, r24
    3276:	cb 01       	movw	r24, r22
    3278:	8f 83       	std	Y+7, r24	; 0x07
    327a:	98 87       	std	Y+8, r25	; 0x08
    327c:	a9 87       	std	Y+9, r26	; 0x09
    327e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3280:	6f 81       	ldd	r22, Y+7	; 0x07
    3282:	78 85       	ldd	r23, Y+8	; 0x08
    3284:	89 85       	ldd	r24, Y+9	; 0x09
    3286:	9a 85       	ldd	r25, Y+10	; 0x0a
    3288:	20 e0       	ldi	r18, 0x00	; 0
    328a:	30 e0       	ldi	r19, 0x00	; 0
    328c:	40 e8       	ldi	r20, 0x80	; 128
    328e:	5f e3       	ldi	r21, 0x3F	; 63
    3290:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    3294:	88 23       	and	r24, r24
    3296:	2c f4       	brge	.+10     	; 0x32a2 <HLCD4_voidSendData+0x284>
		__ticks = 1;
    3298:	81 e0       	ldi	r24, 0x01	; 1
    329a:	90 e0       	ldi	r25, 0x00	; 0
    329c:	9e 83       	std	Y+6, r25	; 0x06
    329e:	8d 83       	std	Y+5, r24	; 0x05
    32a0:	3f c0       	rjmp	.+126    	; 0x3320 <HLCD4_voidSendData+0x302>
	else if (__tmp > 65535)
    32a2:	6f 81       	ldd	r22, Y+7	; 0x07
    32a4:	78 85       	ldd	r23, Y+8	; 0x08
    32a6:	89 85       	ldd	r24, Y+9	; 0x09
    32a8:	9a 85       	ldd	r25, Y+10	; 0x0a
    32aa:	20 e0       	ldi	r18, 0x00	; 0
    32ac:	3f ef       	ldi	r19, 0xFF	; 255
    32ae:	4f e7       	ldi	r20, 0x7F	; 127
    32b0:	57 e4       	ldi	r21, 0x47	; 71
    32b2:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    32b6:	18 16       	cp	r1, r24
    32b8:	4c f5       	brge	.+82     	; 0x330c <HLCD4_voidSendData+0x2ee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    32ba:	6b 85       	ldd	r22, Y+11	; 0x0b
    32bc:	7c 85       	ldd	r23, Y+12	; 0x0c
    32be:	8d 85       	ldd	r24, Y+13	; 0x0d
    32c0:	9e 85       	ldd	r25, Y+14	; 0x0e
    32c2:	20 e0       	ldi	r18, 0x00	; 0
    32c4:	30 e0       	ldi	r19, 0x00	; 0
    32c6:	40 e2       	ldi	r20, 0x20	; 32
    32c8:	51 e4       	ldi	r21, 0x41	; 65
    32ca:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    32ce:	dc 01       	movw	r26, r24
    32d0:	cb 01       	movw	r24, r22
    32d2:	bc 01       	movw	r22, r24
    32d4:	cd 01       	movw	r24, r26
    32d6:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    32da:	dc 01       	movw	r26, r24
    32dc:	cb 01       	movw	r24, r22
    32de:	9e 83       	std	Y+6, r25	; 0x06
    32e0:	8d 83       	std	Y+5, r24	; 0x05
    32e2:	0f c0       	rjmp	.+30     	; 0x3302 <HLCD4_voidSendData+0x2e4>
    32e4:	88 ec       	ldi	r24, 0xC8	; 200
    32e6:	90 e0       	ldi	r25, 0x00	; 0
    32e8:	9c 83       	std	Y+4, r25	; 0x04
    32ea:	8b 83       	std	Y+3, r24	; 0x03
    32ec:	8b 81       	ldd	r24, Y+3	; 0x03
    32ee:	9c 81       	ldd	r25, Y+4	; 0x04
    32f0:	01 97       	sbiw	r24, 0x01	; 1
    32f2:	f1 f7       	brne	.-4      	; 0x32f0 <HLCD4_voidSendData+0x2d2>
    32f4:	9c 83       	std	Y+4, r25	; 0x04
    32f6:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    32f8:	8d 81       	ldd	r24, Y+5	; 0x05
    32fa:	9e 81       	ldd	r25, Y+6	; 0x06
    32fc:	01 97       	sbiw	r24, 0x01	; 1
    32fe:	9e 83       	std	Y+6, r25	; 0x06
    3300:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3302:	8d 81       	ldd	r24, Y+5	; 0x05
    3304:	9e 81       	ldd	r25, Y+6	; 0x06
    3306:	00 97       	sbiw	r24, 0x00	; 0
    3308:	69 f7       	brne	.-38     	; 0x32e4 <HLCD4_voidSendData+0x2c6>
    330a:	14 c0       	rjmp	.+40     	; 0x3334 <HLCD4_voidSendData+0x316>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    330c:	6f 81       	ldd	r22, Y+7	; 0x07
    330e:	78 85       	ldd	r23, Y+8	; 0x08
    3310:	89 85       	ldd	r24, Y+9	; 0x09
    3312:	9a 85       	ldd	r25, Y+10	; 0x0a
    3314:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    3318:	dc 01       	movw	r26, r24
    331a:	cb 01       	movw	r24, r22
    331c:	9e 83       	std	Y+6, r25	; 0x06
    331e:	8d 83       	std	Y+5, r24	; 0x05
    3320:	8d 81       	ldd	r24, Y+5	; 0x05
    3322:	9e 81       	ldd	r25, Y+6	; 0x06
    3324:	9a 83       	std	Y+2, r25	; 0x02
    3326:	89 83       	std	Y+1, r24	; 0x01
    3328:	89 81       	ldd	r24, Y+1	; 0x01
    332a:	9a 81       	ldd	r25, Y+2	; 0x02
    332c:	01 97       	sbiw	r24, 0x01	; 1
    332e:	f1 f7       	brne	.-4      	; 0x332c <HLCD4_voidSendData+0x30e>
    3330:	9a 83       	std	Y+2, r25	; 0x02
    3332:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(2);
}
    3334:	ab 96       	adiw	r28, 0x2b	; 43
    3336:	0f b6       	in	r0, 0x3f	; 63
    3338:	f8 94       	cli
    333a:	de bf       	out	0x3e, r29	; 62
    333c:	0f be       	out	0x3f, r0	; 63
    333e:	cd bf       	out	0x3d, r28	; 61
    3340:	cf 91       	pop	r28
    3342:	df 91       	pop	r29
    3344:	08 95       	ret

00003346 <HLCD4_voidInit>:



void HLCD4_voidInit()
{
    3346:	0f 93       	push	r16
    3348:	1f 93       	push	r17
    334a:	df 93       	push	r29
    334c:	cf 93       	push	r28
    334e:	cd b7       	in	r28, 0x3d	; 61
    3350:	de b7       	in	r29, 0x3e	; 62
    3352:	cc 54       	subi	r28, 0x4C	; 76
    3354:	d0 40       	sbci	r29, 0x00	; 0
    3356:	0f b6       	in	r0, 0x3f	; 63
    3358:	f8 94       	cli
    335a:	de bf       	out	0x3e, r29	; 62
    335c:	0f be       	out	0x3f, r0	; 63
    335e:	cd bf       	out	0x3d, r28	; 61
    3360:	fe 01       	movw	r30, r28
    3362:	e7 5b       	subi	r30, 0xB7	; 183
    3364:	ff 4f       	sbci	r31, 0xFF	; 255
    3366:	80 e0       	ldi	r24, 0x00	; 0
    3368:	90 e0       	ldi	r25, 0x00	; 0
    336a:	a0 ef       	ldi	r26, 0xF0	; 240
    336c:	b1 e4       	ldi	r27, 0x41	; 65
    336e:	80 83       	st	Z, r24
    3370:	91 83       	std	Z+1, r25	; 0x01
    3372:	a2 83       	std	Z+2, r26	; 0x02
    3374:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3376:	8e 01       	movw	r16, r28
    3378:	0b 5b       	subi	r16, 0xBB	; 187
    337a:	1f 4f       	sbci	r17, 0xFF	; 255
    337c:	fe 01       	movw	r30, r28
    337e:	e7 5b       	subi	r30, 0xB7	; 183
    3380:	ff 4f       	sbci	r31, 0xFF	; 255
    3382:	60 81       	ld	r22, Z
    3384:	71 81       	ldd	r23, Z+1	; 0x01
    3386:	82 81       	ldd	r24, Z+2	; 0x02
    3388:	93 81       	ldd	r25, Z+3	; 0x03
    338a:	20 e0       	ldi	r18, 0x00	; 0
    338c:	30 e0       	ldi	r19, 0x00	; 0
    338e:	4a ef       	ldi	r20, 0xFA	; 250
    3390:	54 e4       	ldi	r21, 0x44	; 68
    3392:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    3396:	dc 01       	movw	r26, r24
    3398:	cb 01       	movw	r24, r22
    339a:	f8 01       	movw	r30, r16
    339c:	80 83       	st	Z, r24
    339e:	91 83       	std	Z+1, r25	; 0x01
    33a0:	a2 83       	std	Z+2, r26	; 0x02
    33a2:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    33a4:	fe 01       	movw	r30, r28
    33a6:	eb 5b       	subi	r30, 0xBB	; 187
    33a8:	ff 4f       	sbci	r31, 0xFF	; 255
    33aa:	60 81       	ld	r22, Z
    33ac:	71 81       	ldd	r23, Z+1	; 0x01
    33ae:	82 81       	ldd	r24, Z+2	; 0x02
    33b0:	93 81       	ldd	r25, Z+3	; 0x03
    33b2:	20 e0       	ldi	r18, 0x00	; 0
    33b4:	30 e0       	ldi	r19, 0x00	; 0
    33b6:	40 e8       	ldi	r20, 0x80	; 128
    33b8:	5f e3       	ldi	r21, 0x3F	; 63
    33ba:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    33be:	88 23       	and	r24, r24
    33c0:	44 f4       	brge	.+16     	; 0x33d2 <HLCD4_voidInit+0x8c>
		__ticks = 1;
    33c2:	fe 01       	movw	r30, r28
    33c4:	ed 5b       	subi	r30, 0xBD	; 189
    33c6:	ff 4f       	sbci	r31, 0xFF	; 255
    33c8:	81 e0       	ldi	r24, 0x01	; 1
    33ca:	90 e0       	ldi	r25, 0x00	; 0
    33cc:	91 83       	std	Z+1, r25	; 0x01
    33ce:	80 83       	st	Z, r24
    33d0:	64 c0       	rjmp	.+200    	; 0x349a <HLCD4_voidInit+0x154>
	else if (__tmp > 65535)
    33d2:	fe 01       	movw	r30, r28
    33d4:	eb 5b       	subi	r30, 0xBB	; 187
    33d6:	ff 4f       	sbci	r31, 0xFF	; 255
    33d8:	60 81       	ld	r22, Z
    33da:	71 81       	ldd	r23, Z+1	; 0x01
    33dc:	82 81       	ldd	r24, Z+2	; 0x02
    33de:	93 81       	ldd	r25, Z+3	; 0x03
    33e0:	20 e0       	ldi	r18, 0x00	; 0
    33e2:	3f ef       	ldi	r19, 0xFF	; 255
    33e4:	4f e7       	ldi	r20, 0x7F	; 127
    33e6:	57 e4       	ldi	r21, 0x47	; 71
    33e8:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    33ec:	18 16       	cp	r1, r24
    33ee:	0c f0       	brlt	.+2      	; 0x33f2 <HLCD4_voidInit+0xac>
    33f0:	43 c0       	rjmp	.+134    	; 0x3478 <HLCD4_voidInit+0x132>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    33f2:	fe 01       	movw	r30, r28
    33f4:	e7 5b       	subi	r30, 0xB7	; 183
    33f6:	ff 4f       	sbci	r31, 0xFF	; 255
    33f8:	60 81       	ld	r22, Z
    33fa:	71 81       	ldd	r23, Z+1	; 0x01
    33fc:	82 81       	ldd	r24, Z+2	; 0x02
    33fe:	93 81       	ldd	r25, Z+3	; 0x03
    3400:	20 e0       	ldi	r18, 0x00	; 0
    3402:	30 e0       	ldi	r19, 0x00	; 0
    3404:	40 e2       	ldi	r20, 0x20	; 32
    3406:	51 e4       	ldi	r21, 0x41	; 65
    3408:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    340c:	dc 01       	movw	r26, r24
    340e:	cb 01       	movw	r24, r22
    3410:	8e 01       	movw	r16, r28
    3412:	0d 5b       	subi	r16, 0xBD	; 189
    3414:	1f 4f       	sbci	r17, 0xFF	; 255
    3416:	bc 01       	movw	r22, r24
    3418:	cd 01       	movw	r24, r26
    341a:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    341e:	dc 01       	movw	r26, r24
    3420:	cb 01       	movw	r24, r22
    3422:	f8 01       	movw	r30, r16
    3424:	91 83       	std	Z+1, r25	; 0x01
    3426:	80 83       	st	Z, r24
    3428:	1f c0       	rjmp	.+62     	; 0x3468 <HLCD4_voidInit+0x122>
    342a:	fe 01       	movw	r30, r28
    342c:	ef 5b       	subi	r30, 0xBF	; 191
    342e:	ff 4f       	sbci	r31, 0xFF	; 255
    3430:	88 ec       	ldi	r24, 0xC8	; 200
    3432:	90 e0       	ldi	r25, 0x00	; 0
    3434:	91 83       	std	Z+1, r25	; 0x01
    3436:	80 83       	st	Z, r24
    3438:	fe 01       	movw	r30, r28
    343a:	ef 5b       	subi	r30, 0xBF	; 191
    343c:	ff 4f       	sbci	r31, 0xFF	; 255
    343e:	80 81       	ld	r24, Z
    3440:	91 81       	ldd	r25, Z+1	; 0x01
    3442:	01 97       	sbiw	r24, 0x01	; 1
    3444:	f1 f7       	brne	.-4      	; 0x3442 <HLCD4_voidInit+0xfc>
    3446:	fe 01       	movw	r30, r28
    3448:	ef 5b       	subi	r30, 0xBF	; 191
    344a:	ff 4f       	sbci	r31, 0xFF	; 255
    344c:	91 83       	std	Z+1, r25	; 0x01
    344e:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3450:	de 01       	movw	r26, r28
    3452:	ad 5b       	subi	r26, 0xBD	; 189
    3454:	bf 4f       	sbci	r27, 0xFF	; 255
    3456:	fe 01       	movw	r30, r28
    3458:	ed 5b       	subi	r30, 0xBD	; 189
    345a:	ff 4f       	sbci	r31, 0xFF	; 255
    345c:	80 81       	ld	r24, Z
    345e:	91 81       	ldd	r25, Z+1	; 0x01
    3460:	01 97       	sbiw	r24, 0x01	; 1
    3462:	11 96       	adiw	r26, 0x01	; 1
    3464:	9c 93       	st	X, r25
    3466:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3468:	fe 01       	movw	r30, r28
    346a:	ed 5b       	subi	r30, 0xBD	; 189
    346c:	ff 4f       	sbci	r31, 0xFF	; 255
    346e:	80 81       	ld	r24, Z
    3470:	91 81       	ldd	r25, Z+1	; 0x01
    3472:	00 97       	sbiw	r24, 0x00	; 0
    3474:	d1 f6       	brne	.-76     	; 0x342a <HLCD4_voidInit+0xe4>
    3476:	24 c0       	rjmp	.+72     	; 0x34c0 <HLCD4_voidInit+0x17a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3478:	8e 01       	movw	r16, r28
    347a:	0d 5b       	subi	r16, 0xBD	; 189
    347c:	1f 4f       	sbci	r17, 0xFF	; 255
    347e:	fe 01       	movw	r30, r28
    3480:	eb 5b       	subi	r30, 0xBB	; 187
    3482:	ff 4f       	sbci	r31, 0xFF	; 255
    3484:	60 81       	ld	r22, Z
    3486:	71 81       	ldd	r23, Z+1	; 0x01
    3488:	82 81       	ldd	r24, Z+2	; 0x02
    348a:	93 81       	ldd	r25, Z+3	; 0x03
    348c:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    3490:	dc 01       	movw	r26, r24
    3492:	cb 01       	movw	r24, r22
    3494:	f8 01       	movw	r30, r16
    3496:	91 83       	std	Z+1, r25	; 0x01
    3498:	80 83       	st	Z, r24
    349a:	fe 01       	movw	r30, r28
    349c:	ed 5b       	subi	r30, 0xBD	; 189
    349e:	ff 4f       	sbci	r31, 0xFF	; 255
    34a0:	80 81       	ld	r24, Z
    34a2:	91 81       	ldd	r25, Z+1	; 0x01
    34a4:	fe 01       	movw	r30, r28
    34a6:	ff 96       	adiw	r30, 0x3f	; 63
    34a8:	91 83       	std	Z+1, r25	; 0x01
    34aa:	80 83       	st	Z, r24
    34ac:	fe 01       	movw	r30, r28
    34ae:	ff 96       	adiw	r30, 0x3f	; 63
    34b0:	80 81       	ld	r24, Z
    34b2:	91 81       	ldd	r25, Z+1	; 0x01
    34b4:	01 97       	sbiw	r24, 0x01	; 1
    34b6:	f1 f7       	brne	.-4      	; 0x34b4 <HLCD4_voidInit+0x16e>
    34b8:	fe 01       	movw	r30, r28
    34ba:	ff 96       	adiw	r30, 0x3f	; 63
    34bc:	91 83       	std	Z+1, r25	; 0x01
    34be:	80 83       	st	Z, r24
    _delay_ms(30);
    HLCD4_voidSendCommand(FUNCTION_SET1);
    34c0:	80 e2       	ldi	r24, 0x20	; 32
    34c2:	0e 94 76 16 	call	0x2cec	; 0x2cec <HLCD4_voidSendCommand>
    HLCD4_voidSendCommand(FUNCTION_SET2);
    34c6:	80 e2       	ldi	r24, 0x20	; 32
    34c8:	0e 94 76 16 	call	0x2cec	; 0x2cec <HLCD4_voidSendCommand>
    HLCD4_voidSendCommand(FUNCTION_SET3);
    34cc:	80 e8       	ldi	r24, 0x80	; 128
    34ce:	0e 94 76 16 	call	0x2cec	; 0x2cec <HLCD4_voidSendCommand>
    34d2:	80 e0       	ldi	r24, 0x00	; 0
    34d4:	90 e0       	ldi	r25, 0x00	; 0
    34d6:	a0 e2       	ldi	r26, 0x20	; 32
    34d8:	b2 e4       	ldi	r27, 0x42	; 66
    34da:	8b af       	std	Y+59, r24	; 0x3b
    34dc:	9c af       	std	Y+60, r25	; 0x3c
    34de:	ad af       	std	Y+61, r26	; 0x3d
    34e0:	be af       	std	Y+62, r27	; 0x3e
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    34e2:	6b ad       	ldd	r22, Y+59	; 0x3b
    34e4:	7c ad       	ldd	r23, Y+60	; 0x3c
    34e6:	8d ad       	ldd	r24, Y+61	; 0x3d
    34e8:	9e ad       	ldd	r25, Y+62	; 0x3e
    34ea:	2b ea       	ldi	r18, 0xAB	; 171
    34ec:	3a ea       	ldi	r19, 0xAA	; 170
    34ee:	4a e2       	ldi	r20, 0x2A	; 42
    34f0:	50 e4       	ldi	r21, 0x40	; 64
    34f2:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    34f6:	dc 01       	movw	r26, r24
    34f8:	cb 01       	movw	r24, r22
    34fa:	8f ab       	std	Y+55, r24	; 0x37
    34fc:	98 af       	std	Y+56, r25	; 0x38
    34fe:	a9 af       	std	Y+57, r26	; 0x39
    3500:	ba af       	std	Y+58, r27	; 0x3a
	if (__tmp < 1.0)
    3502:	6f a9       	ldd	r22, Y+55	; 0x37
    3504:	78 ad       	ldd	r23, Y+56	; 0x38
    3506:	89 ad       	ldd	r24, Y+57	; 0x39
    3508:	9a ad       	ldd	r25, Y+58	; 0x3a
    350a:	20 e0       	ldi	r18, 0x00	; 0
    350c:	30 e0       	ldi	r19, 0x00	; 0
    350e:	40 e8       	ldi	r20, 0x80	; 128
    3510:	5f e3       	ldi	r21, 0x3F	; 63
    3512:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    3516:	88 23       	and	r24, r24
    3518:	1c f4       	brge	.+6      	; 0x3520 <HLCD4_voidInit+0x1da>
		__ticks = 1;
    351a:	81 e0       	ldi	r24, 0x01	; 1
    351c:	8e ab       	std	Y+54, r24	; 0x36
    351e:	91 c0       	rjmp	.+290    	; 0x3642 <HLCD4_voidInit+0x2fc>
	else if (__tmp > 255)
    3520:	6f a9       	ldd	r22, Y+55	; 0x37
    3522:	78 ad       	ldd	r23, Y+56	; 0x38
    3524:	89 ad       	ldd	r24, Y+57	; 0x39
    3526:	9a ad       	ldd	r25, Y+58	; 0x3a
    3528:	20 e0       	ldi	r18, 0x00	; 0
    352a:	30 e0       	ldi	r19, 0x00	; 0
    352c:	4f e7       	ldi	r20, 0x7F	; 127
    352e:	53 e4       	ldi	r21, 0x43	; 67
    3530:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    3534:	18 16       	cp	r1, r24
    3536:	0c f0       	brlt	.+2      	; 0x353a <HLCD4_voidInit+0x1f4>
    3538:	7b c0       	rjmp	.+246    	; 0x3630 <HLCD4_voidInit+0x2ea>
	{
		_delay_ms(__us / 1000.0);
    353a:	6b ad       	ldd	r22, Y+59	; 0x3b
    353c:	7c ad       	ldd	r23, Y+60	; 0x3c
    353e:	8d ad       	ldd	r24, Y+61	; 0x3d
    3540:	9e ad       	ldd	r25, Y+62	; 0x3e
    3542:	20 e0       	ldi	r18, 0x00	; 0
    3544:	30 e0       	ldi	r19, 0x00	; 0
    3546:	4a e7       	ldi	r20, 0x7A	; 122
    3548:	54 e4       	ldi	r21, 0x44	; 68
    354a:	0e 94 0d 0a 	call	0x141a	; 0x141a <__divsf3>
    354e:	dc 01       	movw	r26, r24
    3550:	cb 01       	movw	r24, r22
    3552:	8a ab       	std	Y+50, r24	; 0x32
    3554:	9b ab       	std	Y+51, r25	; 0x33
    3556:	ac ab       	std	Y+52, r26	; 0x34
    3558:	bd ab       	std	Y+53, r27	; 0x35
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    355a:	6a a9       	ldd	r22, Y+50	; 0x32
    355c:	7b a9       	ldd	r23, Y+51	; 0x33
    355e:	8c a9       	ldd	r24, Y+52	; 0x34
    3560:	9d a9       	ldd	r25, Y+53	; 0x35
    3562:	20 e0       	ldi	r18, 0x00	; 0
    3564:	30 e0       	ldi	r19, 0x00	; 0
    3566:	4a ef       	ldi	r20, 0xFA	; 250
    3568:	54 e4       	ldi	r21, 0x44	; 68
    356a:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    356e:	dc 01       	movw	r26, r24
    3570:	cb 01       	movw	r24, r22
    3572:	8e a7       	std	Y+46, r24	; 0x2e
    3574:	9f a7       	std	Y+47, r25	; 0x2f
    3576:	a8 ab       	std	Y+48, r26	; 0x30
    3578:	b9 ab       	std	Y+49, r27	; 0x31
	if (__tmp < 1.0)
    357a:	6e a5       	ldd	r22, Y+46	; 0x2e
    357c:	7f a5       	ldd	r23, Y+47	; 0x2f
    357e:	88 a9       	ldd	r24, Y+48	; 0x30
    3580:	99 a9       	ldd	r25, Y+49	; 0x31
    3582:	20 e0       	ldi	r18, 0x00	; 0
    3584:	30 e0       	ldi	r19, 0x00	; 0
    3586:	40 e8       	ldi	r20, 0x80	; 128
    3588:	5f e3       	ldi	r21, 0x3F	; 63
    358a:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    358e:	88 23       	and	r24, r24
    3590:	2c f4       	brge	.+10     	; 0x359c <HLCD4_voidInit+0x256>
		__ticks = 1;
    3592:	81 e0       	ldi	r24, 0x01	; 1
    3594:	90 e0       	ldi	r25, 0x00	; 0
    3596:	9d a7       	std	Y+45, r25	; 0x2d
    3598:	8c a7       	std	Y+44, r24	; 0x2c
    359a:	3f c0       	rjmp	.+126    	; 0x361a <HLCD4_voidInit+0x2d4>
	else if (__tmp > 65535)
    359c:	6e a5       	ldd	r22, Y+46	; 0x2e
    359e:	7f a5       	ldd	r23, Y+47	; 0x2f
    35a0:	88 a9       	ldd	r24, Y+48	; 0x30
    35a2:	99 a9       	ldd	r25, Y+49	; 0x31
    35a4:	20 e0       	ldi	r18, 0x00	; 0
    35a6:	3f ef       	ldi	r19, 0xFF	; 255
    35a8:	4f e7       	ldi	r20, 0x7F	; 127
    35aa:	57 e4       	ldi	r21, 0x47	; 71
    35ac:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    35b0:	18 16       	cp	r1, r24
    35b2:	4c f5       	brge	.+82     	; 0x3606 <HLCD4_voidInit+0x2c0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    35b4:	6a a9       	ldd	r22, Y+50	; 0x32
    35b6:	7b a9       	ldd	r23, Y+51	; 0x33
    35b8:	8c a9       	ldd	r24, Y+52	; 0x34
    35ba:	9d a9       	ldd	r25, Y+53	; 0x35
    35bc:	20 e0       	ldi	r18, 0x00	; 0
    35be:	30 e0       	ldi	r19, 0x00	; 0
    35c0:	40 e2       	ldi	r20, 0x20	; 32
    35c2:	51 e4       	ldi	r21, 0x41	; 65
    35c4:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    35c8:	dc 01       	movw	r26, r24
    35ca:	cb 01       	movw	r24, r22
    35cc:	bc 01       	movw	r22, r24
    35ce:	cd 01       	movw	r24, r26
    35d0:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    35d4:	dc 01       	movw	r26, r24
    35d6:	cb 01       	movw	r24, r22
    35d8:	9d a7       	std	Y+45, r25	; 0x2d
    35da:	8c a7       	std	Y+44, r24	; 0x2c
    35dc:	0f c0       	rjmp	.+30     	; 0x35fc <HLCD4_voidInit+0x2b6>
    35de:	88 ec       	ldi	r24, 0xC8	; 200
    35e0:	90 e0       	ldi	r25, 0x00	; 0
    35e2:	9b a7       	std	Y+43, r25	; 0x2b
    35e4:	8a a7       	std	Y+42, r24	; 0x2a
    35e6:	8a a5       	ldd	r24, Y+42	; 0x2a
    35e8:	9b a5       	ldd	r25, Y+43	; 0x2b
    35ea:	01 97       	sbiw	r24, 0x01	; 1
    35ec:	f1 f7       	brne	.-4      	; 0x35ea <HLCD4_voidInit+0x2a4>
    35ee:	9b a7       	std	Y+43, r25	; 0x2b
    35f0:	8a a7       	std	Y+42, r24	; 0x2a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    35f2:	8c a5       	ldd	r24, Y+44	; 0x2c
    35f4:	9d a5       	ldd	r25, Y+45	; 0x2d
    35f6:	01 97       	sbiw	r24, 0x01	; 1
    35f8:	9d a7       	std	Y+45, r25	; 0x2d
    35fa:	8c a7       	std	Y+44, r24	; 0x2c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    35fc:	8c a5       	ldd	r24, Y+44	; 0x2c
    35fe:	9d a5       	ldd	r25, Y+45	; 0x2d
    3600:	00 97       	sbiw	r24, 0x00	; 0
    3602:	69 f7       	brne	.-38     	; 0x35de <HLCD4_voidInit+0x298>
    3604:	24 c0       	rjmp	.+72     	; 0x364e <HLCD4_voidInit+0x308>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3606:	6e a5       	ldd	r22, Y+46	; 0x2e
    3608:	7f a5       	ldd	r23, Y+47	; 0x2f
    360a:	88 a9       	ldd	r24, Y+48	; 0x30
    360c:	99 a9       	ldd	r25, Y+49	; 0x31
    360e:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    3612:	dc 01       	movw	r26, r24
    3614:	cb 01       	movw	r24, r22
    3616:	9d a7       	std	Y+45, r25	; 0x2d
    3618:	8c a7       	std	Y+44, r24	; 0x2c
    361a:	8c a5       	ldd	r24, Y+44	; 0x2c
    361c:	9d a5       	ldd	r25, Y+45	; 0x2d
    361e:	99 a7       	std	Y+41, r25	; 0x29
    3620:	88 a7       	std	Y+40, r24	; 0x28
    3622:	88 a5       	ldd	r24, Y+40	; 0x28
    3624:	99 a5       	ldd	r25, Y+41	; 0x29
    3626:	01 97       	sbiw	r24, 0x01	; 1
    3628:	f1 f7       	brne	.-4      	; 0x3626 <HLCD4_voidInit+0x2e0>
    362a:	99 a7       	std	Y+41, r25	; 0x29
    362c:	88 a7       	std	Y+40, r24	; 0x28
    362e:	0f c0       	rjmp	.+30     	; 0x364e <HLCD4_voidInit+0x308>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3630:	6f a9       	ldd	r22, Y+55	; 0x37
    3632:	78 ad       	ldd	r23, Y+56	; 0x38
    3634:	89 ad       	ldd	r24, Y+57	; 0x39
    3636:	9a ad       	ldd	r25, Y+58	; 0x3a
    3638:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    363c:	dc 01       	movw	r26, r24
    363e:	cb 01       	movw	r24, r22
    3640:	8e ab       	std	Y+54, r24	; 0x36
    3642:	8e a9       	ldd	r24, Y+54	; 0x36
    3644:	8f a3       	std	Y+39, r24	; 0x27
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3646:	8f a1       	ldd	r24, Y+39	; 0x27
    3648:	8a 95       	dec	r24
    364a:	f1 f7       	brne	.-4      	; 0x3648 <HLCD4_voidInit+0x302>
    364c:	8f a3       	std	Y+39, r24	; 0x27
    _delay_us(40);
    HLCD4_voidSendCommand(ON_OFF_CONTROL1);
    364e:	80 e0       	ldi	r24, 0x00	; 0
    3650:	0e 94 76 16 	call	0x2cec	; 0x2cec <HLCD4_voidSendCommand>
    HLCD4_voidSendCommand(ON_OFF_CONTROL2);
    3654:	80 ec       	ldi	r24, 0xC0	; 192
    3656:	0e 94 76 16 	call	0x2cec	; 0x2cec <HLCD4_voidSendCommand>
    365a:	80 e0       	ldi	r24, 0x00	; 0
    365c:	90 e0       	ldi	r25, 0x00	; 0
    365e:	a0 e2       	ldi	r26, 0x20	; 32
    3660:	b2 e4       	ldi	r27, 0x42	; 66
    3662:	8b a3       	std	Y+35, r24	; 0x23
    3664:	9c a3       	std	Y+36, r25	; 0x24
    3666:	ad a3       	std	Y+37, r26	; 0x25
    3668:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    366a:	6b a1       	ldd	r22, Y+35	; 0x23
    366c:	7c a1       	ldd	r23, Y+36	; 0x24
    366e:	8d a1       	ldd	r24, Y+37	; 0x25
    3670:	9e a1       	ldd	r25, Y+38	; 0x26
    3672:	2b ea       	ldi	r18, 0xAB	; 171
    3674:	3a ea       	ldi	r19, 0xAA	; 170
    3676:	4a e2       	ldi	r20, 0x2A	; 42
    3678:	50 e4       	ldi	r21, 0x40	; 64
    367a:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    367e:	dc 01       	movw	r26, r24
    3680:	cb 01       	movw	r24, r22
    3682:	8f 8f       	std	Y+31, r24	; 0x1f
    3684:	98 a3       	std	Y+32, r25	; 0x20
    3686:	a9 a3       	std	Y+33, r26	; 0x21
    3688:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    368a:	6f 8d       	ldd	r22, Y+31	; 0x1f
    368c:	78 a1       	ldd	r23, Y+32	; 0x20
    368e:	89 a1       	ldd	r24, Y+33	; 0x21
    3690:	9a a1       	ldd	r25, Y+34	; 0x22
    3692:	20 e0       	ldi	r18, 0x00	; 0
    3694:	30 e0       	ldi	r19, 0x00	; 0
    3696:	40 e8       	ldi	r20, 0x80	; 128
    3698:	5f e3       	ldi	r21, 0x3F	; 63
    369a:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    369e:	88 23       	and	r24, r24
    36a0:	1c f4       	brge	.+6      	; 0x36a8 <HLCD4_voidInit+0x362>
		__ticks = 1;
    36a2:	81 e0       	ldi	r24, 0x01	; 1
    36a4:	8e 8f       	std	Y+30, r24	; 0x1e
    36a6:	91 c0       	rjmp	.+290    	; 0x37ca <HLCD4_voidInit+0x484>
	else if (__tmp > 255)
    36a8:	6f 8d       	ldd	r22, Y+31	; 0x1f
    36aa:	78 a1       	ldd	r23, Y+32	; 0x20
    36ac:	89 a1       	ldd	r24, Y+33	; 0x21
    36ae:	9a a1       	ldd	r25, Y+34	; 0x22
    36b0:	20 e0       	ldi	r18, 0x00	; 0
    36b2:	30 e0       	ldi	r19, 0x00	; 0
    36b4:	4f e7       	ldi	r20, 0x7F	; 127
    36b6:	53 e4       	ldi	r21, 0x43	; 67
    36b8:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    36bc:	18 16       	cp	r1, r24
    36be:	0c f0       	brlt	.+2      	; 0x36c2 <HLCD4_voidInit+0x37c>
    36c0:	7b c0       	rjmp	.+246    	; 0x37b8 <HLCD4_voidInit+0x472>
	{
		_delay_ms(__us / 1000.0);
    36c2:	6b a1       	ldd	r22, Y+35	; 0x23
    36c4:	7c a1       	ldd	r23, Y+36	; 0x24
    36c6:	8d a1       	ldd	r24, Y+37	; 0x25
    36c8:	9e a1       	ldd	r25, Y+38	; 0x26
    36ca:	20 e0       	ldi	r18, 0x00	; 0
    36cc:	30 e0       	ldi	r19, 0x00	; 0
    36ce:	4a e7       	ldi	r20, 0x7A	; 122
    36d0:	54 e4       	ldi	r21, 0x44	; 68
    36d2:	0e 94 0d 0a 	call	0x141a	; 0x141a <__divsf3>
    36d6:	dc 01       	movw	r26, r24
    36d8:	cb 01       	movw	r24, r22
    36da:	8a 8f       	std	Y+26, r24	; 0x1a
    36dc:	9b 8f       	std	Y+27, r25	; 0x1b
    36de:	ac 8f       	std	Y+28, r26	; 0x1c
    36e0:	bd 8f       	std	Y+29, r27	; 0x1d
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    36e2:	6a 8d       	ldd	r22, Y+26	; 0x1a
    36e4:	7b 8d       	ldd	r23, Y+27	; 0x1b
    36e6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    36e8:	9d 8d       	ldd	r25, Y+29	; 0x1d
    36ea:	20 e0       	ldi	r18, 0x00	; 0
    36ec:	30 e0       	ldi	r19, 0x00	; 0
    36ee:	4a ef       	ldi	r20, 0xFA	; 250
    36f0:	54 e4       	ldi	r21, 0x44	; 68
    36f2:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    36f6:	dc 01       	movw	r26, r24
    36f8:	cb 01       	movw	r24, r22
    36fa:	8e 8b       	std	Y+22, r24	; 0x16
    36fc:	9f 8b       	std	Y+23, r25	; 0x17
    36fe:	a8 8f       	std	Y+24, r26	; 0x18
    3700:	b9 8f       	std	Y+25, r27	; 0x19
	if (__tmp < 1.0)
    3702:	6e 89       	ldd	r22, Y+22	; 0x16
    3704:	7f 89       	ldd	r23, Y+23	; 0x17
    3706:	88 8d       	ldd	r24, Y+24	; 0x18
    3708:	99 8d       	ldd	r25, Y+25	; 0x19
    370a:	20 e0       	ldi	r18, 0x00	; 0
    370c:	30 e0       	ldi	r19, 0x00	; 0
    370e:	40 e8       	ldi	r20, 0x80	; 128
    3710:	5f e3       	ldi	r21, 0x3F	; 63
    3712:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    3716:	88 23       	and	r24, r24
    3718:	2c f4       	brge	.+10     	; 0x3724 <HLCD4_voidInit+0x3de>
		__ticks = 1;
    371a:	81 e0       	ldi	r24, 0x01	; 1
    371c:	90 e0       	ldi	r25, 0x00	; 0
    371e:	9d 8b       	std	Y+21, r25	; 0x15
    3720:	8c 8b       	std	Y+20, r24	; 0x14
    3722:	3f c0       	rjmp	.+126    	; 0x37a2 <HLCD4_voidInit+0x45c>
	else if (__tmp > 65535)
    3724:	6e 89       	ldd	r22, Y+22	; 0x16
    3726:	7f 89       	ldd	r23, Y+23	; 0x17
    3728:	88 8d       	ldd	r24, Y+24	; 0x18
    372a:	99 8d       	ldd	r25, Y+25	; 0x19
    372c:	20 e0       	ldi	r18, 0x00	; 0
    372e:	3f ef       	ldi	r19, 0xFF	; 255
    3730:	4f e7       	ldi	r20, 0x7F	; 127
    3732:	57 e4       	ldi	r21, 0x47	; 71
    3734:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    3738:	18 16       	cp	r1, r24
    373a:	4c f5       	brge	.+82     	; 0x378e <HLCD4_voidInit+0x448>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    373c:	6a 8d       	ldd	r22, Y+26	; 0x1a
    373e:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3740:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3742:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3744:	20 e0       	ldi	r18, 0x00	; 0
    3746:	30 e0       	ldi	r19, 0x00	; 0
    3748:	40 e2       	ldi	r20, 0x20	; 32
    374a:	51 e4       	ldi	r21, 0x41	; 65
    374c:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    3750:	dc 01       	movw	r26, r24
    3752:	cb 01       	movw	r24, r22
    3754:	bc 01       	movw	r22, r24
    3756:	cd 01       	movw	r24, r26
    3758:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    375c:	dc 01       	movw	r26, r24
    375e:	cb 01       	movw	r24, r22
    3760:	9d 8b       	std	Y+21, r25	; 0x15
    3762:	8c 8b       	std	Y+20, r24	; 0x14
    3764:	0f c0       	rjmp	.+30     	; 0x3784 <HLCD4_voidInit+0x43e>
    3766:	88 ec       	ldi	r24, 0xC8	; 200
    3768:	90 e0       	ldi	r25, 0x00	; 0
    376a:	9b 8b       	std	Y+19, r25	; 0x13
    376c:	8a 8b       	std	Y+18, r24	; 0x12
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    376e:	8a 89       	ldd	r24, Y+18	; 0x12
    3770:	9b 89       	ldd	r25, Y+19	; 0x13
    3772:	01 97       	sbiw	r24, 0x01	; 1
    3774:	f1 f7       	brne	.-4      	; 0x3772 <HLCD4_voidInit+0x42c>
    3776:	9b 8b       	std	Y+19, r25	; 0x13
    3778:	8a 8b       	std	Y+18, r24	; 0x12
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    377a:	8c 89       	ldd	r24, Y+20	; 0x14
    377c:	9d 89       	ldd	r25, Y+21	; 0x15
    377e:	01 97       	sbiw	r24, 0x01	; 1
    3780:	9d 8b       	std	Y+21, r25	; 0x15
    3782:	8c 8b       	std	Y+20, r24	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3784:	8c 89       	ldd	r24, Y+20	; 0x14
    3786:	9d 89       	ldd	r25, Y+21	; 0x15
    3788:	00 97       	sbiw	r24, 0x00	; 0
    378a:	69 f7       	brne	.-38     	; 0x3766 <HLCD4_voidInit+0x420>
    378c:	24 c0       	rjmp	.+72     	; 0x37d6 <HLCD4_voidInit+0x490>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    378e:	6e 89       	ldd	r22, Y+22	; 0x16
    3790:	7f 89       	ldd	r23, Y+23	; 0x17
    3792:	88 8d       	ldd	r24, Y+24	; 0x18
    3794:	99 8d       	ldd	r25, Y+25	; 0x19
    3796:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    379a:	dc 01       	movw	r26, r24
    379c:	cb 01       	movw	r24, r22
    379e:	9d 8b       	std	Y+21, r25	; 0x15
    37a0:	8c 8b       	std	Y+20, r24	; 0x14
    37a2:	8c 89       	ldd	r24, Y+20	; 0x14
    37a4:	9d 89       	ldd	r25, Y+21	; 0x15
    37a6:	99 8b       	std	Y+17, r25	; 0x11
    37a8:	88 8b       	std	Y+16, r24	; 0x10
    37aa:	88 89       	ldd	r24, Y+16	; 0x10
    37ac:	99 89       	ldd	r25, Y+17	; 0x11
    37ae:	01 97       	sbiw	r24, 0x01	; 1
    37b0:	f1 f7       	brne	.-4      	; 0x37ae <HLCD4_voidInit+0x468>
    37b2:	99 8b       	std	Y+17, r25	; 0x11
    37b4:	88 8b       	std	Y+16, r24	; 0x10
    37b6:	0f c0       	rjmp	.+30     	; 0x37d6 <HLCD4_voidInit+0x490>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    37b8:	6f 8d       	ldd	r22, Y+31	; 0x1f
    37ba:	78 a1       	ldd	r23, Y+32	; 0x20
    37bc:	89 a1       	ldd	r24, Y+33	; 0x21
    37be:	9a a1       	ldd	r25, Y+34	; 0x22
    37c0:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    37c4:	dc 01       	movw	r26, r24
    37c6:	cb 01       	movw	r24, r22
    37c8:	8e 8f       	std	Y+30, r24	; 0x1e
    37ca:	8e 8d       	ldd	r24, Y+30	; 0x1e
    37cc:	8f 87       	std	Y+15, r24	; 0x0f
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    37ce:	8f 85       	ldd	r24, Y+15	; 0x0f
    37d0:	8a 95       	dec	r24
    37d2:	f1 f7       	brne	.-4      	; 0x37d0 <HLCD4_voidInit+0x48a>
    37d4:	8f 87       	std	Y+15, r24	; 0x0f
    _delay_us(40);
    HLCD4_voidSendCommand(DISPLAY_CLEAR1);
    37d6:	80 e0       	ldi	r24, 0x00	; 0
    37d8:	0e 94 76 16 	call	0x2cec	; 0x2cec <HLCD4_voidSendCommand>
    HLCD4_voidSendCommand(DISPLAY_CLEAR2);
    37dc:	80 e1       	ldi	r24, 0x10	; 16
    37de:	0e 94 76 16 	call	0x2cec	; 0x2cec <HLCD4_voidSendCommand>
    37e2:	80 e0       	ldi	r24, 0x00	; 0
    37e4:	90 e0       	ldi	r25, 0x00	; 0
    37e6:	a0 e0       	ldi	r26, 0x00	; 0
    37e8:	b0 e4       	ldi	r27, 0x40	; 64
    37ea:	8b 87       	std	Y+11, r24	; 0x0b
    37ec:	9c 87       	std	Y+12, r25	; 0x0c
    37ee:	ad 87       	std	Y+13, r26	; 0x0d
    37f0:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    37f2:	6b 85       	ldd	r22, Y+11	; 0x0b
    37f4:	7c 85       	ldd	r23, Y+12	; 0x0c
    37f6:	8d 85       	ldd	r24, Y+13	; 0x0d
    37f8:	9e 85       	ldd	r25, Y+14	; 0x0e
    37fa:	20 e0       	ldi	r18, 0x00	; 0
    37fc:	30 e0       	ldi	r19, 0x00	; 0
    37fe:	4a ef       	ldi	r20, 0xFA	; 250
    3800:	54 e4       	ldi	r21, 0x44	; 68
    3802:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    3806:	dc 01       	movw	r26, r24
    3808:	cb 01       	movw	r24, r22
    380a:	8f 83       	std	Y+7, r24	; 0x07
    380c:	98 87       	std	Y+8, r25	; 0x08
    380e:	a9 87       	std	Y+9, r26	; 0x09
    3810:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3812:	6f 81       	ldd	r22, Y+7	; 0x07
    3814:	78 85       	ldd	r23, Y+8	; 0x08
    3816:	89 85       	ldd	r24, Y+9	; 0x09
    3818:	9a 85       	ldd	r25, Y+10	; 0x0a
    381a:	20 e0       	ldi	r18, 0x00	; 0
    381c:	30 e0       	ldi	r19, 0x00	; 0
    381e:	40 e8       	ldi	r20, 0x80	; 128
    3820:	5f e3       	ldi	r21, 0x3F	; 63
    3822:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    3826:	88 23       	and	r24, r24
    3828:	2c f4       	brge	.+10     	; 0x3834 <HLCD4_voidInit+0x4ee>
		__ticks = 1;
    382a:	81 e0       	ldi	r24, 0x01	; 1
    382c:	90 e0       	ldi	r25, 0x00	; 0
    382e:	9e 83       	std	Y+6, r25	; 0x06
    3830:	8d 83       	std	Y+5, r24	; 0x05
    3832:	3f c0       	rjmp	.+126    	; 0x38b2 <HLCD4_voidInit+0x56c>
	else if (__tmp > 65535)
    3834:	6f 81       	ldd	r22, Y+7	; 0x07
    3836:	78 85       	ldd	r23, Y+8	; 0x08
    3838:	89 85       	ldd	r24, Y+9	; 0x09
    383a:	9a 85       	ldd	r25, Y+10	; 0x0a
    383c:	20 e0       	ldi	r18, 0x00	; 0
    383e:	3f ef       	ldi	r19, 0xFF	; 255
    3840:	4f e7       	ldi	r20, 0x7F	; 127
    3842:	57 e4       	ldi	r21, 0x47	; 71
    3844:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    3848:	18 16       	cp	r1, r24
    384a:	4c f5       	brge	.+82     	; 0x389e <HLCD4_voidInit+0x558>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    384c:	6b 85       	ldd	r22, Y+11	; 0x0b
    384e:	7c 85       	ldd	r23, Y+12	; 0x0c
    3850:	8d 85       	ldd	r24, Y+13	; 0x0d
    3852:	9e 85       	ldd	r25, Y+14	; 0x0e
    3854:	20 e0       	ldi	r18, 0x00	; 0
    3856:	30 e0       	ldi	r19, 0x00	; 0
    3858:	40 e2       	ldi	r20, 0x20	; 32
    385a:	51 e4       	ldi	r21, 0x41	; 65
    385c:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    3860:	dc 01       	movw	r26, r24
    3862:	cb 01       	movw	r24, r22
    3864:	bc 01       	movw	r22, r24
    3866:	cd 01       	movw	r24, r26
    3868:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    386c:	dc 01       	movw	r26, r24
    386e:	cb 01       	movw	r24, r22
    3870:	9e 83       	std	Y+6, r25	; 0x06
    3872:	8d 83       	std	Y+5, r24	; 0x05
    3874:	0f c0       	rjmp	.+30     	; 0x3894 <HLCD4_voidInit+0x54e>
    3876:	88 ec       	ldi	r24, 0xC8	; 200
    3878:	90 e0       	ldi	r25, 0x00	; 0
    387a:	9c 83       	std	Y+4, r25	; 0x04
    387c:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    387e:	8b 81       	ldd	r24, Y+3	; 0x03
    3880:	9c 81       	ldd	r25, Y+4	; 0x04
    3882:	01 97       	sbiw	r24, 0x01	; 1
    3884:	f1 f7       	brne	.-4      	; 0x3882 <HLCD4_voidInit+0x53c>
    3886:	9c 83       	std	Y+4, r25	; 0x04
    3888:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    388a:	8d 81       	ldd	r24, Y+5	; 0x05
    388c:	9e 81       	ldd	r25, Y+6	; 0x06
    388e:	01 97       	sbiw	r24, 0x01	; 1
    3890:	9e 83       	std	Y+6, r25	; 0x06
    3892:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3894:	8d 81       	ldd	r24, Y+5	; 0x05
    3896:	9e 81       	ldd	r25, Y+6	; 0x06
    3898:	00 97       	sbiw	r24, 0x00	; 0
    389a:	69 f7       	brne	.-38     	; 0x3876 <HLCD4_voidInit+0x530>
    389c:	14 c0       	rjmp	.+40     	; 0x38c6 <HLCD4_voidInit+0x580>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    389e:	6f 81       	ldd	r22, Y+7	; 0x07
    38a0:	78 85       	ldd	r23, Y+8	; 0x08
    38a2:	89 85       	ldd	r24, Y+9	; 0x09
    38a4:	9a 85       	ldd	r25, Y+10	; 0x0a
    38a6:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    38aa:	dc 01       	movw	r26, r24
    38ac:	cb 01       	movw	r24, r22
    38ae:	9e 83       	std	Y+6, r25	; 0x06
    38b0:	8d 83       	std	Y+5, r24	; 0x05
    38b2:	8d 81       	ldd	r24, Y+5	; 0x05
    38b4:	9e 81       	ldd	r25, Y+6	; 0x06
    38b6:	9a 83       	std	Y+2, r25	; 0x02
    38b8:	89 83       	std	Y+1, r24	; 0x01
    38ba:	89 81       	ldd	r24, Y+1	; 0x01
    38bc:	9a 81       	ldd	r25, Y+2	; 0x02
    38be:	01 97       	sbiw	r24, 0x01	; 1
    38c0:	f1 f7       	brne	.-4      	; 0x38be <HLCD4_voidInit+0x578>
    38c2:	9a 83       	std	Y+2, r25	; 0x02
    38c4:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(2);
    HLCD4_voidSendCommand(ENTRY_MODE_SET1);
    38c6:	80 e0       	ldi	r24, 0x00	; 0
    38c8:	0e 94 76 16 	call	0x2cec	; 0x2cec <HLCD4_voidSendCommand>
    HLCD4_voidSendCommand(ENTRY_MODE_SET2);
    38cc:	80 e6       	ldi	r24, 0x60	; 96
    38ce:	0e 94 76 16 	call	0x2cec	; 0x2cec <HLCD4_voidSendCommand>
    global_u8Init=1;
    38d2:	81 e0       	ldi	r24, 0x01	; 1
    38d4:	80 93 ac 01 	sts	0x01AC, r24
} 
    38d8:	c4 5b       	subi	r28, 0xB4	; 180
    38da:	df 4f       	sbci	r29, 0xFF	; 255
    38dc:	0f b6       	in	r0, 0x3f	; 63
    38de:	f8 94       	cli
    38e0:	de bf       	out	0x3e, r29	; 62
    38e2:	0f be       	out	0x3f, r0	; 63
    38e4:	cd bf       	out	0x3d, r28	; 61
    38e6:	cf 91       	pop	r28
    38e8:	df 91       	pop	r29
    38ea:	1f 91       	pop	r17
    38ec:	0f 91       	pop	r16
    38ee:	08 95       	ret

000038f0 <HLCD4_voidClearDisplay>:

void HLCD4_voidClearDisplay(void)
{
    38f0:	df 93       	push	r29
    38f2:	cf 93       	push	r28
    38f4:	cd b7       	in	r28, 0x3d	; 61
    38f6:	de b7       	in	r29, 0x3e	; 62
    38f8:	2e 97       	sbiw	r28, 0x0e	; 14
    38fa:	0f b6       	in	r0, 0x3f	; 63
    38fc:	f8 94       	cli
    38fe:	de bf       	out	0x3e, r29	; 62
    3900:	0f be       	out	0x3f, r0	; 63
    3902:	cd bf       	out	0x3d, r28	; 61
    HLCD4_voidSendCommand(DISPLAY_CLEAR);
    3904:	81 e0       	ldi	r24, 0x01	; 1
    3906:	0e 94 76 16 	call	0x2cec	; 0x2cec <HLCD4_voidSendCommand>
    390a:	80 e0       	ldi	r24, 0x00	; 0
    390c:	90 e0       	ldi	r25, 0x00	; 0
    390e:	a0 e0       	ldi	r26, 0x00	; 0
    3910:	b0 e4       	ldi	r27, 0x40	; 64
    3912:	8b 87       	std	Y+11, r24	; 0x0b
    3914:	9c 87       	std	Y+12, r25	; 0x0c
    3916:	ad 87       	std	Y+13, r26	; 0x0d
    3918:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    391a:	6b 85       	ldd	r22, Y+11	; 0x0b
    391c:	7c 85       	ldd	r23, Y+12	; 0x0c
    391e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3920:	9e 85       	ldd	r25, Y+14	; 0x0e
    3922:	20 e0       	ldi	r18, 0x00	; 0
    3924:	30 e0       	ldi	r19, 0x00	; 0
    3926:	4a ef       	ldi	r20, 0xFA	; 250
    3928:	54 e4       	ldi	r21, 0x44	; 68
    392a:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    392e:	dc 01       	movw	r26, r24
    3930:	cb 01       	movw	r24, r22
    3932:	8f 83       	std	Y+7, r24	; 0x07
    3934:	98 87       	std	Y+8, r25	; 0x08
    3936:	a9 87       	std	Y+9, r26	; 0x09
    3938:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    393a:	6f 81       	ldd	r22, Y+7	; 0x07
    393c:	78 85       	ldd	r23, Y+8	; 0x08
    393e:	89 85       	ldd	r24, Y+9	; 0x09
    3940:	9a 85       	ldd	r25, Y+10	; 0x0a
    3942:	20 e0       	ldi	r18, 0x00	; 0
    3944:	30 e0       	ldi	r19, 0x00	; 0
    3946:	40 e8       	ldi	r20, 0x80	; 128
    3948:	5f e3       	ldi	r21, 0x3F	; 63
    394a:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    394e:	88 23       	and	r24, r24
    3950:	2c f4       	brge	.+10     	; 0x395c <HLCD4_voidClearDisplay+0x6c>
		__ticks = 1;
    3952:	81 e0       	ldi	r24, 0x01	; 1
    3954:	90 e0       	ldi	r25, 0x00	; 0
    3956:	9e 83       	std	Y+6, r25	; 0x06
    3958:	8d 83       	std	Y+5, r24	; 0x05
    395a:	3f c0       	rjmp	.+126    	; 0x39da <HLCD4_voidClearDisplay+0xea>
	else if (__tmp > 65535)
    395c:	6f 81       	ldd	r22, Y+7	; 0x07
    395e:	78 85       	ldd	r23, Y+8	; 0x08
    3960:	89 85       	ldd	r24, Y+9	; 0x09
    3962:	9a 85       	ldd	r25, Y+10	; 0x0a
    3964:	20 e0       	ldi	r18, 0x00	; 0
    3966:	3f ef       	ldi	r19, 0xFF	; 255
    3968:	4f e7       	ldi	r20, 0x7F	; 127
    396a:	57 e4       	ldi	r21, 0x47	; 71
    396c:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    3970:	18 16       	cp	r1, r24
    3972:	4c f5       	brge	.+82     	; 0x39c6 <HLCD4_voidClearDisplay+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3974:	6b 85       	ldd	r22, Y+11	; 0x0b
    3976:	7c 85       	ldd	r23, Y+12	; 0x0c
    3978:	8d 85       	ldd	r24, Y+13	; 0x0d
    397a:	9e 85       	ldd	r25, Y+14	; 0x0e
    397c:	20 e0       	ldi	r18, 0x00	; 0
    397e:	30 e0       	ldi	r19, 0x00	; 0
    3980:	40 e2       	ldi	r20, 0x20	; 32
    3982:	51 e4       	ldi	r21, 0x41	; 65
    3984:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    3988:	dc 01       	movw	r26, r24
    398a:	cb 01       	movw	r24, r22
    398c:	bc 01       	movw	r22, r24
    398e:	cd 01       	movw	r24, r26
    3990:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    3994:	dc 01       	movw	r26, r24
    3996:	cb 01       	movw	r24, r22
    3998:	9e 83       	std	Y+6, r25	; 0x06
    399a:	8d 83       	std	Y+5, r24	; 0x05
    399c:	0f c0       	rjmp	.+30     	; 0x39bc <HLCD4_voidClearDisplay+0xcc>
    399e:	88 ec       	ldi	r24, 0xC8	; 200
    39a0:	90 e0       	ldi	r25, 0x00	; 0
    39a2:	9c 83       	std	Y+4, r25	; 0x04
    39a4:	8b 83       	std	Y+3, r24	; 0x03
    39a6:	8b 81       	ldd	r24, Y+3	; 0x03
    39a8:	9c 81       	ldd	r25, Y+4	; 0x04
    39aa:	01 97       	sbiw	r24, 0x01	; 1
    39ac:	f1 f7       	brne	.-4      	; 0x39aa <HLCD4_voidClearDisplay+0xba>
    39ae:	9c 83       	std	Y+4, r25	; 0x04
    39b0:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    39b2:	8d 81       	ldd	r24, Y+5	; 0x05
    39b4:	9e 81       	ldd	r25, Y+6	; 0x06
    39b6:	01 97       	sbiw	r24, 0x01	; 1
    39b8:	9e 83       	std	Y+6, r25	; 0x06
    39ba:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    39bc:	8d 81       	ldd	r24, Y+5	; 0x05
    39be:	9e 81       	ldd	r25, Y+6	; 0x06
    39c0:	00 97       	sbiw	r24, 0x00	; 0
    39c2:	69 f7       	brne	.-38     	; 0x399e <HLCD4_voidClearDisplay+0xae>
    39c4:	14 c0       	rjmp	.+40     	; 0x39ee <HLCD4_voidClearDisplay+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    39c6:	6f 81       	ldd	r22, Y+7	; 0x07
    39c8:	78 85       	ldd	r23, Y+8	; 0x08
    39ca:	89 85       	ldd	r24, Y+9	; 0x09
    39cc:	9a 85       	ldd	r25, Y+10	; 0x0a
    39ce:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    39d2:	dc 01       	movw	r26, r24
    39d4:	cb 01       	movw	r24, r22
    39d6:	9e 83       	std	Y+6, r25	; 0x06
    39d8:	8d 83       	std	Y+5, r24	; 0x05
    39da:	8d 81       	ldd	r24, Y+5	; 0x05
    39dc:	9e 81       	ldd	r25, Y+6	; 0x06
    39de:	9a 83       	std	Y+2, r25	; 0x02
    39e0:	89 83       	std	Y+1, r24	; 0x01
    39e2:	89 81       	ldd	r24, Y+1	; 0x01
    39e4:	9a 81       	ldd	r25, Y+2	; 0x02
    39e6:	01 97       	sbiw	r24, 0x01	; 1
    39e8:	f1 f7       	brne	.-4      	; 0x39e6 <HLCD4_voidClearDisplay+0xf6>
    39ea:	9a 83       	std	Y+2, r25	; 0x02
    39ec:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(2);
}
    39ee:	2e 96       	adiw	r28, 0x0e	; 14
    39f0:	0f b6       	in	r0, 0x3f	; 63
    39f2:	f8 94       	cli
    39f4:	de bf       	out	0x3e, r29	; 62
    39f6:	0f be       	out	0x3f, r0	; 63
    39f8:	cd bf       	out	0x3d, r28	; 61
    39fa:	cf 91       	pop	r28
    39fc:	df 91       	pop	r29
    39fe:	08 95       	ret

00003a00 <HLCD4_voidSendString>:

void HLCD4_voidSendString(u8 * A_Pu8String)
{
    3a00:	df 93       	push	r29
    3a02:	cf 93       	push	r28
    3a04:	00 d0       	rcall	.+0      	; 0x3a06 <HLCD4_voidSendString+0x6>
    3a06:	0f 92       	push	r0
    3a08:	cd b7       	in	r28, 0x3d	; 61
    3a0a:	de b7       	in	r29, 0x3e	; 62
    3a0c:	9b 83       	std	Y+3, r25	; 0x03
    3a0e:	8a 83       	std	Y+2, r24	; 0x02
    u8 local_u8Couter=0;
    3a10:	19 82       	std	Y+1, r1	; 0x01
    3a12:	0e c0       	rjmp	.+28     	; 0x3a30 <HLCD4_voidSendString+0x30>
    while (A_Pu8String[local_u8Couter]!='\0')
    {
        HLCD4_voidSendData(A_Pu8String[local_u8Couter]);
    3a14:	89 81       	ldd	r24, Y+1	; 0x01
    3a16:	28 2f       	mov	r18, r24
    3a18:	30 e0       	ldi	r19, 0x00	; 0
    3a1a:	8a 81       	ldd	r24, Y+2	; 0x02
    3a1c:	9b 81       	ldd	r25, Y+3	; 0x03
    3a1e:	fc 01       	movw	r30, r24
    3a20:	e2 0f       	add	r30, r18
    3a22:	f3 1f       	adc	r31, r19
    3a24:	80 81       	ld	r24, Z
    3a26:	0e 94 0f 18 	call	0x301e	; 0x301e <HLCD4_voidSendData>
        local_u8Couter++;
    3a2a:	89 81       	ldd	r24, Y+1	; 0x01
    3a2c:	8f 5f       	subi	r24, 0xFF	; 255
    3a2e:	89 83       	std	Y+1, r24	; 0x01
}

void HLCD4_voidSendString(u8 * A_Pu8String)
{
    u8 local_u8Couter=0;
    while (A_Pu8String[local_u8Couter]!='\0')
    3a30:	89 81       	ldd	r24, Y+1	; 0x01
    3a32:	28 2f       	mov	r18, r24
    3a34:	30 e0       	ldi	r19, 0x00	; 0
    3a36:	8a 81       	ldd	r24, Y+2	; 0x02
    3a38:	9b 81       	ldd	r25, Y+3	; 0x03
    3a3a:	fc 01       	movw	r30, r24
    3a3c:	e2 0f       	add	r30, r18
    3a3e:	f3 1f       	adc	r31, r19
    3a40:	80 81       	ld	r24, Z
    3a42:	88 23       	and	r24, r24
    3a44:	39 f7       	brne	.-50     	; 0x3a14 <HLCD4_voidSendString+0x14>
    {
        HLCD4_voidSendData(A_Pu8String[local_u8Couter]);
        local_u8Couter++;
    }
    
}
    3a46:	0f 90       	pop	r0
    3a48:	0f 90       	pop	r0
    3a4a:	0f 90       	pop	r0
    3a4c:	cf 91       	pop	r28
    3a4e:	df 91       	pop	r29
    3a50:	08 95       	ret

00003a52 <HLCD4_voidGoToPos>:

void HLCD4_voidGoToPos(u8 A_u8RowNum,u8 A_u8ColNum)
{
    3a52:	df 93       	push	r29
    3a54:	cf 93       	push	r28
    3a56:	cd b7       	in	r28, 0x3d	; 61
    3a58:	de b7       	in	r29, 0x3e	; 62
    3a5a:	63 97       	sbiw	r28, 0x13	; 19
    3a5c:	0f b6       	in	r0, 0x3f	; 63
    3a5e:	f8 94       	cli
    3a60:	de bf       	out	0x3e, r29	; 62
    3a62:	0f be       	out	0x3f, r0	; 63
    3a64:	cd bf       	out	0x3d, r28	; 61
    3a66:	88 8b       	std	Y+16, r24	; 0x10
    3a68:	69 8b       	std	Y+17, r22	; 0x11
    // _delay_ms(1);

    //*******************************//
    //Second method
	u8 local_u8Address;
    switch(A_u8RowNum)
    3a6a:	88 89       	ldd	r24, Y+16	; 0x10
    3a6c:	28 2f       	mov	r18, r24
    3a6e:	30 e0       	ldi	r19, 0x00	; 0
    3a70:	3b 8b       	std	Y+19, r19	; 0x13
    3a72:	2a 8b       	std	Y+18, r18	; 0x12
    3a74:	8a 89       	ldd	r24, Y+18	; 0x12
    3a76:	9b 89       	ldd	r25, Y+19	; 0x13
    3a78:	81 30       	cpi	r24, 0x01	; 1
    3a7a:	91 05       	cpc	r25, r1
    3a7c:	31 f0       	breq	.+12     	; 0x3a8a <HLCD4_voidGoToPos+0x38>
    3a7e:	2a 89       	ldd	r18, Y+18	; 0x12
    3a80:	3b 89       	ldd	r19, Y+19	; 0x13
    3a82:	22 30       	cpi	r18, 0x02	; 2
    3a84:	31 05       	cpc	r19, r1
    3a86:	59 f0       	breq	.+22     	; 0x3a9e <HLCD4_voidGoToPos+0x4c>
    3a88:	13 c0       	rjmp	.+38     	; 0x3ab0 <HLCD4_voidGoToPos+0x5e>
    {
        case LCD_ROW_ONE:
        local_u8Address=FIRST_ROW_ADDRESS + A_u8ColNum -1;
    3a8a:	89 89       	ldd	r24, Y+17	; 0x11
    3a8c:	81 50       	subi	r24, 0x01	; 1
    3a8e:	8f 87       	std	Y+15, r24	; 0x0f
        SET_BIT(local_u8Address,PIN7);
    3a90:	8f 85       	ldd	r24, Y+15	; 0x0f
    3a92:	80 68       	ori	r24, 0x80	; 128
    3a94:	8f 87       	std	Y+15, r24	; 0x0f
        HLCD4_voidSendCommand(local_u8Address);
    3a96:	8f 85       	ldd	r24, Y+15	; 0x0f
    3a98:	0e 94 76 16 	call	0x2cec	; 0x2cec <HLCD4_voidSendCommand>
    3a9c:	09 c0       	rjmp	.+18     	; 0x3ab0 <HLCD4_voidGoToPos+0x5e>
        break;

        case LCD_ROW_TWO:
        local_u8Address=SECOND_ROW_ADDRESS + A_u8ColNum;
    3a9e:	89 89       	ldd	r24, Y+17	; 0x11
    3aa0:	81 5c       	subi	r24, 0xC1	; 193
    3aa2:	8f 87       	std	Y+15, r24	; 0x0f
        SET_BIT(local_u8Address,PIN7);
    3aa4:	8f 85       	ldd	r24, Y+15	; 0x0f
    3aa6:	80 68       	ori	r24, 0x80	; 128
    3aa8:	8f 87       	std	Y+15, r24	; 0x0f
        HLCD4_voidSendCommand(local_u8Address);
    3aaa:	8f 85       	ldd	r24, Y+15	; 0x0f
    3aac:	0e 94 76 16 	call	0x2cec	; 0x2cec <HLCD4_voidSendCommand>
    3ab0:	80 e0       	ldi	r24, 0x00	; 0
    3ab2:	90 e0       	ldi	r25, 0x00	; 0
    3ab4:	a0 e8       	ldi	r26, 0x80	; 128
    3ab6:	bf e3       	ldi	r27, 0x3F	; 63
    3ab8:	8b 87       	std	Y+11, r24	; 0x0b
    3aba:	9c 87       	std	Y+12, r25	; 0x0c
    3abc:	ad 87       	std	Y+13, r26	; 0x0d
    3abe:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3ac0:	6b 85       	ldd	r22, Y+11	; 0x0b
    3ac2:	7c 85       	ldd	r23, Y+12	; 0x0c
    3ac4:	8d 85       	ldd	r24, Y+13	; 0x0d
    3ac6:	9e 85       	ldd	r25, Y+14	; 0x0e
    3ac8:	20 e0       	ldi	r18, 0x00	; 0
    3aca:	30 e0       	ldi	r19, 0x00	; 0
    3acc:	4a ef       	ldi	r20, 0xFA	; 250
    3ace:	54 e4       	ldi	r21, 0x44	; 68
    3ad0:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    3ad4:	dc 01       	movw	r26, r24
    3ad6:	cb 01       	movw	r24, r22
    3ad8:	8f 83       	std	Y+7, r24	; 0x07
    3ada:	98 87       	std	Y+8, r25	; 0x08
    3adc:	a9 87       	std	Y+9, r26	; 0x09
    3ade:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3ae0:	6f 81       	ldd	r22, Y+7	; 0x07
    3ae2:	78 85       	ldd	r23, Y+8	; 0x08
    3ae4:	89 85       	ldd	r24, Y+9	; 0x09
    3ae6:	9a 85       	ldd	r25, Y+10	; 0x0a
    3ae8:	20 e0       	ldi	r18, 0x00	; 0
    3aea:	30 e0       	ldi	r19, 0x00	; 0
    3aec:	40 e8       	ldi	r20, 0x80	; 128
    3aee:	5f e3       	ldi	r21, 0x3F	; 63
    3af0:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    3af4:	88 23       	and	r24, r24
    3af6:	2c f4       	brge	.+10     	; 0x3b02 <HLCD4_voidGoToPos+0xb0>
		__ticks = 1;
    3af8:	81 e0       	ldi	r24, 0x01	; 1
    3afa:	90 e0       	ldi	r25, 0x00	; 0
    3afc:	9e 83       	std	Y+6, r25	; 0x06
    3afe:	8d 83       	std	Y+5, r24	; 0x05
    3b00:	3f c0       	rjmp	.+126    	; 0x3b80 <HLCD4_voidGoToPos+0x12e>
	else if (__tmp > 65535)
    3b02:	6f 81       	ldd	r22, Y+7	; 0x07
    3b04:	78 85       	ldd	r23, Y+8	; 0x08
    3b06:	89 85       	ldd	r24, Y+9	; 0x09
    3b08:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b0a:	20 e0       	ldi	r18, 0x00	; 0
    3b0c:	3f ef       	ldi	r19, 0xFF	; 255
    3b0e:	4f e7       	ldi	r20, 0x7F	; 127
    3b10:	57 e4       	ldi	r21, 0x47	; 71
    3b12:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    3b16:	18 16       	cp	r1, r24
    3b18:	4c f5       	brge	.+82     	; 0x3b6c <HLCD4_voidGoToPos+0x11a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3b1a:	6b 85       	ldd	r22, Y+11	; 0x0b
    3b1c:	7c 85       	ldd	r23, Y+12	; 0x0c
    3b1e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3b20:	9e 85       	ldd	r25, Y+14	; 0x0e
    3b22:	20 e0       	ldi	r18, 0x00	; 0
    3b24:	30 e0       	ldi	r19, 0x00	; 0
    3b26:	40 e2       	ldi	r20, 0x20	; 32
    3b28:	51 e4       	ldi	r21, 0x41	; 65
    3b2a:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    3b2e:	dc 01       	movw	r26, r24
    3b30:	cb 01       	movw	r24, r22
    3b32:	bc 01       	movw	r22, r24
    3b34:	cd 01       	movw	r24, r26
    3b36:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    3b3a:	dc 01       	movw	r26, r24
    3b3c:	cb 01       	movw	r24, r22
    3b3e:	9e 83       	std	Y+6, r25	; 0x06
    3b40:	8d 83       	std	Y+5, r24	; 0x05
    3b42:	0f c0       	rjmp	.+30     	; 0x3b62 <HLCD4_voidGoToPos+0x110>
    3b44:	88 ec       	ldi	r24, 0xC8	; 200
    3b46:	90 e0       	ldi	r25, 0x00	; 0
    3b48:	9c 83       	std	Y+4, r25	; 0x04
    3b4a:	8b 83       	std	Y+3, r24	; 0x03
    3b4c:	8b 81       	ldd	r24, Y+3	; 0x03
    3b4e:	9c 81       	ldd	r25, Y+4	; 0x04
    3b50:	01 97       	sbiw	r24, 0x01	; 1
    3b52:	f1 f7       	brne	.-4      	; 0x3b50 <HLCD4_voidGoToPos+0xfe>
    3b54:	9c 83       	std	Y+4, r25	; 0x04
    3b56:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3b58:	8d 81       	ldd	r24, Y+5	; 0x05
    3b5a:	9e 81       	ldd	r25, Y+6	; 0x06
    3b5c:	01 97       	sbiw	r24, 0x01	; 1
    3b5e:	9e 83       	std	Y+6, r25	; 0x06
    3b60:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3b62:	8d 81       	ldd	r24, Y+5	; 0x05
    3b64:	9e 81       	ldd	r25, Y+6	; 0x06
    3b66:	00 97       	sbiw	r24, 0x00	; 0
    3b68:	69 f7       	brne	.-38     	; 0x3b44 <HLCD4_voidGoToPos+0xf2>
    3b6a:	14 c0       	rjmp	.+40     	; 0x3b94 <HLCD4_voidGoToPos+0x142>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3b6c:	6f 81       	ldd	r22, Y+7	; 0x07
    3b6e:	78 85       	ldd	r23, Y+8	; 0x08
    3b70:	89 85       	ldd	r24, Y+9	; 0x09
    3b72:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b74:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    3b78:	dc 01       	movw	r26, r24
    3b7a:	cb 01       	movw	r24, r22
    3b7c:	9e 83       	std	Y+6, r25	; 0x06
    3b7e:	8d 83       	std	Y+5, r24	; 0x05
    3b80:	8d 81       	ldd	r24, Y+5	; 0x05
    3b82:	9e 81       	ldd	r25, Y+6	; 0x06
    3b84:	9a 83       	std	Y+2, r25	; 0x02
    3b86:	89 83       	std	Y+1, r24	; 0x01
    3b88:	89 81       	ldd	r24, Y+1	; 0x01
    3b8a:	9a 81       	ldd	r25, Y+2	; 0x02
    3b8c:	01 97       	sbiw	r24, 0x01	; 1
    3b8e:	f1 f7       	brne	.-4      	; 0x3b8c <HLCD4_voidGoToPos+0x13a>
    3b90:	9a 83       	std	Y+2, r25	; 0x02
    3b92:	89 83       	std	Y+1, r24	; 0x01
        break;

    }
    _delay_ms(1);

}
    3b94:	63 96       	adiw	r28, 0x13	; 19
    3b96:	0f b6       	in	r0, 0x3f	; 63
    3b98:	f8 94       	cli
    3b9a:	de bf       	out	0x3e, r29	; 62
    3b9c:	0f be       	out	0x3f, r0	; 63
    3b9e:	cd bf       	out	0x3d, r28	; 61
    3ba0:	cf 91       	pop	r28
    3ba2:	df 91       	pop	r29
    3ba4:	08 95       	ret

00003ba6 <HLCD4_voidDisplayNumber>:

void HLCD4_voidDisplayNumber(u32 A_u32Number)
{
    3ba6:	df 93       	push	r29
    3ba8:	cf 93       	push	r28
    3baa:	00 d0       	rcall	.+0      	; 0x3bac <HLCD4_voidDisplayNumber+0x6>
    3bac:	00 d0       	rcall	.+0      	; 0x3bae <HLCD4_voidDisplayNumber+0x8>
    3bae:	cd b7       	in	r28, 0x3d	; 61
    3bb0:	de b7       	in	r29, 0x3e	; 62
    3bb2:	9c 83       	std	Y+4, r25	; 0x04
    3bb4:	8b 83       	std	Y+3, r24	; 0x03
    // u8 local_u8NumToStr[100];
    // itoa(A_u32Number,local_u8NumToStr,10);
    // HLCD4_voidSendString(local_u8NumToStr);
    //****************************************************//
    //third method: it will deal with zero unlike the first method so it's not problem here
    u32 local_u32Number=1;
    3bb6:	81 e0       	ldi	r24, 0x01	; 1
    3bb8:	90 e0       	ldi	r25, 0x00	; 0
    3bba:	9a 83       	std	Y+2, r25	; 0x02
    3bbc:	89 83       	std	Y+1, r24	; 0x01
    if(A_u32Number==0)
    3bbe:	8b 81       	ldd	r24, Y+3	; 0x03
    3bc0:	9c 81       	ldd	r25, Y+4	; 0x04
    3bc2:	00 97       	sbiw	r24, 0x00	; 0
    3bc4:	31 f5       	brne	.+76     	; 0x3c12 <HLCD4_voidDisplayNumber+0x6c>
    {
        HLCD4_voidSendData('0');
    3bc6:	80 e3       	ldi	r24, 0x30	; 48
    3bc8:	0e 94 0f 18 	call	0x301e	; 0x301e <HLCD4_voidSendData>
    3bcc:	22 c0       	rjmp	.+68     	; 0x3c12 <HLCD4_voidDisplayNumber+0x6c>
    }   
    while(A_u32Number !=0)
    {
            local_u32Number=((local_u32Number * 10)+(A_u32Number%10));
    3bce:	89 81       	ldd	r24, Y+1	; 0x01
    3bd0:	9a 81       	ldd	r25, Y+2	; 0x02
    3bd2:	9c 01       	movw	r18, r24
    3bd4:	22 0f       	add	r18, r18
    3bd6:	33 1f       	adc	r19, r19
    3bd8:	c9 01       	movw	r24, r18
    3bda:	88 0f       	add	r24, r24
    3bdc:	99 1f       	adc	r25, r25
    3bde:	88 0f       	add	r24, r24
    3be0:	99 1f       	adc	r25, r25
    3be2:	f9 01       	movw	r30, r18
    3be4:	e8 0f       	add	r30, r24
    3be6:	f9 1f       	adc	r31, r25
    3be8:	8b 81       	ldd	r24, Y+3	; 0x03
    3bea:	9c 81       	ldd	r25, Y+4	; 0x04
    3bec:	2a e0       	ldi	r18, 0x0A	; 10
    3bee:	30 e0       	ldi	r19, 0x00	; 0
    3bf0:	b9 01       	movw	r22, r18
    3bf2:	0e 94 b4 42 	call	0x8568	; 0x8568 <__udivmodhi4>
    3bf6:	8e 0f       	add	r24, r30
    3bf8:	9f 1f       	adc	r25, r31
    3bfa:	9a 83       	std	Y+2, r25	; 0x02
    3bfc:	89 83       	std	Y+1, r24	; 0x01
            A_u32Number=A_u32Number/10;
    3bfe:	8b 81       	ldd	r24, Y+3	; 0x03
    3c00:	9c 81       	ldd	r25, Y+4	; 0x04
    3c02:	2a e0       	ldi	r18, 0x0A	; 10
    3c04:	30 e0       	ldi	r19, 0x00	; 0
    3c06:	b9 01       	movw	r22, r18
    3c08:	0e 94 b4 42 	call	0x8568	; 0x8568 <__udivmodhi4>
    3c0c:	cb 01       	movw	r24, r22
    3c0e:	9c 83       	std	Y+4, r25	; 0x04
    3c10:	8b 83       	std	Y+3, r24	; 0x03
    u32 local_u32Number=1;
    if(A_u32Number==0)
    {
        HLCD4_voidSendData('0');
    }   
    while(A_u32Number !=0)
    3c12:	8b 81       	ldd	r24, Y+3	; 0x03
    3c14:	9c 81       	ldd	r25, Y+4	; 0x04
    3c16:	00 97       	sbiw	r24, 0x00	; 0
    3c18:	d1 f6       	brne	.-76     	; 0x3bce <HLCD4_voidDisplayNumber+0x28>
    3c1a:	14 c0       	rjmp	.+40     	; 0x3c44 <HLCD4_voidDisplayNumber+0x9e>
            A_u32Number=A_u32Number/10;

    }
    while (local_u32Number!=1)
    {
        HLCD4_voidSendData((local_u32Number%10)+48);
    3c1c:	89 81       	ldd	r24, Y+1	; 0x01
    3c1e:	9a 81       	ldd	r25, Y+2	; 0x02
    3c20:	2a e0       	ldi	r18, 0x0A	; 10
    3c22:	30 e0       	ldi	r19, 0x00	; 0
    3c24:	b9 01       	movw	r22, r18
    3c26:	0e 94 b4 42 	call	0x8568	; 0x8568 <__udivmodhi4>
    3c2a:	80 5d       	subi	r24, 0xD0	; 208
    3c2c:	0e 94 0f 18 	call	0x301e	; 0x301e <HLCD4_voidSendData>
        local_u32Number=local_u32Number/10;
    3c30:	89 81       	ldd	r24, Y+1	; 0x01
    3c32:	9a 81       	ldd	r25, Y+2	; 0x02
    3c34:	2a e0       	ldi	r18, 0x0A	; 10
    3c36:	30 e0       	ldi	r19, 0x00	; 0
    3c38:	b9 01       	movw	r22, r18
    3c3a:	0e 94 b4 42 	call	0x8568	; 0x8568 <__udivmodhi4>
    3c3e:	cb 01       	movw	r24, r22
    3c40:	9a 83       	std	Y+2, r25	; 0x02
    3c42:	89 83       	std	Y+1, r24	; 0x01
    {
            local_u32Number=((local_u32Number * 10)+(A_u32Number%10));
            A_u32Number=A_u32Number/10;

    }
    while (local_u32Number!=1)
    3c44:	89 81       	ldd	r24, Y+1	; 0x01
    3c46:	9a 81       	ldd	r25, Y+2	; 0x02
    3c48:	81 30       	cpi	r24, 0x01	; 1
    3c4a:	91 05       	cpc	r25, r1
    3c4c:	39 f7       	brne	.-50     	; 0x3c1c <HLCD4_voidDisplayNumber+0x76>
    {
        HLCD4_voidSendData((local_u32Number%10)+48);
        local_u32Number=local_u32Number/10;
    }
}
    3c4e:	0f 90       	pop	r0
    3c50:	0f 90       	pop	r0
    3c52:	0f 90       	pop	r0
    3c54:	0f 90       	pop	r0
    3c56:	cf 91       	pop	r28
    3c58:	df 91       	pop	r29
    3c5a:	08 95       	ret

00003c5c <HLCD4_voidStoreCustomChar>:

void HLCD4_voidStoreCustomChar(u8 * A_u8Pattern,u8 A_u8CGRAMIndex)
{
    3c5c:	df 93       	push	r29
    3c5e:	cf 93       	push	r28
    3c60:	cd b7       	in	r28, 0x3d	; 61
    3c62:	de b7       	in	r29, 0x3e	; 62
    3c64:	ab 97       	sbiw	r28, 0x2b	; 43
    3c66:	0f b6       	in	r0, 0x3f	; 63
    3c68:	f8 94       	cli
    3c6a:	de bf       	out	0x3e, r29	; 62
    3c6c:	0f be       	out	0x3f, r0	; 63
    3c6e:	cd bf       	out	0x3d, r28	; 61
    3c70:	9a a7       	std	Y+42, r25	; 0x2a
    3c72:	89 a7       	std	Y+41, r24	; 0x29
    3c74:	6b a7       	std	Y+43, r22	; 0x2b
    u8 local_u8Address;
    if(A_u8CGRAMIndex<8)
    3c76:	8b a5       	ldd	r24, Y+43	; 0x2b
    3c78:	88 30       	cpi	r24, 0x08	; 8
    3c7a:	08 f0       	brcs	.+2      	; 0x3c7e <HLCD4_voidStoreCustomChar+0x22>
    3c7c:	e5 c0       	rjmp	.+458    	; 0x3e48 <HLCD4_voidStoreCustomChar+0x1ec>
    {
        A_u8CGRAMIndex=A_u8CGRAMIndex*8;
    3c7e:	8b a5       	ldd	r24, Y+43	; 0x2b
    3c80:	88 2f       	mov	r24, r24
    3c82:	90 e0       	ldi	r25, 0x00	; 0
    3c84:	88 0f       	add	r24, r24
    3c86:	99 1f       	adc	r25, r25
    3c88:	88 0f       	add	r24, r24
    3c8a:	99 1f       	adc	r25, r25
    3c8c:	88 0f       	add	r24, r24
    3c8e:	99 1f       	adc	r25, r25
    3c90:	8b a7       	std	Y+43, r24	; 0x2b
        SET_BIT(A_u8CGRAMIndex,PIN6);
    3c92:	8b a5       	ldd	r24, Y+43	; 0x2b
    3c94:	80 64       	ori	r24, 0x40	; 64
    3c96:	8b a7       	std	Y+43, r24	; 0x2b
        CLR_BIT(A_u8CGRAMIndex,PIN7);
    3c98:	8b a5       	ldd	r24, Y+43	; 0x2b
    3c9a:	8f 77       	andi	r24, 0x7F	; 127
    3c9c:	8b a7       	std	Y+43, r24	; 0x2b
        HLCD4_voidSendCommand(A_u8CGRAMIndex);
    3c9e:	8b a5       	ldd	r24, Y+43	; 0x2b
    3ca0:	0e 94 76 16 	call	0x2cec	; 0x2cec <HLCD4_voidSendCommand>
        for(u8 i=0;i<8;i++)
    3ca4:	1f a2       	std	Y+39, r1	; 0x27
    3ca6:	cc c0       	rjmp	.+408    	; 0x3e40 <HLCD4_voidStoreCustomChar+0x1e4>
        {
            HLCD4_voidSendData(A_u8Pattern[i]);
    3ca8:	8f a1       	ldd	r24, Y+39	; 0x27
    3caa:	28 2f       	mov	r18, r24
    3cac:	30 e0       	ldi	r19, 0x00	; 0
    3cae:	89 a5       	ldd	r24, Y+41	; 0x29
    3cb0:	9a a5       	ldd	r25, Y+42	; 0x2a
    3cb2:	fc 01       	movw	r30, r24
    3cb4:	e2 0f       	add	r30, r18
    3cb6:	f3 1f       	adc	r31, r19
    3cb8:	80 81       	ld	r24, Z
    3cba:	0e 94 0f 18 	call	0x301e	; 0x301e <HLCD4_voidSendData>
    3cbe:	80 e0       	ldi	r24, 0x00	; 0
    3cc0:	90 e0       	ldi	r25, 0x00	; 0
    3cc2:	a0 e7       	ldi	r26, 0x70	; 112
    3cc4:	b2 e4       	ldi	r27, 0x42	; 66
    3cc6:	8b a3       	std	Y+35, r24	; 0x23
    3cc8:	9c a3       	std	Y+36, r25	; 0x24
    3cca:	ad a3       	std	Y+37, r26	; 0x25
    3ccc:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3cce:	6b a1       	ldd	r22, Y+35	; 0x23
    3cd0:	7c a1       	ldd	r23, Y+36	; 0x24
    3cd2:	8d a1       	ldd	r24, Y+37	; 0x25
    3cd4:	9e a1       	ldd	r25, Y+38	; 0x26
    3cd6:	2b ea       	ldi	r18, 0xAB	; 171
    3cd8:	3a ea       	ldi	r19, 0xAA	; 170
    3cda:	4a e2       	ldi	r20, 0x2A	; 42
    3cdc:	50 e4       	ldi	r21, 0x40	; 64
    3cde:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    3ce2:	dc 01       	movw	r26, r24
    3ce4:	cb 01       	movw	r24, r22
    3ce6:	8f 8f       	std	Y+31, r24	; 0x1f
    3ce8:	98 a3       	std	Y+32, r25	; 0x20
    3cea:	a9 a3       	std	Y+33, r26	; 0x21
    3cec:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    3cee:	6f 8d       	ldd	r22, Y+31	; 0x1f
    3cf0:	78 a1       	ldd	r23, Y+32	; 0x20
    3cf2:	89 a1       	ldd	r24, Y+33	; 0x21
    3cf4:	9a a1       	ldd	r25, Y+34	; 0x22
    3cf6:	20 e0       	ldi	r18, 0x00	; 0
    3cf8:	30 e0       	ldi	r19, 0x00	; 0
    3cfa:	40 e8       	ldi	r20, 0x80	; 128
    3cfc:	5f e3       	ldi	r21, 0x3F	; 63
    3cfe:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    3d02:	88 23       	and	r24, r24
    3d04:	1c f4       	brge	.+6      	; 0x3d0c <HLCD4_voidStoreCustomChar+0xb0>
		__ticks = 1;
    3d06:	81 e0       	ldi	r24, 0x01	; 1
    3d08:	8e 8f       	std	Y+30, r24	; 0x1e
    3d0a:	91 c0       	rjmp	.+290    	; 0x3e2e <HLCD4_voidStoreCustomChar+0x1d2>
	else if (__tmp > 255)
    3d0c:	6f 8d       	ldd	r22, Y+31	; 0x1f
    3d0e:	78 a1       	ldd	r23, Y+32	; 0x20
    3d10:	89 a1       	ldd	r24, Y+33	; 0x21
    3d12:	9a a1       	ldd	r25, Y+34	; 0x22
    3d14:	20 e0       	ldi	r18, 0x00	; 0
    3d16:	30 e0       	ldi	r19, 0x00	; 0
    3d18:	4f e7       	ldi	r20, 0x7F	; 127
    3d1a:	53 e4       	ldi	r21, 0x43	; 67
    3d1c:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    3d20:	18 16       	cp	r1, r24
    3d22:	0c f0       	brlt	.+2      	; 0x3d26 <HLCD4_voidStoreCustomChar+0xca>
    3d24:	7b c0       	rjmp	.+246    	; 0x3e1c <HLCD4_voidStoreCustomChar+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    3d26:	6b a1       	ldd	r22, Y+35	; 0x23
    3d28:	7c a1       	ldd	r23, Y+36	; 0x24
    3d2a:	8d a1       	ldd	r24, Y+37	; 0x25
    3d2c:	9e a1       	ldd	r25, Y+38	; 0x26
    3d2e:	20 e0       	ldi	r18, 0x00	; 0
    3d30:	30 e0       	ldi	r19, 0x00	; 0
    3d32:	4a e7       	ldi	r20, 0x7A	; 122
    3d34:	54 e4       	ldi	r21, 0x44	; 68
    3d36:	0e 94 0d 0a 	call	0x141a	; 0x141a <__divsf3>
    3d3a:	dc 01       	movw	r26, r24
    3d3c:	cb 01       	movw	r24, r22
    3d3e:	8a 8f       	std	Y+26, r24	; 0x1a
    3d40:	9b 8f       	std	Y+27, r25	; 0x1b
    3d42:	ac 8f       	std	Y+28, r26	; 0x1c
    3d44:	bd 8f       	std	Y+29, r27	; 0x1d
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3d46:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3d48:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3d4a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3d4c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3d4e:	20 e0       	ldi	r18, 0x00	; 0
    3d50:	30 e0       	ldi	r19, 0x00	; 0
    3d52:	4a ef       	ldi	r20, 0xFA	; 250
    3d54:	54 e4       	ldi	r21, 0x44	; 68
    3d56:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    3d5a:	dc 01       	movw	r26, r24
    3d5c:	cb 01       	movw	r24, r22
    3d5e:	8e 8b       	std	Y+22, r24	; 0x16
    3d60:	9f 8b       	std	Y+23, r25	; 0x17
    3d62:	a8 8f       	std	Y+24, r26	; 0x18
    3d64:	b9 8f       	std	Y+25, r27	; 0x19
	if (__tmp < 1.0)
    3d66:	6e 89       	ldd	r22, Y+22	; 0x16
    3d68:	7f 89       	ldd	r23, Y+23	; 0x17
    3d6a:	88 8d       	ldd	r24, Y+24	; 0x18
    3d6c:	99 8d       	ldd	r25, Y+25	; 0x19
    3d6e:	20 e0       	ldi	r18, 0x00	; 0
    3d70:	30 e0       	ldi	r19, 0x00	; 0
    3d72:	40 e8       	ldi	r20, 0x80	; 128
    3d74:	5f e3       	ldi	r21, 0x3F	; 63
    3d76:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    3d7a:	88 23       	and	r24, r24
    3d7c:	2c f4       	brge	.+10     	; 0x3d88 <HLCD4_voidStoreCustomChar+0x12c>
		__ticks = 1;
    3d7e:	81 e0       	ldi	r24, 0x01	; 1
    3d80:	90 e0       	ldi	r25, 0x00	; 0
    3d82:	9d 8b       	std	Y+21, r25	; 0x15
    3d84:	8c 8b       	std	Y+20, r24	; 0x14
    3d86:	3f c0       	rjmp	.+126    	; 0x3e06 <HLCD4_voidStoreCustomChar+0x1aa>
	else if (__tmp > 65535)
    3d88:	6e 89       	ldd	r22, Y+22	; 0x16
    3d8a:	7f 89       	ldd	r23, Y+23	; 0x17
    3d8c:	88 8d       	ldd	r24, Y+24	; 0x18
    3d8e:	99 8d       	ldd	r25, Y+25	; 0x19
    3d90:	20 e0       	ldi	r18, 0x00	; 0
    3d92:	3f ef       	ldi	r19, 0xFF	; 255
    3d94:	4f e7       	ldi	r20, 0x7F	; 127
    3d96:	57 e4       	ldi	r21, 0x47	; 71
    3d98:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    3d9c:	18 16       	cp	r1, r24
    3d9e:	4c f5       	brge	.+82     	; 0x3df2 <HLCD4_voidStoreCustomChar+0x196>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3da0:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3da2:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3da4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3da6:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3da8:	20 e0       	ldi	r18, 0x00	; 0
    3daa:	30 e0       	ldi	r19, 0x00	; 0
    3dac:	40 e2       	ldi	r20, 0x20	; 32
    3dae:	51 e4       	ldi	r21, 0x41	; 65
    3db0:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    3db4:	dc 01       	movw	r26, r24
    3db6:	cb 01       	movw	r24, r22
    3db8:	bc 01       	movw	r22, r24
    3dba:	cd 01       	movw	r24, r26
    3dbc:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    3dc0:	dc 01       	movw	r26, r24
    3dc2:	cb 01       	movw	r24, r22
    3dc4:	9d 8b       	std	Y+21, r25	; 0x15
    3dc6:	8c 8b       	std	Y+20, r24	; 0x14
    3dc8:	0f c0       	rjmp	.+30     	; 0x3de8 <HLCD4_voidStoreCustomChar+0x18c>
    3dca:	88 ec       	ldi	r24, 0xC8	; 200
    3dcc:	90 e0       	ldi	r25, 0x00	; 0
    3dce:	9b 8b       	std	Y+19, r25	; 0x13
    3dd0:	8a 8b       	std	Y+18, r24	; 0x12
    3dd2:	8a 89       	ldd	r24, Y+18	; 0x12
    3dd4:	9b 89       	ldd	r25, Y+19	; 0x13
    3dd6:	01 97       	sbiw	r24, 0x01	; 1
    3dd8:	f1 f7       	brne	.-4      	; 0x3dd6 <HLCD4_voidStoreCustomChar+0x17a>
    3dda:	9b 8b       	std	Y+19, r25	; 0x13
    3ddc:	8a 8b       	std	Y+18, r24	; 0x12
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3dde:	8c 89       	ldd	r24, Y+20	; 0x14
    3de0:	9d 89       	ldd	r25, Y+21	; 0x15
    3de2:	01 97       	sbiw	r24, 0x01	; 1
    3de4:	9d 8b       	std	Y+21, r25	; 0x15
    3de6:	8c 8b       	std	Y+20, r24	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3de8:	8c 89       	ldd	r24, Y+20	; 0x14
    3dea:	9d 89       	ldd	r25, Y+21	; 0x15
    3dec:	00 97       	sbiw	r24, 0x00	; 0
    3dee:	69 f7       	brne	.-38     	; 0x3dca <HLCD4_voidStoreCustomChar+0x16e>
    3df0:	24 c0       	rjmp	.+72     	; 0x3e3a <HLCD4_voidStoreCustomChar+0x1de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3df2:	6e 89       	ldd	r22, Y+22	; 0x16
    3df4:	7f 89       	ldd	r23, Y+23	; 0x17
    3df6:	88 8d       	ldd	r24, Y+24	; 0x18
    3df8:	99 8d       	ldd	r25, Y+25	; 0x19
    3dfa:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    3dfe:	dc 01       	movw	r26, r24
    3e00:	cb 01       	movw	r24, r22
    3e02:	9d 8b       	std	Y+21, r25	; 0x15
    3e04:	8c 8b       	std	Y+20, r24	; 0x14
    3e06:	8c 89       	ldd	r24, Y+20	; 0x14
    3e08:	9d 89       	ldd	r25, Y+21	; 0x15
    3e0a:	99 8b       	std	Y+17, r25	; 0x11
    3e0c:	88 8b       	std	Y+16, r24	; 0x10
    3e0e:	88 89       	ldd	r24, Y+16	; 0x10
    3e10:	99 89       	ldd	r25, Y+17	; 0x11
    3e12:	01 97       	sbiw	r24, 0x01	; 1
    3e14:	f1 f7       	brne	.-4      	; 0x3e12 <HLCD4_voidStoreCustomChar+0x1b6>
    3e16:	99 8b       	std	Y+17, r25	; 0x11
    3e18:	88 8b       	std	Y+16, r24	; 0x10
    3e1a:	0f c0       	rjmp	.+30     	; 0x3e3a <HLCD4_voidStoreCustomChar+0x1de>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3e1c:	6f 8d       	ldd	r22, Y+31	; 0x1f
    3e1e:	78 a1       	ldd	r23, Y+32	; 0x20
    3e20:	89 a1       	ldd	r24, Y+33	; 0x21
    3e22:	9a a1       	ldd	r25, Y+34	; 0x22
    3e24:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    3e28:	dc 01       	movw	r26, r24
    3e2a:	cb 01       	movw	r24, r22
    3e2c:	8e 8f       	std	Y+30, r24	; 0x1e
    3e2e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3e30:	8f 87       	std	Y+15, r24	; 0x0f
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3e32:	8f 85       	ldd	r24, Y+15	; 0x0f
    3e34:	8a 95       	dec	r24
    3e36:	f1 f7       	brne	.-4      	; 0x3e34 <HLCD4_voidStoreCustomChar+0x1d8>
    3e38:	8f 87       	std	Y+15, r24	; 0x0f
    {
        A_u8CGRAMIndex=A_u8CGRAMIndex*8;
        SET_BIT(A_u8CGRAMIndex,PIN6);
        CLR_BIT(A_u8CGRAMIndex,PIN7);
        HLCD4_voidSendCommand(A_u8CGRAMIndex);
        for(u8 i=0;i<8;i++)
    3e3a:	8f a1       	ldd	r24, Y+39	; 0x27
    3e3c:	8f 5f       	subi	r24, 0xFF	; 255
    3e3e:	8f a3       	std	Y+39, r24	; 0x27
    3e40:	8f a1       	ldd	r24, Y+39	; 0x27
    3e42:	88 30       	cpi	r24, 0x08	; 8
    3e44:	08 f4       	brcc	.+2      	; 0x3e48 <HLCD4_voidStoreCustomChar+0x1ec>
    3e46:	30 cf       	rjmp	.-416    	; 0x3ca8 <HLCD4_voidStoreCustomChar+0x4c>
        {
            HLCD4_voidSendData(A_u8Pattern[i]);
            _delay_us(60);
        }
    }
    HLCD4_voidSendCommand(RETURN_HOME);
    3e48:	82 e0       	ldi	r24, 0x02	; 2
    3e4a:	0e 94 76 16 	call	0x2cec	; 0x2cec <HLCD4_voidSendCommand>
    3e4e:	80 e0       	ldi	r24, 0x00	; 0
    3e50:	90 e0       	ldi	r25, 0x00	; 0
    3e52:	a0 e0       	ldi	r26, 0x00	; 0
    3e54:	b0 e4       	ldi	r27, 0x40	; 64
    3e56:	8b 87       	std	Y+11, r24	; 0x0b
    3e58:	9c 87       	std	Y+12, r25	; 0x0c
    3e5a:	ad 87       	std	Y+13, r26	; 0x0d
    3e5c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3e5e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3e60:	7c 85       	ldd	r23, Y+12	; 0x0c
    3e62:	8d 85       	ldd	r24, Y+13	; 0x0d
    3e64:	9e 85       	ldd	r25, Y+14	; 0x0e
    3e66:	20 e0       	ldi	r18, 0x00	; 0
    3e68:	30 e0       	ldi	r19, 0x00	; 0
    3e6a:	4a ef       	ldi	r20, 0xFA	; 250
    3e6c:	54 e4       	ldi	r21, 0x44	; 68
    3e6e:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    3e72:	dc 01       	movw	r26, r24
    3e74:	cb 01       	movw	r24, r22
    3e76:	8f 83       	std	Y+7, r24	; 0x07
    3e78:	98 87       	std	Y+8, r25	; 0x08
    3e7a:	a9 87       	std	Y+9, r26	; 0x09
    3e7c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3e7e:	6f 81       	ldd	r22, Y+7	; 0x07
    3e80:	78 85       	ldd	r23, Y+8	; 0x08
    3e82:	89 85       	ldd	r24, Y+9	; 0x09
    3e84:	9a 85       	ldd	r25, Y+10	; 0x0a
    3e86:	20 e0       	ldi	r18, 0x00	; 0
    3e88:	30 e0       	ldi	r19, 0x00	; 0
    3e8a:	40 e8       	ldi	r20, 0x80	; 128
    3e8c:	5f e3       	ldi	r21, 0x3F	; 63
    3e8e:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    3e92:	88 23       	and	r24, r24
    3e94:	2c f4       	brge	.+10     	; 0x3ea0 <HLCD4_voidStoreCustomChar+0x244>
		__ticks = 1;
    3e96:	81 e0       	ldi	r24, 0x01	; 1
    3e98:	90 e0       	ldi	r25, 0x00	; 0
    3e9a:	9e 83       	std	Y+6, r25	; 0x06
    3e9c:	8d 83       	std	Y+5, r24	; 0x05
    3e9e:	3f c0       	rjmp	.+126    	; 0x3f1e <HLCD4_voidStoreCustomChar+0x2c2>
	else if (__tmp > 65535)
    3ea0:	6f 81       	ldd	r22, Y+7	; 0x07
    3ea2:	78 85       	ldd	r23, Y+8	; 0x08
    3ea4:	89 85       	ldd	r24, Y+9	; 0x09
    3ea6:	9a 85       	ldd	r25, Y+10	; 0x0a
    3ea8:	20 e0       	ldi	r18, 0x00	; 0
    3eaa:	3f ef       	ldi	r19, 0xFF	; 255
    3eac:	4f e7       	ldi	r20, 0x7F	; 127
    3eae:	57 e4       	ldi	r21, 0x47	; 71
    3eb0:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    3eb4:	18 16       	cp	r1, r24
    3eb6:	4c f5       	brge	.+82     	; 0x3f0a <HLCD4_voidStoreCustomChar+0x2ae>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3eb8:	6b 85       	ldd	r22, Y+11	; 0x0b
    3eba:	7c 85       	ldd	r23, Y+12	; 0x0c
    3ebc:	8d 85       	ldd	r24, Y+13	; 0x0d
    3ebe:	9e 85       	ldd	r25, Y+14	; 0x0e
    3ec0:	20 e0       	ldi	r18, 0x00	; 0
    3ec2:	30 e0       	ldi	r19, 0x00	; 0
    3ec4:	40 e2       	ldi	r20, 0x20	; 32
    3ec6:	51 e4       	ldi	r21, 0x41	; 65
    3ec8:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    3ecc:	dc 01       	movw	r26, r24
    3ece:	cb 01       	movw	r24, r22
    3ed0:	bc 01       	movw	r22, r24
    3ed2:	cd 01       	movw	r24, r26
    3ed4:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    3ed8:	dc 01       	movw	r26, r24
    3eda:	cb 01       	movw	r24, r22
    3edc:	9e 83       	std	Y+6, r25	; 0x06
    3ede:	8d 83       	std	Y+5, r24	; 0x05
    3ee0:	0f c0       	rjmp	.+30     	; 0x3f00 <HLCD4_voidStoreCustomChar+0x2a4>
    3ee2:	88 ec       	ldi	r24, 0xC8	; 200
    3ee4:	90 e0       	ldi	r25, 0x00	; 0
    3ee6:	9c 83       	std	Y+4, r25	; 0x04
    3ee8:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3eea:	8b 81       	ldd	r24, Y+3	; 0x03
    3eec:	9c 81       	ldd	r25, Y+4	; 0x04
    3eee:	01 97       	sbiw	r24, 0x01	; 1
    3ef0:	f1 f7       	brne	.-4      	; 0x3eee <HLCD4_voidStoreCustomChar+0x292>
    3ef2:	9c 83       	std	Y+4, r25	; 0x04
    3ef4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3ef6:	8d 81       	ldd	r24, Y+5	; 0x05
    3ef8:	9e 81       	ldd	r25, Y+6	; 0x06
    3efa:	01 97       	sbiw	r24, 0x01	; 1
    3efc:	9e 83       	std	Y+6, r25	; 0x06
    3efe:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3f00:	8d 81       	ldd	r24, Y+5	; 0x05
    3f02:	9e 81       	ldd	r25, Y+6	; 0x06
    3f04:	00 97       	sbiw	r24, 0x00	; 0
    3f06:	69 f7       	brne	.-38     	; 0x3ee2 <HLCD4_voidStoreCustomChar+0x286>
    3f08:	14 c0       	rjmp	.+40     	; 0x3f32 <HLCD4_voidStoreCustomChar+0x2d6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3f0a:	6f 81       	ldd	r22, Y+7	; 0x07
    3f0c:	78 85       	ldd	r23, Y+8	; 0x08
    3f0e:	89 85       	ldd	r24, Y+9	; 0x09
    3f10:	9a 85       	ldd	r25, Y+10	; 0x0a
    3f12:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    3f16:	dc 01       	movw	r26, r24
    3f18:	cb 01       	movw	r24, r22
    3f1a:	9e 83       	std	Y+6, r25	; 0x06
    3f1c:	8d 83       	std	Y+5, r24	; 0x05
    3f1e:	8d 81       	ldd	r24, Y+5	; 0x05
    3f20:	9e 81       	ldd	r25, Y+6	; 0x06
    3f22:	9a 83       	std	Y+2, r25	; 0x02
    3f24:	89 83       	std	Y+1, r24	; 0x01
    3f26:	89 81       	ldd	r24, Y+1	; 0x01
    3f28:	9a 81       	ldd	r25, Y+2	; 0x02
    3f2a:	01 97       	sbiw	r24, 0x01	; 1
    3f2c:	f1 f7       	brne	.-4      	; 0x3f2a <HLCD4_voidStoreCustomChar+0x2ce>
    3f2e:	9a 83       	std	Y+2, r25	; 0x02
    3f30:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(2);

}
    3f32:	ab 96       	adiw	r28, 0x2b	; 43
    3f34:	0f b6       	in	r0, 0x3f	; 63
    3f36:	f8 94       	cli
    3f38:	de bf       	out	0x3e, r29	; 62
    3f3a:	0f be       	out	0x3f, r0	; 63
    3f3c:	cd bf       	out	0x3d, r28	; 61
    3f3e:	cf 91       	pop	r28
    3f40:	df 91       	pop	r29
    3f42:	08 95       	ret

00003f44 <HLCD4_voidDisplayCustomChar>:

void HLCD4_voidDisplayCustomChar(u8 A_u8CGRAMIndex,u8 A_u8Row,u8 A_u8Col)
{
    3f44:	df 93       	push	r29
    3f46:	cf 93       	push	r28
    3f48:	00 d0       	rcall	.+0      	; 0x3f4a <HLCD4_voidDisplayCustomChar+0x6>
    3f4a:	0f 92       	push	r0
    3f4c:	cd b7       	in	r28, 0x3d	; 61
    3f4e:	de b7       	in	r29, 0x3e	; 62
    3f50:	89 83       	std	Y+1, r24	; 0x01
    3f52:	6a 83       	std	Y+2, r22	; 0x02
    3f54:	4b 83       	std	Y+3, r20	; 0x03
    HLCD4_voidGoToPos(A_u8Row,A_u8Col);
    3f56:	8a 81       	ldd	r24, Y+2	; 0x02
    3f58:	6b 81       	ldd	r22, Y+3	; 0x03
    3f5a:	0e 94 29 1d 	call	0x3a52	; 0x3a52 <HLCD4_voidGoToPos>
    HLCD4_voidSendData(A_u8CGRAMIndex);
    3f5e:	89 81       	ldd	r24, Y+1	; 0x01
    3f60:	0e 94 0f 18 	call	0x301e	; 0x301e <HLCD4_voidSendData>
    3f64:	0f 90       	pop	r0
    3f66:	0f 90       	pop	r0
    3f68:	0f 90       	pop	r0
    3f6a:	cf 91       	pop	r28
    3f6c:	df 91       	pop	r29
    3f6e:	08 95       	ret

00003f70 <HLCD8_voidSendCommand>:
#define F_CPU 8000000UL
#include <math.h>
#include <stdlib.h>

void HLCD8_voidSendCommand(u8 A_u8Command)
{
    3f70:	df 93       	push	r29
    3f72:	cf 93       	push	r28
    3f74:	cd b7       	in	r28, 0x3d	; 61
    3f76:	de b7       	in	r29, 0x3e	; 62
    3f78:	2f 97       	sbiw	r28, 0x0f	; 15
    3f7a:	0f b6       	in	r0, 0x3f	; 63
    3f7c:	f8 94       	cli
    3f7e:	de bf       	out	0x3e, r29	; 62
    3f80:	0f be       	out	0x3f, r0	; 63
    3f82:	cd bf       	out	0x3d, r28	; 61
    3f84:	8f 87       	std	Y+15, r24	; 0x0f
    //RS=0 RW=0
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,RS_PIN,PIN_LOW);
    3f86:	82 e0       	ldi	r24, 0x02	; 2
    3f88:	60 e0       	ldi	r22, 0x00	; 0
    3f8a:	40 e0       	ldi	r20, 0x00	; 0
    3f8c:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,RW_PIN,PIN_LOW);
    3f90:	82 e0       	ldi	r24, 0x02	; 2
    3f92:	61 e0       	ldi	r22, 0x01	; 1
    3f94:	40 e0       	ldi	r20, 0x00	; 0
    3f96:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>

    MDIO_voidSetPortValue(LCD_DATA_PORT,A_u8Command);
    3f9a:	83 e0       	ldi	r24, 0x03	; 3
    3f9c:	6f 85       	ldd	r22, Y+15	; 0x0f
    3f9e:	0e 94 40 12 	call	0x2480	; 0x2480 <MDIO_voidSetPortValue>
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_HIGH);
    3fa2:	82 e0       	ldi	r24, 0x02	; 2
    3fa4:	62 e0       	ldi	r22, 0x02	; 2
    3fa6:	41 e0       	ldi	r20, 0x01	; 1
    3fa8:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    3fac:	80 e0       	ldi	r24, 0x00	; 0
    3fae:	90 e0       	ldi	r25, 0x00	; 0
    3fb0:	a0 e0       	ldi	r26, 0x00	; 0
    3fb2:	b0 e4       	ldi	r27, 0x40	; 64
    3fb4:	8b 87       	std	Y+11, r24	; 0x0b
    3fb6:	9c 87       	std	Y+12, r25	; 0x0c
    3fb8:	ad 87       	std	Y+13, r26	; 0x0d
    3fba:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3fbc:	6b 85       	ldd	r22, Y+11	; 0x0b
    3fbe:	7c 85       	ldd	r23, Y+12	; 0x0c
    3fc0:	8d 85       	ldd	r24, Y+13	; 0x0d
    3fc2:	9e 85       	ldd	r25, Y+14	; 0x0e
    3fc4:	20 e0       	ldi	r18, 0x00	; 0
    3fc6:	30 e0       	ldi	r19, 0x00	; 0
    3fc8:	4a ef       	ldi	r20, 0xFA	; 250
    3fca:	54 e4       	ldi	r21, 0x44	; 68
    3fcc:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    3fd0:	dc 01       	movw	r26, r24
    3fd2:	cb 01       	movw	r24, r22
    3fd4:	8f 83       	std	Y+7, r24	; 0x07
    3fd6:	98 87       	std	Y+8, r25	; 0x08
    3fd8:	a9 87       	std	Y+9, r26	; 0x09
    3fda:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3fdc:	6f 81       	ldd	r22, Y+7	; 0x07
    3fde:	78 85       	ldd	r23, Y+8	; 0x08
    3fe0:	89 85       	ldd	r24, Y+9	; 0x09
    3fe2:	9a 85       	ldd	r25, Y+10	; 0x0a
    3fe4:	20 e0       	ldi	r18, 0x00	; 0
    3fe6:	30 e0       	ldi	r19, 0x00	; 0
    3fe8:	40 e8       	ldi	r20, 0x80	; 128
    3fea:	5f e3       	ldi	r21, 0x3F	; 63
    3fec:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    3ff0:	88 23       	and	r24, r24
    3ff2:	2c f4       	brge	.+10     	; 0x3ffe <HLCD8_voidSendCommand+0x8e>
		__ticks = 1;
    3ff4:	81 e0       	ldi	r24, 0x01	; 1
    3ff6:	90 e0       	ldi	r25, 0x00	; 0
    3ff8:	9e 83       	std	Y+6, r25	; 0x06
    3ffa:	8d 83       	std	Y+5, r24	; 0x05
    3ffc:	3f c0       	rjmp	.+126    	; 0x407c <HLCD8_voidSendCommand+0x10c>
	else if (__tmp > 65535)
    3ffe:	6f 81       	ldd	r22, Y+7	; 0x07
    4000:	78 85       	ldd	r23, Y+8	; 0x08
    4002:	89 85       	ldd	r24, Y+9	; 0x09
    4004:	9a 85       	ldd	r25, Y+10	; 0x0a
    4006:	20 e0       	ldi	r18, 0x00	; 0
    4008:	3f ef       	ldi	r19, 0xFF	; 255
    400a:	4f e7       	ldi	r20, 0x7F	; 127
    400c:	57 e4       	ldi	r21, 0x47	; 71
    400e:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    4012:	18 16       	cp	r1, r24
    4014:	4c f5       	brge	.+82     	; 0x4068 <HLCD8_voidSendCommand+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4016:	6b 85       	ldd	r22, Y+11	; 0x0b
    4018:	7c 85       	ldd	r23, Y+12	; 0x0c
    401a:	8d 85       	ldd	r24, Y+13	; 0x0d
    401c:	9e 85       	ldd	r25, Y+14	; 0x0e
    401e:	20 e0       	ldi	r18, 0x00	; 0
    4020:	30 e0       	ldi	r19, 0x00	; 0
    4022:	40 e2       	ldi	r20, 0x20	; 32
    4024:	51 e4       	ldi	r21, 0x41	; 65
    4026:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    402a:	dc 01       	movw	r26, r24
    402c:	cb 01       	movw	r24, r22
    402e:	bc 01       	movw	r22, r24
    4030:	cd 01       	movw	r24, r26
    4032:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    4036:	dc 01       	movw	r26, r24
    4038:	cb 01       	movw	r24, r22
    403a:	9e 83       	std	Y+6, r25	; 0x06
    403c:	8d 83       	std	Y+5, r24	; 0x05
    403e:	0f c0       	rjmp	.+30     	; 0x405e <HLCD8_voidSendCommand+0xee>
    4040:	88 ec       	ldi	r24, 0xC8	; 200
    4042:	90 e0       	ldi	r25, 0x00	; 0
    4044:	9c 83       	std	Y+4, r25	; 0x04
    4046:	8b 83       	std	Y+3, r24	; 0x03
    4048:	8b 81       	ldd	r24, Y+3	; 0x03
    404a:	9c 81       	ldd	r25, Y+4	; 0x04
    404c:	01 97       	sbiw	r24, 0x01	; 1
    404e:	f1 f7       	brne	.-4      	; 0x404c <HLCD8_voidSendCommand+0xdc>
    4050:	9c 83       	std	Y+4, r25	; 0x04
    4052:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4054:	8d 81       	ldd	r24, Y+5	; 0x05
    4056:	9e 81       	ldd	r25, Y+6	; 0x06
    4058:	01 97       	sbiw	r24, 0x01	; 1
    405a:	9e 83       	std	Y+6, r25	; 0x06
    405c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    405e:	8d 81       	ldd	r24, Y+5	; 0x05
    4060:	9e 81       	ldd	r25, Y+6	; 0x06
    4062:	00 97       	sbiw	r24, 0x00	; 0
    4064:	69 f7       	brne	.-38     	; 0x4040 <HLCD8_voidSendCommand+0xd0>
    4066:	14 c0       	rjmp	.+40     	; 0x4090 <HLCD8_voidSendCommand+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4068:	6f 81       	ldd	r22, Y+7	; 0x07
    406a:	78 85       	ldd	r23, Y+8	; 0x08
    406c:	89 85       	ldd	r24, Y+9	; 0x09
    406e:	9a 85       	ldd	r25, Y+10	; 0x0a
    4070:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    4074:	dc 01       	movw	r26, r24
    4076:	cb 01       	movw	r24, r22
    4078:	9e 83       	std	Y+6, r25	; 0x06
    407a:	8d 83       	std	Y+5, r24	; 0x05
    407c:	8d 81       	ldd	r24, Y+5	; 0x05
    407e:	9e 81       	ldd	r25, Y+6	; 0x06
    4080:	9a 83       	std	Y+2, r25	; 0x02
    4082:	89 83       	std	Y+1, r24	; 0x01
    4084:	89 81       	ldd	r24, Y+1	; 0x01
    4086:	9a 81       	ldd	r25, Y+2	; 0x02
    4088:	01 97       	sbiw	r24, 0x01	; 1
    408a:	f1 f7       	brne	.-4      	; 0x4088 <HLCD8_voidSendCommand+0x118>
    408c:	9a 83       	std	Y+2, r25	; 0x02
    408e:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(2);
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_LOW);
    4090:	82 e0       	ldi	r24, 0x02	; 2
    4092:	62 e0       	ldi	r22, 0x02	; 2
    4094:	40 e0       	ldi	r20, 0x00	; 0
    4096:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
}
    409a:	2f 96       	adiw	r28, 0x0f	; 15
    409c:	0f b6       	in	r0, 0x3f	; 63
    409e:	f8 94       	cli
    40a0:	de bf       	out	0x3e, r29	; 62
    40a2:	0f be       	out	0x3f, r0	; 63
    40a4:	cd bf       	out	0x3d, r28	; 61
    40a6:	cf 91       	pop	r28
    40a8:	df 91       	pop	r29
    40aa:	08 95       	ret

000040ac <HLCD8_voidSendData>:


void HLCD8_voidSendData(u8 A_u8Data)
{
    40ac:	df 93       	push	r29
    40ae:	cf 93       	push	r28
    40b0:	cd b7       	in	r28, 0x3d	; 61
    40b2:	de b7       	in	r29, 0x3e	; 62
    40b4:	2f 97       	sbiw	r28, 0x0f	; 15
    40b6:	0f b6       	in	r0, 0x3f	; 63
    40b8:	f8 94       	cli
    40ba:	de bf       	out	0x3e, r29	; 62
    40bc:	0f be       	out	0x3f, r0	; 63
    40be:	cd bf       	out	0x3d, r28	; 61
    40c0:	8f 87       	std	Y+15, r24	; 0x0f
    //RS=1 RW=0
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,RS_PIN,PIN_HIGH);
    40c2:	82 e0       	ldi	r24, 0x02	; 2
    40c4:	60 e0       	ldi	r22, 0x00	; 0
    40c6:	41 e0       	ldi	r20, 0x01	; 1
    40c8:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,RW_PIN,PIN_LOW);
    40cc:	82 e0       	ldi	r24, 0x02	; 2
    40ce:	61 e0       	ldi	r22, 0x01	; 1
    40d0:	40 e0       	ldi	r20, 0x00	; 0
    40d2:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>

    MDIO_voidSetPortValue(LCD_DATA_PORT,A_u8Data);
    40d6:	83 e0       	ldi	r24, 0x03	; 3
    40d8:	6f 85       	ldd	r22, Y+15	; 0x0f
    40da:	0e 94 40 12 	call	0x2480	; 0x2480 <MDIO_voidSetPortValue>

    MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_HIGH);
    40de:	82 e0       	ldi	r24, 0x02	; 2
    40e0:	62 e0       	ldi	r22, 0x02	; 2
    40e2:	41 e0       	ldi	r20, 0x01	; 1
    40e4:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    40e8:	80 e0       	ldi	r24, 0x00	; 0
    40ea:	90 e0       	ldi	r25, 0x00	; 0
    40ec:	a0 e0       	ldi	r26, 0x00	; 0
    40ee:	b0 e4       	ldi	r27, 0x40	; 64
    40f0:	8b 87       	std	Y+11, r24	; 0x0b
    40f2:	9c 87       	std	Y+12, r25	; 0x0c
    40f4:	ad 87       	std	Y+13, r26	; 0x0d
    40f6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    40f8:	6b 85       	ldd	r22, Y+11	; 0x0b
    40fa:	7c 85       	ldd	r23, Y+12	; 0x0c
    40fc:	8d 85       	ldd	r24, Y+13	; 0x0d
    40fe:	9e 85       	ldd	r25, Y+14	; 0x0e
    4100:	20 e0       	ldi	r18, 0x00	; 0
    4102:	30 e0       	ldi	r19, 0x00	; 0
    4104:	4a ef       	ldi	r20, 0xFA	; 250
    4106:	54 e4       	ldi	r21, 0x44	; 68
    4108:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    410c:	dc 01       	movw	r26, r24
    410e:	cb 01       	movw	r24, r22
    4110:	8f 83       	std	Y+7, r24	; 0x07
    4112:	98 87       	std	Y+8, r25	; 0x08
    4114:	a9 87       	std	Y+9, r26	; 0x09
    4116:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4118:	6f 81       	ldd	r22, Y+7	; 0x07
    411a:	78 85       	ldd	r23, Y+8	; 0x08
    411c:	89 85       	ldd	r24, Y+9	; 0x09
    411e:	9a 85       	ldd	r25, Y+10	; 0x0a
    4120:	20 e0       	ldi	r18, 0x00	; 0
    4122:	30 e0       	ldi	r19, 0x00	; 0
    4124:	40 e8       	ldi	r20, 0x80	; 128
    4126:	5f e3       	ldi	r21, 0x3F	; 63
    4128:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    412c:	88 23       	and	r24, r24
    412e:	2c f4       	brge	.+10     	; 0x413a <HLCD8_voidSendData+0x8e>
		__ticks = 1;
    4130:	81 e0       	ldi	r24, 0x01	; 1
    4132:	90 e0       	ldi	r25, 0x00	; 0
    4134:	9e 83       	std	Y+6, r25	; 0x06
    4136:	8d 83       	std	Y+5, r24	; 0x05
    4138:	3f c0       	rjmp	.+126    	; 0x41b8 <HLCD8_voidSendData+0x10c>
	else if (__tmp > 65535)
    413a:	6f 81       	ldd	r22, Y+7	; 0x07
    413c:	78 85       	ldd	r23, Y+8	; 0x08
    413e:	89 85       	ldd	r24, Y+9	; 0x09
    4140:	9a 85       	ldd	r25, Y+10	; 0x0a
    4142:	20 e0       	ldi	r18, 0x00	; 0
    4144:	3f ef       	ldi	r19, 0xFF	; 255
    4146:	4f e7       	ldi	r20, 0x7F	; 127
    4148:	57 e4       	ldi	r21, 0x47	; 71
    414a:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    414e:	18 16       	cp	r1, r24
    4150:	4c f5       	brge	.+82     	; 0x41a4 <HLCD8_voidSendData+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4152:	6b 85       	ldd	r22, Y+11	; 0x0b
    4154:	7c 85       	ldd	r23, Y+12	; 0x0c
    4156:	8d 85       	ldd	r24, Y+13	; 0x0d
    4158:	9e 85       	ldd	r25, Y+14	; 0x0e
    415a:	20 e0       	ldi	r18, 0x00	; 0
    415c:	30 e0       	ldi	r19, 0x00	; 0
    415e:	40 e2       	ldi	r20, 0x20	; 32
    4160:	51 e4       	ldi	r21, 0x41	; 65
    4162:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    4166:	dc 01       	movw	r26, r24
    4168:	cb 01       	movw	r24, r22
    416a:	bc 01       	movw	r22, r24
    416c:	cd 01       	movw	r24, r26
    416e:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    4172:	dc 01       	movw	r26, r24
    4174:	cb 01       	movw	r24, r22
    4176:	9e 83       	std	Y+6, r25	; 0x06
    4178:	8d 83       	std	Y+5, r24	; 0x05
    417a:	0f c0       	rjmp	.+30     	; 0x419a <HLCD8_voidSendData+0xee>
    417c:	88 ec       	ldi	r24, 0xC8	; 200
    417e:	90 e0       	ldi	r25, 0x00	; 0
    4180:	9c 83       	std	Y+4, r25	; 0x04
    4182:	8b 83       	std	Y+3, r24	; 0x03
    4184:	8b 81       	ldd	r24, Y+3	; 0x03
    4186:	9c 81       	ldd	r25, Y+4	; 0x04
    4188:	01 97       	sbiw	r24, 0x01	; 1
    418a:	f1 f7       	brne	.-4      	; 0x4188 <HLCD8_voidSendData+0xdc>
    418c:	9c 83       	std	Y+4, r25	; 0x04
    418e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4190:	8d 81       	ldd	r24, Y+5	; 0x05
    4192:	9e 81       	ldd	r25, Y+6	; 0x06
    4194:	01 97       	sbiw	r24, 0x01	; 1
    4196:	9e 83       	std	Y+6, r25	; 0x06
    4198:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    419a:	8d 81       	ldd	r24, Y+5	; 0x05
    419c:	9e 81       	ldd	r25, Y+6	; 0x06
    419e:	00 97       	sbiw	r24, 0x00	; 0
    41a0:	69 f7       	brne	.-38     	; 0x417c <HLCD8_voidSendData+0xd0>
    41a2:	14 c0       	rjmp	.+40     	; 0x41cc <HLCD8_voidSendData+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    41a4:	6f 81       	ldd	r22, Y+7	; 0x07
    41a6:	78 85       	ldd	r23, Y+8	; 0x08
    41a8:	89 85       	ldd	r24, Y+9	; 0x09
    41aa:	9a 85       	ldd	r25, Y+10	; 0x0a
    41ac:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    41b0:	dc 01       	movw	r26, r24
    41b2:	cb 01       	movw	r24, r22
    41b4:	9e 83       	std	Y+6, r25	; 0x06
    41b6:	8d 83       	std	Y+5, r24	; 0x05
    41b8:	8d 81       	ldd	r24, Y+5	; 0x05
    41ba:	9e 81       	ldd	r25, Y+6	; 0x06
    41bc:	9a 83       	std	Y+2, r25	; 0x02
    41be:	89 83       	std	Y+1, r24	; 0x01
    41c0:	89 81       	ldd	r24, Y+1	; 0x01
    41c2:	9a 81       	ldd	r25, Y+2	; 0x02
    41c4:	01 97       	sbiw	r24, 0x01	; 1
    41c6:	f1 f7       	brne	.-4      	; 0x41c4 <HLCD8_voidSendData+0x118>
    41c8:	9a 83       	std	Y+2, r25	; 0x02
    41ca:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(2);
    MDIO_voidSetPinValue(LCD_CONTROL_PORT,E_PIN,PIN_LOW);
    41cc:	82 e0       	ldi	r24, 0x02	; 2
    41ce:	62 e0       	ldi	r22, 0x02	; 2
    41d0:	40 e0       	ldi	r20, 0x00	; 0
    41d2:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
}
    41d6:	2f 96       	adiw	r28, 0x0f	; 15
    41d8:	0f b6       	in	r0, 0x3f	; 63
    41da:	f8 94       	cli
    41dc:	de bf       	out	0x3e, r29	; 62
    41de:	0f be       	out	0x3f, r0	; 63
    41e0:	cd bf       	out	0x3d, r28	; 61
    41e2:	cf 91       	pop	r28
    41e4:	df 91       	pop	r29
    41e6:	08 95       	ret

000041e8 <HLCD8_voidInit>:


void HLCD8_voidInit()
{
    41e8:	df 93       	push	r29
    41ea:	cf 93       	push	r28
    41ec:	cd b7       	in	r28, 0x3d	; 61
    41ee:	de b7       	in	r29, 0x3e	; 62
    41f0:	e8 97       	sbiw	r28, 0x38	; 56
    41f2:	0f b6       	in	r0, 0x3f	; 63
    41f4:	f8 94       	cli
    41f6:	de bf       	out	0x3e, r29	; 62
    41f8:	0f be       	out	0x3f, r0	; 63
    41fa:	cd bf       	out	0x3d, r28	; 61
    41fc:	80 e0       	ldi	r24, 0x00	; 0
    41fe:	90 e0       	ldi	r25, 0x00	; 0
    4200:	a0 ef       	ldi	r26, 0xF0	; 240
    4202:	b1 e4       	ldi	r27, 0x41	; 65
    4204:	8d ab       	std	Y+53, r24	; 0x35
    4206:	9e ab       	std	Y+54, r25	; 0x36
    4208:	af ab       	std	Y+55, r26	; 0x37
    420a:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    420c:	6d a9       	ldd	r22, Y+53	; 0x35
    420e:	7e a9       	ldd	r23, Y+54	; 0x36
    4210:	8f a9       	ldd	r24, Y+55	; 0x37
    4212:	98 ad       	ldd	r25, Y+56	; 0x38
    4214:	20 e0       	ldi	r18, 0x00	; 0
    4216:	30 e0       	ldi	r19, 0x00	; 0
    4218:	4a ef       	ldi	r20, 0xFA	; 250
    421a:	54 e4       	ldi	r21, 0x44	; 68
    421c:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    4220:	dc 01       	movw	r26, r24
    4222:	cb 01       	movw	r24, r22
    4224:	89 ab       	std	Y+49, r24	; 0x31
    4226:	9a ab       	std	Y+50, r25	; 0x32
    4228:	ab ab       	std	Y+51, r26	; 0x33
    422a:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    422c:	69 a9       	ldd	r22, Y+49	; 0x31
    422e:	7a a9       	ldd	r23, Y+50	; 0x32
    4230:	8b a9       	ldd	r24, Y+51	; 0x33
    4232:	9c a9       	ldd	r25, Y+52	; 0x34
    4234:	20 e0       	ldi	r18, 0x00	; 0
    4236:	30 e0       	ldi	r19, 0x00	; 0
    4238:	40 e8       	ldi	r20, 0x80	; 128
    423a:	5f e3       	ldi	r21, 0x3F	; 63
    423c:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    4240:	88 23       	and	r24, r24
    4242:	2c f4       	brge	.+10     	; 0x424e <HLCD8_voidInit+0x66>
		__ticks = 1;
    4244:	81 e0       	ldi	r24, 0x01	; 1
    4246:	90 e0       	ldi	r25, 0x00	; 0
    4248:	98 ab       	std	Y+48, r25	; 0x30
    424a:	8f a7       	std	Y+47, r24	; 0x2f
    424c:	3f c0       	rjmp	.+126    	; 0x42cc <HLCD8_voidInit+0xe4>
	else if (__tmp > 65535)
    424e:	69 a9       	ldd	r22, Y+49	; 0x31
    4250:	7a a9       	ldd	r23, Y+50	; 0x32
    4252:	8b a9       	ldd	r24, Y+51	; 0x33
    4254:	9c a9       	ldd	r25, Y+52	; 0x34
    4256:	20 e0       	ldi	r18, 0x00	; 0
    4258:	3f ef       	ldi	r19, 0xFF	; 255
    425a:	4f e7       	ldi	r20, 0x7F	; 127
    425c:	57 e4       	ldi	r21, 0x47	; 71
    425e:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    4262:	18 16       	cp	r1, r24
    4264:	4c f5       	brge	.+82     	; 0x42b8 <HLCD8_voidInit+0xd0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4266:	6d a9       	ldd	r22, Y+53	; 0x35
    4268:	7e a9       	ldd	r23, Y+54	; 0x36
    426a:	8f a9       	ldd	r24, Y+55	; 0x37
    426c:	98 ad       	ldd	r25, Y+56	; 0x38
    426e:	20 e0       	ldi	r18, 0x00	; 0
    4270:	30 e0       	ldi	r19, 0x00	; 0
    4272:	40 e2       	ldi	r20, 0x20	; 32
    4274:	51 e4       	ldi	r21, 0x41	; 65
    4276:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    427a:	dc 01       	movw	r26, r24
    427c:	cb 01       	movw	r24, r22
    427e:	bc 01       	movw	r22, r24
    4280:	cd 01       	movw	r24, r26
    4282:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    4286:	dc 01       	movw	r26, r24
    4288:	cb 01       	movw	r24, r22
    428a:	98 ab       	std	Y+48, r25	; 0x30
    428c:	8f a7       	std	Y+47, r24	; 0x2f
    428e:	0f c0       	rjmp	.+30     	; 0x42ae <HLCD8_voidInit+0xc6>
    4290:	88 ec       	ldi	r24, 0xC8	; 200
    4292:	90 e0       	ldi	r25, 0x00	; 0
    4294:	9e a7       	std	Y+46, r25	; 0x2e
    4296:	8d a7       	std	Y+45, r24	; 0x2d
    4298:	8d a5       	ldd	r24, Y+45	; 0x2d
    429a:	9e a5       	ldd	r25, Y+46	; 0x2e
    429c:	01 97       	sbiw	r24, 0x01	; 1
    429e:	f1 f7       	brne	.-4      	; 0x429c <HLCD8_voidInit+0xb4>
    42a0:	9e a7       	std	Y+46, r25	; 0x2e
    42a2:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    42a4:	8f a5       	ldd	r24, Y+47	; 0x2f
    42a6:	98 a9       	ldd	r25, Y+48	; 0x30
    42a8:	01 97       	sbiw	r24, 0x01	; 1
    42aa:	98 ab       	std	Y+48, r25	; 0x30
    42ac:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    42ae:	8f a5       	ldd	r24, Y+47	; 0x2f
    42b0:	98 a9       	ldd	r25, Y+48	; 0x30
    42b2:	00 97       	sbiw	r24, 0x00	; 0
    42b4:	69 f7       	brne	.-38     	; 0x4290 <HLCD8_voidInit+0xa8>
    42b6:	14 c0       	rjmp	.+40     	; 0x42e0 <HLCD8_voidInit+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    42b8:	69 a9       	ldd	r22, Y+49	; 0x31
    42ba:	7a a9       	ldd	r23, Y+50	; 0x32
    42bc:	8b a9       	ldd	r24, Y+51	; 0x33
    42be:	9c a9       	ldd	r25, Y+52	; 0x34
    42c0:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    42c4:	dc 01       	movw	r26, r24
    42c6:	cb 01       	movw	r24, r22
    42c8:	98 ab       	std	Y+48, r25	; 0x30
    42ca:	8f a7       	std	Y+47, r24	; 0x2f
    42cc:	8f a5       	ldd	r24, Y+47	; 0x2f
    42ce:	98 a9       	ldd	r25, Y+48	; 0x30
    42d0:	9c a7       	std	Y+44, r25	; 0x2c
    42d2:	8b a7       	std	Y+43, r24	; 0x2b
    42d4:	8b a5       	ldd	r24, Y+43	; 0x2b
    42d6:	9c a5       	ldd	r25, Y+44	; 0x2c
    42d8:	01 97       	sbiw	r24, 0x01	; 1
    42da:	f1 f7       	brne	.-4      	; 0x42d8 <HLCD8_voidInit+0xf0>
    42dc:	9c a7       	std	Y+44, r25	; 0x2c
    42de:	8b a7       	std	Y+43, r24	; 0x2b
    _delay_ms(30);
    HLCD8_voidSendCommand(FUNCTION_SET);
    42e0:	88 e3       	ldi	r24, 0x38	; 56
    42e2:	0e 94 b8 1f 	call	0x3f70	; 0x3f70 <HLCD8_voidSendCommand>
    42e6:	80 e0       	ldi	r24, 0x00	; 0
    42e8:	90 e0       	ldi	r25, 0x00	; 0
    42ea:	a0 e8       	ldi	r26, 0x80	; 128
    42ec:	bf e3       	ldi	r27, 0x3F	; 63
    42ee:	8f a3       	std	Y+39, r24	; 0x27
    42f0:	98 a7       	std	Y+40, r25	; 0x28
    42f2:	a9 a7       	std	Y+41, r26	; 0x29
    42f4:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    42f6:	6f a1       	ldd	r22, Y+39	; 0x27
    42f8:	78 a5       	ldd	r23, Y+40	; 0x28
    42fa:	89 a5       	ldd	r24, Y+41	; 0x29
    42fc:	9a a5       	ldd	r25, Y+42	; 0x2a
    42fe:	20 e0       	ldi	r18, 0x00	; 0
    4300:	30 e0       	ldi	r19, 0x00	; 0
    4302:	4a ef       	ldi	r20, 0xFA	; 250
    4304:	54 e4       	ldi	r21, 0x44	; 68
    4306:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    430a:	dc 01       	movw	r26, r24
    430c:	cb 01       	movw	r24, r22
    430e:	8b a3       	std	Y+35, r24	; 0x23
    4310:	9c a3       	std	Y+36, r25	; 0x24
    4312:	ad a3       	std	Y+37, r26	; 0x25
    4314:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    4316:	6b a1       	ldd	r22, Y+35	; 0x23
    4318:	7c a1       	ldd	r23, Y+36	; 0x24
    431a:	8d a1       	ldd	r24, Y+37	; 0x25
    431c:	9e a1       	ldd	r25, Y+38	; 0x26
    431e:	20 e0       	ldi	r18, 0x00	; 0
    4320:	30 e0       	ldi	r19, 0x00	; 0
    4322:	40 e8       	ldi	r20, 0x80	; 128
    4324:	5f e3       	ldi	r21, 0x3F	; 63
    4326:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    432a:	88 23       	and	r24, r24
    432c:	2c f4       	brge	.+10     	; 0x4338 <HLCD8_voidInit+0x150>
		__ticks = 1;
    432e:	81 e0       	ldi	r24, 0x01	; 1
    4330:	90 e0       	ldi	r25, 0x00	; 0
    4332:	9a a3       	std	Y+34, r25	; 0x22
    4334:	89 a3       	std	Y+33, r24	; 0x21
    4336:	3f c0       	rjmp	.+126    	; 0x43b6 <HLCD8_voidInit+0x1ce>
	else if (__tmp > 65535)
    4338:	6b a1       	ldd	r22, Y+35	; 0x23
    433a:	7c a1       	ldd	r23, Y+36	; 0x24
    433c:	8d a1       	ldd	r24, Y+37	; 0x25
    433e:	9e a1       	ldd	r25, Y+38	; 0x26
    4340:	20 e0       	ldi	r18, 0x00	; 0
    4342:	3f ef       	ldi	r19, 0xFF	; 255
    4344:	4f e7       	ldi	r20, 0x7F	; 127
    4346:	57 e4       	ldi	r21, 0x47	; 71
    4348:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    434c:	18 16       	cp	r1, r24
    434e:	4c f5       	brge	.+82     	; 0x43a2 <HLCD8_voidInit+0x1ba>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4350:	6f a1       	ldd	r22, Y+39	; 0x27
    4352:	78 a5       	ldd	r23, Y+40	; 0x28
    4354:	89 a5       	ldd	r24, Y+41	; 0x29
    4356:	9a a5       	ldd	r25, Y+42	; 0x2a
    4358:	20 e0       	ldi	r18, 0x00	; 0
    435a:	30 e0       	ldi	r19, 0x00	; 0
    435c:	40 e2       	ldi	r20, 0x20	; 32
    435e:	51 e4       	ldi	r21, 0x41	; 65
    4360:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    4364:	dc 01       	movw	r26, r24
    4366:	cb 01       	movw	r24, r22
    4368:	bc 01       	movw	r22, r24
    436a:	cd 01       	movw	r24, r26
    436c:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    4370:	dc 01       	movw	r26, r24
    4372:	cb 01       	movw	r24, r22
    4374:	9a a3       	std	Y+34, r25	; 0x22
    4376:	89 a3       	std	Y+33, r24	; 0x21
    4378:	0f c0       	rjmp	.+30     	; 0x4398 <HLCD8_voidInit+0x1b0>
    437a:	88 ec       	ldi	r24, 0xC8	; 200
    437c:	90 e0       	ldi	r25, 0x00	; 0
    437e:	98 a3       	std	Y+32, r25	; 0x20
    4380:	8f 8f       	std	Y+31, r24	; 0x1f
    4382:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4384:	98 a1       	ldd	r25, Y+32	; 0x20
    4386:	01 97       	sbiw	r24, 0x01	; 1
    4388:	f1 f7       	brne	.-4      	; 0x4386 <HLCD8_voidInit+0x19e>
    438a:	98 a3       	std	Y+32, r25	; 0x20
    438c:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    438e:	89 a1       	ldd	r24, Y+33	; 0x21
    4390:	9a a1       	ldd	r25, Y+34	; 0x22
    4392:	01 97       	sbiw	r24, 0x01	; 1
    4394:	9a a3       	std	Y+34, r25	; 0x22
    4396:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4398:	89 a1       	ldd	r24, Y+33	; 0x21
    439a:	9a a1       	ldd	r25, Y+34	; 0x22
    439c:	00 97       	sbiw	r24, 0x00	; 0
    439e:	69 f7       	brne	.-38     	; 0x437a <HLCD8_voidInit+0x192>
    43a0:	14 c0       	rjmp	.+40     	; 0x43ca <HLCD8_voidInit+0x1e2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    43a2:	6b a1       	ldd	r22, Y+35	; 0x23
    43a4:	7c a1       	ldd	r23, Y+36	; 0x24
    43a6:	8d a1       	ldd	r24, Y+37	; 0x25
    43a8:	9e a1       	ldd	r25, Y+38	; 0x26
    43aa:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    43ae:	dc 01       	movw	r26, r24
    43b0:	cb 01       	movw	r24, r22
    43b2:	9a a3       	std	Y+34, r25	; 0x22
    43b4:	89 a3       	std	Y+33, r24	; 0x21
    43b6:	89 a1       	ldd	r24, Y+33	; 0x21
    43b8:	9a a1       	ldd	r25, Y+34	; 0x22
    43ba:	9e 8f       	std	Y+30, r25	; 0x1e
    43bc:	8d 8f       	std	Y+29, r24	; 0x1d
    43be:	8d 8d       	ldd	r24, Y+29	; 0x1d
    43c0:	9e 8d       	ldd	r25, Y+30	; 0x1e
    43c2:	01 97       	sbiw	r24, 0x01	; 1
    43c4:	f1 f7       	brne	.-4      	; 0x43c2 <HLCD8_voidInit+0x1da>
    43c6:	9e 8f       	std	Y+30, r25	; 0x1e
    43c8:	8d 8f       	std	Y+29, r24	; 0x1d
    _delay_ms(1);
    HLCD8_voidSendCommand(ON_OFF_CONTROL);
    43ca:	8c e0       	ldi	r24, 0x0C	; 12
    43cc:	0e 94 b8 1f 	call	0x3f70	; 0x3f70 <HLCD8_voidSendCommand>
    43d0:	80 e0       	ldi	r24, 0x00	; 0
    43d2:	90 e0       	ldi	r25, 0x00	; 0
    43d4:	a0 e8       	ldi	r26, 0x80	; 128
    43d6:	bf e3       	ldi	r27, 0x3F	; 63
    43d8:	89 8f       	std	Y+25, r24	; 0x19
    43da:	9a 8f       	std	Y+26, r25	; 0x1a
    43dc:	ab 8f       	std	Y+27, r26	; 0x1b
    43de:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    43e0:	69 8d       	ldd	r22, Y+25	; 0x19
    43e2:	7a 8d       	ldd	r23, Y+26	; 0x1a
    43e4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    43e6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    43e8:	20 e0       	ldi	r18, 0x00	; 0
    43ea:	30 e0       	ldi	r19, 0x00	; 0
    43ec:	4a ef       	ldi	r20, 0xFA	; 250
    43ee:	54 e4       	ldi	r21, 0x44	; 68
    43f0:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    43f4:	dc 01       	movw	r26, r24
    43f6:	cb 01       	movw	r24, r22
    43f8:	8d 8b       	std	Y+21, r24	; 0x15
    43fa:	9e 8b       	std	Y+22, r25	; 0x16
    43fc:	af 8b       	std	Y+23, r26	; 0x17
    43fe:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    4400:	6d 89       	ldd	r22, Y+21	; 0x15
    4402:	7e 89       	ldd	r23, Y+22	; 0x16
    4404:	8f 89       	ldd	r24, Y+23	; 0x17
    4406:	98 8d       	ldd	r25, Y+24	; 0x18
    4408:	20 e0       	ldi	r18, 0x00	; 0
    440a:	30 e0       	ldi	r19, 0x00	; 0
    440c:	40 e8       	ldi	r20, 0x80	; 128
    440e:	5f e3       	ldi	r21, 0x3F	; 63
    4410:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    4414:	88 23       	and	r24, r24
    4416:	2c f4       	brge	.+10     	; 0x4422 <HLCD8_voidInit+0x23a>
		__ticks = 1;
    4418:	81 e0       	ldi	r24, 0x01	; 1
    441a:	90 e0       	ldi	r25, 0x00	; 0
    441c:	9c 8b       	std	Y+20, r25	; 0x14
    441e:	8b 8b       	std	Y+19, r24	; 0x13
    4420:	3f c0       	rjmp	.+126    	; 0x44a0 <HLCD8_voidInit+0x2b8>
	else if (__tmp > 65535)
    4422:	6d 89       	ldd	r22, Y+21	; 0x15
    4424:	7e 89       	ldd	r23, Y+22	; 0x16
    4426:	8f 89       	ldd	r24, Y+23	; 0x17
    4428:	98 8d       	ldd	r25, Y+24	; 0x18
    442a:	20 e0       	ldi	r18, 0x00	; 0
    442c:	3f ef       	ldi	r19, 0xFF	; 255
    442e:	4f e7       	ldi	r20, 0x7F	; 127
    4430:	57 e4       	ldi	r21, 0x47	; 71
    4432:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    4436:	18 16       	cp	r1, r24
    4438:	4c f5       	brge	.+82     	; 0x448c <HLCD8_voidInit+0x2a4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    443a:	69 8d       	ldd	r22, Y+25	; 0x19
    443c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    443e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4440:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4442:	20 e0       	ldi	r18, 0x00	; 0
    4444:	30 e0       	ldi	r19, 0x00	; 0
    4446:	40 e2       	ldi	r20, 0x20	; 32
    4448:	51 e4       	ldi	r21, 0x41	; 65
    444a:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    444e:	dc 01       	movw	r26, r24
    4450:	cb 01       	movw	r24, r22
    4452:	bc 01       	movw	r22, r24
    4454:	cd 01       	movw	r24, r26
    4456:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    445a:	dc 01       	movw	r26, r24
    445c:	cb 01       	movw	r24, r22
    445e:	9c 8b       	std	Y+20, r25	; 0x14
    4460:	8b 8b       	std	Y+19, r24	; 0x13
    4462:	0f c0       	rjmp	.+30     	; 0x4482 <HLCD8_voidInit+0x29a>
    4464:	88 ec       	ldi	r24, 0xC8	; 200
    4466:	90 e0       	ldi	r25, 0x00	; 0
    4468:	9a 8b       	std	Y+18, r25	; 0x12
    446a:	89 8b       	std	Y+17, r24	; 0x11
    446c:	89 89       	ldd	r24, Y+17	; 0x11
    446e:	9a 89       	ldd	r25, Y+18	; 0x12
    4470:	01 97       	sbiw	r24, 0x01	; 1
    4472:	f1 f7       	brne	.-4      	; 0x4470 <HLCD8_voidInit+0x288>
    4474:	9a 8b       	std	Y+18, r25	; 0x12
    4476:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4478:	8b 89       	ldd	r24, Y+19	; 0x13
    447a:	9c 89       	ldd	r25, Y+20	; 0x14
    447c:	01 97       	sbiw	r24, 0x01	; 1
    447e:	9c 8b       	std	Y+20, r25	; 0x14
    4480:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4482:	8b 89       	ldd	r24, Y+19	; 0x13
    4484:	9c 89       	ldd	r25, Y+20	; 0x14
    4486:	00 97       	sbiw	r24, 0x00	; 0
    4488:	69 f7       	brne	.-38     	; 0x4464 <HLCD8_voidInit+0x27c>
    448a:	14 c0       	rjmp	.+40     	; 0x44b4 <HLCD8_voidInit+0x2cc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    448c:	6d 89       	ldd	r22, Y+21	; 0x15
    448e:	7e 89       	ldd	r23, Y+22	; 0x16
    4490:	8f 89       	ldd	r24, Y+23	; 0x17
    4492:	98 8d       	ldd	r25, Y+24	; 0x18
    4494:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    4498:	dc 01       	movw	r26, r24
    449a:	cb 01       	movw	r24, r22
    449c:	9c 8b       	std	Y+20, r25	; 0x14
    449e:	8b 8b       	std	Y+19, r24	; 0x13
    44a0:	8b 89       	ldd	r24, Y+19	; 0x13
    44a2:	9c 89       	ldd	r25, Y+20	; 0x14
    44a4:	98 8b       	std	Y+16, r25	; 0x10
    44a6:	8f 87       	std	Y+15, r24	; 0x0f
    44a8:	8f 85       	ldd	r24, Y+15	; 0x0f
    44aa:	98 89       	ldd	r25, Y+16	; 0x10
    44ac:	01 97       	sbiw	r24, 0x01	; 1
    44ae:	f1 f7       	brne	.-4      	; 0x44ac <HLCD8_voidInit+0x2c4>
    44b0:	98 8b       	std	Y+16, r25	; 0x10
    44b2:	8f 87       	std	Y+15, r24	; 0x0f
    _delay_ms(1);
    HLCD8_voidSendCommand(DISPLAY_CLEAR);
    44b4:	81 e0       	ldi	r24, 0x01	; 1
    44b6:	0e 94 b8 1f 	call	0x3f70	; 0x3f70 <HLCD8_voidSendCommand>
    44ba:	80 e0       	ldi	r24, 0x00	; 0
    44bc:	90 e0       	ldi	r25, 0x00	; 0
    44be:	a0 e0       	ldi	r26, 0x00	; 0
    44c0:	b0 e4       	ldi	r27, 0x40	; 64
    44c2:	8b 87       	std	Y+11, r24	; 0x0b
    44c4:	9c 87       	std	Y+12, r25	; 0x0c
    44c6:	ad 87       	std	Y+13, r26	; 0x0d
    44c8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    44ca:	6b 85       	ldd	r22, Y+11	; 0x0b
    44cc:	7c 85       	ldd	r23, Y+12	; 0x0c
    44ce:	8d 85       	ldd	r24, Y+13	; 0x0d
    44d0:	9e 85       	ldd	r25, Y+14	; 0x0e
    44d2:	20 e0       	ldi	r18, 0x00	; 0
    44d4:	30 e0       	ldi	r19, 0x00	; 0
    44d6:	4a ef       	ldi	r20, 0xFA	; 250
    44d8:	54 e4       	ldi	r21, 0x44	; 68
    44da:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    44de:	dc 01       	movw	r26, r24
    44e0:	cb 01       	movw	r24, r22
    44e2:	8f 83       	std	Y+7, r24	; 0x07
    44e4:	98 87       	std	Y+8, r25	; 0x08
    44e6:	a9 87       	std	Y+9, r26	; 0x09
    44e8:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    44ea:	6f 81       	ldd	r22, Y+7	; 0x07
    44ec:	78 85       	ldd	r23, Y+8	; 0x08
    44ee:	89 85       	ldd	r24, Y+9	; 0x09
    44f0:	9a 85       	ldd	r25, Y+10	; 0x0a
    44f2:	20 e0       	ldi	r18, 0x00	; 0
    44f4:	30 e0       	ldi	r19, 0x00	; 0
    44f6:	40 e8       	ldi	r20, 0x80	; 128
    44f8:	5f e3       	ldi	r21, 0x3F	; 63
    44fa:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    44fe:	88 23       	and	r24, r24
    4500:	2c f4       	brge	.+10     	; 0x450c <HLCD8_voidInit+0x324>
		__ticks = 1;
    4502:	81 e0       	ldi	r24, 0x01	; 1
    4504:	90 e0       	ldi	r25, 0x00	; 0
    4506:	9e 83       	std	Y+6, r25	; 0x06
    4508:	8d 83       	std	Y+5, r24	; 0x05
    450a:	3f c0       	rjmp	.+126    	; 0x458a <HLCD8_voidInit+0x3a2>
	else if (__tmp > 65535)
    450c:	6f 81       	ldd	r22, Y+7	; 0x07
    450e:	78 85       	ldd	r23, Y+8	; 0x08
    4510:	89 85       	ldd	r24, Y+9	; 0x09
    4512:	9a 85       	ldd	r25, Y+10	; 0x0a
    4514:	20 e0       	ldi	r18, 0x00	; 0
    4516:	3f ef       	ldi	r19, 0xFF	; 255
    4518:	4f e7       	ldi	r20, 0x7F	; 127
    451a:	57 e4       	ldi	r21, 0x47	; 71
    451c:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    4520:	18 16       	cp	r1, r24
    4522:	4c f5       	brge	.+82     	; 0x4576 <HLCD8_voidInit+0x38e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4524:	6b 85       	ldd	r22, Y+11	; 0x0b
    4526:	7c 85       	ldd	r23, Y+12	; 0x0c
    4528:	8d 85       	ldd	r24, Y+13	; 0x0d
    452a:	9e 85       	ldd	r25, Y+14	; 0x0e
    452c:	20 e0       	ldi	r18, 0x00	; 0
    452e:	30 e0       	ldi	r19, 0x00	; 0
    4530:	40 e2       	ldi	r20, 0x20	; 32
    4532:	51 e4       	ldi	r21, 0x41	; 65
    4534:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    4538:	dc 01       	movw	r26, r24
    453a:	cb 01       	movw	r24, r22
    453c:	bc 01       	movw	r22, r24
    453e:	cd 01       	movw	r24, r26
    4540:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    4544:	dc 01       	movw	r26, r24
    4546:	cb 01       	movw	r24, r22
    4548:	9e 83       	std	Y+6, r25	; 0x06
    454a:	8d 83       	std	Y+5, r24	; 0x05
    454c:	0f c0       	rjmp	.+30     	; 0x456c <HLCD8_voidInit+0x384>
    454e:	88 ec       	ldi	r24, 0xC8	; 200
    4550:	90 e0       	ldi	r25, 0x00	; 0
    4552:	9c 83       	std	Y+4, r25	; 0x04
    4554:	8b 83       	std	Y+3, r24	; 0x03
    4556:	8b 81       	ldd	r24, Y+3	; 0x03
    4558:	9c 81       	ldd	r25, Y+4	; 0x04
    455a:	01 97       	sbiw	r24, 0x01	; 1
    455c:	f1 f7       	brne	.-4      	; 0x455a <HLCD8_voidInit+0x372>
    455e:	9c 83       	std	Y+4, r25	; 0x04
    4560:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4562:	8d 81       	ldd	r24, Y+5	; 0x05
    4564:	9e 81       	ldd	r25, Y+6	; 0x06
    4566:	01 97       	sbiw	r24, 0x01	; 1
    4568:	9e 83       	std	Y+6, r25	; 0x06
    456a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    456c:	8d 81       	ldd	r24, Y+5	; 0x05
    456e:	9e 81       	ldd	r25, Y+6	; 0x06
    4570:	00 97       	sbiw	r24, 0x00	; 0
    4572:	69 f7       	brne	.-38     	; 0x454e <HLCD8_voidInit+0x366>
    4574:	14 c0       	rjmp	.+40     	; 0x459e <HLCD8_voidInit+0x3b6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4576:	6f 81       	ldd	r22, Y+7	; 0x07
    4578:	78 85       	ldd	r23, Y+8	; 0x08
    457a:	89 85       	ldd	r24, Y+9	; 0x09
    457c:	9a 85       	ldd	r25, Y+10	; 0x0a
    457e:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    4582:	dc 01       	movw	r26, r24
    4584:	cb 01       	movw	r24, r22
    4586:	9e 83       	std	Y+6, r25	; 0x06
    4588:	8d 83       	std	Y+5, r24	; 0x05
    458a:	8d 81       	ldd	r24, Y+5	; 0x05
    458c:	9e 81       	ldd	r25, Y+6	; 0x06
    458e:	9a 83       	std	Y+2, r25	; 0x02
    4590:	89 83       	std	Y+1, r24	; 0x01
    4592:	89 81       	ldd	r24, Y+1	; 0x01
    4594:	9a 81       	ldd	r25, Y+2	; 0x02
    4596:	01 97       	sbiw	r24, 0x01	; 1
    4598:	f1 f7       	brne	.-4      	; 0x4596 <HLCD8_voidInit+0x3ae>
    459a:	9a 83       	std	Y+2, r25	; 0x02
    459c:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(2);
    HLCD8_voidSendCommand(ENTRY_MODE_SET);
    459e:	86 e0       	ldi	r24, 0x06	; 6
    45a0:	0e 94 b8 1f 	call	0x3f70	; 0x3f70 <HLCD8_voidSendCommand>
}
    45a4:	e8 96       	adiw	r28, 0x38	; 56
    45a6:	0f b6       	in	r0, 0x3f	; 63
    45a8:	f8 94       	cli
    45aa:	de bf       	out	0x3e, r29	; 62
    45ac:	0f be       	out	0x3f, r0	; 63
    45ae:	cd bf       	out	0x3d, r28	; 61
    45b0:	cf 91       	pop	r28
    45b2:	df 91       	pop	r29
    45b4:	08 95       	ret

000045b6 <HLCD8_voidClearDisplay>:

void HLCD8_voidClearDisplay(void)
{
    45b6:	df 93       	push	r29
    45b8:	cf 93       	push	r28
    45ba:	cd b7       	in	r28, 0x3d	; 61
    45bc:	de b7       	in	r29, 0x3e	; 62
    45be:	2e 97       	sbiw	r28, 0x0e	; 14
    45c0:	0f b6       	in	r0, 0x3f	; 63
    45c2:	f8 94       	cli
    45c4:	de bf       	out	0x3e, r29	; 62
    45c6:	0f be       	out	0x3f, r0	; 63
    45c8:	cd bf       	out	0x3d, r28	; 61
    HLCD8_voidSendCommand(DISPLAY_CLEAR);
    45ca:	81 e0       	ldi	r24, 0x01	; 1
    45cc:	0e 94 b8 1f 	call	0x3f70	; 0x3f70 <HLCD8_voidSendCommand>
    45d0:	80 e0       	ldi	r24, 0x00	; 0
    45d2:	90 e0       	ldi	r25, 0x00	; 0
    45d4:	a0 e0       	ldi	r26, 0x00	; 0
    45d6:	b0 e4       	ldi	r27, 0x40	; 64
    45d8:	8b 87       	std	Y+11, r24	; 0x0b
    45da:	9c 87       	std	Y+12, r25	; 0x0c
    45dc:	ad 87       	std	Y+13, r26	; 0x0d
    45de:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    45e0:	6b 85       	ldd	r22, Y+11	; 0x0b
    45e2:	7c 85       	ldd	r23, Y+12	; 0x0c
    45e4:	8d 85       	ldd	r24, Y+13	; 0x0d
    45e6:	9e 85       	ldd	r25, Y+14	; 0x0e
    45e8:	20 e0       	ldi	r18, 0x00	; 0
    45ea:	30 e0       	ldi	r19, 0x00	; 0
    45ec:	4a ef       	ldi	r20, 0xFA	; 250
    45ee:	54 e4       	ldi	r21, 0x44	; 68
    45f0:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    45f4:	dc 01       	movw	r26, r24
    45f6:	cb 01       	movw	r24, r22
    45f8:	8f 83       	std	Y+7, r24	; 0x07
    45fa:	98 87       	std	Y+8, r25	; 0x08
    45fc:	a9 87       	std	Y+9, r26	; 0x09
    45fe:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4600:	6f 81       	ldd	r22, Y+7	; 0x07
    4602:	78 85       	ldd	r23, Y+8	; 0x08
    4604:	89 85       	ldd	r24, Y+9	; 0x09
    4606:	9a 85       	ldd	r25, Y+10	; 0x0a
    4608:	20 e0       	ldi	r18, 0x00	; 0
    460a:	30 e0       	ldi	r19, 0x00	; 0
    460c:	40 e8       	ldi	r20, 0x80	; 128
    460e:	5f e3       	ldi	r21, 0x3F	; 63
    4610:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    4614:	88 23       	and	r24, r24
    4616:	2c f4       	brge	.+10     	; 0x4622 <HLCD8_voidClearDisplay+0x6c>
		__ticks = 1;
    4618:	81 e0       	ldi	r24, 0x01	; 1
    461a:	90 e0       	ldi	r25, 0x00	; 0
    461c:	9e 83       	std	Y+6, r25	; 0x06
    461e:	8d 83       	std	Y+5, r24	; 0x05
    4620:	3f c0       	rjmp	.+126    	; 0x46a0 <HLCD8_voidClearDisplay+0xea>
	else if (__tmp > 65535)
    4622:	6f 81       	ldd	r22, Y+7	; 0x07
    4624:	78 85       	ldd	r23, Y+8	; 0x08
    4626:	89 85       	ldd	r24, Y+9	; 0x09
    4628:	9a 85       	ldd	r25, Y+10	; 0x0a
    462a:	20 e0       	ldi	r18, 0x00	; 0
    462c:	3f ef       	ldi	r19, 0xFF	; 255
    462e:	4f e7       	ldi	r20, 0x7F	; 127
    4630:	57 e4       	ldi	r21, 0x47	; 71
    4632:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    4636:	18 16       	cp	r1, r24
    4638:	4c f5       	brge	.+82     	; 0x468c <HLCD8_voidClearDisplay+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    463a:	6b 85       	ldd	r22, Y+11	; 0x0b
    463c:	7c 85       	ldd	r23, Y+12	; 0x0c
    463e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4640:	9e 85       	ldd	r25, Y+14	; 0x0e
    4642:	20 e0       	ldi	r18, 0x00	; 0
    4644:	30 e0       	ldi	r19, 0x00	; 0
    4646:	40 e2       	ldi	r20, 0x20	; 32
    4648:	51 e4       	ldi	r21, 0x41	; 65
    464a:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    464e:	dc 01       	movw	r26, r24
    4650:	cb 01       	movw	r24, r22
    4652:	bc 01       	movw	r22, r24
    4654:	cd 01       	movw	r24, r26
    4656:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    465a:	dc 01       	movw	r26, r24
    465c:	cb 01       	movw	r24, r22
    465e:	9e 83       	std	Y+6, r25	; 0x06
    4660:	8d 83       	std	Y+5, r24	; 0x05
    4662:	0f c0       	rjmp	.+30     	; 0x4682 <HLCD8_voidClearDisplay+0xcc>
    4664:	88 ec       	ldi	r24, 0xC8	; 200
    4666:	90 e0       	ldi	r25, 0x00	; 0
    4668:	9c 83       	std	Y+4, r25	; 0x04
    466a:	8b 83       	std	Y+3, r24	; 0x03
    466c:	8b 81       	ldd	r24, Y+3	; 0x03
    466e:	9c 81       	ldd	r25, Y+4	; 0x04
    4670:	01 97       	sbiw	r24, 0x01	; 1
    4672:	f1 f7       	brne	.-4      	; 0x4670 <HLCD8_voidClearDisplay+0xba>
    4674:	9c 83       	std	Y+4, r25	; 0x04
    4676:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4678:	8d 81       	ldd	r24, Y+5	; 0x05
    467a:	9e 81       	ldd	r25, Y+6	; 0x06
    467c:	01 97       	sbiw	r24, 0x01	; 1
    467e:	9e 83       	std	Y+6, r25	; 0x06
    4680:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4682:	8d 81       	ldd	r24, Y+5	; 0x05
    4684:	9e 81       	ldd	r25, Y+6	; 0x06
    4686:	00 97       	sbiw	r24, 0x00	; 0
    4688:	69 f7       	brne	.-38     	; 0x4664 <HLCD8_voidClearDisplay+0xae>
    468a:	14 c0       	rjmp	.+40     	; 0x46b4 <HLCD8_voidClearDisplay+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    468c:	6f 81       	ldd	r22, Y+7	; 0x07
    468e:	78 85       	ldd	r23, Y+8	; 0x08
    4690:	89 85       	ldd	r24, Y+9	; 0x09
    4692:	9a 85       	ldd	r25, Y+10	; 0x0a
    4694:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    4698:	dc 01       	movw	r26, r24
    469a:	cb 01       	movw	r24, r22
    469c:	9e 83       	std	Y+6, r25	; 0x06
    469e:	8d 83       	std	Y+5, r24	; 0x05
    46a0:	8d 81       	ldd	r24, Y+5	; 0x05
    46a2:	9e 81       	ldd	r25, Y+6	; 0x06
    46a4:	9a 83       	std	Y+2, r25	; 0x02
    46a6:	89 83       	std	Y+1, r24	; 0x01
    46a8:	89 81       	ldd	r24, Y+1	; 0x01
    46aa:	9a 81       	ldd	r25, Y+2	; 0x02
    46ac:	01 97       	sbiw	r24, 0x01	; 1
    46ae:	f1 f7       	brne	.-4      	; 0x46ac <HLCD8_voidClearDisplay+0xf6>
    46b0:	9a 83       	std	Y+2, r25	; 0x02
    46b2:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(2);
}
    46b4:	2e 96       	adiw	r28, 0x0e	; 14
    46b6:	0f b6       	in	r0, 0x3f	; 63
    46b8:	f8 94       	cli
    46ba:	de bf       	out	0x3e, r29	; 62
    46bc:	0f be       	out	0x3f, r0	; 63
    46be:	cd bf       	out	0x3d, r28	; 61
    46c0:	cf 91       	pop	r28
    46c2:	df 91       	pop	r29
    46c4:	08 95       	ret

000046c6 <HLCD8_voidSendString>:


void HLCD8_voidSendString(u8 * A_Pu8String)
{
    46c6:	df 93       	push	r29
    46c8:	cf 93       	push	r28
    46ca:	00 d0       	rcall	.+0      	; 0x46cc <HLCD8_voidSendString+0x6>
    46cc:	0f 92       	push	r0
    46ce:	cd b7       	in	r28, 0x3d	; 61
    46d0:	de b7       	in	r29, 0x3e	; 62
    46d2:	9b 83       	std	Y+3, r25	; 0x03
    46d4:	8a 83       	std	Y+2, r24	; 0x02
    u8 local_u8Couter=0;
    46d6:	19 82       	std	Y+1, r1	; 0x01
    46d8:	0e c0       	rjmp	.+28     	; 0x46f6 <HLCD8_voidSendString+0x30>
    while (A_Pu8String[local_u8Couter]!='\0')
    {
        HLCD8_voidSendData(A_Pu8String[local_u8Couter]);
    46da:	89 81       	ldd	r24, Y+1	; 0x01
    46dc:	28 2f       	mov	r18, r24
    46de:	30 e0       	ldi	r19, 0x00	; 0
    46e0:	8a 81       	ldd	r24, Y+2	; 0x02
    46e2:	9b 81       	ldd	r25, Y+3	; 0x03
    46e4:	fc 01       	movw	r30, r24
    46e6:	e2 0f       	add	r30, r18
    46e8:	f3 1f       	adc	r31, r19
    46ea:	80 81       	ld	r24, Z
    46ec:	0e 94 56 20 	call	0x40ac	; 0x40ac <HLCD8_voidSendData>
        local_u8Couter++;
    46f0:	89 81       	ldd	r24, Y+1	; 0x01
    46f2:	8f 5f       	subi	r24, 0xFF	; 255
    46f4:	89 83       	std	Y+1, r24	; 0x01


void HLCD8_voidSendString(u8 * A_Pu8String)
{
    u8 local_u8Couter=0;
    while (A_Pu8String[local_u8Couter]!='\0')
    46f6:	89 81       	ldd	r24, Y+1	; 0x01
    46f8:	28 2f       	mov	r18, r24
    46fa:	30 e0       	ldi	r19, 0x00	; 0
    46fc:	8a 81       	ldd	r24, Y+2	; 0x02
    46fe:	9b 81       	ldd	r25, Y+3	; 0x03
    4700:	fc 01       	movw	r30, r24
    4702:	e2 0f       	add	r30, r18
    4704:	f3 1f       	adc	r31, r19
    4706:	80 81       	ld	r24, Z
    4708:	88 23       	and	r24, r24
    470a:	39 f7       	brne	.-50     	; 0x46da <HLCD8_voidSendString+0x14>
    {
        HLCD8_voidSendData(A_Pu8String[local_u8Couter]);
        local_u8Couter++;
    }
    
}
    470c:	0f 90       	pop	r0
    470e:	0f 90       	pop	r0
    4710:	0f 90       	pop	r0
    4712:	cf 91       	pop	r28
    4714:	df 91       	pop	r29
    4716:	08 95       	ret

00004718 <HLCD8_voidGoToPos>:

void HLCD8_voidGoToPos(u8 A_u8RowNum,u8 A_u8ColNum)
{
    4718:	df 93       	push	r29
    471a:	cf 93       	push	r28
    471c:	cd b7       	in	r28, 0x3d	; 61
    471e:	de b7       	in	r29, 0x3e	; 62
    4720:	63 97       	sbiw	r28, 0x13	; 19
    4722:	0f b6       	in	r0, 0x3f	; 63
    4724:	f8 94       	cli
    4726:	de bf       	out	0x3e, r29	; 62
    4728:	0f be       	out	0x3f, r0	; 63
    472a:	cd bf       	out	0x3d, r28	; 61
    472c:	88 8b       	std	Y+16, r24	; 0x10
    472e:	69 8b       	std	Y+17, r22	; 0x11
    // }
    // _delay_ms(1);
    /************************************************************/ 
    //Second method
	u8 local_u8Address;
    switch(A_u8RowNum)
    4730:	88 89       	ldd	r24, Y+16	; 0x10
    4732:	28 2f       	mov	r18, r24
    4734:	30 e0       	ldi	r19, 0x00	; 0
    4736:	3b 8b       	std	Y+19, r19	; 0x13
    4738:	2a 8b       	std	Y+18, r18	; 0x12
    473a:	8a 89       	ldd	r24, Y+18	; 0x12
    473c:	9b 89       	ldd	r25, Y+19	; 0x13
    473e:	81 30       	cpi	r24, 0x01	; 1
    4740:	91 05       	cpc	r25, r1
    4742:	31 f0       	breq	.+12     	; 0x4750 <HLCD8_voidGoToPos+0x38>
    4744:	2a 89       	ldd	r18, Y+18	; 0x12
    4746:	3b 89       	ldd	r19, Y+19	; 0x13
    4748:	22 30       	cpi	r18, 0x02	; 2
    474a:	31 05       	cpc	r19, r1
    474c:	59 f0       	breq	.+22     	; 0x4764 <HLCD8_voidGoToPos+0x4c>
    474e:	13 c0       	rjmp	.+38     	; 0x4776 <HLCD8_voidGoToPos+0x5e>
    {
        case LCD_ROW_ONE:
        local_u8Address=FIRST_ROW_ADDRESS + A_u8ColNum -1;
    4750:	89 89       	ldd	r24, Y+17	; 0x11
    4752:	81 50       	subi	r24, 0x01	; 1
    4754:	8f 87       	std	Y+15, r24	; 0x0f
        SET_BIT(local_u8Address,PIN7);
    4756:	8f 85       	ldd	r24, Y+15	; 0x0f
    4758:	80 68       	ori	r24, 0x80	; 128
    475a:	8f 87       	std	Y+15, r24	; 0x0f
        HLCD8_voidSendCommand(local_u8Address);
    475c:	8f 85       	ldd	r24, Y+15	; 0x0f
    475e:	0e 94 b8 1f 	call	0x3f70	; 0x3f70 <HLCD8_voidSendCommand>
    4762:	09 c0       	rjmp	.+18     	; 0x4776 <HLCD8_voidGoToPos+0x5e>
        break;

        case LCD_ROW_TWO:
        local_u8Address=SECOND_ROW_ADDRESS + A_u8ColNum;
    4764:	89 89       	ldd	r24, Y+17	; 0x11
    4766:	81 5c       	subi	r24, 0xC1	; 193
    4768:	8f 87       	std	Y+15, r24	; 0x0f
        SET_BIT(local_u8Address,PIN7);
    476a:	8f 85       	ldd	r24, Y+15	; 0x0f
    476c:	80 68       	ori	r24, 0x80	; 128
    476e:	8f 87       	std	Y+15, r24	; 0x0f
        HLCD8_voidSendCommand(local_u8Address);
    4770:	8f 85       	ldd	r24, Y+15	; 0x0f
    4772:	0e 94 b8 1f 	call	0x3f70	; 0x3f70 <HLCD8_voidSendCommand>
    4776:	80 e0       	ldi	r24, 0x00	; 0
    4778:	90 e0       	ldi	r25, 0x00	; 0
    477a:	a0 e8       	ldi	r26, 0x80	; 128
    477c:	bf e3       	ldi	r27, 0x3F	; 63
    477e:	8b 87       	std	Y+11, r24	; 0x0b
    4780:	9c 87       	std	Y+12, r25	; 0x0c
    4782:	ad 87       	std	Y+13, r26	; 0x0d
    4784:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4786:	6b 85       	ldd	r22, Y+11	; 0x0b
    4788:	7c 85       	ldd	r23, Y+12	; 0x0c
    478a:	8d 85       	ldd	r24, Y+13	; 0x0d
    478c:	9e 85       	ldd	r25, Y+14	; 0x0e
    478e:	20 e0       	ldi	r18, 0x00	; 0
    4790:	30 e0       	ldi	r19, 0x00	; 0
    4792:	4a ef       	ldi	r20, 0xFA	; 250
    4794:	54 e4       	ldi	r21, 0x44	; 68
    4796:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    479a:	dc 01       	movw	r26, r24
    479c:	cb 01       	movw	r24, r22
    479e:	8f 83       	std	Y+7, r24	; 0x07
    47a0:	98 87       	std	Y+8, r25	; 0x08
    47a2:	a9 87       	std	Y+9, r26	; 0x09
    47a4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    47a6:	6f 81       	ldd	r22, Y+7	; 0x07
    47a8:	78 85       	ldd	r23, Y+8	; 0x08
    47aa:	89 85       	ldd	r24, Y+9	; 0x09
    47ac:	9a 85       	ldd	r25, Y+10	; 0x0a
    47ae:	20 e0       	ldi	r18, 0x00	; 0
    47b0:	30 e0       	ldi	r19, 0x00	; 0
    47b2:	40 e8       	ldi	r20, 0x80	; 128
    47b4:	5f e3       	ldi	r21, 0x3F	; 63
    47b6:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    47ba:	88 23       	and	r24, r24
    47bc:	2c f4       	brge	.+10     	; 0x47c8 <HLCD8_voidGoToPos+0xb0>
		__ticks = 1;
    47be:	81 e0       	ldi	r24, 0x01	; 1
    47c0:	90 e0       	ldi	r25, 0x00	; 0
    47c2:	9e 83       	std	Y+6, r25	; 0x06
    47c4:	8d 83       	std	Y+5, r24	; 0x05
    47c6:	3f c0       	rjmp	.+126    	; 0x4846 <HLCD8_voidGoToPos+0x12e>
	else if (__tmp > 65535)
    47c8:	6f 81       	ldd	r22, Y+7	; 0x07
    47ca:	78 85       	ldd	r23, Y+8	; 0x08
    47cc:	89 85       	ldd	r24, Y+9	; 0x09
    47ce:	9a 85       	ldd	r25, Y+10	; 0x0a
    47d0:	20 e0       	ldi	r18, 0x00	; 0
    47d2:	3f ef       	ldi	r19, 0xFF	; 255
    47d4:	4f e7       	ldi	r20, 0x7F	; 127
    47d6:	57 e4       	ldi	r21, 0x47	; 71
    47d8:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    47dc:	18 16       	cp	r1, r24
    47de:	4c f5       	brge	.+82     	; 0x4832 <HLCD8_voidGoToPos+0x11a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    47e0:	6b 85       	ldd	r22, Y+11	; 0x0b
    47e2:	7c 85       	ldd	r23, Y+12	; 0x0c
    47e4:	8d 85       	ldd	r24, Y+13	; 0x0d
    47e6:	9e 85       	ldd	r25, Y+14	; 0x0e
    47e8:	20 e0       	ldi	r18, 0x00	; 0
    47ea:	30 e0       	ldi	r19, 0x00	; 0
    47ec:	40 e2       	ldi	r20, 0x20	; 32
    47ee:	51 e4       	ldi	r21, 0x41	; 65
    47f0:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    47f4:	dc 01       	movw	r26, r24
    47f6:	cb 01       	movw	r24, r22
    47f8:	bc 01       	movw	r22, r24
    47fa:	cd 01       	movw	r24, r26
    47fc:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    4800:	dc 01       	movw	r26, r24
    4802:	cb 01       	movw	r24, r22
    4804:	9e 83       	std	Y+6, r25	; 0x06
    4806:	8d 83       	std	Y+5, r24	; 0x05
    4808:	0f c0       	rjmp	.+30     	; 0x4828 <HLCD8_voidGoToPos+0x110>
    480a:	88 ec       	ldi	r24, 0xC8	; 200
    480c:	90 e0       	ldi	r25, 0x00	; 0
    480e:	9c 83       	std	Y+4, r25	; 0x04
    4810:	8b 83       	std	Y+3, r24	; 0x03
    4812:	8b 81       	ldd	r24, Y+3	; 0x03
    4814:	9c 81       	ldd	r25, Y+4	; 0x04
    4816:	01 97       	sbiw	r24, 0x01	; 1
    4818:	f1 f7       	brne	.-4      	; 0x4816 <HLCD8_voidGoToPos+0xfe>
    481a:	9c 83       	std	Y+4, r25	; 0x04
    481c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    481e:	8d 81       	ldd	r24, Y+5	; 0x05
    4820:	9e 81       	ldd	r25, Y+6	; 0x06
    4822:	01 97       	sbiw	r24, 0x01	; 1
    4824:	9e 83       	std	Y+6, r25	; 0x06
    4826:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4828:	8d 81       	ldd	r24, Y+5	; 0x05
    482a:	9e 81       	ldd	r25, Y+6	; 0x06
    482c:	00 97       	sbiw	r24, 0x00	; 0
    482e:	69 f7       	brne	.-38     	; 0x480a <HLCD8_voidGoToPos+0xf2>
    4830:	14 c0       	rjmp	.+40     	; 0x485a <HLCD8_voidGoToPos+0x142>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4832:	6f 81       	ldd	r22, Y+7	; 0x07
    4834:	78 85       	ldd	r23, Y+8	; 0x08
    4836:	89 85       	ldd	r24, Y+9	; 0x09
    4838:	9a 85       	ldd	r25, Y+10	; 0x0a
    483a:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    483e:	dc 01       	movw	r26, r24
    4840:	cb 01       	movw	r24, r22
    4842:	9e 83       	std	Y+6, r25	; 0x06
    4844:	8d 83       	std	Y+5, r24	; 0x05
    4846:	8d 81       	ldd	r24, Y+5	; 0x05
    4848:	9e 81       	ldd	r25, Y+6	; 0x06
    484a:	9a 83       	std	Y+2, r25	; 0x02
    484c:	89 83       	std	Y+1, r24	; 0x01
    484e:	89 81       	ldd	r24, Y+1	; 0x01
    4850:	9a 81       	ldd	r25, Y+2	; 0x02
    4852:	01 97       	sbiw	r24, 0x01	; 1
    4854:	f1 f7       	brne	.-4      	; 0x4852 <HLCD8_voidGoToPos+0x13a>
    4856:	9a 83       	std	Y+2, r25	; 0x02
    4858:	89 83       	std	Y+1, r24	; 0x01
        break;

    }
    _delay_ms(1);

}
    485a:	63 96       	adiw	r28, 0x13	; 19
    485c:	0f b6       	in	r0, 0x3f	; 63
    485e:	f8 94       	cli
    4860:	de bf       	out	0x3e, r29	; 62
    4862:	0f be       	out	0x3f, r0	; 63
    4864:	cd bf       	out	0x3d, r28	; 61
    4866:	cf 91       	pop	r28
    4868:	df 91       	pop	r29
    486a:	08 95       	ret

0000486c <HLCD8_voidDisplayNumber>:

void HLCD8_voidDisplayNumber(u32 A_u32Number)
{
    486c:	df 93       	push	r29
    486e:	cf 93       	push	r28
    4870:	00 d0       	rcall	.+0      	; 0x4872 <HLCD8_voidDisplayNumber+0x6>
    4872:	00 d0       	rcall	.+0      	; 0x4874 <HLCD8_voidDisplayNumber+0x8>
    4874:	cd b7       	in	r28, 0x3d	; 61
    4876:	de b7       	in	r29, 0x3e	; 62
    4878:	9c 83       	std	Y+4, r25	; 0x04
    487a:	8b 83       	std	Y+3, r24	; 0x03
    // u8 local_u8NumToStr[100];
    // itoa(A_u32Number,local_u8NumToStr,10);
    // HLCD8_voidSendString(local_u8NumToStr);
    //****************************************************//
    //third method: it will deal with zero unlike the first method so it's not problem here
    u32 local_u32Number=1;
    487c:	81 e0       	ldi	r24, 0x01	; 1
    487e:	90 e0       	ldi	r25, 0x00	; 0
    4880:	9a 83       	std	Y+2, r25	; 0x02
    4882:	89 83       	std	Y+1, r24	; 0x01
    if(A_u32Number==0)
    4884:	8b 81       	ldd	r24, Y+3	; 0x03
    4886:	9c 81       	ldd	r25, Y+4	; 0x04
    4888:	00 97       	sbiw	r24, 0x00	; 0
    488a:	31 f5       	brne	.+76     	; 0x48d8 <HLCD8_voidDisplayNumber+0x6c>
    {
        HLCD8_voidSendData('0');
    488c:	80 e3       	ldi	r24, 0x30	; 48
    488e:	0e 94 56 20 	call	0x40ac	; 0x40ac <HLCD8_voidSendData>
    4892:	22 c0       	rjmp	.+68     	; 0x48d8 <HLCD8_voidDisplayNumber+0x6c>
    }   
    while(A_u32Number !=0)
    {
        local_u32Number=((local_u32Number * 10)+(A_u32Number%10));
    4894:	89 81       	ldd	r24, Y+1	; 0x01
    4896:	9a 81       	ldd	r25, Y+2	; 0x02
    4898:	9c 01       	movw	r18, r24
    489a:	22 0f       	add	r18, r18
    489c:	33 1f       	adc	r19, r19
    489e:	c9 01       	movw	r24, r18
    48a0:	88 0f       	add	r24, r24
    48a2:	99 1f       	adc	r25, r25
    48a4:	88 0f       	add	r24, r24
    48a6:	99 1f       	adc	r25, r25
    48a8:	f9 01       	movw	r30, r18
    48aa:	e8 0f       	add	r30, r24
    48ac:	f9 1f       	adc	r31, r25
    48ae:	8b 81       	ldd	r24, Y+3	; 0x03
    48b0:	9c 81       	ldd	r25, Y+4	; 0x04
    48b2:	2a e0       	ldi	r18, 0x0A	; 10
    48b4:	30 e0       	ldi	r19, 0x00	; 0
    48b6:	b9 01       	movw	r22, r18
    48b8:	0e 94 b4 42 	call	0x8568	; 0x8568 <__udivmodhi4>
    48bc:	8e 0f       	add	r24, r30
    48be:	9f 1f       	adc	r25, r31
    48c0:	9a 83       	std	Y+2, r25	; 0x02
    48c2:	89 83       	std	Y+1, r24	; 0x01
        A_u32Number=A_u32Number/10;
    48c4:	8b 81       	ldd	r24, Y+3	; 0x03
    48c6:	9c 81       	ldd	r25, Y+4	; 0x04
    48c8:	2a e0       	ldi	r18, 0x0A	; 10
    48ca:	30 e0       	ldi	r19, 0x00	; 0
    48cc:	b9 01       	movw	r22, r18
    48ce:	0e 94 b4 42 	call	0x8568	; 0x8568 <__udivmodhi4>
    48d2:	cb 01       	movw	r24, r22
    48d4:	9c 83       	std	Y+4, r25	; 0x04
    48d6:	8b 83       	std	Y+3, r24	; 0x03
    u32 local_u32Number=1;
    if(A_u32Number==0)
    {
        HLCD8_voidSendData('0');
    }   
    while(A_u32Number !=0)
    48d8:	8b 81       	ldd	r24, Y+3	; 0x03
    48da:	9c 81       	ldd	r25, Y+4	; 0x04
    48dc:	00 97       	sbiw	r24, 0x00	; 0
    48de:	d1 f6       	brne	.-76     	; 0x4894 <HLCD8_voidDisplayNumber+0x28>
    48e0:	14 c0       	rjmp	.+40     	; 0x490a <HLCD8_voidDisplayNumber+0x9e>
        A_u32Number=A_u32Number/10;

    }
    while (local_u32Number!=1)
    {
        HLCD8_voidSendData((local_u32Number%10)+48);
    48e2:	89 81       	ldd	r24, Y+1	; 0x01
    48e4:	9a 81       	ldd	r25, Y+2	; 0x02
    48e6:	2a e0       	ldi	r18, 0x0A	; 10
    48e8:	30 e0       	ldi	r19, 0x00	; 0
    48ea:	b9 01       	movw	r22, r18
    48ec:	0e 94 b4 42 	call	0x8568	; 0x8568 <__udivmodhi4>
    48f0:	80 5d       	subi	r24, 0xD0	; 208
    48f2:	0e 94 56 20 	call	0x40ac	; 0x40ac <HLCD8_voidSendData>
        local_u32Number=local_u32Number/10;
    48f6:	89 81       	ldd	r24, Y+1	; 0x01
    48f8:	9a 81       	ldd	r25, Y+2	; 0x02
    48fa:	2a e0       	ldi	r18, 0x0A	; 10
    48fc:	30 e0       	ldi	r19, 0x00	; 0
    48fe:	b9 01       	movw	r22, r18
    4900:	0e 94 b4 42 	call	0x8568	; 0x8568 <__udivmodhi4>
    4904:	cb 01       	movw	r24, r22
    4906:	9a 83       	std	Y+2, r25	; 0x02
    4908:	89 83       	std	Y+1, r24	; 0x01
    {
        local_u32Number=((local_u32Number * 10)+(A_u32Number%10));
        A_u32Number=A_u32Number/10;

    }
    while (local_u32Number!=1)
    490a:	89 81       	ldd	r24, Y+1	; 0x01
    490c:	9a 81       	ldd	r25, Y+2	; 0x02
    490e:	81 30       	cpi	r24, 0x01	; 1
    4910:	91 05       	cpc	r25, r1
    4912:	39 f7       	brne	.-50     	; 0x48e2 <HLCD8_voidDisplayNumber+0x76>
    {
        HLCD8_voidSendData((local_u32Number%10)+48);
        local_u32Number=local_u32Number/10;
    }
}
    4914:	0f 90       	pop	r0
    4916:	0f 90       	pop	r0
    4918:	0f 90       	pop	r0
    491a:	0f 90       	pop	r0
    491c:	cf 91       	pop	r28
    491e:	df 91       	pop	r29
    4920:	08 95       	ret

00004922 <HLCD8_voidStoreCustomChar>:

void HLCD8_voidStoreCustomChar(u8 * A_u8Pattern,u8 A_u8CGRAMIndex)
{
    4922:	df 93       	push	r29
    4924:	cf 93       	push	r28
    4926:	cd b7       	in	r28, 0x3d	; 61
    4928:	de b7       	in	r29, 0x3e	; 62
    492a:	ab 97       	sbiw	r28, 0x2b	; 43
    492c:	0f b6       	in	r0, 0x3f	; 63
    492e:	f8 94       	cli
    4930:	de bf       	out	0x3e, r29	; 62
    4932:	0f be       	out	0x3f, r0	; 63
    4934:	cd bf       	out	0x3d, r28	; 61
    4936:	9a a7       	std	Y+42, r25	; 0x2a
    4938:	89 a7       	std	Y+41, r24	; 0x29
    493a:	6b a7       	std	Y+43, r22	; 0x2b
    u8 local_u8Address;
    if(A_u8CGRAMIndex<8)
    493c:	8b a5       	ldd	r24, Y+43	; 0x2b
    493e:	88 30       	cpi	r24, 0x08	; 8
    4940:	08 f0       	brcs	.+2      	; 0x4944 <HLCD8_voidStoreCustomChar+0x22>
    4942:	e5 c0       	rjmp	.+458    	; 0x4b0e <HLCD8_voidStoreCustomChar+0x1ec>
    {
        A_u8CGRAMIndex=A_u8CGRAMIndex*8;
    4944:	8b a5       	ldd	r24, Y+43	; 0x2b
    4946:	88 2f       	mov	r24, r24
    4948:	90 e0       	ldi	r25, 0x00	; 0
    494a:	88 0f       	add	r24, r24
    494c:	99 1f       	adc	r25, r25
    494e:	88 0f       	add	r24, r24
    4950:	99 1f       	adc	r25, r25
    4952:	88 0f       	add	r24, r24
    4954:	99 1f       	adc	r25, r25
    4956:	8b a7       	std	Y+43, r24	; 0x2b
        SET_BIT(A_u8CGRAMIndex,PIN6);
    4958:	8b a5       	ldd	r24, Y+43	; 0x2b
    495a:	80 64       	ori	r24, 0x40	; 64
    495c:	8b a7       	std	Y+43, r24	; 0x2b
        CLR_BIT(A_u8CGRAMIndex,PIN7);
    495e:	8b a5       	ldd	r24, Y+43	; 0x2b
    4960:	8f 77       	andi	r24, 0x7F	; 127
    4962:	8b a7       	std	Y+43, r24	; 0x2b
        HLCD8_voidSendCommand(A_u8CGRAMIndex);
    4964:	8b a5       	ldd	r24, Y+43	; 0x2b
    4966:	0e 94 b8 1f 	call	0x3f70	; 0x3f70 <HLCD8_voidSendCommand>
        for(u8 i=0;i<8;i++)
    496a:	1f a2       	std	Y+39, r1	; 0x27
    496c:	cc c0       	rjmp	.+408    	; 0x4b06 <HLCD8_voidStoreCustomChar+0x1e4>
        {
            HLCD8_voidSendData(A_u8Pattern[i]);
    496e:	8f a1       	ldd	r24, Y+39	; 0x27
    4970:	28 2f       	mov	r18, r24
    4972:	30 e0       	ldi	r19, 0x00	; 0
    4974:	89 a5       	ldd	r24, Y+41	; 0x29
    4976:	9a a5       	ldd	r25, Y+42	; 0x2a
    4978:	fc 01       	movw	r30, r24
    497a:	e2 0f       	add	r30, r18
    497c:	f3 1f       	adc	r31, r19
    497e:	80 81       	ld	r24, Z
    4980:	0e 94 56 20 	call	0x40ac	; 0x40ac <HLCD8_voidSendData>
    4984:	80 e0       	ldi	r24, 0x00	; 0
    4986:	90 e0       	ldi	r25, 0x00	; 0
    4988:	a0 e7       	ldi	r26, 0x70	; 112
    498a:	b2 e4       	ldi	r27, 0x42	; 66
    498c:	8b a3       	std	Y+35, r24	; 0x23
    498e:	9c a3       	std	Y+36, r25	; 0x24
    4990:	ad a3       	std	Y+37, r26	; 0x25
    4992:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    4994:	6b a1       	ldd	r22, Y+35	; 0x23
    4996:	7c a1       	ldd	r23, Y+36	; 0x24
    4998:	8d a1       	ldd	r24, Y+37	; 0x25
    499a:	9e a1       	ldd	r25, Y+38	; 0x26
    499c:	2b ea       	ldi	r18, 0xAB	; 171
    499e:	3a ea       	ldi	r19, 0xAA	; 170
    49a0:	4a e2       	ldi	r20, 0x2A	; 42
    49a2:	50 e4       	ldi	r21, 0x40	; 64
    49a4:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    49a8:	dc 01       	movw	r26, r24
    49aa:	cb 01       	movw	r24, r22
    49ac:	8f 8f       	std	Y+31, r24	; 0x1f
    49ae:	98 a3       	std	Y+32, r25	; 0x20
    49b0:	a9 a3       	std	Y+33, r26	; 0x21
    49b2:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    49b4:	6f 8d       	ldd	r22, Y+31	; 0x1f
    49b6:	78 a1       	ldd	r23, Y+32	; 0x20
    49b8:	89 a1       	ldd	r24, Y+33	; 0x21
    49ba:	9a a1       	ldd	r25, Y+34	; 0x22
    49bc:	20 e0       	ldi	r18, 0x00	; 0
    49be:	30 e0       	ldi	r19, 0x00	; 0
    49c0:	40 e8       	ldi	r20, 0x80	; 128
    49c2:	5f e3       	ldi	r21, 0x3F	; 63
    49c4:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    49c8:	88 23       	and	r24, r24
    49ca:	1c f4       	brge	.+6      	; 0x49d2 <HLCD8_voidStoreCustomChar+0xb0>
		__ticks = 1;
    49cc:	81 e0       	ldi	r24, 0x01	; 1
    49ce:	8e 8f       	std	Y+30, r24	; 0x1e
    49d0:	91 c0       	rjmp	.+290    	; 0x4af4 <HLCD8_voidStoreCustomChar+0x1d2>
	else if (__tmp > 255)
    49d2:	6f 8d       	ldd	r22, Y+31	; 0x1f
    49d4:	78 a1       	ldd	r23, Y+32	; 0x20
    49d6:	89 a1       	ldd	r24, Y+33	; 0x21
    49d8:	9a a1       	ldd	r25, Y+34	; 0x22
    49da:	20 e0       	ldi	r18, 0x00	; 0
    49dc:	30 e0       	ldi	r19, 0x00	; 0
    49de:	4f e7       	ldi	r20, 0x7F	; 127
    49e0:	53 e4       	ldi	r21, 0x43	; 67
    49e2:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    49e6:	18 16       	cp	r1, r24
    49e8:	0c f0       	brlt	.+2      	; 0x49ec <HLCD8_voidStoreCustomChar+0xca>
    49ea:	7b c0       	rjmp	.+246    	; 0x4ae2 <HLCD8_voidStoreCustomChar+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    49ec:	6b a1       	ldd	r22, Y+35	; 0x23
    49ee:	7c a1       	ldd	r23, Y+36	; 0x24
    49f0:	8d a1       	ldd	r24, Y+37	; 0x25
    49f2:	9e a1       	ldd	r25, Y+38	; 0x26
    49f4:	20 e0       	ldi	r18, 0x00	; 0
    49f6:	30 e0       	ldi	r19, 0x00	; 0
    49f8:	4a e7       	ldi	r20, 0x7A	; 122
    49fa:	54 e4       	ldi	r21, 0x44	; 68
    49fc:	0e 94 0d 0a 	call	0x141a	; 0x141a <__divsf3>
    4a00:	dc 01       	movw	r26, r24
    4a02:	cb 01       	movw	r24, r22
    4a04:	8a 8f       	std	Y+26, r24	; 0x1a
    4a06:	9b 8f       	std	Y+27, r25	; 0x1b
    4a08:	ac 8f       	std	Y+28, r26	; 0x1c
    4a0a:	bd 8f       	std	Y+29, r27	; 0x1d
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4a0c:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4a0e:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4a10:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4a12:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4a14:	20 e0       	ldi	r18, 0x00	; 0
    4a16:	30 e0       	ldi	r19, 0x00	; 0
    4a18:	4a ef       	ldi	r20, 0xFA	; 250
    4a1a:	54 e4       	ldi	r21, 0x44	; 68
    4a1c:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    4a20:	dc 01       	movw	r26, r24
    4a22:	cb 01       	movw	r24, r22
    4a24:	8e 8b       	std	Y+22, r24	; 0x16
    4a26:	9f 8b       	std	Y+23, r25	; 0x17
    4a28:	a8 8f       	std	Y+24, r26	; 0x18
    4a2a:	b9 8f       	std	Y+25, r27	; 0x19
	if (__tmp < 1.0)
    4a2c:	6e 89       	ldd	r22, Y+22	; 0x16
    4a2e:	7f 89       	ldd	r23, Y+23	; 0x17
    4a30:	88 8d       	ldd	r24, Y+24	; 0x18
    4a32:	99 8d       	ldd	r25, Y+25	; 0x19
    4a34:	20 e0       	ldi	r18, 0x00	; 0
    4a36:	30 e0       	ldi	r19, 0x00	; 0
    4a38:	40 e8       	ldi	r20, 0x80	; 128
    4a3a:	5f e3       	ldi	r21, 0x3F	; 63
    4a3c:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    4a40:	88 23       	and	r24, r24
    4a42:	2c f4       	brge	.+10     	; 0x4a4e <HLCD8_voidStoreCustomChar+0x12c>
		__ticks = 1;
    4a44:	81 e0       	ldi	r24, 0x01	; 1
    4a46:	90 e0       	ldi	r25, 0x00	; 0
    4a48:	9d 8b       	std	Y+21, r25	; 0x15
    4a4a:	8c 8b       	std	Y+20, r24	; 0x14
    4a4c:	3f c0       	rjmp	.+126    	; 0x4acc <HLCD8_voidStoreCustomChar+0x1aa>
	else if (__tmp > 65535)
    4a4e:	6e 89       	ldd	r22, Y+22	; 0x16
    4a50:	7f 89       	ldd	r23, Y+23	; 0x17
    4a52:	88 8d       	ldd	r24, Y+24	; 0x18
    4a54:	99 8d       	ldd	r25, Y+25	; 0x19
    4a56:	20 e0       	ldi	r18, 0x00	; 0
    4a58:	3f ef       	ldi	r19, 0xFF	; 255
    4a5a:	4f e7       	ldi	r20, 0x7F	; 127
    4a5c:	57 e4       	ldi	r21, 0x47	; 71
    4a5e:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    4a62:	18 16       	cp	r1, r24
    4a64:	4c f5       	brge	.+82     	; 0x4ab8 <HLCD8_voidStoreCustomChar+0x196>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4a66:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4a68:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4a6a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4a6c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4a6e:	20 e0       	ldi	r18, 0x00	; 0
    4a70:	30 e0       	ldi	r19, 0x00	; 0
    4a72:	40 e2       	ldi	r20, 0x20	; 32
    4a74:	51 e4       	ldi	r21, 0x41	; 65
    4a76:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    4a7a:	dc 01       	movw	r26, r24
    4a7c:	cb 01       	movw	r24, r22
    4a7e:	bc 01       	movw	r22, r24
    4a80:	cd 01       	movw	r24, r26
    4a82:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    4a86:	dc 01       	movw	r26, r24
    4a88:	cb 01       	movw	r24, r22
    4a8a:	9d 8b       	std	Y+21, r25	; 0x15
    4a8c:	8c 8b       	std	Y+20, r24	; 0x14
    4a8e:	0f c0       	rjmp	.+30     	; 0x4aae <HLCD8_voidStoreCustomChar+0x18c>
    4a90:	88 ec       	ldi	r24, 0xC8	; 200
    4a92:	90 e0       	ldi	r25, 0x00	; 0
    4a94:	9b 8b       	std	Y+19, r25	; 0x13
    4a96:	8a 8b       	std	Y+18, r24	; 0x12
    4a98:	8a 89       	ldd	r24, Y+18	; 0x12
    4a9a:	9b 89       	ldd	r25, Y+19	; 0x13
    4a9c:	01 97       	sbiw	r24, 0x01	; 1
    4a9e:	f1 f7       	brne	.-4      	; 0x4a9c <HLCD8_voidStoreCustomChar+0x17a>
    4aa0:	9b 8b       	std	Y+19, r25	; 0x13
    4aa2:	8a 8b       	std	Y+18, r24	; 0x12
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4aa4:	8c 89       	ldd	r24, Y+20	; 0x14
    4aa6:	9d 89       	ldd	r25, Y+21	; 0x15
    4aa8:	01 97       	sbiw	r24, 0x01	; 1
    4aaa:	9d 8b       	std	Y+21, r25	; 0x15
    4aac:	8c 8b       	std	Y+20, r24	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4aae:	8c 89       	ldd	r24, Y+20	; 0x14
    4ab0:	9d 89       	ldd	r25, Y+21	; 0x15
    4ab2:	00 97       	sbiw	r24, 0x00	; 0
    4ab4:	69 f7       	brne	.-38     	; 0x4a90 <HLCD8_voidStoreCustomChar+0x16e>
    4ab6:	24 c0       	rjmp	.+72     	; 0x4b00 <HLCD8_voidStoreCustomChar+0x1de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4ab8:	6e 89       	ldd	r22, Y+22	; 0x16
    4aba:	7f 89       	ldd	r23, Y+23	; 0x17
    4abc:	88 8d       	ldd	r24, Y+24	; 0x18
    4abe:	99 8d       	ldd	r25, Y+25	; 0x19
    4ac0:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    4ac4:	dc 01       	movw	r26, r24
    4ac6:	cb 01       	movw	r24, r22
    4ac8:	9d 8b       	std	Y+21, r25	; 0x15
    4aca:	8c 8b       	std	Y+20, r24	; 0x14
    4acc:	8c 89       	ldd	r24, Y+20	; 0x14
    4ace:	9d 89       	ldd	r25, Y+21	; 0x15
    4ad0:	99 8b       	std	Y+17, r25	; 0x11
    4ad2:	88 8b       	std	Y+16, r24	; 0x10
    4ad4:	88 89       	ldd	r24, Y+16	; 0x10
    4ad6:	99 89       	ldd	r25, Y+17	; 0x11
    4ad8:	01 97       	sbiw	r24, 0x01	; 1
    4ada:	f1 f7       	brne	.-4      	; 0x4ad8 <HLCD8_voidStoreCustomChar+0x1b6>
    4adc:	99 8b       	std	Y+17, r25	; 0x11
    4ade:	88 8b       	std	Y+16, r24	; 0x10
    4ae0:	0f c0       	rjmp	.+30     	; 0x4b00 <HLCD8_voidStoreCustomChar+0x1de>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4ae2:	6f 8d       	ldd	r22, Y+31	; 0x1f
    4ae4:	78 a1       	ldd	r23, Y+32	; 0x20
    4ae6:	89 a1       	ldd	r24, Y+33	; 0x21
    4ae8:	9a a1       	ldd	r25, Y+34	; 0x22
    4aea:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    4aee:	dc 01       	movw	r26, r24
    4af0:	cb 01       	movw	r24, r22
    4af2:	8e 8f       	std	Y+30, r24	; 0x1e
    4af4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4af6:	8f 87       	std	Y+15, r24	; 0x0f
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4af8:	8f 85       	ldd	r24, Y+15	; 0x0f
    4afa:	8a 95       	dec	r24
    4afc:	f1 f7       	brne	.-4      	; 0x4afa <HLCD8_voidStoreCustomChar+0x1d8>
    4afe:	8f 87       	std	Y+15, r24	; 0x0f
    {
        A_u8CGRAMIndex=A_u8CGRAMIndex*8;
        SET_BIT(A_u8CGRAMIndex,PIN6);
        CLR_BIT(A_u8CGRAMIndex,PIN7);
        HLCD8_voidSendCommand(A_u8CGRAMIndex);
        for(u8 i=0;i<8;i++)
    4b00:	8f a1       	ldd	r24, Y+39	; 0x27
    4b02:	8f 5f       	subi	r24, 0xFF	; 255
    4b04:	8f a3       	std	Y+39, r24	; 0x27
    4b06:	8f a1       	ldd	r24, Y+39	; 0x27
    4b08:	88 30       	cpi	r24, 0x08	; 8
    4b0a:	08 f4       	brcc	.+2      	; 0x4b0e <HLCD8_voidStoreCustomChar+0x1ec>
    4b0c:	30 cf       	rjmp	.-416    	; 0x496e <HLCD8_voidStoreCustomChar+0x4c>
        {
            HLCD8_voidSendData(A_u8Pattern[i]);
            _delay_us(60);
        }
    }
    HLCD8_voidSendCommand(RETURN_HOME);
    4b0e:	82 e0       	ldi	r24, 0x02	; 2
    4b10:	0e 94 b8 1f 	call	0x3f70	; 0x3f70 <HLCD8_voidSendCommand>
    4b14:	80 e0       	ldi	r24, 0x00	; 0
    4b16:	90 e0       	ldi	r25, 0x00	; 0
    4b18:	a0 e0       	ldi	r26, 0x00	; 0
    4b1a:	b0 e4       	ldi	r27, 0x40	; 64
    4b1c:	8b 87       	std	Y+11, r24	; 0x0b
    4b1e:	9c 87       	std	Y+12, r25	; 0x0c
    4b20:	ad 87       	std	Y+13, r26	; 0x0d
    4b22:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4b24:	6b 85       	ldd	r22, Y+11	; 0x0b
    4b26:	7c 85       	ldd	r23, Y+12	; 0x0c
    4b28:	8d 85       	ldd	r24, Y+13	; 0x0d
    4b2a:	9e 85       	ldd	r25, Y+14	; 0x0e
    4b2c:	20 e0       	ldi	r18, 0x00	; 0
    4b2e:	30 e0       	ldi	r19, 0x00	; 0
    4b30:	4a ef       	ldi	r20, 0xFA	; 250
    4b32:	54 e4       	ldi	r21, 0x44	; 68
    4b34:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    4b38:	dc 01       	movw	r26, r24
    4b3a:	cb 01       	movw	r24, r22
    4b3c:	8f 83       	std	Y+7, r24	; 0x07
    4b3e:	98 87       	std	Y+8, r25	; 0x08
    4b40:	a9 87       	std	Y+9, r26	; 0x09
    4b42:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4b44:	6f 81       	ldd	r22, Y+7	; 0x07
    4b46:	78 85       	ldd	r23, Y+8	; 0x08
    4b48:	89 85       	ldd	r24, Y+9	; 0x09
    4b4a:	9a 85       	ldd	r25, Y+10	; 0x0a
    4b4c:	20 e0       	ldi	r18, 0x00	; 0
    4b4e:	30 e0       	ldi	r19, 0x00	; 0
    4b50:	40 e8       	ldi	r20, 0x80	; 128
    4b52:	5f e3       	ldi	r21, 0x3F	; 63
    4b54:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    4b58:	88 23       	and	r24, r24
    4b5a:	2c f4       	brge	.+10     	; 0x4b66 <HLCD8_voidStoreCustomChar+0x244>
		__ticks = 1;
    4b5c:	81 e0       	ldi	r24, 0x01	; 1
    4b5e:	90 e0       	ldi	r25, 0x00	; 0
    4b60:	9e 83       	std	Y+6, r25	; 0x06
    4b62:	8d 83       	std	Y+5, r24	; 0x05
    4b64:	3f c0       	rjmp	.+126    	; 0x4be4 <HLCD8_voidStoreCustomChar+0x2c2>
	else if (__tmp > 65535)
    4b66:	6f 81       	ldd	r22, Y+7	; 0x07
    4b68:	78 85       	ldd	r23, Y+8	; 0x08
    4b6a:	89 85       	ldd	r24, Y+9	; 0x09
    4b6c:	9a 85       	ldd	r25, Y+10	; 0x0a
    4b6e:	20 e0       	ldi	r18, 0x00	; 0
    4b70:	3f ef       	ldi	r19, 0xFF	; 255
    4b72:	4f e7       	ldi	r20, 0x7F	; 127
    4b74:	57 e4       	ldi	r21, 0x47	; 71
    4b76:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    4b7a:	18 16       	cp	r1, r24
    4b7c:	4c f5       	brge	.+82     	; 0x4bd0 <HLCD8_voidStoreCustomChar+0x2ae>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4b7e:	6b 85       	ldd	r22, Y+11	; 0x0b
    4b80:	7c 85       	ldd	r23, Y+12	; 0x0c
    4b82:	8d 85       	ldd	r24, Y+13	; 0x0d
    4b84:	9e 85       	ldd	r25, Y+14	; 0x0e
    4b86:	20 e0       	ldi	r18, 0x00	; 0
    4b88:	30 e0       	ldi	r19, 0x00	; 0
    4b8a:	40 e2       	ldi	r20, 0x20	; 32
    4b8c:	51 e4       	ldi	r21, 0x41	; 65
    4b8e:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    4b92:	dc 01       	movw	r26, r24
    4b94:	cb 01       	movw	r24, r22
    4b96:	bc 01       	movw	r22, r24
    4b98:	cd 01       	movw	r24, r26
    4b9a:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    4b9e:	dc 01       	movw	r26, r24
    4ba0:	cb 01       	movw	r24, r22
    4ba2:	9e 83       	std	Y+6, r25	; 0x06
    4ba4:	8d 83       	std	Y+5, r24	; 0x05
    4ba6:	0f c0       	rjmp	.+30     	; 0x4bc6 <HLCD8_voidStoreCustomChar+0x2a4>
    4ba8:	88 ec       	ldi	r24, 0xC8	; 200
    4baa:	90 e0       	ldi	r25, 0x00	; 0
    4bac:	9c 83       	std	Y+4, r25	; 0x04
    4bae:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4bb0:	8b 81       	ldd	r24, Y+3	; 0x03
    4bb2:	9c 81       	ldd	r25, Y+4	; 0x04
    4bb4:	01 97       	sbiw	r24, 0x01	; 1
    4bb6:	f1 f7       	brne	.-4      	; 0x4bb4 <HLCD8_voidStoreCustomChar+0x292>
    4bb8:	9c 83       	std	Y+4, r25	; 0x04
    4bba:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4bbc:	8d 81       	ldd	r24, Y+5	; 0x05
    4bbe:	9e 81       	ldd	r25, Y+6	; 0x06
    4bc0:	01 97       	sbiw	r24, 0x01	; 1
    4bc2:	9e 83       	std	Y+6, r25	; 0x06
    4bc4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4bc6:	8d 81       	ldd	r24, Y+5	; 0x05
    4bc8:	9e 81       	ldd	r25, Y+6	; 0x06
    4bca:	00 97       	sbiw	r24, 0x00	; 0
    4bcc:	69 f7       	brne	.-38     	; 0x4ba8 <HLCD8_voidStoreCustomChar+0x286>
    4bce:	14 c0       	rjmp	.+40     	; 0x4bf8 <HLCD8_voidStoreCustomChar+0x2d6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4bd0:	6f 81       	ldd	r22, Y+7	; 0x07
    4bd2:	78 85       	ldd	r23, Y+8	; 0x08
    4bd4:	89 85       	ldd	r24, Y+9	; 0x09
    4bd6:	9a 85       	ldd	r25, Y+10	; 0x0a
    4bd8:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    4bdc:	dc 01       	movw	r26, r24
    4bde:	cb 01       	movw	r24, r22
    4be0:	9e 83       	std	Y+6, r25	; 0x06
    4be2:	8d 83       	std	Y+5, r24	; 0x05
    4be4:	8d 81       	ldd	r24, Y+5	; 0x05
    4be6:	9e 81       	ldd	r25, Y+6	; 0x06
    4be8:	9a 83       	std	Y+2, r25	; 0x02
    4bea:	89 83       	std	Y+1, r24	; 0x01
    4bec:	89 81       	ldd	r24, Y+1	; 0x01
    4bee:	9a 81       	ldd	r25, Y+2	; 0x02
    4bf0:	01 97       	sbiw	r24, 0x01	; 1
    4bf2:	f1 f7       	brne	.-4      	; 0x4bf0 <HLCD8_voidStoreCustomChar+0x2ce>
    4bf4:	9a 83       	std	Y+2, r25	; 0x02
    4bf6:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(2);

}
    4bf8:	ab 96       	adiw	r28, 0x2b	; 43
    4bfa:	0f b6       	in	r0, 0x3f	; 63
    4bfc:	f8 94       	cli
    4bfe:	de bf       	out	0x3e, r29	; 62
    4c00:	0f be       	out	0x3f, r0	; 63
    4c02:	cd bf       	out	0x3d, r28	; 61
    4c04:	cf 91       	pop	r28
    4c06:	df 91       	pop	r29
    4c08:	08 95       	ret

00004c0a <HLCD8_voidDisplayCustomChar>:

void HLCD8_voidDisplayCustomChar(u8 A_u8CGRAMIndex,u8 A_u8Row,u8 A_u8Col)
{
    4c0a:	df 93       	push	r29
    4c0c:	cf 93       	push	r28
    4c0e:	00 d0       	rcall	.+0      	; 0x4c10 <HLCD8_voidDisplayCustomChar+0x6>
    4c10:	0f 92       	push	r0
    4c12:	cd b7       	in	r28, 0x3d	; 61
    4c14:	de b7       	in	r29, 0x3e	; 62
    4c16:	89 83       	std	Y+1, r24	; 0x01
    4c18:	6a 83       	std	Y+2, r22	; 0x02
    4c1a:	4b 83       	std	Y+3, r20	; 0x03
    HLCD8_voidGoToPos(A_u8Row,A_u8Col);
    4c1c:	8a 81       	ldd	r24, Y+2	; 0x02
    4c1e:	6b 81       	ldd	r22, Y+3	; 0x03
    4c20:	0e 94 8c 23 	call	0x4718	; 0x4718 <HLCD8_voidGoToPos>
    HLCD8_voidSendData(A_u8CGRAMIndex);
    4c24:	89 81       	ldd	r24, Y+1	; 0x01
    4c26:	0e 94 56 20 	call	0x40ac	; 0x40ac <HLCD8_voidSendData>
    4c2a:	0f 90       	pop	r0
    4c2c:	0f 90       	pop	r0
    4c2e:	0f 90       	pop	r0
    4c30:	cf 91       	pop	r28
    4c32:	df 91       	pop	r29
    4c34:	08 95       	ret

00004c36 <RTOS_voidInit>:


RTOS_TCB RTOS_AOfTasks[RTOS_MAX_NUMBER_OF_TASKS];

void RTOS_voidInit(void)
{
    4c36:	df 93       	push	r29
    4c38:	cf 93       	push	r28
    4c3a:	cd b7       	in	r28, 0x3d	; 61
    4c3c:	de b7       	in	r29, 0x3e	; 62
    //set callback function for timer0 ctc mode
    MTIMER0_voidCTCSetCallBack(RTOS_voidScheduler);
    4c3e:	80 ea       	ldi	r24, 0xA0	; 160
    4c40:	96 e2       	ldi	r25, 0x26	; 38
    4c42:	0e 94 56 32 	call	0x64ac	; 0x64ac <MTIMER0_voidCTCSetCallBack>
    MTIMER0_voidInit(TIMER0_NORMAL_MODE,TIMER0_PRESCALER_8,TIMER0_COMPARE_OUTPUT_MODE_NORMAL);
    4c46:	80 e0       	ldi	r24, 0x00	; 0
    4c48:	62 e0       	ldi	r22, 0x02	; 2
    4c4a:	40 e0       	ldi	r20, 0x00	; 0
    4c4c:	0e 94 4c 31 	call	0x6298	; 0x6298 <MTIMER0_voidInit>
}
    4c50:	cf 91       	pop	r28
    4c52:	df 91       	pop	r29
    4c54:	08 95       	ret

00004c56 <RTOS_voidInitArrayFunctions>:

void RTOS_voidInitArrayFunctions()
{
    4c56:	df 93       	push	r29
    4c58:	cf 93       	push	r28
    4c5a:	0f 92       	push	r0
    4c5c:	cd b7       	in	r28, 0x3d	; 61
    4c5e:	de b7       	in	r29, 0x3e	; 62
    u8 local_u8Counter=0;   
    4c60:	19 82       	std	Y+1, r1	; 0x01
    4c62:	12 c0       	rjmp	.+36     	; 0x4c88 <RTOS_voidInitArrayFunctions+0x32>
    for(;local_u8Counter<RTOS_MAX_NUMBER_OF_TASKS;local_u8Counter++)
    {
        RTOS_AOfTasks[local_u8Counter].pf=NULL;
    4c64:	89 81       	ldd	r24, Y+1	; 0x01
    4c66:	28 2f       	mov	r18, r24
    4c68:	30 e0       	ldi	r19, 0x00	; 0
    4c6a:	c9 01       	movw	r24, r18
    4c6c:	88 0f       	add	r24, r24
    4c6e:	99 1f       	adc	r25, r25
    4c70:	82 0f       	add	r24, r18
    4c72:	93 1f       	adc	r25, r19
    4c74:	88 0f       	add	r24, r24
    4c76:	99 1f       	adc	r25, r25
    4c78:	fc 01       	movw	r30, r24
    4c7a:	ea 52       	subi	r30, 0x2A	; 42
    4c7c:	fe 4f       	sbci	r31, 0xFE	; 254
    4c7e:	11 82       	std	Z+1, r1	; 0x01
    4c80:	10 82       	st	Z, r1
}

void RTOS_voidInitArrayFunctions()
{
    u8 local_u8Counter=0;   
    for(;local_u8Counter<RTOS_MAX_NUMBER_OF_TASKS;local_u8Counter++)
    4c82:	89 81       	ldd	r24, Y+1	; 0x01
    4c84:	8f 5f       	subi	r24, 0xFF	; 255
    4c86:	89 83       	std	Y+1, r24	; 0x01
    4c88:	89 81       	ldd	r24, Y+1	; 0x01
    4c8a:	83 30       	cpi	r24, 0x03	; 3
    4c8c:	58 f3       	brcs	.-42     	; 0x4c64 <RTOS_voidInitArrayFunctions+0xe>
    {
        RTOS_AOfTasks[local_u8Counter].pf=NULL;
    }
}
    4c8e:	0f 90       	pop	r0
    4c90:	cf 91       	pop	r28
    4c92:	df 91       	pop	r29
    4c94:	08 95       	ret

00004c96 <RTOS_voidCreateTask>:

void RTOS_voidCreateTask(u8 A_u8Priority,u16 A_u16Periodicty,u16 A_u16FirstDelay,void(*pf)(void))
{
    4c96:	df 93       	push	r29
    4c98:	cf 93       	push	r28
    4c9a:	cd b7       	in	r28, 0x3d	; 61
    4c9c:	de b7       	in	r29, 0x3e	; 62
    4c9e:	27 97       	sbiw	r28, 0x07	; 7
    4ca0:	0f b6       	in	r0, 0x3f	; 63
    4ca2:	f8 94       	cli
    4ca4:	de bf       	out	0x3e, r29	; 62
    4ca6:	0f be       	out	0x3f, r0	; 63
    4ca8:	cd bf       	out	0x3d, r28	; 61
    4caa:	89 83       	std	Y+1, r24	; 0x01
    4cac:	7b 83       	std	Y+3, r23	; 0x03
    4cae:	6a 83       	std	Y+2, r22	; 0x02
    4cb0:	5d 83       	std	Y+5, r21	; 0x05
    4cb2:	4c 83       	std	Y+4, r20	; 0x04
    4cb4:	3f 83       	std	Y+7, r19	; 0x07
    4cb6:	2e 83       	std	Y+6, r18	; 0x06
    if(A_u8Priority<RTOS_MAX_NUMBER_OF_TASKS && pf!=NULL)
    4cb8:	89 81       	ldd	r24, Y+1	; 0x01
    4cba:	83 30       	cpi	r24, 0x03	; 3
    4cbc:	c0 f5       	brcc	.+112    	; 0x4d2e <RTOS_voidCreateTask+0x98>
    4cbe:	8e 81       	ldd	r24, Y+6	; 0x06
    4cc0:	9f 81       	ldd	r25, Y+7	; 0x07
    4cc2:	00 97       	sbiw	r24, 0x00	; 0
    4cc4:	a1 f1       	breq	.+104    	; 0x4d2e <RTOS_voidCreateTask+0x98>
    {
        RTOS_AOfTasks[A_u8Priority].FirstDelay=A_u16FirstDelay;
    4cc6:	89 81       	ldd	r24, Y+1	; 0x01
    4cc8:	28 2f       	mov	r18, r24
    4cca:	30 e0       	ldi	r19, 0x00	; 0
    4ccc:	c9 01       	movw	r24, r18
    4cce:	88 0f       	add	r24, r24
    4cd0:	99 1f       	adc	r25, r25
    4cd2:	82 0f       	add	r24, r18
    4cd4:	93 1f       	adc	r25, r19
    4cd6:	88 0f       	add	r24, r24
    4cd8:	99 1f       	adc	r25, r25
    4cda:	fc 01       	movw	r30, r24
    4cdc:	ee 52       	subi	r30, 0x2E	; 46
    4cde:	fe 4f       	sbci	r31, 0xFE	; 254
    4ce0:	8c 81       	ldd	r24, Y+4	; 0x04
    4ce2:	9d 81       	ldd	r25, Y+5	; 0x05
    4ce4:	91 83       	std	Z+1, r25	; 0x01
    4ce6:	80 83       	st	Z, r24
        RTOS_AOfTasks[A_u8Priority].Periodicty=A_u16Periodicty;
    4ce8:	89 81       	ldd	r24, Y+1	; 0x01
    4cea:	28 2f       	mov	r18, r24
    4cec:	30 e0       	ldi	r19, 0x00	; 0
    4cee:	c9 01       	movw	r24, r18
    4cf0:	88 0f       	add	r24, r24
    4cf2:	99 1f       	adc	r25, r25
    4cf4:	82 0f       	add	r24, r18
    4cf6:	93 1f       	adc	r25, r19
    4cf8:	01 96       	adiw	r24, 0x01	; 1
    4cfa:	88 0f       	add	r24, r24
    4cfc:	99 1f       	adc	r25, r25
    4cfe:	fc 01       	movw	r30, r24
    4d00:	ee 52       	subi	r30, 0x2E	; 46
    4d02:	fe 4f       	sbci	r31, 0xFE	; 254
    4d04:	8a 81       	ldd	r24, Y+2	; 0x02
    4d06:	9b 81       	ldd	r25, Y+3	; 0x03
    4d08:	91 83       	std	Z+1, r25	; 0x01
    4d0a:	80 83       	st	Z, r24
        RTOS_AOfTasks[A_u8Priority].pf=pf;
    4d0c:	89 81       	ldd	r24, Y+1	; 0x01
    4d0e:	28 2f       	mov	r18, r24
    4d10:	30 e0       	ldi	r19, 0x00	; 0
    4d12:	c9 01       	movw	r24, r18
    4d14:	88 0f       	add	r24, r24
    4d16:	99 1f       	adc	r25, r25
    4d18:	82 0f       	add	r24, r18
    4d1a:	93 1f       	adc	r25, r19
    4d1c:	88 0f       	add	r24, r24
    4d1e:	99 1f       	adc	r25, r25
    4d20:	fc 01       	movw	r30, r24
    4d22:	ea 52       	subi	r30, 0x2A	; 42
    4d24:	fe 4f       	sbci	r31, 0xFE	; 254
    4d26:	8e 81       	ldd	r24, Y+6	; 0x06
    4d28:	9f 81       	ldd	r25, Y+7	; 0x07
    4d2a:	91 83       	std	Z+1, r25	; 0x01
    4d2c:	80 83       	st	Z, r24
    }
}
    4d2e:	27 96       	adiw	r28, 0x07	; 7
    4d30:	0f b6       	in	r0, 0x3f	; 63
    4d32:	f8 94       	cli
    4d34:	de bf       	out	0x3e, r29	; 62
    4d36:	0f be       	out	0x3f, r0	; 63
    4d38:	cd bf       	out	0x3d, r28	; 61
    4d3a:	cf 91       	pop	r28
    4d3c:	df 91       	pop	r29
    4d3e:	08 95       	ret

00004d40 <RTOS_voidScheduler>:



void RTOS_voidScheduler(void)
{
    4d40:	df 93       	push	r29
    4d42:	cf 93       	push	r28
    4d44:	0f 92       	push	r0
    4d46:	cd b7       	in	r28, 0x3d	; 61
    4d48:	de b7       	in	r29, 0x3e	; 62
    u8 local_u8TaskCounter=0;
    4d4a:	19 82       	std	Y+1, r1	; 0x01
    4d4c:	78 c0       	rjmp	.+240    	; 0x4e3e <RTOS_voidScheduler+0xfe>
    for(;local_u8TaskCounter<RTOS_MAX_NUMBER_OF_TASKS;local_u8TaskCounter++)
    {
        if(RTOS_AOfTasks[local_u8TaskCounter].FirstDelay == 0)
    4d4e:	89 81       	ldd	r24, Y+1	; 0x01
    4d50:	28 2f       	mov	r18, r24
    4d52:	30 e0       	ldi	r19, 0x00	; 0
    4d54:	c9 01       	movw	r24, r18
    4d56:	88 0f       	add	r24, r24
    4d58:	99 1f       	adc	r25, r25
    4d5a:	82 0f       	add	r24, r18
    4d5c:	93 1f       	adc	r25, r19
    4d5e:	88 0f       	add	r24, r24
    4d60:	99 1f       	adc	r25, r25
    4d62:	fc 01       	movw	r30, r24
    4d64:	ee 52       	subi	r30, 0x2E	; 46
    4d66:	fe 4f       	sbci	r31, 0xFE	; 254
    4d68:	80 81       	ld	r24, Z
    4d6a:	91 81       	ldd	r25, Z+1	; 0x01
    4d6c:	00 97       	sbiw	r24, 0x00	; 0
    4d6e:	09 f0       	breq	.+2      	; 0x4d72 <RTOS_voidScheduler+0x32>
    4d70:	45 c0       	rjmp	.+138    	; 0x4dfc <RTOS_voidScheduler+0xbc>
        {
            if(RTOS_AOfTasks[local_u8TaskCounter].pf !=NULL)
    4d72:	89 81       	ldd	r24, Y+1	; 0x01
    4d74:	28 2f       	mov	r18, r24
    4d76:	30 e0       	ldi	r19, 0x00	; 0
    4d78:	c9 01       	movw	r24, r18
    4d7a:	88 0f       	add	r24, r24
    4d7c:	99 1f       	adc	r25, r25
    4d7e:	82 0f       	add	r24, r18
    4d80:	93 1f       	adc	r25, r19
    4d82:	88 0f       	add	r24, r24
    4d84:	99 1f       	adc	r25, r25
    4d86:	fc 01       	movw	r30, r24
    4d88:	ea 52       	subi	r30, 0x2A	; 42
    4d8a:	fe 4f       	sbci	r31, 0xFE	; 254
    4d8c:	80 81       	ld	r24, Z
    4d8e:	91 81       	ldd	r25, Z+1	; 0x01
    4d90:	00 97       	sbiw	r24, 0x00	; 0
    4d92:	89 f0       	breq	.+34     	; 0x4db6 <RTOS_voidScheduler+0x76>
            {
                RTOS_AOfTasks[local_u8TaskCounter].pf();
    4d94:	89 81       	ldd	r24, Y+1	; 0x01
    4d96:	28 2f       	mov	r18, r24
    4d98:	30 e0       	ldi	r19, 0x00	; 0
    4d9a:	c9 01       	movw	r24, r18
    4d9c:	88 0f       	add	r24, r24
    4d9e:	99 1f       	adc	r25, r25
    4da0:	82 0f       	add	r24, r18
    4da2:	93 1f       	adc	r25, r19
    4da4:	88 0f       	add	r24, r24
    4da6:	99 1f       	adc	r25, r25
    4da8:	fc 01       	movw	r30, r24
    4daa:	ea 52       	subi	r30, 0x2A	; 42
    4dac:	fe 4f       	sbci	r31, 0xFE	; 254
    4dae:	01 90       	ld	r0, Z+
    4db0:	f0 81       	ld	r31, Z
    4db2:	e0 2d       	mov	r30, r0
    4db4:	09 95       	icall
            }
            RTOS_AOfTasks[local_u8TaskCounter].FirstDelay = RTOS_AOfTasks[local_u8TaskCounter].Periodicty-1;
    4db6:	89 81       	ldd	r24, Y+1	; 0x01
    4db8:	48 2f       	mov	r20, r24
    4dba:	50 e0       	ldi	r21, 0x00	; 0
    4dbc:	89 81       	ldd	r24, Y+1	; 0x01
    4dbe:	28 2f       	mov	r18, r24
    4dc0:	30 e0       	ldi	r19, 0x00	; 0
    4dc2:	c9 01       	movw	r24, r18
    4dc4:	88 0f       	add	r24, r24
    4dc6:	99 1f       	adc	r25, r25
    4dc8:	82 0f       	add	r24, r18
    4dca:	93 1f       	adc	r25, r19
    4dcc:	01 96       	adiw	r24, 0x01	; 1
    4dce:	88 0f       	add	r24, r24
    4dd0:	99 1f       	adc	r25, r25
    4dd2:	fc 01       	movw	r30, r24
    4dd4:	ee 52       	subi	r30, 0x2E	; 46
    4dd6:	fe 4f       	sbci	r31, 0xFE	; 254
    4dd8:	80 81       	ld	r24, Z
    4dda:	91 81       	ldd	r25, Z+1	; 0x01
    4ddc:	9c 01       	movw	r18, r24
    4dde:	21 50       	subi	r18, 0x01	; 1
    4de0:	30 40       	sbci	r19, 0x00	; 0
    4de2:	ca 01       	movw	r24, r20
    4de4:	88 0f       	add	r24, r24
    4de6:	99 1f       	adc	r25, r25
    4de8:	84 0f       	add	r24, r20
    4dea:	95 1f       	adc	r25, r21
    4dec:	88 0f       	add	r24, r24
    4dee:	99 1f       	adc	r25, r25
    4df0:	fc 01       	movw	r30, r24
    4df2:	ee 52       	subi	r30, 0x2E	; 46
    4df4:	fe 4f       	sbci	r31, 0xFE	; 254
    4df6:	31 83       	std	Z+1, r19	; 0x01
    4df8:	20 83       	st	Z, r18
    4dfa:	1e c0       	rjmp	.+60     	; 0x4e38 <RTOS_voidScheduler+0xf8>
        }
        else
        {
            RTOS_AOfTasks[local_u8TaskCounter].FirstDelay--;
    4dfc:	89 81       	ldd	r24, Y+1	; 0x01
    4dfe:	28 2f       	mov	r18, r24
    4e00:	30 e0       	ldi	r19, 0x00	; 0
    4e02:	c9 01       	movw	r24, r18
    4e04:	88 0f       	add	r24, r24
    4e06:	99 1f       	adc	r25, r25
    4e08:	82 0f       	add	r24, r18
    4e0a:	93 1f       	adc	r25, r19
    4e0c:	88 0f       	add	r24, r24
    4e0e:	99 1f       	adc	r25, r25
    4e10:	fc 01       	movw	r30, r24
    4e12:	ee 52       	subi	r30, 0x2E	; 46
    4e14:	fe 4f       	sbci	r31, 0xFE	; 254
    4e16:	80 81       	ld	r24, Z
    4e18:	91 81       	ldd	r25, Z+1	; 0x01
    4e1a:	ac 01       	movw	r20, r24
    4e1c:	41 50       	subi	r20, 0x01	; 1
    4e1e:	50 40       	sbci	r21, 0x00	; 0
    4e20:	c9 01       	movw	r24, r18
    4e22:	88 0f       	add	r24, r24
    4e24:	99 1f       	adc	r25, r25
    4e26:	82 0f       	add	r24, r18
    4e28:	93 1f       	adc	r25, r19
    4e2a:	88 0f       	add	r24, r24
    4e2c:	99 1f       	adc	r25, r25
    4e2e:	fc 01       	movw	r30, r24
    4e30:	ee 52       	subi	r30, 0x2E	; 46
    4e32:	fe 4f       	sbci	r31, 0xFE	; 254
    4e34:	51 83       	std	Z+1, r21	; 0x01
    4e36:	40 83       	st	Z, r20


void RTOS_voidScheduler(void)
{
    u8 local_u8TaskCounter=0;
    for(;local_u8TaskCounter<RTOS_MAX_NUMBER_OF_TASKS;local_u8TaskCounter++)
    4e38:	89 81       	ldd	r24, Y+1	; 0x01
    4e3a:	8f 5f       	subi	r24, 0xFF	; 255
    4e3c:	89 83       	std	Y+1, r24	; 0x01
    4e3e:	89 81       	ldd	r24, Y+1	; 0x01
    4e40:	83 30       	cpi	r24, 0x03	; 3
    4e42:	08 f4       	brcc	.+2      	; 0x4e46 <RTOS_voidScheduler+0x106>
    4e44:	84 cf       	rjmp	.-248    	; 0x4d4e <RTOS_voidScheduler+0xe>
        else
        {
            RTOS_AOfTasks[local_u8TaskCounter].FirstDelay--;
        }
    }
}
    4e46:	0f 90       	pop	r0
    4e48:	cf 91       	pop	r28
    4e4a:	df 91       	pop	r29
    4e4c:	08 95       	ret

00004e4e <HSERVO_voidInit>:
#include "../Include/HAL/SERVOMOTOR/SERVO_Private.h"



void HSERVO_voidInit(void)
{
    4e4e:	df 93       	push	r29
    4e50:	cf 93       	push	r28
    4e52:	cd b7       	in	r28, 0x3d	; 61
    4e54:	de b7       	in	r29, 0x3e	; 62
	MTIMER1_voidInit(TIMER1_FAST_PWM_ICR1,TIMER1_PRESCALER_8,TIMER1_COMPARE_OUTPUT_MODE_A_NON_INVERTING,TIMER1_COMPARE_OUTPUT_MODE_B_NON_INVERTING);
    4e56:	8d e0       	ldi	r24, 0x0D	; 13
    4e58:	62 e0       	ldi	r22, 0x02	; 2
    4e5a:	42 e0       	ldi	r20, 0x02	; 2
    4e5c:	22 e0       	ldi	r18, 0x02	; 2
    4e5e:	0e 94 ce 32 	call	0x659c	; 0x659c <MTIMER1_voidInit>
	MTIMER1_voidSetICR1Value(19999);
    4e62:	8f e1       	ldi	r24, 0x1F	; 31
    4e64:	9e e4       	ldi	r25, 0x4E	; 78
    4e66:	0e 94 2e 36 	call	0x6c5c	; 0x6c5c <MTIMER1_voidSetICR1Value>
        time = 1/50 hz = 20msec =20000usec
        so setting value of ICR1 to be 19999 cause it takes another step from 19999 to 0 
        By varing the duty cycle between 999 to 1999 we get 0 to 180

    */
}
    4e6a:	cf 91       	pop	r28
    4e6c:	df 91       	pop	r29
    4e6e:	08 95       	ret

00004e70 <HSERVO_voidSetServoAngle>:
----------------  = ------------     so desired Angel =====> OCRA_value =  (------------) + 999
Angle      -  0      180  -  0                                                   180
*/

void HSERVO_voidSetServoAngle(u8 A_u8Angle)
{
    4e70:	2f 92       	push	r2
    4e72:	3f 92       	push	r3
    4e74:	4f 92       	push	r4
    4e76:	5f 92       	push	r5
    4e78:	6f 92       	push	r6
    4e7a:	7f 92       	push	r7
    4e7c:	8f 92       	push	r8
    4e7e:	9f 92       	push	r9
    4e80:	af 92       	push	r10
    4e82:	bf 92       	push	r11
    4e84:	cf 92       	push	r12
    4e86:	df 92       	push	r13
    4e88:	ef 92       	push	r14
    4e8a:	ff 92       	push	r15
    4e8c:	0f 93       	push	r16
    4e8e:	1f 93       	push	r17
    4e90:	df 93       	push	r29
    4e92:	cf 93       	push	r28
    4e94:	cd b7       	in	r28, 0x3d	; 61
    4e96:	de b7       	in	r29, 0x3e	; 62
    4e98:	c1 55       	subi	r28, 0x51	; 81
    4e9a:	d0 40       	sbci	r29, 0x00	; 0
    4e9c:	0f b6       	in	r0, 0x3f	; 63
    4e9e:	f8 94       	cli
    4ea0:	de bf       	out	0x3e, r29	; 62
    4ea2:	0f be       	out	0x3f, r0	; 63
    4ea4:	cd bf       	out	0x3d, r28	; 61
    4ea6:	8b 83       	std	Y+3, r24	; 0x03
    u16 local_u16OCRAValue = (((u64)A_u8Angle*1000)/180)+999;
    4ea8:	8b 81       	ldd	r24, Y+3	; 0x03
    4eaa:	08 2f       	mov	r16, r24
    4eac:	10 e0       	ldi	r17, 0x00	; 0
    4eae:	20 e0       	ldi	r18, 0x00	; 0
    4eb0:	30 e0       	ldi	r19, 0x00	; 0
    4eb2:	40 e0       	ldi	r20, 0x00	; 0
    4eb4:	50 e0       	ldi	r21, 0x00	; 0
    4eb6:	60 e0       	ldi	r22, 0x00	; 0
    4eb8:	70 e0       	ldi	r23, 0x00	; 0
    4eba:	0c 83       	std	Y+4, r16	; 0x04
    4ebc:	1d 83       	std	Y+5, r17	; 0x05
    4ebe:	2e 83       	std	Y+6, r18	; 0x06
    4ec0:	3f 83       	std	Y+7, r19	; 0x07
    4ec2:	48 87       	std	Y+8, r20	; 0x08
    4ec4:	59 87       	std	Y+9, r21	; 0x09
    4ec6:	6a 87       	std	Y+10, r22	; 0x0a
    4ec8:	7b 87       	std	Y+11, r23	; 0x0b
    4eca:	ac 80       	ldd	r10, Y+4	; 0x04
    4ecc:	bd 80       	ldd	r11, Y+5	; 0x05
    4ece:	ce 80       	ldd	r12, Y+6	; 0x06
    4ed0:	df 80       	ldd	r13, Y+7	; 0x07
    4ed2:	e8 84       	ldd	r14, Y+8	; 0x08
    4ed4:	f9 84       	ldd	r15, Y+9	; 0x09
    4ed6:	0a 85       	ldd	r16, Y+10	; 0x0a
    4ed8:	1b 85       	ldd	r17, Y+11	; 0x0b
    4eda:	2a 2d       	mov	r18, r10
    4edc:	3b 2d       	mov	r19, r11
    4ede:	4c 2d       	mov	r20, r12
    4ee0:	5d 2d       	mov	r21, r13
    4ee2:	6e 2d       	mov	r22, r14
    4ee4:	7f 2d       	mov	r23, r15
    4ee6:	80 2f       	mov	r24, r16
    4ee8:	91 2f       	mov	r25, r17
    4eea:	02 e0       	ldi	r16, 0x02	; 2
    4eec:	0e 94 49 00 	call	0x92	; 0x92 <__ashldi3>
    4ef0:	2c 87       	std	Y+12, r18	; 0x0c
    4ef2:	3d 87       	std	Y+13, r19	; 0x0d
    4ef4:	4e 87       	std	Y+14, r20	; 0x0e
    4ef6:	5f 87       	std	Y+15, r21	; 0x0f
    4ef8:	68 8b       	std	Y+16, r22	; 0x10
    4efa:	79 8b       	std	Y+17, r23	; 0x11
    4efc:	8a 8b       	std	Y+18, r24	; 0x12
    4efe:	9b 8b       	std	Y+19, r25	; 0x13
    4f00:	2c 85       	ldd	r18, Y+12	; 0x0c
    4f02:	3d 85       	ldd	r19, Y+13	; 0x0d
    4f04:	4e 85       	ldd	r20, Y+14	; 0x0e
    4f06:	5f 85       	ldd	r21, Y+15	; 0x0f
    4f08:	68 89       	ldd	r22, Y+16	; 0x10
    4f0a:	79 89       	ldd	r23, Y+17	; 0x11
    4f0c:	8a 89       	ldd	r24, Y+18	; 0x12
    4f0e:	9b 89       	ldd	r25, Y+19	; 0x13
    4f10:	05 e0       	ldi	r16, 0x05	; 5
    4f12:	0e 94 49 00 	call	0x92	; 0x92 <__ashldi3>
    4f16:	2c 8b       	std	Y+20, r18	; 0x14
    4f18:	3d 8b       	std	Y+21, r19	; 0x15
    4f1a:	4e 8b       	std	Y+22, r20	; 0x16
    4f1c:	5f 8b       	std	Y+23, r21	; 0x17
    4f1e:	68 8f       	std	Y+24, r22	; 0x18
    4f20:	79 8f       	std	Y+25, r23	; 0x19
    4f22:	8a 8f       	std	Y+26, r24	; 0x1a
    4f24:	9b 8f       	std	Y+27, r25	; 0x1b
    4f26:	1c 89       	ldd	r17, Y+20	; 0x14
    4f28:	2c 85       	ldd	r18, Y+12	; 0x0c
    4f2a:	12 1b       	sub	r17, r18
    4f2c:	1c 8f       	std	Y+28, r17	; 0x1c
    4f2e:	31 e0       	ldi	r19, 0x01	; 1
    4f30:	3c a3       	std	Y+36, r19	; 0x24
    4f32:	4c 8d       	ldd	r20, Y+28	; 0x1c
    4f34:	5c 89       	ldd	r21, Y+20	; 0x14
    4f36:	54 17       	cp	r21, r20
    4f38:	08 f0       	brcs	.+2      	; 0x4f3c <HSERVO_voidSetServoAngle+0xcc>
    4f3a:	1c a2       	std	Y+36, r1	; 0x24
    4f3c:	6d 89       	ldd	r22, Y+21	; 0x15
    4f3e:	7d 85       	ldd	r23, Y+13	; 0x0d
    4f40:	67 1b       	sub	r22, r23
    4f42:	6d 8f       	std	Y+29, r22	; 0x1d
    4f44:	81 e0       	ldi	r24, 0x01	; 1
    4f46:	8d a3       	std	Y+37, r24	; 0x25
    4f48:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4f4a:	0d 89       	ldd	r16, Y+21	; 0x15
    4f4c:	09 17       	cp	r16, r25
    4f4e:	08 f0       	brcs	.+2      	; 0x4f52 <HSERVO_voidSetServoAngle+0xe2>
    4f50:	1d a2       	std	Y+37, r1	; 0x25
    4f52:	1d 8d       	ldd	r17, Y+29	; 0x1d
    4f54:	2c a1       	ldd	r18, Y+36	; 0x24
    4f56:	12 1b       	sub	r17, r18
    4f58:	1e a3       	std	Y+38, r17	; 0x26
    4f5a:	31 e0       	ldi	r19, 0x01	; 1
    4f5c:	3f a3       	std	Y+39, r19	; 0x27
    4f5e:	4e a1       	ldd	r20, Y+38	; 0x26
    4f60:	5d 8d       	ldd	r21, Y+29	; 0x1d
    4f62:	54 17       	cp	r21, r20
    4f64:	08 f0       	brcs	.+2      	; 0x4f68 <HSERVO_voidSetServoAngle+0xf8>
    4f66:	1f a2       	std	Y+39, r1	; 0x27
    4f68:	6d a1       	ldd	r22, Y+37	; 0x25
    4f6a:	7f a1       	ldd	r23, Y+39	; 0x27
    4f6c:	67 2b       	or	r22, r23
    4f6e:	6d a3       	std	Y+37, r22	; 0x25
    4f70:	8e a1       	ldd	r24, Y+38	; 0x26
    4f72:	8d 8f       	std	Y+29, r24	; 0x1d
    4f74:	9e 89       	ldd	r25, Y+22	; 0x16
    4f76:	0e 85       	ldd	r16, Y+14	; 0x0e
    4f78:	90 1b       	sub	r25, r16
    4f7a:	9e 8f       	std	Y+30, r25	; 0x1e
    4f7c:	11 e0       	ldi	r17, 0x01	; 1
    4f7e:	18 a7       	std	Y+40, r17	; 0x28
    4f80:	2e 8d       	ldd	r18, Y+30	; 0x1e
    4f82:	3e 89       	ldd	r19, Y+22	; 0x16
    4f84:	32 17       	cp	r19, r18
    4f86:	08 f0       	brcs	.+2      	; 0x4f8a <HSERVO_voidSetServoAngle+0x11a>
    4f88:	18 a6       	std	Y+40, r1	; 0x28
    4f8a:	4e 8d       	ldd	r20, Y+30	; 0x1e
    4f8c:	5d a1       	ldd	r21, Y+37	; 0x25
    4f8e:	45 1b       	sub	r20, r21
    4f90:	49 a7       	std	Y+41, r20	; 0x29
    4f92:	61 e0       	ldi	r22, 0x01	; 1
    4f94:	6a a7       	std	Y+42, r22	; 0x2a
    4f96:	79 a5       	ldd	r23, Y+41	; 0x29
    4f98:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4f9a:	87 17       	cp	r24, r23
    4f9c:	08 f0       	brcs	.+2      	; 0x4fa0 <HSERVO_voidSetServoAngle+0x130>
    4f9e:	1a a6       	std	Y+42, r1	; 0x2a
    4fa0:	98 a5       	ldd	r25, Y+40	; 0x28
    4fa2:	0a a5       	ldd	r16, Y+42	; 0x2a
    4fa4:	90 2b       	or	r25, r16
    4fa6:	98 a7       	std	Y+40, r25	; 0x28
    4fa8:	19 a5       	ldd	r17, Y+41	; 0x29
    4faa:	1e 8f       	std	Y+30, r17	; 0x1e
    4fac:	2f 89       	ldd	r18, Y+23	; 0x17
    4fae:	3f 85       	ldd	r19, Y+15	; 0x0f
    4fb0:	23 1b       	sub	r18, r19
    4fb2:	2f 8f       	std	Y+31, r18	; 0x1f
    4fb4:	41 e0       	ldi	r20, 0x01	; 1
    4fb6:	4b a7       	std	Y+43, r20	; 0x2b
    4fb8:	5f 8d       	ldd	r21, Y+31	; 0x1f
    4fba:	6f 89       	ldd	r22, Y+23	; 0x17
    4fbc:	65 17       	cp	r22, r21
    4fbe:	08 f0       	brcs	.+2      	; 0x4fc2 <HSERVO_voidSetServoAngle+0x152>
    4fc0:	1b a6       	std	Y+43, r1	; 0x2b
    4fc2:	7f 8d       	ldd	r23, Y+31	; 0x1f
    4fc4:	88 a5       	ldd	r24, Y+40	; 0x28
    4fc6:	78 1b       	sub	r23, r24
    4fc8:	7c a7       	std	Y+44, r23	; 0x2c
    4fca:	91 e0       	ldi	r25, 0x01	; 1
    4fcc:	9d a7       	std	Y+45, r25	; 0x2d
    4fce:	0c a5       	ldd	r16, Y+44	; 0x2c
    4fd0:	1f 8d       	ldd	r17, Y+31	; 0x1f
    4fd2:	10 17       	cp	r17, r16
    4fd4:	08 f0       	brcs	.+2      	; 0x4fd8 <HSERVO_voidSetServoAngle+0x168>
    4fd6:	1d a6       	std	Y+45, r1	; 0x2d
    4fd8:	2b a5       	ldd	r18, Y+43	; 0x2b
    4fda:	3d a5       	ldd	r19, Y+45	; 0x2d
    4fdc:	23 2b       	or	r18, r19
    4fde:	2b a7       	std	Y+43, r18	; 0x2b
    4fe0:	4c a5       	ldd	r20, Y+44	; 0x2c
    4fe2:	4f 8f       	std	Y+31, r20	; 0x1f
    4fe4:	58 8d       	ldd	r21, Y+24	; 0x18
    4fe6:	68 89       	ldd	r22, Y+16	; 0x10
    4fe8:	56 1b       	sub	r21, r22
    4fea:	58 a3       	std	Y+32, r21	; 0x20
    4fec:	71 e0       	ldi	r23, 0x01	; 1
    4fee:	7e a7       	std	Y+46, r23	; 0x2e
    4ff0:	88 a1       	ldd	r24, Y+32	; 0x20
    4ff2:	98 8d       	ldd	r25, Y+24	; 0x18
    4ff4:	98 17       	cp	r25, r24
    4ff6:	08 f0       	brcs	.+2      	; 0x4ffa <HSERVO_voidSetServoAngle+0x18a>
    4ff8:	1e a6       	std	Y+46, r1	; 0x2e
    4ffa:	08 a1       	ldd	r16, Y+32	; 0x20
    4ffc:	1b a5       	ldd	r17, Y+43	; 0x2b
    4ffe:	01 1b       	sub	r16, r17
    5000:	0f a7       	std	Y+47, r16	; 0x2f
    5002:	21 e0       	ldi	r18, 0x01	; 1
    5004:	28 ab       	std	Y+48, r18	; 0x30
    5006:	3f a5       	ldd	r19, Y+47	; 0x2f
    5008:	48 a1       	ldd	r20, Y+32	; 0x20
    500a:	43 17       	cp	r20, r19
    500c:	08 f0       	brcs	.+2      	; 0x5010 <HSERVO_voidSetServoAngle+0x1a0>
    500e:	18 aa       	std	Y+48, r1	; 0x30
    5010:	5e a5       	ldd	r21, Y+46	; 0x2e
    5012:	68 a9       	ldd	r22, Y+48	; 0x30
    5014:	56 2b       	or	r21, r22
    5016:	5e a7       	std	Y+46, r21	; 0x2e
    5018:	7f a5       	ldd	r23, Y+47	; 0x2f
    501a:	78 a3       	std	Y+32, r23	; 0x20
    501c:	89 8d       	ldd	r24, Y+25	; 0x19
    501e:	99 89       	ldd	r25, Y+17	; 0x11
    5020:	89 1b       	sub	r24, r25
    5022:	89 a3       	std	Y+33, r24	; 0x21
    5024:	01 e0       	ldi	r16, 0x01	; 1
    5026:	09 ab       	std	Y+49, r16	; 0x31
    5028:	19 a1       	ldd	r17, Y+33	; 0x21
    502a:	29 8d       	ldd	r18, Y+25	; 0x19
    502c:	21 17       	cp	r18, r17
    502e:	08 f0       	brcs	.+2      	; 0x5032 <HSERVO_voidSetServoAngle+0x1c2>
    5030:	19 aa       	std	Y+49, r1	; 0x31
    5032:	39 a1       	ldd	r19, Y+33	; 0x21
    5034:	4e a5       	ldd	r20, Y+46	; 0x2e
    5036:	34 1b       	sub	r19, r20
    5038:	3a ab       	std	Y+50, r19	; 0x32
    503a:	51 e0       	ldi	r21, 0x01	; 1
    503c:	5b ab       	std	Y+51, r21	; 0x33
    503e:	6a a9       	ldd	r22, Y+50	; 0x32
    5040:	79 a1       	ldd	r23, Y+33	; 0x21
    5042:	76 17       	cp	r23, r22
    5044:	08 f0       	brcs	.+2      	; 0x5048 <HSERVO_voidSetServoAngle+0x1d8>
    5046:	1b aa       	std	Y+51, r1	; 0x33
    5048:	89 a9       	ldd	r24, Y+49	; 0x31
    504a:	9b a9       	ldd	r25, Y+51	; 0x33
    504c:	89 2b       	or	r24, r25
    504e:	89 ab       	std	Y+49, r24	; 0x31
    5050:	0a a9       	ldd	r16, Y+50	; 0x32
    5052:	09 a3       	std	Y+33, r16	; 0x21
    5054:	1a 8d       	ldd	r17, Y+26	; 0x1a
    5056:	2a 89       	ldd	r18, Y+18	; 0x12
    5058:	12 1b       	sub	r17, r18
    505a:	1a a3       	std	Y+34, r17	; 0x22
    505c:	31 e0       	ldi	r19, 0x01	; 1
    505e:	3c ab       	std	Y+52, r19	; 0x34
    5060:	4a a1       	ldd	r20, Y+34	; 0x22
    5062:	5a 8d       	ldd	r21, Y+26	; 0x1a
    5064:	54 17       	cp	r21, r20
    5066:	08 f0       	brcs	.+2      	; 0x506a <HSERVO_voidSetServoAngle+0x1fa>
    5068:	1c aa       	std	Y+52, r1	; 0x34
    506a:	6a a1       	ldd	r22, Y+34	; 0x22
    506c:	79 a9       	ldd	r23, Y+49	; 0x31
    506e:	67 1b       	sub	r22, r23
    5070:	6d ab       	std	Y+53, r22	; 0x35
    5072:	81 e0       	ldi	r24, 0x01	; 1
    5074:	8e ab       	std	Y+54, r24	; 0x36
    5076:	9d a9       	ldd	r25, Y+53	; 0x35
    5078:	0a a1       	ldd	r16, Y+34	; 0x22
    507a:	09 17       	cp	r16, r25
    507c:	08 f0       	brcs	.+2      	; 0x5080 <HSERVO_voidSetServoAngle+0x210>
    507e:	1e aa       	std	Y+54, r1	; 0x36
    5080:	1c a9       	ldd	r17, Y+52	; 0x34
    5082:	2e a9       	ldd	r18, Y+54	; 0x36
    5084:	12 2b       	or	r17, r18
    5086:	1c ab       	std	Y+52, r17	; 0x34
    5088:	3d a9       	ldd	r19, Y+53	; 0x35
    508a:	3a a3       	std	Y+34, r19	; 0x22
    508c:	4b 8d       	ldd	r20, Y+27	; 0x1b
    508e:	5b 89       	ldd	r21, Y+19	; 0x13
    5090:	45 1b       	sub	r20, r21
    5092:	4b a3       	std	Y+35, r20	; 0x23
    5094:	8b a1       	ldd	r24, Y+35	; 0x23
    5096:	6c a9       	ldd	r22, Y+52	; 0x34
    5098:	86 1b       	sub	r24, r22
    509a:	8b a3       	std	Y+35, r24	; 0x23
    509c:	7c 8d       	ldd	r23, Y+28	; 0x1c
    509e:	7c 8b       	std	Y+20, r23	; 0x14
    50a0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    50a2:	8d 8b       	std	Y+21, r24	; 0x15
    50a4:	9e 8d       	ldd	r25, Y+30	; 0x1e
    50a6:	9e 8b       	std	Y+22, r25	; 0x16
    50a8:	0f 8d       	ldd	r16, Y+31	; 0x1f
    50aa:	0f 8b       	std	Y+23, r16	; 0x17
    50ac:	18 a1       	ldd	r17, Y+32	; 0x20
    50ae:	18 8f       	std	Y+24, r17	; 0x18
    50b0:	29 a1       	ldd	r18, Y+33	; 0x21
    50b2:	29 8f       	std	Y+25, r18	; 0x19
    50b4:	3a a1       	ldd	r19, Y+34	; 0x22
    50b6:	3a 8f       	std	Y+26, r19	; 0x1a
    50b8:	4b a1       	ldd	r20, Y+35	; 0x23
    50ba:	4b 8f       	std	Y+27, r20	; 0x1b
    50bc:	5c 89       	ldd	r21, Y+20	; 0x14
    50be:	6c 81       	ldd	r22, Y+4	; 0x04
    50c0:	56 0f       	add	r21, r22
    50c2:	5f ab       	std	Y+55, r21	; 0x37
    50c4:	71 e0       	ldi	r23, 0x01	; 1
    50c6:	7f af       	std	Y+63, r23	; 0x3f
    50c8:	8f a9       	ldd	r24, Y+55	; 0x37
    50ca:	9c 89       	ldd	r25, Y+20	; 0x14
    50cc:	89 17       	cp	r24, r25
    50ce:	08 f0       	brcs	.+2      	; 0x50d2 <HSERVO_voidSetServoAngle+0x262>
    50d0:	1f ae       	std	Y+63, r1	; 0x3f
    50d2:	0d 89       	ldd	r16, Y+21	; 0x15
    50d4:	1d 81       	ldd	r17, Y+5	; 0x05
    50d6:	01 0f       	add	r16, r17
    50d8:	08 af       	std	Y+56, r16	; 0x38
    50da:	21 e0       	ldi	r18, 0x01	; 1
    50dc:	21 96       	adiw	r28, 0x01	; 1
    50de:	2f af       	std	Y+63, r18	; 0x3f
    50e0:	21 97       	sbiw	r28, 0x01	; 1
    50e2:	38 ad       	ldd	r19, Y+56	; 0x38
    50e4:	4d 89       	ldd	r20, Y+21	; 0x15
    50e6:	34 17       	cp	r19, r20
    50e8:	18 f0       	brcs	.+6      	; 0x50f0 <HSERVO_voidSetServoAngle+0x280>
    50ea:	21 96       	adiw	r28, 0x01	; 1
    50ec:	1f ae       	std	Y+63, r1	; 0x3f
    50ee:	21 97       	sbiw	r28, 0x01	; 1
    50f0:	5f ad       	ldd	r21, Y+63	; 0x3f
    50f2:	68 ad       	ldd	r22, Y+56	; 0x38
    50f4:	56 0f       	add	r21, r22
    50f6:	22 96       	adiw	r28, 0x02	; 2
    50f8:	5f af       	std	Y+63, r21	; 0x3f
    50fa:	22 97       	sbiw	r28, 0x02	; 2
    50fc:	71 e0       	ldi	r23, 0x01	; 1
    50fe:	23 96       	adiw	r28, 0x03	; 3
    5100:	7f af       	std	Y+63, r23	; 0x3f
    5102:	23 97       	sbiw	r28, 0x03	; 3
    5104:	22 96       	adiw	r28, 0x02	; 2
    5106:	8f ad       	ldd	r24, Y+63	; 0x3f
    5108:	22 97       	sbiw	r28, 0x02	; 2
    510a:	98 ad       	ldd	r25, Y+56	; 0x38
    510c:	89 17       	cp	r24, r25
    510e:	18 f0       	brcs	.+6      	; 0x5116 <HSERVO_voidSetServoAngle+0x2a6>
    5110:	23 96       	adiw	r28, 0x03	; 3
    5112:	1f ae       	std	Y+63, r1	; 0x3f
    5114:	23 97       	sbiw	r28, 0x03	; 3
    5116:	21 96       	adiw	r28, 0x01	; 1
    5118:	0f ad       	ldd	r16, Y+63	; 0x3f
    511a:	21 97       	sbiw	r28, 0x01	; 1
    511c:	23 96       	adiw	r28, 0x03	; 3
    511e:	1f ad       	ldd	r17, Y+63	; 0x3f
    5120:	23 97       	sbiw	r28, 0x03	; 3
    5122:	01 2b       	or	r16, r17
    5124:	21 96       	adiw	r28, 0x01	; 1
    5126:	0f af       	std	Y+63, r16	; 0x3f
    5128:	21 97       	sbiw	r28, 0x01	; 1
    512a:	22 96       	adiw	r28, 0x02	; 2
    512c:	2f ad       	ldd	r18, Y+63	; 0x3f
    512e:	22 97       	sbiw	r28, 0x02	; 2
    5130:	28 af       	std	Y+56, r18	; 0x38
    5132:	3e 89       	ldd	r19, Y+22	; 0x16
    5134:	4e 81       	ldd	r20, Y+6	; 0x06
    5136:	34 0f       	add	r19, r20
    5138:	39 af       	std	Y+57, r19	; 0x39
    513a:	51 e0       	ldi	r21, 0x01	; 1
    513c:	24 96       	adiw	r28, 0x04	; 4
    513e:	5f af       	std	Y+63, r21	; 0x3f
    5140:	24 97       	sbiw	r28, 0x04	; 4
    5142:	69 ad       	ldd	r22, Y+57	; 0x39
    5144:	7e 89       	ldd	r23, Y+22	; 0x16
    5146:	67 17       	cp	r22, r23
    5148:	18 f0       	brcs	.+6      	; 0x5150 <HSERVO_voidSetServoAngle+0x2e0>
    514a:	24 96       	adiw	r28, 0x04	; 4
    514c:	1f ae       	std	Y+63, r1	; 0x3f
    514e:	24 97       	sbiw	r28, 0x04	; 4
    5150:	21 96       	adiw	r28, 0x01	; 1
    5152:	8f ad       	ldd	r24, Y+63	; 0x3f
    5154:	21 97       	sbiw	r28, 0x01	; 1
    5156:	99 ad       	ldd	r25, Y+57	; 0x39
    5158:	89 0f       	add	r24, r25
    515a:	25 96       	adiw	r28, 0x05	; 5
    515c:	8f af       	std	Y+63, r24	; 0x3f
    515e:	25 97       	sbiw	r28, 0x05	; 5
    5160:	01 e0       	ldi	r16, 0x01	; 1
    5162:	26 96       	adiw	r28, 0x06	; 6
    5164:	0f af       	std	Y+63, r16	; 0x3f
    5166:	26 97       	sbiw	r28, 0x06	; 6
    5168:	25 96       	adiw	r28, 0x05	; 5
    516a:	1f ad       	ldd	r17, Y+63	; 0x3f
    516c:	25 97       	sbiw	r28, 0x05	; 5
    516e:	29 ad       	ldd	r18, Y+57	; 0x39
    5170:	12 17       	cp	r17, r18
    5172:	18 f0       	brcs	.+6      	; 0x517a <HSERVO_voidSetServoAngle+0x30a>
    5174:	26 96       	adiw	r28, 0x06	; 6
    5176:	1f ae       	std	Y+63, r1	; 0x3f
    5178:	26 97       	sbiw	r28, 0x06	; 6
    517a:	24 96       	adiw	r28, 0x04	; 4
    517c:	3f ad       	ldd	r19, Y+63	; 0x3f
    517e:	24 97       	sbiw	r28, 0x04	; 4
    5180:	26 96       	adiw	r28, 0x06	; 6
    5182:	4f ad       	ldd	r20, Y+63	; 0x3f
    5184:	26 97       	sbiw	r28, 0x06	; 6
    5186:	34 2b       	or	r19, r20
    5188:	24 96       	adiw	r28, 0x04	; 4
    518a:	3f af       	std	Y+63, r19	; 0x3f
    518c:	24 97       	sbiw	r28, 0x04	; 4
    518e:	25 96       	adiw	r28, 0x05	; 5
    5190:	5f ad       	ldd	r21, Y+63	; 0x3f
    5192:	25 97       	sbiw	r28, 0x05	; 5
    5194:	59 af       	std	Y+57, r21	; 0x39
    5196:	6f 89       	ldd	r22, Y+23	; 0x17
    5198:	7f 81       	ldd	r23, Y+7	; 0x07
    519a:	67 0f       	add	r22, r23
    519c:	6a af       	std	Y+58, r22	; 0x3a
    519e:	81 e0       	ldi	r24, 0x01	; 1
    51a0:	27 96       	adiw	r28, 0x07	; 7
    51a2:	8f af       	std	Y+63, r24	; 0x3f
    51a4:	27 97       	sbiw	r28, 0x07	; 7
    51a6:	9a ad       	ldd	r25, Y+58	; 0x3a
    51a8:	0f 89       	ldd	r16, Y+23	; 0x17
    51aa:	90 17       	cp	r25, r16
    51ac:	18 f0       	brcs	.+6      	; 0x51b4 <HSERVO_voidSetServoAngle+0x344>
    51ae:	27 96       	adiw	r28, 0x07	; 7
    51b0:	1f ae       	std	Y+63, r1	; 0x3f
    51b2:	27 97       	sbiw	r28, 0x07	; 7
    51b4:	24 96       	adiw	r28, 0x04	; 4
    51b6:	1f ad       	ldd	r17, Y+63	; 0x3f
    51b8:	24 97       	sbiw	r28, 0x04	; 4
    51ba:	2a ad       	ldd	r18, Y+58	; 0x3a
    51bc:	12 0f       	add	r17, r18
    51be:	28 96       	adiw	r28, 0x08	; 8
    51c0:	1f af       	std	Y+63, r17	; 0x3f
    51c2:	28 97       	sbiw	r28, 0x08	; 8
    51c4:	31 e0       	ldi	r19, 0x01	; 1
    51c6:	29 96       	adiw	r28, 0x09	; 9
    51c8:	3f af       	std	Y+63, r19	; 0x3f
    51ca:	29 97       	sbiw	r28, 0x09	; 9
    51cc:	28 96       	adiw	r28, 0x08	; 8
    51ce:	4f ad       	ldd	r20, Y+63	; 0x3f
    51d0:	28 97       	sbiw	r28, 0x08	; 8
    51d2:	5a ad       	ldd	r21, Y+58	; 0x3a
    51d4:	45 17       	cp	r20, r21
    51d6:	18 f0       	brcs	.+6      	; 0x51de <HSERVO_voidSetServoAngle+0x36e>
    51d8:	29 96       	adiw	r28, 0x09	; 9
    51da:	1f ae       	std	Y+63, r1	; 0x3f
    51dc:	29 97       	sbiw	r28, 0x09	; 9
    51de:	27 96       	adiw	r28, 0x07	; 7
    51e0:	6f ad       	ldd	r22, Y+63	; 0x3f
    51e2:	27 97       	sbiw	r28, 0x07	; 7
    51e4:	29 96       	adiw	r28, 0x09	; 9
    51e6:	7f ad       	ldd	r23, Y+63	; 0x3f
    51e8:	29 97       	sbiw	r28, 0x09	; 9
    51ea:	67 2b       	or	r22, r23
    51ec:	27 96       	adiw	r28, 0x07	; 7
    51ee:	6f af       	std	Y+63, r22	; 0x3f
    51f0:	27 97       	sbiw	r28, 0x07	; 7
    51f2:	28 96       	adiw	r28, 0x08	; 8
    51f4:	8f ad       	ldd	r24, Y+63	; 0x3f
    51f6:	28 97       	sbiw	r28, 0x08	; 8
    51f8:	8a af       	std	Y+58, r24	; 0x3a
    51fa:	98 8d       	ldd	r25, Y+24	; 0x18
    51fc:	08 85       	ldd	r16, Y+8	; 0x08
    51fe:	90 0f       	add	r25, r16
    5200:	9b af       	std	Y+59, r25	; 0x3b
    5202:	11 e0       	ldi	r17, 0x01	; 1
    5204:	2a 96       	adiw	r28, 0x0a	; 10
    5206:	1f af       	std	Y+63, r17	; 0x3f
    5208:	2a 97       	sbiw	r28, 0x0a	; 10
    520a:	2b ad       	ldd	r18, Y+59	; 0x3b
    520c:	38 8d       	ldd	r19, Y+24	; 0x18
    520e:	23 17       	cp	r18, r19
    5210:	18 f0       	brcs	.+6      	; 0x5218 <HSERVO_voidSetServoAngle+0x3a8>
    5212:	2a 96       	adiw	r28, 0x0a	; 10
    5214:	1f ae       	std	Y+63, r1	; 0x3f
    5216:	2a 97       	sbiw	r28, 0x0a	; 10
    5218:	27 96       	adiw	r28, 0x07	; 7
    521a:	4f ad       	ldd	r20, Y+63	; 0x3f
    521c:	27 97       	sbiw	r28, 0x07	; 7
    521e:	5b ad       	ldd	r21, Y+59	; 0x3b
    5220:	45 0f       	add	r20, r21
    5222:	2b 96       	adiw	r28, 0x0b	; 11
    5224:	4f af       	std	Y+63, r20	; 0x3f
    5226:	2b 97       	sbiw	r28, 0x0b	; 11
    5228:	61 e0       	ldi	r22, 0x01	; 1
    522a:	2c 96       	adiw	r28, 0x0c	; 12
    522c:	6f af       	std	Y+63, r22	; 0x3f
    522e:	2c 97       	sbiw	r28, 0x0c	; 12
    5230:	2b 96       	adiw	r28, 0x0b	; 11
    5232:	7f ad       	ldd	r23, Y+63	; 0x3f
    5234:	2b 97       	sbiw	r28, 0x0b	; 11
    5236:	8b ad       	ldd	r24, Y+59	; 0x3b
    5238:	78 17       	cp	r23, r24
    523a:	18 f0       	brcs	.+6      	; 0x5242 <HSERVO_voidSetServoAngle+0x3d2>
    523c:	2c 96       	adiw	r28, 0x0c	; 12
    523e:	1f ae       	std	Y+63, r1	; 0x3f
    5240:	2c 97       	sbiw	r28, 0x0c	; 12
    5242:	2a 96       	adiw	r28, 0x0a	; 10
    5244:	9f ad       	ldd	r25, Y+63	; 0x3f
    5246:	2a 97       	sbiw	r28, 0x0a	; 10
    5248:	2c 96       	adiw	r28, 0x0c	; 12
    524a:	0f ad       	ldd	r16, Y+63	; 0x3f
    524c:	2c 97       	sbiw	r28, 0x0c	; 12
    524e:	90 2b       	or	r25, r16
    5250:	2a 96       	adiw	r28, 0x0a	; 10
    5252:	9f af       	std	Y+63, r25	; 0x3f
    5254:	2a 97       	sbiw	r28, 0x0a	; 10
    5256:	2b 96       	adiw	r28, 0x0b	; 11
    5258:	1f ad       	ldd	r17, Y+63	; 0x3f
    525a:	2b 97       	sbiw	r28, 0x0b	; 11
    525c:	1b af       	std	Y+59, r17	; 0x3b
    525e:	29 8d       	ldd	r18, Y+25	; 0x19
    5260:	39 85       	ldd	r19, Y+9	; 0x09
    5262:	23 0f       	add	r18, r19
    5264:	2c af       	std	Y+60, r18	; 0x3c
    5266:	41 e0       	ldi	r20, 0x01	; 1
    5268:	2d 96       	adiw	r28, 0x0d	; 13
    526a:	4f af       	std	Y+63, r20	; 0x3f
    526c:	2d 97       	sbiw	r28, 0x0d	; 13
    526e:	5c ad       	ldd	r21, Y+60	; 0x3c
    5270:	69 8d       	ldd	r22, Y+25	; 0x19
    5272:	56 17       	cp	r21, r22
    5274:	18 f0       	brcs	.+6      	; 0x527c <HSERVO_voidSetServoAngle+0x40c>
    5276:	2d 96       	adiw	r28, 0x0d	; 13
    5278:	1f ae       	std	Y+63, r1	; 0x3f
    527a:	2d 97       	sbiw	r28, 0x0d	; 13
    527c:	2a 96       	adiw	r28, 0x0a	; 10
    527e:	7f ad       	ldd	r23, Y+63	; 0x3f
    5280:	2a 97       	sbiw	r28, 0x0a	; 10
    5282:	8c ad       	ldd	r24, Y+60	; 0x3c
    5284:	78 0f       	add	r23, r24
    5286:	2e 96       	adiw	r28, 0x0e	; 14
    5288:	7f af       	std	Y+63, r23	; 0x3f
    528a:	2e 97       	sbiw	r28, 0x0e	; 14
    528c:	91 e0       	ldi	r25, 0x01	; 1
    528e:	2f 96       	adiw	r28, 0x0f	; 15
    5290:	9f af       	std	Y+63, r25	; 0x3f
    5292:	2f 97       	sbiw	r28, 0x0f	; 15
    5294:	2e 96       	adiw	r28, 0x0e	; 14
    5296:	0f ad       	ldd	r16, Y+63	; 0x3f
    5298:	2e 97       	sbiw	r28, 0x0e	; 14
    529a:	1c ad       	ldd	r17, Y+60	; 0x3c
    529c:	01 17       	cp	r16, r17
    529e:	18 f0       	brcs	.+6      	; 0x52a6 <HSERVO_voidSetServoAngle+0x436>
    52a0:	2f 96       	adiw	r28, 0x0f	; 15
    52a2:	1f ae       	std	Y+63, r1	; 0x3f
    52a4:	2f 97       	sbiw	r28, 0x0f	; 15
    52a6:	2d 96       	adiw	r28, 0x0d	; 13
    52a8:	2f ad       	ldd	r18, Y+63	; 0x3f
    52aa:	2d 97       	sbiw	r28, 0x0d	; 13
    52ac:	2f 96       	adiw	r28, 0x0f	; 15
    52ae:	3f ad       	ldd	r19, Y+63	; 0x3f
    52b0:	2f 97       	sbiw	r28, 0x0f	; 15
    52b2:	23 2b       	or	r18, r19
    52b4:	2d 96       	adiw	r28, 0x0d	; 13
    52b6:	2f af       	std	Y+63, r18	; 0x3f
    52b8:	2d 97       	sbiw	r28, 0x0d	; 13
    52ba:	2e 96       	adiw	r28, 0x0e	; 14
    52bc:	4f ad       	ldd	r20, Y+63	; 0x3f
    52be:	2e 97       	sbiw	r28, 0x0e	; 14
    52c0:	4c af       	std	Y+60, r20	; 0x3c
    52c2:	5a 8d       	ldd	r21, Y+26	; 0x1a
    52c4:	6a 85       	ldd	r22, Y+10	; 0x0a
    52c6:	56 0f       	add	r21, r22
    52c8:	5d af       	std	Y+61, r21	; 0x3d
    52ca:	71 e0       	ldi	r23, 0x01	; 1
    52cc:	60 96       	adiw	r28, 0x10	; 16
    52ce:	7f af       	std	Y+63, r23	; 0x3f
    52d0:	60 97       	sbiw	r28, 0x10	; 16
    52d2:	8d ad       	ldd	r24, Y+61	; 0x3d
    52d4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    52d6:	89 17       	cp	r24, r25
    52d8:	18 f0       	brcs	.+6      	; 0x52e0 <HSERVO_voidSetServoAngle+0x470>
    52da:	60 96       	adiw	r28, 0x10	; 16
    52dc:	1f ae       	std	Y+63, r1	; 0x3f
    52de:	60 97       	sbiw	r28, 0x10	; 16
    52e0:	2d 96       	adiw	r28, 0x0d	; 13
    52e2:	0f ad       	ldd	r16, Y+63	; 0x3f
    52e4:	2d 97       	sbiw	r28, 0x0d	; 13
    52e6:	1d ad       	ldd	r17, Y+61	; 0x3d
    52e8:	01 0f       	add	r16, r17
    52ea:	61 96       	adiw	r28, 0x11	; 17
    52ec:	0f af       	std	Y+63, r16	; 0x3f
    52ee:	61 97       	sbiw	r28, 0x11	; 17
    52f0:	21 e0       	ldi	r18, 0x01	; 1
    52f2:	62 96       	adiw	r28, 0x12	; 18
    52f4:	2f af       	std	Y+63, r18	; 0x3f
    52f6:	62 97       	sbiw	r28, 0x12	; 18
    52f8:	61 96       	adiw	r28, 0x11	; 17
    52fa:	3f ad       	ldd	r19, Y+63	; 0x3f
    52fc:	61 97       	sbiw	r28, 0x11	; 17
    52fe:	4d ad       	ldd	r20, Y+61	; 0x3d
    5300:	34 17       	cp	r19, r20
    5302:	18 f0       	brcs	.+6      	; 0x530a <HSERVO_voidSetServoAngle+0x49a>
    5304:	62 96       	adiw	r28, 0x12	; 18
    5306:	1f ae       	std	Y+63, r1	; 0x3f
    5308:	62 97       	sbiw	r28, 0x12	; 18
    530a:	60 96       	adiw	r28, 0x10	; 16
    530c:	5f ad       	ldd	r21, Y+63	; 0x3f
    530e:	60 97       	sbiw	r28, 0x10	; 16
    5310:	62 96       	adiw	r28, 0x12	; 18
    5312:	6f ad       	ldd	r22, Y+63	; 0x3f
    5314:	62 97       	sbiw	r28, 0x12	; 18
    5316:	56 2b       	or	r21, r22
    5318:	60 96       	adiw	r28, 0x10	; 16
    531a:	5f af       	std	Y+63, r21	; 0x3f
    531c:	60 97       	sbiw	r28, 0x10	; 16
    531e:	61 96       	adiw	r28, 0x11	; 17
    5320:	7f ad       	ldd	r23, Y+63	; 0x3f
    5322:	61 97       	sbiw	r28, 0x11	; 17
    5324:	7d af       	std	Y+61, r23	; 0x3d
    5326:	8b 8d       	ldd	r24, Y+27	; 0x1b
    5328:	9b 85       	ldd	r25, Y+11	; 0x0b
    532a:	89 0f       	add	r24, r25
    532c:	8e af       	std	Y+62, r24	; 0x3e
    532e:	60 96       	adiw	r28, 0x10	; 16
    5330:	8f ad       	ldd	r24, Y+63	; 0x3f
    5332:	60 97       	sbiw	r28, 0x10	; 16
    5334:	0e ad       	ldd	r16, Y+62	; 0x3e
    5336:	80 0f       	add	r24, r16
    5338:	8e af       	std	Y+62, r24	; 0x3e
    533a:	1f a9       	ldd	r17, Y+55	; 0x37
    533c:	1c 8b       	std	Y+20, r17	; 0x14
    533e:	28 ad       	ldd	r18, Y+56	; 0x38
    5340:	2d 8b       	std	Y+21, r18	; 0x15
    5342:	39 ad       	ldd	r19, Y+57	; 0x39
    5344:	3e 8b       	std	Y+22, r19	; 0x16
    5346:	4a ad       	ldd	r20, Y+58	; 0x3a
    5348:	4f 8b       	std	Y+23, r20	; 0x17
    534a:	5b ad       	ldd	r21, Y+59	; 0x3b
    534c:	58 8f       	std	Y+24, r21	; 0x18
    534e:	6c ad       	ldd	r22, Y+60	; 0x3c
    5350:	69 8f       	std	Y+25, r22	; 0x19
    5352:	7d ad       	ldd	r23, Y+61	; 0x3d
    5354:	7a 8f       	std	Y+26, r23	; 0x1a
    5356:	8e ad       	ldd	r24, Y+62	; 0x3e
    5358:	8b 8f       	std	Y+27, r24	; 0x1b
    535a:	2c 89       	ldd	r18, Y+20	; 0x14
    535c:	3d 89       	ldd	r19, Y+21	; 0x15
    535e:	4e 89       	ldd	r20, Y+22	; 0x16
    5360:	5f 89       	ldd	r21, Y+23	; 0x17
    5362:	68 8d       	ldd	r22, Y+24	; 0x18
    5364:	79 8d       	ldd	r23, Y+25	; 0x19
    5366:	8a 8d       	ldd	r24, Y+26	; 0x1a
    5368:	9b 8d       	ldd	r25, Y+27	; 0x1b
    536a:	03 e0       	ldi	r16, 0x03	; 3
    536c:	0e 94 49 00 	call	0x92	; 0x92 <__ashldi3>
    5370:	22 2e       	mov	r2, r18
    5372:	33 2e       	mov	r3, r19
    5374:	44 2e       	mov	r4, r20
    5376:	55 2e       	mov	r5, r21
    5378:	66 2e       	mov	r6, r22
    537a:	77 2e       	mov	r7, r23
    537c:	88 2e       	mov	r8, r24
    537e:	99 2e       	mov	r9, r25
    5380:	a2 2c       	mov	r10, r2
    5382:	b3 2c       	mov	r11, r3
    5384:	c4 2c       	mov	r12, r4
    5386:	d5 2c       	mov	r13, r5
    5388:	e6 2c       	mov	r14, r6
    538a:	f7 2c       	mov	r15, r7
    538c:	08 2d       	mov	r16, r8
    538e:	19 2d       	mov	r17, r9
    5390:	2a 2d       	mov	r18, r10
    5392:	3b 2d       	mov	r19, r11
    5394:	4c 2d       	mov	r20, r12
    5396:	5d 2d       	mov	r21, r13
    5398:	6e 2d       	mov	r22, r14
    539a:	7f 2d       	mov	r23, r15
    539c:	80 2f       	mov	r24, r16
    539e:	91 2f       	mov	r25, r17
    53a0:	0f 2e       	mov	r0, r31
    53a2:	f4 eb       	ldi	r31, 0xB4	; 180
    53a4:	af 2e       	mov	r10, r31
    53a6:	f0 2d       	mov	r31, r0
    53a8:	bb 24       	eor	r11, r11
    53aa:	cc 24       	eor	r12, r12
    53ac:	dd 24       	eor	r13, r13
    53ae:	ee 24       	eor	r14, r14
    53b0:	ff 24       	eor	r15, r15
    53b2:	00 e0       	ldi	r16, 0x00	; 0
    53b4:	10 e0       	ldi	r17, 0x00	; 0
    53b6:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <__udivdi3>
    53ba:	a2 2e       	mov	r10, r18
    53bc:	b3 2e       	mov	r11, r19
    53be:	c4 2e       	mov	r12, r20
    53c0:	d5 2e       	mov	r13, r21
    53c2:	e6 2e       	mov	r14, r22
    53c4:	f7 2e       	mov	r15, r23
    53c6:	08 2f       	mov	r16, r24
    53c8:	19 2f       	mov	r17, r25
    53ca:	2a 2d       	mov	r18, r10
    53cc:	3b 2d       	mov	r19, r11
    53ce:	4c 2d       	mov	r20, r12
    53d0:	5d 2d       	mov	r21, r13
    53d2:	6e 2d       	mov	r22, r14
    53d4:	7f 2d       	mov	r23, r15
    53d6:	80 2f       	mov	r24, r16
    53d8:	91 2f       	mov	r25, r17
    53da:	c9 01       	movw	r24, r18
    53dc:	89 51       	subi	r24, 0x19	; 25
    53de:	9c 4f       	sbci	r25, 0xFC	; 252
    53e0:	9a 83       	std	Y+2, r25	; 0x02
    53e2:	89 83       	std	Y+1, r24	; 0x01
    MTIMER1_voidSetOCR1AValue(local_u16OCRAValue);
    53e4:	89 81       	ldd	r24, Y+1	; 0x01
    53e6:	9a 81       	ldd	r25, Y+2	; 0x02
    53e8:	0e 94 40 36 	call	0x6c80	; 0x6c80 <MTIMER1_voidSetOCR1AValue>
    // MTIMER1_voidSetOCR1AValue(1499);

}
    53ec:	cf 5a       	subi	r28, 0xAF	; 175
    53ee:	df 4f       	sbci	r29, 0xFF	; 255
    53f0:	0f b6       	in	r0, 0x3f	; 63
    53f2:	f8 94       	cli
    53f4:	de bf       	out	0x3e, r29	; 62
    53f6:	0f be       	out	0x3f, r0	; 63
    53f8:	cd bf       	out	0x3d, r28	; 61
    53fa:	cf 91       	pop	r28
    53fc:	df 91       	pop	r29
    53fe:	1f 91       	pop	r17
    5400:	0f 91       	pop	r16
    5402:	ff 90       	pop	r15
    5404:	ef 90       	pop	r14
    5406:	df 90       	pop	r13
    5408:	cf 90       	pop	r12
    540a:	bf 90       	pop	r11
    540c:	af 90       	pop	r10
    540e:	9f 90       	pop	r9
    5410:	8f 90       	pop	r8
    5412:	7f 90       	pop	r7
    5414:	6f 90       	pop	r6
    5416:	5f 90       	pop	r5
    5418:	4f 90       	pop	r4
    541a:	3f 90       	pop	r3
    541c:	2f 90       	pop	r2
    541e:	08 95       	ret

00005420 <MSPI_int>:
static void (*SPI_INT)(void)=NULLPTR;



void MSPI_int()
{
    5420:	df 93       	push	r29
    5422:	cf 93       	push	r28
    5424:	cd b7       	in	r28, 0x3d	; 61
    5426:	de b7       	in	r29, 0x3e	; 62
    #if (SPI_MODE_SELECT == SPI_MASTER)
    SET_BIT(SPCR,MSTR);
    5428:	ad e2       	ldi	r26, 0x2D	; 45
    542a:	b0 e0       	ldi	r27, 0x00	; 0
    542c:	ed e2       	ldi	r30, 0x2D	; 45
    542e:	f0 e0       	ldi	r31, 0x00	; 0
    5430:	80 81       	ld	r24, Z
    5432:	80 61       	ori	r24, 0x10	; 16
    5434:	8c 93       	st	X, r24
    #endif

    #if (CLK_PHASE_SPI == SAMPLE_THEN_SETUP_SPI)
    CLR_BIT(SPCR,CPHA);
    #else
    SET_BIT(SPCR,CPHA);
    5436:	ad e2       	ldi	r26, 0x2D	; 45
    5438:	b0 e0       	ldi	r27, 0x00	; 0
    543a:	ed e2       	ldi	r30, 0x2D	; 45
    543c:	f0 e0       	ldi	r31, 0x00	; 0
    543e:	80 81       	ld	r24, Z
    5440:	84 60       	ori	r24, 0x04	; 4
    5442:	8c 93       	st	X, r24
    #endif

    #if (CLK_POLARITY_SPI == RISING_THEN_FALLING_SPI)
    CLR_BIT(SPCR,CPOL);
    5444:	ad e2       	ldi	r26, 0x2D	; 45
    5446:	b0 e0       	ldi	r27, 0x00	; 0
    5448:	ed e2       	ldi	r30, 0x2D	; 45
    544a:	f0 e0       	ldi	r31, 0x00	; 0
    544c:	80 81       	ld	r24, Z
    544e:	87 7f       	andi	r24, 0xF7	; 247
    5450:	8c 93       	st	X, r24
    #else
    SET_BIT(SPCR,CPOL)
    #endif

    #if (SPI_DATA_ORDER == SPI_LSB_FIRST)
    SET_BIT(SPCR,DORD);
    5452:	ad e2       	ldi	r26, 0x2D	; 45
    5454:	b0 e0       	ldi	r27, 0x00	; 0
    5456:	ed e2       	ldi	r30, 0x2D	; 45
    5458:	f0 e0       	ldi	r31, 0x00	; 0
    545a:	80 81       	ld	r24, Z
    545c:	80 62       	ori	r24, 0x20	; 32
    545e:	8c 93       	st	X, r24
    #elif (SPI_CLK_RATE==SPI_CLK_OVER_8)
    SET_BIT(SPCR,SPR0);
    CLR_BIT(SPCR,SPR1);
    SET_BIT(SPSR,SPI2X);
    #elif (SPI_CLK_RATE==SPI_CLK_OVER_16)
    SET_BIT(SPCR,SPR0);
    5460:	ad e2       	ldi	r26, 0x2D	; 45
    5462:	b0 e0       	ldi	r27, 0x00	; 0
    5464:	ed e2       	ldi	r30, 0x2D	; 45
    5466:	f0 e0       	ldi	r31, 0x00	; 0
    5468:	80 81       	ld	r24, Z
    546a:	81 60       	ori	r24, 0x01	; 1
    546c:	8c 93       	st	X, r24
    CLR_BIT(SPCR,SPR1);
    546e:	ad e2       	ldi	r26, 0x2D	; 45
    5470:	b0 e0       	ldi	r27, 0x00	; 0
    5472:	ed e2       	ldi	r30, 0x2D	; 45
    5474:	f0 e0       	ldi	r31, 0x00	; 0
    5476:	80 81       	ld	r24, Z
    5478:	8d 7f       	andi	r24, 0xFD	; 253
    547a:	8c 93       	st	X, r24
    CLR_BIT(SPSR,SPI2X);
    547c:	ae e2       	ldi	r26, 0x2E	; 46
    547e:	b0 e0       	ldi	r27, 0x00	; 0
    5480:	ee e2       	ldi	r30, 0x2E	; 46
    5482:	f0 e0       	ldi	r31, 0x00	; 0
    5484:	80 81       	ld	r24, Z
    5486:	8e 7f       	andi	r24, 0xFE	; 254
    5488:	8c 93       	st	X, r24

    /*
        it must be done after any initialization step
        or do it in the last step like here
    */
    SET_BIT(SPCR,SPE);
    548a:	ad e2       	ldi	r26, 0x2D	; 45
    548c:	b0 e0       	ldi	r27, 0x00	; 0
    548e:	ed e2       	ldi	r30, 0x2D	; 45
    5490:	f0 e0       	ldi	r31, 0x00	; 0
    5492:	80 81       	ld	r24, Z
    5494:	80 64       	ori	r24, 0x40	; 64
    5496:	8c 93       	st	X, r24
}
    5498:	cf 91       	pop	r28
    549a:	df 91       	pop	r29
    549c:	08 95       	ret

0000549e <MSPI_u8SendRecieveData>:

u8 MSPI_u8SendRecieveData(u8 A_u8Send)
{   
    549e:	df 93       	push	r29
    54a0:	cf 93       	push	r28
    54a2:	0f 92       	push	r0
    54a4:	cd b7       	in	r28, 0x3d	; 61
    54a6:	de b7       	in	r29, 0x3e	; 62
    54a8:	89 83       	std	Y+1, r24	; 0x01
    SPDR= A_u8Send;
    54aa:	ef e2       	ldi	r30, 0x2F	; 47
    54ac:	f0 e0       	ldi	r31, 0x00	; 0
    54ae:	89 81       	ldd	r24, Y+1	; 0x01
    54b0:	80 83       	st	Z, r24
    // polling until the register to be shifted in slave/master
    while(GET_BIT(SPSR,SPIF)==0);
    54b2:	ee e2       	ldi	r30, 0x2E	; 46
    54b4:	f0 e0       	ldi	r31, 0x00	; 0
    54b6:	80 81       	ld	r24, Z
    54b8:	88 2f       	mov	r24, r24
    54ba:	90 e0       	ldi	r25, 0x00	; 0
    54bc:	9c 01       	movw	r18, r24
    54be:	2f 77       	andi	r18, 0x7F	; 127
    54c0:	ee e2       	ldi	r30, 0x2E	; 46
    54c2:	f0 e0       	ldi	r31, 0x00	; 0
    54c4:	80 81       	ld	r24, Z
    54c6:	88 2f       	mov	r24, r24
    54c8:	90 e0       	ldi	r25, 0x00	; 0
    54ca:	28 17       	cp	r18, r24
    54cc:	39 07       	cpc	r19, r25
    54ce:	89 f3       	breq	.-30     	; 0x54b2 <MSPI_u8SendRecieveData+0x14>
    return SPDR;
    54d0:	ef e2       	ldi	r30, 0x2F	; 47
    54d2:	f0 e0       	ldi	r31, 0x00	; 0
    54d4:	80 81       	ld	r24, Z
}
    54d6:	0f 90       	pop	r0
    54d8:	cf 91       	pop	r28
    54da:	df 91       	pop	r29
    54dc:	08 95       	ret

000054de <MSPI_voidInterruptEnable>:
/******************************************Interrupt Section*********************************/
void MSPI_voidInterruptEnable()
{
    54de:	df 93       	push	r29
    54e0:	cf 93       	push	r28
    54e2:	cd b7       	in	r28, 0x3d	; 61
    54e4:	de b7       	in	r29, 0x3e	; 62
    SET_BIT(SPCR,SPIE);
    54e6:	ad e2       	ldi	r26, 0x2D	; 45
    54e8:	b0 e0       	ldi	r27, 0x00	; 0
    54ea:	ed e2       	ldi	r30, 0x2D	; 45
    54ec:	f0 e0       	ldi	r31, 0x00	; 0
    54ee:	80 81       	ld	r24, Z
    54f0:	80 68       	ori	r24, 0x80	; 128
    54f2:	8c 93       	st	X, r24
}
    54f4:	cf 91       	pop	r28
    54f6:	df 91       	pop	r29
    54f8:	08 95       	ret

000054fa <MSPI_voidInterruptDisable>:

void MSPI_voidInterruptDisable()
{
    54fa:	df 93       	push	r29
    54fc:	cf 93       	push	r28
    54fe:	cd b7       	in	r28, 0x3d	; 61
    5500:	de b7       	in	r29, 0x3e	; 62
    CLR_BIT(SPCR,SPIE);
    5502:	ad e2       	ldi	r26, 0x2D	; 45
    5504:	b0 e0       	ldi	r27, 0x00	; 0
    5506:	ed e2       	ldi	r30, 0x2D	; 45
    5508:	f0 e0       	ldi	r31, 0x00	; 0
    550a:	80 81       	ld	r24, Z
    550c:	8f 77       	andi	r24, 0x7F	; 127
    550e:	8c 93       	st	X, r24
}
    5510:	cf 91       	pop	r28
    5512:	df 91       	pop	r29
    5514:	08 95       	ret

00005516 <MSPI_voidSetCallBack>:

void MSPI_voidSetCallBack(void(*pf)(void))
{
    5516:	df 93       	push	r29
    5518:	cf 93       	push	r28
    551a:	00 d0       	rcall	.+0      	; 0x551c <MSPI_voidSetCallBack+0x6>
    551c:	cd b7       	in	r28, 0x3d	; 61
    551e:	de b7       	in	r29, 0x3e	; 62
    5520:	9a 83       	std	Y+2, r25	; 0x02
    5522:	89 83       	std	Y+1, r24	; 0x01
    SPI_INT=pf;
    5524:	89 81       	ldd	r24, Y+1	; 0x01
    5526:	9a 81       	ldd	r25, Y+2	; 0x02
    5528:	90 93 ae 01 	sts	0x01AE, r25
    552c:	80 93 ad 01 	sts	0x01AD, r24
}
    5530:	0f 90       	pop	r0
    5532:	0f 90       	pop	r0
    5534:	cf 91       	pop	r28
    5536:	df 91       	pop	r29
    5538:	08 95       	ret

0000553a <__vector_12>:

ISR(SPI_VECT)
{
    553a:	1f 92       	push	r1
    553c:	0f 92       	push	r0
    553e:	0f b6       	in	r0, 0x3f	; 63
    5540:	0f 92       	push	r0
    5542:	11 24       	eor	r1, r1
    5544:	2f 93       	push	r18
    5546:	3f 93       	push	r19
    5548:	4f 93       	push	r20
    554a:	5f 93       	push	r21
    554c:	6f 93       	push	r22
    554e:	7f 93       	push	r23
    5550:	8f 93       	push	r24
    5552:	9f 93       	push	r25
    5554:	af 93       	push	r26
    5556:	bf 93       	push	r27
    5558:	ef 93       	push	r30
    555a:	ff 93       	push	r31
    555c:	df 93       	push	r29
    555e:	cf 93       	push	r28
    5560:	cd b7       	in	r28, 0x3d	; 61
    5562:	de b7       	in	r29, 0x3e	; 62
    if(SPI_INT != NULLPTR)SPI_INT();
    5564:	80 91 ad 01 	lds	r24, 0x01AD
    5568:	90 91 ae 01 	lds	r25, 0x01AE
    556c:	00 97       	sbiw	r24, 0x00	; 0
    556e:	29 f0       	breq	.+10     	; 0x557a <__vector_12+0x40>
    5570:	e0 91 ad 01 	lds	r30, 0x01AD
    5574:	f0 91 ae 01 	lds	r31, 0x01AE
    5578:	09 95       	icall
}
    557a:	cf 91       	pop	r28
    557c:	df 91       	pop	r29
    557e:	ff 91       	pop	r31
    5580:	ef 91       	pop	r30
    5582:	bf 91       	pop	r27
    5584:	af 91       	pop	r26
    5586:	9f 91       	pop	r25
    5588:	8f 91       	pop	r24
    558a:	7f 91       	pop	r23
    558c:	6f 91       	pop	r22
    558e:	5f 91       	pop	r21
    5590:	4f 91       	pop	r20
    5592:	3f 91       	pop	r19
    5594:	2f 91       	pop	r18
    5596:	0f 90       	pop	r0
    5598:	0f be       	out	0x3f, r0	; 63
    559a:	0f 90       	pop	r0
    559c:	1f 90       	pop	r1
    559e:	18 95       	reti

000055a0 <HSSD_voidDisplay>:
#include "../Include/HAL/SSD/SSD_Private.h"
#include "../Include/HAL/SSD/SSD_Configuration.h"

#include <util/delay.h>
void HSSD_voidDisplay(u8 A_u8Number,u8 A_u8PortId)
{
    55a0:	df 93       	push	r29
    55a2:	cf 93       	push	r28
    55a4:	00 d0       	rcall	.+0      	; 0x55a6 <HSSD_voidDisplay+0x6>
    55a6:	00 d0       	rcall	.+0      	; 0x55a8 <HSSD_voidDisplay+0x8>
    55a8:	cd b7       	in	r28, 0x3d	; 61
    55aa:	de b7       	in	r29, 0x3e	; 62
    55ac:	89 83       	std	Y+1, r24	; 0x01
    55ae:	6a 83       	std	Y+2, r22	; 0x02
	switch(A_u8Number)
    55b0:	89 81       	ldd	r24, Y+1	; 0x01
    55b2:	28 2f       	mov	r18, r24
    55b4:	30 e0       	ldi	r19, 0x00	; 0
    55b6:	3c 83       	std	Y+4, r19	; 0x04
    55b8:	2b 83       	std	Y+3, r18	; 0x03
    55ba:	8b 81       	ldd	r24, Y+3	; 0x03
    55bc:	9c 81       	ldd	r25, Y+4	; 0x04
    55be:	8b 35       	cpi	r24, 0x5B	; 91
    55c0:	91 05       	cpc	r25, r1
    55c2:	09 f4       	brne	.+2      	; 0x55c6 <HSSD_voidDisplay+0x26>
    55c4:	4c c0       	rjmp	.+152    	; 0x565e <HSSD_voidDisplay+0xbe>
    55c6:	2b 81       	ldd	r18, Y+3	; 0x03
    55c8:	3c 81       	ldd	r19, Y+4	; 0x04
    55ca:	2c 35       	cpi	r18, 0x5C	; 92
    55cc:	31 05       	cpc	r19, r1
    55ce:	e4 f4       	brge	.+56     	; 0x5608 <HSSD_voidDisplay+0x68>
    55d0:	8b 81       	ldd	r24, Y+3	; 0x03
    55d2:	9c 81       	ldd	r25, Y+4	; 0x04
    55d4:	87 30       	cpi	r24, 0x07	; 7
    55d6:	91 05       	cpc	r25, r1
    55d8:	09 f4       	brne	.+2      	; 0x55dc <HSSD_voidDisplay+0x3c>
    55da:	5a c0       	rjmp	.+180    	; 0x5690 <HSSD_voidDisplay+0xf0>
    55dc:	2b 81       	ldd	r18, Y+3	; 0x03
    55de:	3c 81       	ldd	r19, Y+4	; 0x04
    55e0:	28 30       	cpi	r18, 0x08	; 8
    55e2:	31 05       	cpc	r19, r1
    55e4:	34 f4       	brge	.+12     	; 0x55f2 <HSSD_voidDisplay+0x52>
    55e6:	8b 81       	ldd	r24, Y+3	; 0x03
    55e8:	9c 81       	ldd	r25, Y+4	; 0x04
    55ea:	86 30       	cpi	r24, 0x06	; 6
    55ec:	91 05       	cpc	r25, r1
    55ee:	91 f1       	breq	.+100    	; 0x5654 <HSSD_voidDisplay+0xb4>
    55f0:	5d c0       	rjmp	.+186    	; 0x56ac <HSSD_voidDisplay+0x10c>
    55f2:	2b 81       	ldd	r18, Y+3	; 0x03
    55f4:	3c 81       	ldd	r19, Y+4	; 0x04
    55f6:	2f 33       	cpi	r18, 0x3F	; 63
    55f8:	31 05       	cpc	r19, r1
    55fa:	39 f1       	breq	.+78     	; 0x564a <HSSD_voidDisplay+0xaa>
    55fc:	8b 81       	ldd	r24, Y+3	; 0x03
    55fe:	9c 81       	ldd	r25, Y+4	; 0x04
    5600:	8f 34       	cpi	r24, 0x4F	; 79
    5602:	91 05       	cpc	r25, r1
    5604:	89 f1       	breq	.+98     	; 0x5668 <HSSD_voidDisplay+0xc8>
    5606:	52 c0       	rjmp	.+164    	; 0x56ac <HSSD_voidDisplay+0x10c>
    5608:	2b 81       	ldd	r18, Y+3	; 0x03
    560a:	3c 81       	ldd	r19, Y+4	; 0x04
    560c:	2f 36       	cpi	r18, 0x6F	; 111
    560e:	31 05       	cpc	r19, r1
    5610:	09 f4       	brne	.+2      	; 0x5614 <HSSD_voidDisplay+0x74>
    5612:	48 c0       	rjmp	.+144    	; 0x56a4 <HSSD_voidDisplay+0x104>
    5614:	8b 81       	ldd	r24, Y+3	; 0x03
    5616:	9c 81       	ldd	r25, Y+4	; 0x04
    5618:	80 37       	cpi	r24, 0x70	; 112
    561a:	91 05       	cpc	r25, r1
    561c:	5c f4       	brge	.+22     	; 0x5634 <HSSD_voidDisplay+0x94>
    561e:	2b 81       	ldd	r18, Y+3	; 0x03
    5620:	3c 81       	ldd	r19, Y+4	; 0x04
    5622:	26 36       	cpi	r18, 0x66	; 102
    5624:	31 05       	cpc	r19, r1
    5626:	29 f1       	breq	.+74     	; 0x5672 <HSSD_voidDisplay+0xd2>
    5628:	8b 81       	ldd	r24, Y+3	; 0x03
    562a:	9c 81       	ldd	r25, Y+4	; 0x04
    562c:	8d 36       	cpi	r24, 0x6D	; 109
    562e:	91 05       	cpc	r25, r1
    5630:	29 f1       	breq	.+74     	; 0x567c <HSSD_voidDisplay+0xdc>
    5632:	3c c0       	rjmp	.+120    	; 0x56ac <HSSD_voidDisplay+0x10c>
    5634:	2b 81       	ldd	r18, Y+3	; 0x03
    5636:	3c 81       	ldd	r19, Y+4	; 0x04
    5638:	2d 37       	cpi	r18, 0x7D	; 125
    563a:	31 05       	cpc	r19, r1
    563c:	21 f1       	breq	.+72     	; 0x5686 <HSSD_voidDisplay+0xe6>
    563e:	8b 81       	ldd	r24, Y+3	; 0x03
    5640:	9c 81       	ldd	r25, Y+4	; 0x04
    5642:	8f 37       	cpi	r24, 0x7F	; 127
    5644:	91 05       	cpc	r25, r1
    5646:	49 f1       	breq	.+82     	; 0x569a <HSSD_voidDisplay+0xfa>
    5648:	31 c0       	rjmp	.+98     	; 0x56ac <HSSD_voidDisplay+0x10c>
	{
	case ZERO:
		MDIO_voidSetPortValue(A_u8PortId,ZERO);
    564a:	8a 81       	ldd	r24, Y+2	; 0x02
    564c:	6f e3       	ldi	r22, 0x3F	; 63
    564e:	0e 94 40 12 	call	0x2480	; 0x2480 <MDIO_voidSetPortValue>
    5652:	2c c0       	rjmp	.+88     	; 0x56ac <HSSD_voidDisplay+0x10c>
		break;
	case ONE:
		MDIO_voidSetPortValue(A_u8PortId,ONE);
    5654:	8a 81       	ldd	r24, Y+2	; 0x02
    5656:	66 e0       	ldi	r22, 0x06	; 6
    5658:	0e 94 40 12 	call	0x2480	; 0x2480 <MDIO_voidSetPortValue>
    565c:	27 c0       	rjmp	.+78     	; 0x56ac <HSSD_voidDisplay+0x10c>
		break;
	case TWO:
		MDIO_voidSetPortValue(A_u8PortId,TWO);
    565e:	8a 81       	ldd	r24, Y+2	; 0x02
    5660:	6b e5       	ldi	r22, 0x5B	; 91
    5662:	0e 94 40 12 	call	0x2480	; 0x2480 <MDIO_voidSetPortValue>
    5666:	22 c0       	rjmp	.+68     	; 0x56ac <HSSD_voidDisplay+0x10c>
		break;
	case THREE:
		MDIO_voidSetPortValue(A_u8PortId,THREE);
    5668:	8a 81       	ldd	r24, Y+2	; 0x02
    566a:	6f e4       	ldi	r22, 0x4F	; 79
    566c:	0e 94 40 12 	call	0x2480	; 0x2480 <MDIO_voidSetPortValue>
    5670:	1d c0       	rjmp	.+58     	; 0x56ac <HSSD_voidDisplay+0x10c>
		break;
	case FOUR:
		MDIO_voidSetPortValue(A_u8PortId,FOUR);
    5672:	8a 81       	ldd	r24, Y+2	; 0x02
    5674:	66 e6       	ldi	r22, 0x66	; 102
    5676:	0e 94 40 12 	call	0x2480	; 0x2480 <MDIO_voidSetPortValue>
    567a:	18 c0       	rjmp	.+48     	; 0x56ac <HSSD_voidDisplay+0x10c>
		break;
	case FIVE:
		MDIO_voidSetPortValue(A_u8PortId,FIVE);
    567c:	8a 81       	ldd	r24, Y+2	; 0x02
    567e:	6d e6       	ldi	r22, 0x6D	; 109
    5680:	0e 94 40 12 	call	0x2480	; 0x2480 <MDIO_voidSetPortValue>
    5684:	13 c0       	rjmp	.+38     	; 0x56ac <HSSD_voidDisplay+0x10c>
		break;
	case SIX:
		MDIO_voidSetPortValue(A_u8PortId,SIX);
    5686:	8a 81       	ldd	r24, Y+2	; 0x02
    5688:	6d e7       	ldi	r22, 0x7D	; 125
    568a:	0e 94 40 12 	call	0x2480	; 0x2480 <MDIO_voidSetPortValue>
    568e:	0e c0       	rjmp	.+28     	; 0x56ac <HSSD_voidDisplay+0x10c>
		break;
	case SEVEN:
		MDIO_voidSetPortValue(A_u8PortId,SEVEN);
    5690:	8a 81       	ldd	r24, Y+2	; 0x02
    5692:	67 e0       	ldi	r22, 0x07	; 7
    5694:	0e 94 40 12 	call	0x2480	; 0x2480 <MDIO_voidSetPortValue>
    5698:	09 c0       	rjmp	.+18     	; 0x56ac <HSSD_voidDisplay+0x10c>
		break;
	case EIGHT:
		MDIO_voidSetPortValue(A_u8PortId,EIGHT);
    569a:	8a 81       	ldd	r24, Y+2	; 0x02
    569c:	6f e7       	ldi	r22, 0x7F	; 127
    569e:	0e 94 40 12 	call	0x2480	; 0x2480 <MDIO_voidSetPortValue>
    56a2:	04 c0       	rjmp	.+8      	; 0x56ac <HSSD_voidDisplay+0x10c>
		break;
	case NINE:
		MDIO_voidSetPortValue(A_u8PortId,NINE);
    56a4:	8a 81       	ldd	r24, Y+2	; 0x02
    56a6:	6f e6       	ldi	r22, 0x6F	; 111
    56a8:	0e 94 40 12 	call	0x2480	; 0x2480 <MDIO_voidSetPortValue>
		break;
	}
}
    56ac:	0f 90       	pop	r0
    56ae:	0f 90       	pop	r0
    56b0:	0f 90       	pop	r0
    56b2:	0f 90       	pop	r0
    56b4:	cf 91       	pop	r28
    56b6:	df 91       	pop	r29
    56b8:	08 95       	ret

000056ba <HSSD_voidDisplayAscending>:

void HSSD_voidDisplayAscending(u8 A_u8PortId)
{
    56ba:	df 93       	push	r29
    56bc:	cf 93       	push	r28
    56be:	cd b7       	in	r28, 0x3d	; 61
    56c0:	de b7       	in	r29, 0x3e	; 62
    56c2:	6f 97       	sbiw	r28, 0x1f	; 31
    56c4:	0f b6       	in	r0, 0x3f	; 63
    56c6:	f8 94       	cli
    56c8:	de bf       	out	0x3e, r29	; 62
    56ca:	0f be       	out	0x3f, r0	; 63
    56cc:	cd bf       	out	0x3d, r28	; 61
    56ce:	8a 8f       	std	Y+26, r24	; 0x1a
u8 arr[]={ZERO,ONE,TWO,THREE,FOUR,FIVE,SIX,SEVEN,EIGHT,NINE};
    56d0:	ce 01       	movw	r24, r28
    56d2:	40 96       	adiw	r24, 0x10	; 16
    56d4:	9c 8f       	std	Y+28, r25	; 0x1c
    56d6:	8b 8f       	std	Y+27, r24	; 0x1b
    56d8:	ef e8       	ldi	r30, 0x8F	; 143
    56da:	f1 e0       	ldi	r31, 0x01	; 1
    56dc:	fe 8f       	std	Y+30, r31	; 0x1e
    56de:	ed 8f       	std	Y+29, r30	; 0x1d
    56e0:	fa e0       	ldi	r31, 0x0A	; 10
    56e2:	ff 8f       	std	Y+31, r31	; 0x1f
    56e4:	ed 8d       	ldd	r30, Y+29	; 0x1d
    56e6:	fe 8d       	ldd	r31, Y+30	; 0x1e
    56e8:	00 80       	ld	r0, Z
    56ea:	8d 8d       	ldd	r24, Y+29	; 0x1d
    56ec:	9e 8d       	ldd	r25, Y+30	; 0x1e
    56ee:	01 96       	adiw	r24, 0x01	; 1
    56f0:	9e 8f       	std	Y+30, r25	; 0x1e
    56f2:	8d 8f       	std	Y+29, r24	; 0x1d
    56f4:	eb 8d       	ldd	r30, Y+27	; 0x1b
    56f6:	fc 8d       	ldd	r31, Y+28	; 0x1c
    56f8:	00 82       	st	Z, r0
    56fa:	8b 8d       	ldd	r24, Y+27	; 0x1b
    56fc:	9c 8d       	ldd	r25, Y+28	; 0x1c
    56fe:	01 96       	adiw	r24, 0x01	; 1
    5700:	9c 8f       	std	Y+28, r25	; 0x1c
    5702:	8b 8f       	std	Y+27, r24	; 0x1b
    5704:	9f 8d       	ldd	r25, Y+31	; 0x1f
    5706:	91 50       	subi	r25, 0x01	; 1
    5708:	9f 8f       	std	Y+31, r25	; 0x1f
    570a:	ef 8d       	ldd	r30, Y+31	; 0x1f
    570c:	ee 23       	and	r30, r30
    570e:	51 f7       	brne	.-44     	; 0x56e4 <HSSD_voidDisplayAscending+0x2a>
	for(u8 i=0;i<10;i++)
    5710:	1f 86       	std	Y+15, r1	; 0x0f
    5712:	81 c0       	rjmp	.+258    	; 0x5816 <HSSD_voidDisplayAscending+0x15c>
	{
		HSSD_voidDisplay(arr[i],A_u8PortId);
    5714:	8f 85       	ldd	r24, Y+15	; 0x0f
    5716:	28 2f       	mov	r18, r24
    5718:	30 e0       	ldi	r19, 0x00	; 0
    571a:	ce 01       	movw	r24, r28
    571c:	40 96       	adiw	r24, 0x10	; 16
    571e:	fc 01       	movw	r30, r24
    5720:	e2 0f       	add	r30, r18
    5722:	f3 1f       	adc	r31, r19
    5724:	80 81       	ld	r24, Z
    5726:	6a 8d       	ldd	r22, Y+26	; 0x1a
    5728:	0e 94 d0 2a 	call	0x55a0	; 0x55a0 <HSSD_voidDisplay>
    572c:	80 e0       	ldi	r24, 0x00	; 0
    572e:	90 e0       	ldi	r25, 0x00	; 0
    5730:	aa e7       	ldi	r26, 0x7A	; 122
    5732:	b4 e4       	ldi	r27, 0x44	; 68
    5734:	8b 87       	std	Y+11, r24	; 0x0b
    5736:	9c 87       	std	Y+12, r25	; 0x0c
    5738:	ad 87       	std	Y+13, r26	; 0x0d
    573a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    573c:	6b 85       	ldd	r22, Y+11	; 0x0b
    573e:	7c 85       	ldd	r23, Y+12	; 0x0c
    5740:	8d 85       	ldd	r24, Y+13	; 0x0d
    5742:	9e 85       	ldd	r25, Y+14	; 0x0e
    5744:	20 e0       	ldi	r18, 0x00	; 0
    5746:	30 e0       	ldi	r19, 0x00	; 0
    5748:	4a ef       	ldi	r20, 0xFA	; 250
    574a:	54 e4       	ldi	r21, 0x44	; 68
    574c:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    5750:	dc 01       	movw	r26, r24
    5752:	cb 01       	movw	r24, r22
    5754:	8f 83       	std	Y+7, r24	; 0x07
    5756:	98 87       	std	Y+8, r25	; 0x08
    5758:	a9 87       	std	Y+9, r26	; 0x09
    575a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    575c:	6f 81       	ldd	r22, Y+7	; 0x07
    575e:	78 85       	ldd	r23, Y+8	; 0x08
    5760:	89 85       	ldd	r24, Y+9	; 0x09
    5762:	9a 85       	ldd	r25, Y+10	; 0x0a
    5764:	20 e0       	ldi	r18, 0x00	; 0
    5766:	30 e0       	ldi	r19, 0x00	; 0
    5768:	40 e8       	ldi	r20, 0x80	; 128
    576a:	5f e3       	ldi	r21, 0x3F	; 63
    576c:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    5770:	88 23       	and	r24, r24
    5772:	2c f4       	brge	.+10     	; 0x577e <HSSD_voidDisplayAscending+0xc4>
		__ticks = 1;
    5774:	81 e0       	ldi	r24, 0x01	; 1
    5776:	90 e0       	ldi	r25, 0x00	; 0
    5778:	9e 83       	std	Y+6, r25	; 0x06
    577a:	8d 83       	std	Y+5, r24	; 0x05
    577c:	3f c0       	rjmp	.+126    	; 0x57fc <HSSD_voidDisplayAscending+0x142>
	else if (__tmp > 65535)
    577e:	6f 81       	ldd	r22, Y+7	; 0x07
    5780:	78 85       	ldd	r23, Y+8	; 0x08
    5782:	89 85       	ldd	r24, Y+9	; 0x09
    5784:	9a 85       	ldd	r25, Y+10	; 0x0a
    5786:	20 e0       	ldi	r18, 0x00	; 0
    5788:	3f ef       	ldi	r19, 0xFF	; 255
    578a:	4f e7       	ldi	r20, 0x7F	; 127
    578c:	57 e4       	ldi	r21, 0x47	; 71
    578e:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    5792:	18 16       	cp	r1, r24
    5794:	4c f5       	brge	.+82     	; 0x57e8 <HSSD_voidDisplayAscending+0x12e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5796:	6b 85       	ldd	r22, Y+11	; 0x0b
    5798:	7c 85       	ldd	r23, Y+12	; 0x0c
    579a:	8d 85       	ldd	r24, Y+13	; 0x0d
    579c:	9e 85       	ldd	r25, Y+14	; 0x0e
    579e:	20 e0       	ldi	r18, 0x00	; 0
    57a0:	30 e0       	ldi	r19, 0x00	; 0
    57a2:	40 e2       	ldi	r20, 0x20	; 32
    57a4:	51 e4       	ldi	r21, 0x41	; 65
    57a6:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    57aa:	dc 01       	movw	r26, r24
    57ac:	cb 01       	movw	r24, r22
    57ae:	bc 01       	movw	r22, r24
    57b0:	cd 01       	movw	r24, r26
    57b2:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    57b6:	dc 01       	movw	r26, r24
    57b8:	cb 01       	movw	r24, r22
    57ba:	9e 83       	std	Y+6, r25	; 0x06
    57bc:	8d 83       	std	Y+5, r24	; 0x05
    57be:	0f c0       	rjmp	.+30     	; 0x57de <HSSD_voidDisplayAscending+0x124>
    57c0:	88 ec       	ldi	r24, 0xC8	; 200
    57c2:	90 e0       	ldi	r25, 0x00	; 0
    57c4:	9c 83       	std	Y+4, r25	; 0x04
    57c6:	8b 83       	std	Y+3, r24	; 0x03
    57c8:	8b 81       	ldd	r24, Y+3	; 0x03
    57ca:	9c 81       	ldd	r25, Y+4	; 0x04
    57cc:	01 97       	sbiw	r24, 0x01	; 1
    57ce:	f1 f7       	brne	.-4      	; 0x57cc <HSSD_voidDisplayAscending+0x112>
    57d0:	9c 83       	std	Y+4, r25	; 0x04
    57d2:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    57d4:	8d 81       	ldd	r24, Y+5	; 0x05
    57d6:	9e 81       	ldd	r25, Y+6	; 0x06
    57d8:	01 97       	sbiw	r24, 0x01	; 1
    57da:	9e 83       	std	Y+6, r25	; 0x06
    57dc:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    57de:	8d 81       	ldd	r24, Y+5	; 0x05
    57e0:	9e 81       	ldd	r25, Y+6	; 0x06
    57e2:	00 97       	sbiw	r24, 0x00	; 0
    57e4:	69 f7       	brne	.-38     	; 0x57c0 <HSSD_voidDisplayAscending+0x106>
    57e6:	14 c0       	rjmp	.+40     	; 0x5810 <HSSD_voidDisplayAscending+0x156>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    57e8:	6f 81       	ldd	r22, Y+7	; 0x07
    57ea:	78 85       	ldd	r23, Y+8	; 0x08
    57ec:	89 85       	ldd	r24, Y+9	; 0x09
    57ee:	9a 85       	ldd	r25, Y+10	; 0x0a
    57f0:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    57f4:	dc 01       	movw	r26, r24
    57f6:	cb 01       	movw	r24, r22
    57f8:	9e 83       	std	Y+6, r25	; 0x06
    57fa:	8d 83       	std	Y+5, r24	; 0x05
    57fc:	8d 81       	ldd	r24, Y+5	; 0x05
    57fe:	9e 81       	ldd	r25, Y+6	; 0x06
    5800:	9a 83       	std	Y+2, r25	; 0x02
    5802:	89 83       	std	Y+1, r24	; 0x01
    5804:	89 81       	ldd	r24, Y+1	; 0x01
    5806:	9a 81       	ldd	r25, Y+2	; 0x02
    5808:	01 97       	sbiw	r24, 0x01	; 1
    580a:	f1 f7       	brne	.-4      	; 0x5808 <HSSD_voidDisplayAscending+0x14e>
    580c:	9a 83       	std	Y+2, r25	; 0x02
    580e:	89 83       	std	Y+1, r24	; 0x01
}

void HSSD_voidDisplayAscending(u8 A_u8PortId)
{
u8 arr[]={ZERO,ONE,TWO,THREE,FOUR,FIVE,SIX,SEVEN,EIGHT,NINE};
	for(u8 i=0;i<10;i++)
    5810:	8f 85       	ldd	r24, Y+15	; 0x0f
    5812:	8f 5f       	subi	r24, 0xFF	; 255
    5814:	8f 87       	std	Y+15, r24	; 0x0f
    5816:	8f 85       	ldd	r24, Y+15	; 0x0f
    5818:	8a 30       	cpi	r24, 0x0A	; 10
    581a:	08 f4       	brcc	.+2      	; 0x581e <HSSD_voidDisplayAscending+0x164>
    581c:	7b cf       	rjmp	.-266    	; 0x5714 <HSSD_voidDisplayAscending+0x5a>
	{
		HSSD_voidDisplay(arr[i],A_u8PortId);
		_delay_ms(SSD_DELAY);
	}
}
    581e:	6f 96       	adiw	r28, 0x1f	; 31
    5820:	0f b6       	in	r0, 0x3f	; 63
    5822:	f8 94       	cli
    5824:	de bf       	out	0x3e, r29	; 62
    5826:	0f be       	out	0x3f, r0	; 63
    5828:	cd bf       	out	0x3d, r28	; 61
    582a:	cf 91       	pop	r28
    582c:	df 91       	pop	r29
    582e:	08 95       	ret

00005830 <HSSD_voidDisplayDescending>:

void HSSD_voidDisplayDescending(u8 A_u8PortId)
{
    5830:	df 93       	push	r29
    5832:	cf 93       	push	r28
    5834:	cd b7       	in	r28, 0x3d	; 61
    5836:	de b7       	in	r29, 0x3e	; 62
    5838:	6f 97       	sbiw	r28, 0x1f	; 31
    583a:	0f b6       	in	r0, 0x3f	; 63
    583c:	f8 94       	cli
    583e:	de bf       	out	0x3e, r29	; 62
    5840:	0f be       	out	0x3f, r0	; 63
    5842:	cd bf       	out	0x3d, r28	; 61
    5844:	8a 8f       	std	Y+26, r24	; 0x1a
u8 arr[]={ZERO,ONE,TWO,THREE,FOUR,FIVE,SIX,SEVEN,EIGHT,NINE};
    5846:	ce 01       	movw	r24, r28
    5848:	40 96       	adiw	r24, 0x10	; 16
    584a:	9c 8f       	std	Y+28, r25	; 0x1c
    584c:	8b 8f       	std	Y+27, r24	; 0x1b
    584e:	e9 e9       	ldi	r30, 0x99	; 153
    5850:	f1 e0       	ldi	r31, 0x01	; 1
    5852:	fe 8f       	std	Y+30, r31	; 0x1e
    5854:	ed 8f       	std	Y+29, r30	; 0x1d
    5856:	fa e0       	ldi	r31, 0x0A	; 10
    5858:	ff 8f       	std	Y+31, r31	; 0x1f
    585a:	ed 8d       	ldd	r30, Y+29	; 0x1d
    585c:	fe 8d       	ldd	r31, Y+30	; 0x1e
    585e:	00 80       	ld	r0, Z
    5860:	8d 8d       	ldd	r24, Y+29	; 0x1d
    5862:	9e 8d       	ldd	r25, Y+30	; 0x1e
    5864:	01 96       	adiw	r24, 0x01	; 1
    5866:	9e 8f       	std	Y+30, r25	; 0x1e
    5868:	8d 8f       	std	Y+29, r24	; 0x1d
    586a:	eb 8d       	ldd	r30, Y+27	; 0x1b
    586c:	fc 8d       	ldd	r31, Y+28	; 0x1c
    586e:	00 82       	st	Z, r0
    5870:	8b 8d       	ldd	r24, Y+27	; 0x1b
    5872:	9c 8d       	ldd	r25, Y+28	; 0x1c
    5874:	01 96       	adiw	r24, 0x01	; 1
    5876:	9c 8f       	std	Y+28, r25	; 0x1c
    5878:	8b 8f       	std	Y+27, r24	; 0x1b
    587a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    587c:	91 50       	subi	r25, 0x01	; 1
    587e:	9f 8f       	std	Y+31, r25	; 0x1f
    5880:	ef 8d       	ldd	r30, Y+31	; 0x1f
    5882:	ee 23       	and	r30, r30
    5884:	51 f7       	brne	.-44     	; 0x585a <HSSD_voidDisplayDescending+0x2a>
	for(u8 j=9;j>=0;j--)
    5886:	89 e0       	ldi	r24, 0x09	; 9
    5888:	8f 87       	std	Y+15, r24	; 0x0f
	{
		HSSD_voidDisplay(arr[j],A_u8PortId);
    588a:	8f 85       	ldd	r24, Y+15	; 0x0f
    588c:	28 2f       	mov	r18, r24
    588e:	30 e0       	ldi	r19, 0x00	; 0
    5890:	ce 01       	movw	r24, r28
    5892:	40 96       	adiw	r24, 0x10	; 16
    5894:	fc 01       	movw	r30, r24
    5896:	e2 0f       	add	r30, r18
    5898:	f3 1f       	adc	r31, r19
    589a:	80 81       	ld	r24, Z
    589c:	6a 8d       	ldd	r22, Y+26	; 0x1a
    589e:	0e 94 d0 2a 	call	0x55a0	; 0x55a0 <HSSD_voidDisplay>
    58a2:	80 e0       	ldi	r24, 0x00	; 0
    58a4:	90 e0       	ldi	r25, 0x00	; 0
    58a6:	aa e7       	ldi	r26, 0x7A	; 122
    58a8:	b4 e4       	ldi	r27, 0x44	; 68
    58aa:	8b 87       	std	Y+11, r24	; 0x0b
    58ac:	9c 87       	std	Y+12, r25	; 0x0c
    58ae:	ad 87       	std	Y+13, r26	; 0x0d
    58b0:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    58b2:	6b 85       	ldd	r22, Y+11	; 0x0b
    58b4:	7c 85       	ldd	r23, Y+12	; 0x0c
    58b6:	8d 85       	ldd	r24, Y+13	; 0x0d
    58b8:	9e 85       	ldd	r25, Y+14	; 0x0e
    58ba:	20 e0       	ldi	r18, 0x00	; 0
    58bc:	30 e0       	ldi	r19, 0x00	; 0
    58be:	4a ef       	ldi	r20, 0xFA	; 250
    58c0:	54 e4       	ldi	r21, 0x44	; 68
    58c2:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    58c6:	dc 01       	movw	r26, r24
    58c8:	cb 01       	movw	r24, r22
    58ca:	8f 83       	std	Y+7, r24	; 0x07
    58cc:	98 87       	std	Y+8, r25	; 0x08
    58ce:	a9 87       	std	Y+9, r26	; 0x09
    58d0:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    58d2:	6f 81       	ldd	r22, Y+7	; 0x07
    58d4:	78 85       	ldd	r23, Y+8	; 0x08
    58d6:	89 85       	ldd	r24, Y+9	; 0x09
    58d8:	9a 85       	ldd	r25, Y+10	; 0x0a
    58da:	20 e0       	ldi	r18, 0x00	; 0
    58dc:	30 e0       	ldi	r19, 0x00	; 0
    58de:	40 e8       	ldi	r20, 0x80	; 128
    58e0:	5f e3       	ldi	r21, 0x3F	; 63
    58e2:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    58e6:	88 23       	and	r24, r24
    58e8:	2c f4       	brge	.+10     	; 0x58f4 <HSSD_voidDisplayDescending+0xc4>
		__ticks = 1;
    58ea:	81 e0       	ldi	r24, 0x01	; 1
    58ec:	90 e0       	ldi	r25, 0x00	; 0
    58ee:	9e 83       	std	Y+6, r25	; 0x06
    58f0:	8d 83       	std	Y+5, r24	; 0x05
    58f2:	3f c0       	rjmp	.+126    	; 0x5972 <HSSD_voidDisplayDescending+0x142>
	else if (__tmp > 65535)
    58f4:	6f 81       	ldd	r22, Y+7	; 0x07
    58f6:	78 85       	ldd	r23, Y+8	; 0x08
    58f8:	89 85       	ldd	r24, Y+9	; 0x09
    58fa:	9a 85       	ldd	r25, Y+10	; 0x0a
    58fc:	20 e0       	ldi	r18, 0x00	; 0
    58fe:	3f ef       	ldi	r19, 0xFF	; 255
    5900:	4f e7       	ldi	r20, 0x7F	; 127
    5902:	57 e4       	ldi	r21, 0x47	; 71
    5904:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    5908:	18 16       	cp	r1, r24
    590a:	4c f5       	brge	.+82     	; 0x595e <HSSD_voidDisplayDescending+0x12e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    590c:	6b 85       	ldd	r22, Y+11	; 0x0b
    590e:	7c 85       	ldd	r23, Y+12	; 0x0c
    5910:	8d 85       	ldd	r24, Y+13	; 0x0d
    5912:	9e 85       	ldd	r25, Y+14	; 0x0e
    5914:	20 e0       	ldi	r18, 0x00	; 0
    5916:	30 e0       	ldi	r19, 0x00	; 0
    5918:	40 e2       	ldi	r20, 0x20	; 32
    591a:	51 e4       	ldi	r21, 0x41	; 65
    591c:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    5920:	dc 01       	movw	r26, r24
    5922:	cb 01       	movw	r24, r22
    5924:	bc 01       	movw	r22, r24
    5926:	cd 01       	movw	r24, r26
    5928:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    592c:	dc 01       	movw	r26, r24
    592e:	cb 01       	movw	r24, r22
    5930:	9e 83       	std	Y+6, r25	; 0x06
    5932:	8d 83       	std	Y+5, r24	; 0x05
    5934:	0f c0       	rjmp	.+30     	; 0x5954 <HSSD_voidDisplayDescending+0x124>
    5936:	88 ec       	ldi	r24, 0xC8	; 200
    5938:	90 e0       	ldi	r25, 0x00	; 0
    593a:	9c 83       	std	Y+4, r25	; 0x04
    593c:	8b 83       	std	Y+3, r24	; 0x03
    593e:	8b 81       	ldd	r24, Y+3	; 0x03
    5940:	9c 81       	ldd	r25, Y+4	; 0x04
    5942:	01 97       	sbiw	r24, 0x01	; 1
    5944:	f1 f7       	brne	.-4      	; 0x5942 <HSSD_voidDisplayDescending+0x112>
    5946:	9c 83       	std	Y+4, r25	; 0x04
    5948:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    594a:	8d 81       	ldd	r24, Y+5	; 0x05
    594c:	9e 81       	ldd	r25, Y+6	; 0x06
    594e:	01 97       	sbiw	r24, 0x01	; 1
    5950:	9e 83       	std	Y+6, r25	; 0x06
    5952:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5954:	8d 81       	ldd	r24, Y+5	; 0x05
    5956:	9e 81       	ldd	r25, Y+6	; 0x06
    5958:	00 97       	sbiw	r24, 0x00	; 0
    595a:	69 f7       	brne	.-38     	; 0x5936 <HSSD_voidDisplayDescending+0x106>
    595c:	14 c0       	rjmp	.+40     	; 0x5986 <HSSD_voidDisplayDescending+0x156>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    595e:	6f 81       	ldd	r22, Y+7	; 0x07
    5960:	78 85       	ldd	r23, Y+8	; 0x08
    5962:	89 85       	ldd	r24, Y+9	; 0x09
    5964:	9a 85       	ldd	r25, Y+10	; 0x0a
    5966:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    596a:	dc 01       	movw	r26, r24
    596c:	cb 01       	movw	r24, r22
    596e:	9e 83       	std	Y+6, r25	; 0x06
    5970:	8d 83       	std	Y+5, r24	; 0x05
    5972:	8d 81       	ldd	r24, Y+5	; 0x05
    5974:	9e 81       	ldd	r25, Y+6	; 0x06
    5976:	9a 83       	std	Y+2, r25	; 0x02
    5978:	89 83       	std	Y+1, r24	; 0x01
    597a:	89 81       	ldd	r24, Y+1	; 0x01
    597c:	9a 81       	ldd	r25, Y+2	; 0x02
    597e:	01 97       	sbiw	r24, 0x01	; 1
    5980:	f1 f7       	brne	.-4      	; 0x597e <HSSD_voidDisplayDescending+0x14e>
    5982:	9a 83       	std	Y+2, r25	; 0x02
    5984:	89 83       	std	Y+1, r24	; 0x01
}

void HSSD_voidDisplayDescending(u8 A_u8PortId)
{
u8 arr[]={ZERO,ONE,TWO,THREE,FOUR,FIVE,SIX,SEVEN,EIGHT,NINE};
	for(u8 j=9;j>=0;j--)
    5986:	8f 85       	ldd	r24, Y+15	; 0x0f
    5988:	81 50       	subi	r24, 0x01	; 1
    598a:	8f 87       	std	Y+15, r24	; 0x0f
    598c:	7e cf       	rjmp	.-260    	; 0x588a <HSSD_voidDisplayDescending+0x5a>

0000598e <HSTEP_voidFullStep>:
#include "../Include/HAL/STEPPER/STEPPER_Private.h"

#include <util/delay.h>

void HSTEP_voidFullStep()
{
    598e:	df 93       	push	r29
    5990:	cf 93       	push	r28
    5992:	cd b7       	in	r28, 0x3d	; 61
    5994:	de b7       	in	r29, 0x3e	; 62
    5996:	e8 97       	sbiw	r28, 0x38	; 56
    5998:	0f b6       	in	r0, 0x3f	; 63
    599a:	f8 94       	cli
    599c:	de bf       	out	0x3e, r29	; 62
    599e:	0f be       	out	0x3f, r0	; 63
    59a0:	cd bf       	out	0x3d, r28	; 61
    MDIO_voidSetPinValue(STEPPER_PORT,BLUE_COIL_PIN,PIN_HIGH);
    59a2:	80 e0       	ldi	r24, 0x00	; 0
    59a4:	60 e0       	ldi	r22, 0x00	; 0
    59a6:	41 e0       	ldi	r20, 0x01	; 1
    59a8:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,PINK_COIL_PIN,PIN_LOW);
    59ac:	80 e0       	ldi	r24, 0x00	; 0
    59ae:	61 e0       	ldi	r22, 0x01	; 1
    59b0:	40 e0       	ldi	r20, 0x00	; 0
    59b2:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,YELLOW_COIL_PIN,PIN_HIGH);
    59b6:	80 e0       	ldi	r24, 0x00	; 0
    59b8:	62 e0       	ldi	r22, 0x02	; 2
    59ba:	41 e0       	ldi	r20, 0x01	; 1
    59bc:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,ORANGE_COIL_PIN,PIN_HIGH);
    59c0:	80 e0       	ldi	r24, 0x00	; 0
    59c2:	63 e0       	ldi	r22, 0x03	; 3
    59c4:	41 e0       	ldi	r20, 0x01	; 1
    59c6:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    59ca:	80 e0       	ldi	r24, 0x00	; 0
    59cc:	90 e0       	ldi	r25, 0x00	; 0
    59ce:	a0 e2       	ldi	r26, 0x20	; 32
    59d0:	b1 e4       	ldi	r27, 0x41	; 65
    59d2:	8d ab       	std	Y+53, r24	; 0x35
    59d4:	9e ab       	std	Y+54, r25	; 0x36
    59d6:	af ab       	std	Y+55, r26	; 0x37
    59d8:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    59da:	6d a9       	ldd	r22, Y+53	; 0x35
    59dc:	7e a9       	ldd	r23, Y+54	; 0x36
    59de:	8f a9       	ldd	r24, Y+55	; 0x37
    59e0:	98 ad       	ldd	r25, Y+56	; 0x38
    59e2:	20 e0       	ldi	r18, 0x00	; 0
    59e4:	30 e0       	ldi	r19, 0x00	; 0
    59e6:	4a ef       	ldi	r20, 0xFA	; 250
    59e8:	54 e4       	ldi	r21, 0x44	; 68
    59ea:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    59ee:	dc 01       	movw	r26, r24
    59f0:	cb 01       	movw	r24, r22
    59f2:	89 ab       	std	Y+49, r24	; 0x31
    59f4:	9a ab       	std	Y+50, r25	; 0x32
    59f6:	ab ab       	std	Y+51, r26	; 0x33
    59f8:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    59fa:	69 a9       	ldd	r22, Y+49	; 0x31
    59fc:	7a a9       	ldd	r23, Y+50	; 0x32
    59fe:	8b a9       	ldd	r24, Y+51	; 0x33
    5a00:	9c a9       	ldd	r25, Y+52	; 0x34
    5a02:	20 e0       	ldi	r18, 0x00	; 0
    5a04:	30 e0       	ldi	r19, 0x00	; 0
    5a06:	40 e8       	ldi	r20, 0x80	; 128
    5a08:	5f e3       	ldi	r21, 0x3F	; 63
    5a0a:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    5a0e:	88 23       	and	r24, r24
    5a10:	2c f4       	brge	.+10     	; 0x5a1c <HSTEP_voidFullStep+0x8e>
		__ticks = 1;
    5a12:	81 e0       	ldi	r24, 0x01	; 1
    5a14:	90 e0       	ldi	r25, 0x00	; 0
    5a16:	98 ab       	std	Y+48, r25	; 0x30
    5a18:	8f a7       	std	Y+47, r24	; 0x2f
    5a1a:	3f c0       	rjmp	.+126    	; 0x5a9a <HSTEP_voidFullStep+0x10c>
	else if (__tmp > 65535)
    5a1c:	69 a9       	ldd	r22, Y+49	; 0x31
    5a1e:	7a a9       	ldd	r23, Y+50	; 0x32
    5a20:	8b a9       	ldd	r24, Y+51	; 0x33
    5a22:	9c a9       	ldd	r25, Y+52	; 0x34
    5a24:	20 e0       	ldi	r18, 0x00	; 0
    5a26:	3f ef       	ldi	r19, 0xFF	; 255
    5a28:	4f e7       	ldi	r20, 0x7F	; 127
    5a2a:	57 e4       	ldi	r21, 0x47	; 71
    5a2c:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    5a30:	18 16       	cp	r1, r24
    5a32:	4c f5       	brge	.+82     	; 0x5a86 <HSTEP_voidFullStep+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5a34:	6d a9       	ldd	r22, Y+53	; 0x35
    5a36:	7e a9       	ldd	r23, Y+54	; 0x36
    5a38:	8f a9       	ldd	r24, Y+55	; 0x37
    5a3a:	98 ad       	ldd	r25, Y+56	; 0x38
    5a3c:	20 e0       	ldi	r18, 0x00	; 0
    5a3e:	30 e0       	ldi	r19, 0x00	; 0
    5a40:	40 e2       	ldi	r20, 0x20	; 32
    5a42:	51 e4       	ldi	r21, 0x41	; 65
    5a44:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    5a48:	dc 01       	movw	r26, r24
    5a4a:	cb 01       	movw	r24, r22
    5a4c:	bc 01       	movw	r22, r24
    5a4e:	cd 01       	movw	r24, r26
    5a50:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    5a54:	dc 01       	movw	r26, r24
    5a56:	cb 01       	movw	r24, r22
    5a58:	98 ab       	std	Y+48, r25	; 0x30
    5a5a:	8f a7       	std	Y+47, r24	; 0x2f
    5a5c:	0f c0       	rjmp	.+30     	; 0x5a7c <HSTEP_voidFullStep+0xee>
    5a5e:	88 ec       	ldi	r24, 0xC8	; 200
    5a60:	90 e0       	ldi	r25, 0x00	; 0
    5a62:	9e a7       	std	Y+46, r25	; 0x2e
    5a64:	8d a7       	std	Y+45, r24	; 0x2d
    5a66:	8d a5       	ldd	r24, Y+45	; 0x2d
    5a68:	9e a5       	ldd	r25, Y+46	; 0x2e
    5a6a:	01 97       	sbiw	r24, 0x01	; 1
    5a6c:	f1 f7       	brne	.-4      	; 0x5a6a <HSTEP_voidFullStep+0xdc>
    5a6e:	9e a7       	std	Y+46, r25	; 0x2e
    5a70:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5a72:	8f a5       	ldd	r24, Y+47	; 0x2f
    5a74:	98 a9       	ldd	r25, Y+48	; 0x30
    5a76:	01 97       	sbiw	r24, 0x01	; 1
    5a78:	98 ab       	std	Y+48, r25	; 0x30
    5a7a:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5a7c:	8f a5       	ldd	r24, Y+47	; 0x2f
    5a7e:	98 a9       	ldd	r25, Y+48	; 0x30
    5a80:	00 97       	sbiw	r24, 0x00	; 0
    5a82:	69 f7       	brne	.-38     	; 0x5a5e <HSTEP_voidFullStep+0xd0>
    5a84:	14 c0       	rjmp	.+40     	; 0x5aae <HSTEP_voidFullStep+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5a86:	69 a9       	ldd	r22, Y+49	; 0x31
    5a88:	7a a9       	ldd	r23, Y+50	; 0x32
    5a8a:	8b a9       	ldd	r24, Y+51	; 0x33
    5a8c:	9c a9       	ldd	r25, Y+52	; 0x34
    5a8e:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    5a92:	dc 01       	movw	r26, r24
    5a94:	cb 01       	movw	r24, r22
    5a96:	98 ab       	std	Y+48, r25	; 0x30
    5a98:	8f a7       	std	Y+47, r24	; 0x2f
    5a9a:	8f a5       	ldd	r24, Y+47	; 0x2f
    5a9c:	98 a9       	ldd	r25, Y+48	; 0x30
    5a9e:	9c a7       	std	Y+44, r25	; 0x2c
    5aa0:	8b a7       	std	Y+43, r24	; 0x2b
    5aa2:	8b a5       	ldd	r24, Y+43	; 0x2b
    5aa4:	9c a5       	ldd	r25, Y+44	; 0x2c
    5aa6:	01 97       	sbiw	r24, 0x01	; 1
    5aa8:	f1 f7       	brne	.-4      	; 0x5aa6 <HSTEP_voidFullStep+0x118>
    5aaa:	9c a7       	std	Y+44, r25	; 0x2c
    5aac:	8b a7       	std	Y+43, r24	; 0x2b
    _delay_ms(10);
    MDIO_voidSetPinValue(STEPPER_PORT,BLUE_COIL_PIN,PIN_HIGH);
    5aae:	80 e0       	ldi	r24, 0x00	; 0
    5ab0:	60 e0       	ldi	r22, 0x00	; 0
    5ab2:	41 e0       	ldi	r20, 0x01	; 1
    5ab4:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,PINK_COIL_PIN,PIN_HIGH);
    5ab8:	80 e0       	ldi	r24, 0x00	; 0
    5aba:	61 e0       	ldi	r22, 0x01	; 1
    5abc:	41 e0       	ldi	r20, 0x01	; 1
    5abe:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,YELLOW_COIL_PIN,PIN_LOW);
    5ac2:	80 e0       	ldi	r24, 0x00	; 0
    5ac4:	62 e0       	ldi	r22, 0x02	; 2
    5ac6:	40 e0       	ldi	r20, 0x00	; 0
    5ac8:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,ORANGE_COIL_PIN,PIN_HIGH);
    5acc:	80 e0       	ldi	r24, 0x00	; 0
    5ace:	63 e0       	ldi	r22, 0x03	; 3
    5ad0:	41 e0       	ldi	r20, 0x01	; 1
    5ad2:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    5ad6:	80 e0       	ldi	r24, 0x00	; 0
    5ad8:	90 e0       	ldi	r25, 0x00	; 0
    5ada:	a0 e2       	ldi	r26, 0x20	; 32
    5adc:	b1 e4       	ldi	r27, 0x41	; 65
    5ade:	8f a3       	std	Y+39, r24	; 0x27
    5ae0:	98 a7       	std	Y+40, r25	; 0x28
    5ae2:	a9 a7       	std	Y+41, r26	; 0x29
    5ae4:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5ae6:	6f a1       	ldd	r22, Y+39	; 0x27
    5ae8:	78 a5       	ldd	r23, Y+40	; 0x28
    5aea:	89 a5       	ldd	r24, Y+41	; 0x29
    5aec:	9a a5       	ldd	r25, Y+42	; 0x2a
    5aee:	20 e0       	ldi	r18, 0x00	; 0
    5af0:	30 e0       	ldi	r19, 0x00	; 0
    5af2:	4a ef       	ldi	r20, 0xFA	; 250
    5af4:	54 e4       	ldi	r21, 0x44	; 68
    5af6:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    5afa:	dc 01       	movw	r26, r24
    5afc:	cb 01       	movw	r24, r22
    5afe:	8b a3       	std	Y+35, r24	; 0x23
    5b00:	9c a3       	std	Y+36, r25	; 0x24
    5b02:	ad a3       	std	Y+37, r26	; 0x25
    5b04:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    5b06:	6b a1       	ldd	r22, Y+35	; 0x23
    5b08:	7c a1       	ldd	r23, Y+36	; 0x24
    5b0a:	8d a1       	ldd	r24, Y+37	; 0x25
    5b0c:	9e a1       	ldd	r25, Y+38	; 0x26
    5b0e:	20 e0       	ldi	r18, 0x00	; 0
    5b10:	30 e0       	ldi	r19, 0x00	; 0
    5b12:	40 e8       	ldi	r20, 0x80	; 128
    5b14:	5f e3       	ldi	r21, 0x3F	; 63
    5b16:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    5b1a:	88 23       	and	r24, r24
    5b1c:	2c f4       	brge	.+10     	; 0x5b28 <HSTEP_voidFullStep+0x19a>
		__ticks = 1;
    5b1e:	81 e0       	ldi	r24, 0x01	; 1
    5b20:	90 e0       	ldi	r25, 0x00	; 0
    5b22:	9a a3       	std	Y+34, r25	; 0x22
    5b24:	89 a3       	std	Y+33, r24	; 0x21
    5b26:	3f c0       	rjmp	.+126    	; 0x5ba6 <HSTEP_voidFullStep+0x218>
	else if (__tmp > 65535)
    5b28:	6b a1       	ldd	r22, Y+35	; 0x23
    5b2a:	7c a1       	ldd	r23, Y+36	; 0x24
    5b2c:	8d a1       	ldd	r24, Y+37	; 0x25
    5b2e:	9e a1       	ldd	r25, Y+38	; 0x26
    5b30:	20 e0       	ldi	r18, 0x00	; 0
    5b32:	3f ef       	ldi	r19, 0xFF	; 255
    5b34:	4f e7       	ldi	r20, 0x7F	; 127
    5b36:	57 e4       	ldi	r21, 0x47	; 71
    5b38:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    5b3c:	18 16       	cp	r1, r24
    5b3e:	4c f5       	brge	.+82     	; 0x5b92 <HSTEP_voidFullStep+0x204>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5b40:	6f a1       	ldd	r22, Y+39	; 0x27
    5b42:	78 a5       	ldd	r23, Y+40	; 0x28
    5b44:	89 a5       	ldd	r24, Y+41	; 0x29
    5b46:	9a a5       	ldd	r25, Y+42	; 0x2a
    5b48:	20 e0       	ldi	r18, 0x00	; 0
    5b4a:	30 e0       	ldi	r19, 0x00	; 0
    5b4c:	40 e2       	ldi	r20, 0x20	; 32
    5b4e:	51 e4       	ldi	r21, 0x41	; 65
    5b50:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    5b54:	dc 01       	movw	r26, r24
    5b56:	cb 01       	movw	r24, r22
    5b58:	bc 01       	movw	r22, r24
    5b5a:	cd 01       	movw	r24, r26
    5b5c:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    5b60:	dc 01       	movw	r26, r24
    5b62:	cb 01       	movw	r24, r22
    5b64:	9a a3       	std	Y+34, r25	; 0x22
    5b66:	89 a3       	std	Y+33, r24	; 0x21
    5b68:	0f c0       	rjmp	.+30     	; 0x5b88 <HSTEP_voidFullStep+0x1fa>
    5b6a:	88 ec       	ldi	r24, 0xC8	; 200
    5b6c:	90 e0       	ldi	r25, 0x00	; 0
    5b6e:	98 a3       	std	Y+32, r25	; 0x20
    5b70:	8f 8f       	std	Y+31, r24	; 0x1f
    5b72:	8f 8d       	ldd	r24, Y+31	; 0x1f
    5b74:	98 a1       	ldd	r25, Y+32	; 0x20
    5b76:	01 97       	sbiw	r24, 0x01	; 1
    5b78:	f1 f7       	brne	.-4      	; 0x5b76 <HSTEP_voidFullStep+0x1e8>
    5b7a:	98 a3       	std	Y+32, r25	; 0x20
    5b7c:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5b7e:	89 a1       	ldd	r24, Y+33	; 0x21
    5b80:	9a a1       	ldd	r25, Y+34	; 0x22
    5b82:	01 97       	sbiw	r24, 0x01	; 1
    5b84:	9a a3       	std	Y+34, r25	; 0x22
    5b86:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5b88:	89 a1       	ldd	r24, Y+33	; 0x21
    5b8a:	9a a1       	ldd	r25, Y+34	; 0x22
    5b8c:	00 97       	sbiw	r24, 0x00	; 0
    5b8e:	69 f7       	brne	.-38     	; 0x5b6a <HSTEP_voidFullStep+0x1dc>
    5b90:	14 c0       	rjmp	.+40     	; 0x5bba <HSTEP_voidFullStep+0x22c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5b92:	6b a1       	ldd	r22, Y+35	; 0x23
    5b94:	7c a1       	ldd	r23, Y+36	; 0x24
    5b96:	8d a1       	ldd	r24, Y+37	; 0x25
    5b98:	9e a1       	ldd	r25, Y+38	; 0x26
    5b9a:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    5b9e:	dc 01       	movw	r26, r24
    5ba0:	cb 01       	movw	r24, r22
    5ba2:	9a a3       	std	Y+34, r25	; 0x22
    5ba4:	89 a3       	std	Y+33, r24	; 0x21
    5ba6:	89 a1       	ldd	r24, Y+33	; 0x21
    5ba8:	9a a1       	ldd	r25, Y+34	; 0x22
    5baa:	9e 8f       	std	Y+30, r25	; 0x1e
    5bac:	8d 8f       	std	Y+29, r24	; 0x1d
    5bae:	8d 8d       	ldd	r24, Y+29	; 0x1d
    5bb0:	9e 8d       	ldd	r25, Y+30	; 0x1e
    5bb2:	01 97       	sbiw	r24, 0x01	; 1
    5bb4:	f1 f7       	brne	.-4      	; 0x5bb2 <HSTEP_voidFullStep+0x224>
    5bb6:	9e 8f       	std	Y+30, r25	; 0x1e
    5bb8:	8d 8f       	std	Y+29, r24	; 0x1d
    _delay_ms(10);
    MDIO_voidSetPinValue(STEPPER_PORT,BLUE_COIL_PIN,PIN_HIGH);
    5bba:	80 e0       	ldi	r24, 0x00	; 0
    5bbc:	60 e0       	ldi	r22, 0x00	; 0
    5bbe:	41 e0       	ldi	r20, 0x01	; 1
    5bc0:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,PINK_COIL_PIN,PIN_HIGH);
    5bc4:	80 e0       	ldi	r24, 0x00	; 0
    5bc6:	61 e0       	ldi	r22, 0x01	; 1
    5bc8:	41 e0       	ldi	r20, 0x01	; 1
    5bca:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,YELLOW_COIL_PIN,PIN_HIGH);
    5bce:	80 e0       	ldi	r24, 0x00	; 0
    5bd0:	62 e0       	ldi	r22, 0x02	; 2
    5bd2:	41 e0       	ldi	r20, 0x01	; 1
    5bd4:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,ORANGE_COIL_PIN,PIN_LOW);
    5bd8:	80 e0       	ldi	r24, 0x00	; 0
    5bda:	63 e0       	ldi	r22, 0x03	; 3
    5bdc:	40 e0       	ldi	r20, 0x00	; 0
    5bde:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    5be2:	80 e0       	ldi	r24, 0x00	; 0
    5be4:	90 e0       	ldi	r25, 0x00	; 0
    5be6:	a0 e2       	ldi	r26, 0x20	; 32
    5be8:	b1 e4       	ldi	r27, 0x41	; 65
    5bea:	89 8f       	std	Y+25, r24	; 0x19
    5bec:	9a 8f       	std	Y+26, r25	; 0x1a
    5bee:	ab 8f       	std	Y+27, r26	; 0x1b
    5bf0:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5bf2:	69 8d       	ldd	r22, Y+25	; 0x19
    5bf4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    5bf6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    5bf8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    5bfa:	20 e0       	ldi	r18, 0x00	; 0
    5bfc:	30 e0       	ldi	r19, 0x00	; 0
    5bfe:	4a ef       	ldi	r20, 0xFA	; 250
    5c00:	54 e4       	ldi	r21, 0x44	; 68
    5c02:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    5c06:	dc 01       	movw	r26, r24
    5c08:	cb 01       	movw	r24, r22
    5c0a:	8d 8b       	std	Y+21, r24	; 0x15
    5c0c:	9e 8b       	std	Y+22, r25	; 0x16
    5c0e:	af 8b       	std	Y+23, r26	; 0x17
    5c10:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    5c12:	6d 89       	ldd	r22, Y+21	; 0x15
    5c14:	7e 89       	ldd	r23, Y+22	; 0x16
    5c16:	8f 89       	ldd	r24, Y+23	; 0x17
    5c18:	98 8d       	ldd	r25, Y+24	; 0x18
    5c1a:	20 e0       	ldi	r18, 0x00	; 0
    5c1c:	30 e0       	ldi	r19, 0x00	; 0
    5c1e:	40 e8       	ldi	r20, 0x80	; 128
    5c20:	5f e3       	ldi	r21, 0x3F	; 63
    5c22:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    5c26:	88 23       	and	r24, r24
    5c28:	2c f4       	brge	.+10     	; 0x5c34 <HSTEP_voidFullStep+0x2a6>
		__ticks = 1;
    5c2a:	81 e0       	ldi	r24, 0x01	; 1
    5c2c:	90 e0       	ldi	r25, 0x00	; 0
    5c2e:	9c 8b       	std	Y+20, r25	; 0x14
    5c30:	8b 8b       	std	Y+19, r24	; 0x13
    5c32:	3f c0       	rjmp	.+126    	; 0x5cb2 <HSTEP_voidFullStep+0x324>
	else if (__tmp > 65535)
    5c34:	6d 89       	ldd	r22, Y+21	; 0x15
    5c36:	7e 89       	ldd	r23, Y+22	; 0x16
    5c38:	8f 89       	ldd	r24, Y+23	; 0x17
    5c3a:	98 8d       	ldd	r25, Y+24	; 0x18
    5c3c:	20 e0       	ldi	r18, 0x00	; 0
    5c3e:	3f ef       	ldi	r19, 0xFF	; 255
    5c40:	4f e7       	ldi	r20, 0x7F	; 127
    5c42:	57 e4       	ldi	r21, 0x47	; 71
    5c44:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    5c48:	18 16       	cp	r1, r24
    5c4a:	4c f5       	brge	.+82     	; 0x5c9e <HSTEP_voidFullStep+0x310>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5c4c:	69 8d       	ldd	r22, Y+25	; 0x19
    5c4e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    5c50:	8b 8d       	ldd	r24, Y+27	; 0x1b
    5c52:	9c 8d       	ldd	r25, Y+28	; 0x1c
    5c54:	20 e0       	ldi	r18, 0x00	; 0
    5c56:	30 e0       	ldi	r19, 0x00	; 0
    5c58:	40 e2       	ldi	r20, 0x20	; 32
    5c5a:	51 e4       	ldi	r21, 0x41	; 65
    5c5c:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    5c60:	dc 01       	movw	r26, r24
    5c62:	cb 01       	movw	r24, r22
    5c64:	bc 01       	movw	r22, r24
    5c66:	cd 01       	movw	r24, r26
    5c68:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    5c6c:	dc 01       	movw	r26, r24
    5c6e:	cb 01       	movw	r24, r22
    5c70:	9c 8b       	std	Y+20, r25	; 0x14
    5c72:	8b 8b       	std	Y+19, r24	; 0x13
    5c74:	0f c0       	rjmp	.+30     	; 0x5c94 <HSTEP_voidFullStep+0x306>
    5c76:	88 ec       	ldi	r24, 0xC8	; 200
    5c78:	90 e0       	ldi	r25, 0x00	; 0
    5c7a:	9a 8b       	std	Y+18, r25	; 0x12
    5c7c:	89 8b       	std	Y+17, r24	; 0x11
    5c7e:	89 89       	ldd	r24, Y+17	; 0x11
    5c80:	9a 89       	ldd	r25, Y+18	; 0x12
    5c82:	01 97       	sbiw	r24, 0x01	; 1
    5c84:	f1 f7       	brne	.-4      	; 0x5c82 <HSTEP_voidFullStep+0x2f4>
    5c86:	9a 8b       	std	Y+18, r25	; 0x12
    5c88:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5c8a:	8b 89       	ldd	r24, Y+19	; 0x13
    5c8c:	9c 89       	ldd	r25, Y+20	; 0x14
    5c8e:	01 97       	sbiw	r24, 0x01	; 1
    5c90:	9c 8b       	std	Y+20, r25	; 0x14
    5c92:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5c94:	8b 89       	ldd	r24, Y+19	; 0x13
    5c96:	9c 89       	ldd	r25, Y+20	; 0x14
    5c98:	00 97       	sbiw	r24, 0x00	; 0
    5c9a:	69 f7       	brne	.-38     	; 0x5c76 <HSTEP_voidFullStep+0x2e8>
    5c9c:	14 c0       	rjmp	.+40     	; 0x5cc6 <HSTEP_voidFullStep+0x338>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5c9e:	6d 89       	ldd	r22, Y+21	; 0x15
    5ca0:	7e 89       	ldd	r23, Y+22	; 0x16
    5ca2:	8f 89       	ldd	r24, Y+23	; 0x17
    5ca4:	98 8d       	ldd	r25, Y+24	; 0x18
    5ca6:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    5caa:	dc 01       	movw	r26, r24
    5cac:	cb 01       	movw	r24, r22
    5cae:	9c 8b       	std	Y+20, r25	; 0x14
    5cb0:	8b 8b       	std	Y+19, r24	; 0x13
    5cb2:	8b 89       	ldd	r24, Y+19	; 0x13
    5cb4:	9c 89       	ldd	r25, Y+20	; 0x14
    5cb6:	98 8b       	std	Y+16, r25	; 0x10
    5cb8:	8f 87       	std	Y+15, r24	; 0x0f
    5cba:	8f 85       	ldd	r24, Y+15	; 0x0f
    5cbc:	98 89       	ldd	r25, Y+16	; 0x10
    5cbe:	01 97       	sbiw	r24, 0x01	; 1
    5cc0:	f1 f7       	brne	.-4      	; 0x5cbe <HSTEP_voidFullStep+0x330>
    5cc2:	98 8b       	std	Y+16, r25	; 0x10
    5cc4:	8f 87       	std	Y+15, r24	; 0x0f
    _delay_ms(10);
    MDIO_voidSetPinValue(STEPPER_PORT,BLUE_COIL_PIN,PIN_LOW);
    5cc6:	80 e0       	ldi	r24, 0x00	; 0
    5cc8:	60 e0       	ldi	r22, 0x00	; 0
    5cca:	40 e0       	ldi	r20, 0x00	; 0
    5ccc:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,PINK_COIL_PIN,PIN_HIGH);
    5cd0:	80 e0       	ldi	r24, 0x00	; 0
    5cd2:	61 e0       	ldi	r22, 0x01	; 1
    5cd4:	41 e0       	ldi	r20, 0x01	; 1
    5cd6:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,YELLOW_COIL_PIN,PIN_HIGH);
    5cda:	80 e0       	ldi	r24, 0x00	; 0
    5cdc:	62 e0       	ldi	r22, 0x02	; 2
    5cde:	41 e0       	ldi	r20, 0x01	; 1
    5ce0:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,ORANGE_COIL_PIN,PIN_HIGH);
    5ce4:	80 e0       	ldi	r24, 0x00	; 0
    5ce6:	63 e0       	ldi	r22, 0x03	; 3
    5ce8:	41 e0       	ldi	r20, 0x01	; 1
    5cea:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    5cee:	80 e0       	ldi	r24, 0x00	; 0
    5cf0:	90 e0       	ldi	r25, 0x00	; 0
    5cf2:	a0 e2       	ldi	r26, 0x20	; 32
    5cf4:	b1 e4       	ldi	r27, 0x41	; 65
    5cf6:	8b 87       	std	Y+11, r24	; 0x0b
    5cf8:	9c 87       	std	Y+12, r25	; 0x0c
    5cfa:	ad 87       	std	Y+13, r26	; 0x0d
    5cfc:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5cfe:	6b 85       	ldd	r22, Y+11	; 0x0b
    5d00:	7c 85       	ldd	r23, Y+12	; 0x0c
    5d02:	8d 85       	ldd	r24, Y+13	; 0x0d
    5d04:	9e 85       	ldd	r25, Y+14	; 0x0e
    5d06:	20 e0       	ldi	r18, 0x00	; 0
    5d08:	30 e0       	ldi	r19, 0x00	; 0
    5d0a:	4a ef       	ldi	r20, 0xFA	; 250
    5d0c:	54 e4       	ldi	r21, 0x44	; 68
    5d0e:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    5d12:	dc 01       	movw	r26, r24
    5d14:	cb 01       	movw	r24, r22
    5d16:	8f 83       	std	Y+7, r24	; 0x07
    5d18:	98 87       	std	Y+8, r25	; 0x08
    5d1a:	a9 87       	std	Y+9, r26	; 0x09
    5d1c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5d1e:	6f 81       	ldd	r22, Y+7	; 0x07
    5d20:	78 85       	ldd	r23, Y+8	; 0x08
    5d22:	89 85       	ldd	r24, Y+9	; 0x09
    5d24:	9a 85       	ldd	r25, Y+10	; 0x0a
    5d26:	20 e0       	ldi	r18, 0x00	; 0
    5d28:	30 e0       	ldi	r19, 0x00	; 0
    5d2a:	40 e8       	ldi	r20, 0x80	; 128
    5d2c:	5f e3       	ldi	r21, 0x3F	; 63
    5d2e:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    5d32:	88 23       	and	r24, r24
    5d34:	2c f4       	brge	.+10     	; 0x5d40 <HSTEP_voidFullStep+0x3b2>
		__ticks = 1;
    5d36:	81 e0       	ldi	r24, 0x01	; 1
    5d38:	90 e0       	ldi	r25, 0x00	; 0
    5d3a:	9e 83       	std	Y+6, r25	; 0x06
    5d3c:	8d 83       	std	Y+5, r24	; 0x05
    5d3e:	3f c0       	rjmp	.+126    	; 0x5dbe <HSTEP_voidFullStep+0x430>
	else if (__tmp > 65535)
    5d40:	6f 81       	ldd	r22, Y+7	; 0x07
    5d42:	78 85       	ldd	r23, Y+8	; 0x08
    5d44:	89 85       	ldd	r24, Y+9	; 0x09
    5d46:	9a 85       	ldd	r25, Y+10	; 0x0a
    5d48:	20 e0       	ldi	r18, 0x00	; 0
    5d4a:	3f ef       	ldi	r19, 0xFF	; 255
    5d4c:	4f e7       	ldi	r20, 0x7F	; 127
    5d4e:	57 e4       	ldi	r21, 0x47	; 71
    5d50:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    5d54:	18 16       	cp	r1, r24
    5d56:	4c f5       	brge	.+82     	; 0x5daa <HSTEP_voidFullStep+0x41c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5d58:	6b 85       	ldd	r22, Y+11	; 0x0b
    5d5a:	7c 85       	ldd	r23, Y+12	; 0x0c
    5d5c:	8d 85       	ldd	r24, Y+13	; 0x0d
    5d5e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5d60:	20 e0       	ldi	r18, 0x00	; 0
    5d62:	30 e0       	ldi	r19, 0x00	; 0
    5d64:	40 e2       	ldi	r20, 0x20	; 32
    5d66:	51 e4       	ldi	r21, 0x41	; 65
    5d68:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    5d6c:	dc 01       	movw	r26, r24
    5d6e:	cb 01       	movw	r24, r22
    5d70:	bc 01       	movw	r22, r24
    5d72:	cd 01       	movw	r24, r26
    5d74:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    5d78:	dc 01       	movw	r26, r24
    5d7a:	cb 01       	movw	r24, r22
    5d7c:	9e 83       	std	Y+6, r25	; 0x06
    5d7e:	8d 83       	std	Y+5, r24	; 0x05
    5d80:	0f c0       	rjmp	.+30     	; 0x5da0 <HSTEP_voidFullStep+0x412>
    5d82:	88 ec       	ldi	r24, 0xC8	; 200
    5d84:	90 e0       	ldi	r25, 0x00	; 0
    5d86:	9c 83       	std	Y+4, r25	; 0x04
    5d88:	8b 83       	std	Y+3, r24	; 0x03
    5d8a:	8b 81       	ldd	r24, Y+3	; 0x03
    5d8c:	9c 81       	ldd	r25, Y+4	; 0x04
    5d8e:	01 97       	sbiw	r24, 0x01	; 1
    5d90:	f1 f7       	brne	.-4      	; 0x5d8e <HSTEP_voidFullStep+0x400>
    5d92:	9c 83       	std	Y+4, r25	; 0x04
    5d94:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5d96:	8d 81       	ldd	r24, Y+5	; 0x05
    5d98:	9e 81       	ldd	r25, Y+6	; 0x06
    5d9a:	01 97       	sbiw	r24, 0x01	; 1
    5d9c:	9e 83       	std	Y+6, r25	; 0x06
    5d9e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5da0:	8d 81       	ldd	r24, Y+5	; 0x05
    5da2:	9e 81       	ldd	r25, Y+6	; 0x06
    5da4:	00 97       	sbiw	r24, 0x00	; 0
    5da6:	69 f7       	brne	.-38     	; 0x5d82 <HSTEP_voidFullStep+0x3f4>
    5da8:	14 c0       	rjmp	.+40     	; 0x5dd2 <HSTEP_voidFullStep+0x444>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5daa:	6f 81       	ldd	r22, Y+7	; 0x07
    5dac:	78 85       	ldd	r23, Y+8	; 0x08
    5dae:	89 85       	ldd	r24, Y+9	; 0x09
    5db0:	9a 85       	ldd	r25, Y+10	; 0x0a
    5db2:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    5db6:	dc 01       	movw	r26, r24
    5db8:	cb 01       	movw	r24, r22
    5dba:	9e 83       	std	Y+6, r25	; 0x06
    5dbc:	8d 83       	std	Y+5, r24	; 0x05
    5dbe:	8d 81       	ldd	r24, Y+5	; 0x05
    5dc0:	9e 81       	ldd	r25, Y+6	; 0x06
    5dc2:	9a 83       	std	Y+2, r25	; 0x02
    5dc4:	89 83       	std	Y+1, r24	; 0x01
    5dc6:	89 81       	ldd	r24, Y+1	; 0x01
    5dc8:	9a 81       	ldd	r25, Y+2	; 0x02
    5dca:	01 97       	sbiw	r24, 0x01	; 1
    5dcc:	f1 f7       	brne	.-4      	; 0x5dca <HSTEP_voidFullStep+0x43c>
    5dce:	9a 83       	std	Y+2, r25	; 0x02
    5dd0:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(10);
}
    5dd2:	e8 96       	adiw	r28, 0x38	; 56
    5dd4:	0f b6       	in	r0, 0x3f	; 63
    5dd6:	f8 94       	cli
    5dd8:	de bf       	out	0x3e, r29	; 62
    5dda:	0f be       	out	0x3f, r0	; 63
    5ddc:	cd bf       	out	0x3d, r28	; 61
    5dde:	cf 91       	pop	r28
    5de0:	df 91       	pop	r29
    5de2:	08 95       	ret

00005de4 <HSTEP_voidMotorAngle>:

void HSTEP_voidMotorAngle(u32 A_u32Angle)
{
    5de4:	df 93       	push	r29
    5de6:	cf 93       	push	r28
    5de8:	cd b7       	in	r28, 0x3d	; 61
    5dea:	de b7       	in	r29, 0x3e	; 62
    5dec:	c0 54       	subi	r28, 0x40	; 64
    5dee:	d0 40       	sbci	r29, 0x00	; 0
    5df0:	0f b6       	in	r0, 0x3f	; 63
    5df2:	f8 94       	cli
    5df4:	de bf       	out	0x3e, r29	; 62
    5df6:	0f be       	out	0x3f, r0	; 63
    5df8:	cd bf       	out	0x3d, r28	; 61
    5dfa:	fe 01       	movw	r30, r28
    5dfc:	ff 96       	adiw	r30, 0x3f	; 63
    5dfe:	91 83       	std	Z+1, r25	; 0x01
    5e00:	80 83       	st	Z, r24
    u32 local_u32Angle=((NO_OF_STEPS_FOR_360*A_u32Angle)/CIRCLE_ANGLE);
    5e02:	fe 01       	movw	r30, r28
    5e04:	ff 96       	adiw	r30, 0x3f	; 63
    5e06:	80 81       	ld	r24, Z
    5e08:	91 81       	ldd	r25, Z+1	; 0x01
    5e0a:	98 2f       	mov	r25, r24
    5e0c:	88 27       	eor	r24, r24
    5e0e:	99 0f       	add	r25, r25
    5e10:	99 0f       	add	r25, r25
    5e12:	99 0f       	add	r25, r25
    5e14:	28 e6       	ldi	r18, 0x68	; 104
    5e16:	31 e0       	ldi	r19, 0x01	; 1
    5e18:	b9 01       	movw	r22, r18
    5e1a:	0e 94 b4 42 	call	0x8568	; 0x8568 <__udivmodhi4>
    5e1e:	cb 01       	movw	r24, r22
    5e20:	9e af       	std	Y+62, r25	; 0x3e
    5e22:	8d af       	std	Y+61, r24	; 0x3d
    u32 local_u32Steps=local_u32Angle/NO_OF_COILS; 
    5e24:	8d ad       	ldd	r24, Y+61	; 0x3d
    5e26:	9e ad       	ldd	r25, Y+62	; 0x3e
    5e28:	96 95       	lsr	r25
    5e2a:	87 95       	ror	r24
    5e2c:	96 95       	lsr	r25
    5e2e:	87 95       	ror	r24
    5e30:	9c af       	std	Y+60, r25	; 0x3c
    5e32:	8b af       	std	Y+59, r24	; 0x3b
    for(u16 i =0;i<local_u32Steps;i++)
    5e34:	1a ae       	std	Y+58, r1	; 0x3a
    5e36:	19 ae       	std	Y+57, r1	; 0x39
    5e38:	1d c2       	rjmp	.+1082   	; 0x6274 <HSTEP_voidMotorAngle+0x490>
	{
    MDIO_voidSetPinValue(STEPPER_PORT,BLUE_COIL_PIN,PIN_HIGH);
    5e3a:	80 e0       	ldi	r24, 0x00	; 0
    5e3c:	60 e0       	ldi	r22, 0x00	; 0
    5e3e:	41 e0       	ldi	r20, 0x01	; 1
    5e40:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,PINK_COIL_PIN,PIN_LOW);
    5e44:	80 e0       	ldi	r24, 0x00	; 0
    5e46:	61 e0       	ldi	r22, 0x01	; 1
    5e48:	40 e0       	ldi	r20, 0x00	; 0
    5e4a:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,YELLOW_COIL_PIN,PIN_HIGH);
    5e4e:	80 e0       	ldi	r24, 0x00	; 0
    5e50:	62 e0       	ldi	r22, 0x02	; 2
    5e52:	41 e0       	ldi	r20, 0x01	; 1
    5e54:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,ORANGE_COIL_PIN,PIN_HIGH);
    5e58:	80 e0       	ldi	r24, 0x00	; 0
    5e5a:	63 e0       	ldi	r22, 0x03	; 3
    5e5c:	41 e0       	ldi	r20, 0x01	; 1
    5e5e:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    5e62:	80 e0       	ldi	r24, 0x00	; 0
    5e64:	90 e0       	ldi	r25, 0x00	; 0
    5e66:	a0 e2       	ldi	r26, 0x20	; 32
    5e68:	b1 e4       	ldi	r27, 0x41	; 65
    5e6a:	8d ab       	std	Y+53, r24	; 0x35
    5e6c:	9e ab       	std	Y+54, r25	; 0x36
    5e6e:	af ab       	std	Y+55, r26	; 0x37
    5e70:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5e72:	6d a9       	ldd	r22, Y+53	; 0x35
    5e74:	7e a9       	ldd	r23, Y+54	; 0x36
    5e76:	8f a9       	ldd	r24, Y+55	; 0x37
    5e78:	98 ad       	ldd	r25, Y+56	; 0x38
    5e7a:	20 e0       	ldi	r18, 0x00	; 0
    5e7c:	30 e0       	ldi	r19, 0x00	; 0
    5e7e:	4a ef       	ldi	r20, 0xFA	; 250
    5e80:	54 e4       	ldi	r21, 0x44	; 68
    5e82:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    5e86:	dc 01       	movw	r26, r24
    5e88:	cb 01       	movw	r24, r22
    5e8a:	89 ab       	std	Y+49, r24	; 0x31
    5e8c:	9a ab       	std	Y+50, r25	; 0x32
    5e8e:	ab ab       	std	Y+51, r26	; 0x33
    5e90:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    5e92:	69 a9       	ldd	r22, Y+49	; 0x31
    5e94:	7a a9       	ldd	r23, Y+50	; 0x32
    5e96:	8b a9       	ldd	r24, Y+51	; 0x33
    5e98:	9c a9       	ldd	r25, Y+52	; 0x34
    5e9a:	20 e0       	ldi	r18, 0x00	; 0
    5e9c:	30 e0       	ldi	r19, 0x00	; 0
    5e9e:	40 e8       	ldi	r20, 0x80	; 128
    5ea0:	5f e3       	ldi	r21, 0x3F	; 63
    5ea2:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    5ea6:	88 23       	and	r24, r24
    5ea8:	2c f4       	brge	.+10     	; 0x5eb4 <HSTEP_voidMotorAngle+0xd0>
		__ticks = 1;
    5eaa:	81 e0       	ldi	r24, 0x01	; 1
    5eac:	90 e0       	ldi	r25, 0x00	; 0
    5eae:	98 ab       	std	Y+48, r25	; 0x30
    5eb0:	8f a7       	std	Y+47, r24	; 0x2f
    5eb2:	3f c0       	rjmp	.+126    	; 0x5f32 <HSTEP_voidMotorAngle+0x14e>
	else if (__tmp > 65535)
    5eb4:	69 a9       	ldd	r22, Y+49	; 0x31
    5eb6:	7a a9       	ldd	r23, Y+50	; 0x32
    5eb8:	8b a9       	ldd	r24, Y+51	; 0x33
    5eba:	9c a9       	ldd	r25, Y+52	; 0x34
    5ebc:	20 e0       	ldi	r18, 0x00	; 0
    5ebe:	3f ef       	ldi	r19, 0xFF	; 255
    5ec0:	4f e7       	ldi	r20, 0x7F	; 127
    5ec2:	57 e4       	ldi	r21, 0x47	; 71
    5ec4:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    5ec8:	18 16       	cp	r1, r24
    5eca:	4c f5       	brge	.+82     	; 0x5f1e <HSTEP_voidMotorAngle+0x13a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5ecc:	6d a9       	ldd	r22, Y+53	; 0x35
    5ece:	7e a9       	ldd	r23, Y+54	; 0x36
    5ed0:	8f a9       	ldd	r24, Y+55	; 0x37
    5ed2:	98 ad       	ldd	r25, Y+56	; 0x38
    5ed4:	20 e0       	ldi	r18, 0x00	; 0
    5ed6:	30 e0       	ldi	r19, 0x00	; 0
    5ed8:	40 e2       	ldi	r20, 0x20	; 32
    5eda:	51 e4       	ldi	r21, 0x41	; 65
    5edc:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    5ee0:	dc 01       	movw	r26, r24
    5ee2:	cb 01       	movw	r24, r22
    5ee4:	bc 01       	movw	r22, r24
    5ee6:	cd 01       	movw	r24, r26
    5ee8:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    5eec:	dc 01       	movw	r26, r24
    5eee:	cb 01       	movw	r24, r22
    5ef0:	98 ab       	std	Y+48, r25	; 0x30
    5ef2:	8f a7       	std	Y+47, r24	; 0x2f
    5ef4:	0f c0       	rjmp	.+30     	; 0x5f14 <HSTEP_voidMotorAngle+0x130>
    5ef6:	88 ec       	ldi	r24, 0xC8	; 200
    5ef8:	90 e0       	ldi	r25, 0x00	; 0
    5efa:	9e a7       	std	Y+46, r25	; 0x2e
    5efc:	8d a7       	std	Y+45, r24	; 0x2d
    5efe:	8d a5       	ldd	r24, Y+45	; 0x2d
    5f00:	9e a5       	ldd	r25, Y+46	; 0x2e
    5f02:	01 97       	sbiw	r24, 0x01	; 1
    5f04:	f1 f7       	brne	.-4      	; 0x5f02 <HSTEP_voidMotorAngle+0x11e>
    5f06:	9e a7       	std	Y+46, r25	; 0x2e
    5f08:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5f0a:	8f a5       	ldd	r24, Y+47	; 0x2f
    5f0c:	98 a9       	ldd	r25, Y+48	; 0x30
    5f0e:	01 97       	sbiw	r24, 0x01	; 1
    5f10:	98 ab       	std	Y+48, r25	; 0x30
    5f12:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5f14:	8f a5       	ldd	r24, Y+47	; 0x2f
    5f16:	98 a9       	ldd	r25, Y+48	; 0x30
    5f18:	00 97       	sbiw	r24, 0x00	; 0
    5f1a:	69 f7       	brne	.-38     	; 0x5ef6 <HSTEP_voidMotorAngle+0x112>
    5f1c:	14 c0       	rjmp	.+40     	; 0x5f46 <HSTEP_voidMotorAngle+0x162>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5f1e:	69 a9       	ldd	r22, Y+49	; 0x31
    5f20:	7a a9       	ldd	r23, Y+50	; 0x32
    5f22:	8b a9       	ldd	r24, Y+51	; 0x33
    5f24:	9c a9       	ldd	r25, Y+52	; 0x34
    5f26:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    5f2a:	dc 01       	movw	r26, r24
    5f2c:	cb 01       	movw	r24, r22
    5f2e:	98 ab       	std	Y+48, r25	; 0x30
    5f30:	8f a7       	std	Y+47, r24	; 0x2f
    5f32:	8f a5       	ldd	r24, Y+47	; 0x2f
    5f34:	98 a9       	ldd	r25, Y+48	; 0x30
    5f36:	9c a7       	std	Y+44, r25	; 0x2c
    5f38:	8b a7       	std	Y+43, r24	; 0x2b
    5f3a:	8b a5       	ldd	r24, Y+43	; 0x2b
    5f3c:	9c a5       	ldd	r25, Y+44	; 0x2c
    5f3e:	01 97       	sbiw	r24, 0x01	; 1
    5f40:	f1 f7       	brne	.-4      	; 0x5f3e <HSTEP_voidMotorAngle+0x15a>
    5f42:	9c a7       	std	Y+44, r25	; 0x2c
    5f44:	8b a7       	std	Y+43, r24	; 0x2b
    _delay_ms(10);
    MDIO_voidSetPinValue(STEPPER_PORT,BLUE_COIL_PIN,PIN_HIGH);
    5f46:	80 e0       	ldi	r24, 0x00	; 0
    5f48:	60 e0       	ldi	r22, 0x00	; 0
    5f4a:	41 e0       	ldi	r20, 0x01	; 1
    5f4c:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,PINK_COIL_PIN,PIN_HIGH);
    5f50:	80 e0       	ldi	r24, 0x00	; 0
    5f52:	61 e0       	ldi	r22, 0x01	; 1
    5f54:	41 e0       	ldi	r20, 0x01	; 1
    5f56:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,YELLOW_COIL_PIN,PIN_LOW);
    5f5a:	80 e0       	ldi	r24, 0x00	; 0
    5f5c:	62 e0       	ldi	r22, 0x02	; 2
    5f5e:	40 e0       	ldi	r20, 0x00	; 0
    5f60:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,ORANGE_COIL_PIN,PIN_HIGH);
    5f64:	80 e0       	ldi	r24, 0x00	; 0
    5f66:	63 e0       	ldi	r22, 0x03	; 3
    5f68:	41 e0       	ldi	r20, 0x01	; 1
    5f6a:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    5f6e:	80 e0       	ldi	r24, 0x00	; 0
    5f70:	90 e0       	ldi	r25, 0x00	; 0
    5f72:	a0 e2       	ldi	r26, 0x20	; 32
    5f74:	b1 e4       	ldi	r27, 0x41	; 65
    5f76:	8f a3       	std	Y+39, r24	; 0x27
    5f78:	98 a7       	std	Y+40, r25	; 0x28
    5f7a:	a9 a7       	std	Y+41, r26	; 0x29
    5f7c:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5f7e:	6f a1       	ldd	r22, Y+39	; 0x27
    5f80:	78 a5       	ldd	r23, Y+40	; 0x28
    5f82:	89 a5       	ldd	r24, Y+41	; 0x29
    5f84:	9a a5       	ldd	r25, Y+42	; 0x2a
    5f86:	20 e0       	ldi	r18, 0x00	; 0
    5f88:	30 e0       	ldi	r19, 0x00	; 0
    5f8a:	4a ef       	ldi	r20, 0xFA	; 250
    5f8c:	54 e4       	ldi	r21, 0x44	; 68
    5f8e:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    5f92:	dc 01       	movw	r26, r24
    5f94:	cb 01       	movw	r24, r22
    5f96:	8b a3       	std	Y+35, r24	; 0x23
    5f98:	9c a3       	std	Y+36, r25	; 0x24
    5f9a:	ad a3       	std	Y+37, r26	; 0x25
    5f9c:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    5f9e:	6b a1       	ldd	r22, Y+35	; 0x23
    5fa0:	7c a1       	ldd	r23, Y+36	; 0x24
    5fa2:	8d a1       	ldd	r24, Y+37	; 0x25
    5fa4:	9e a1       	ldd	r25, Y+38	; 0x26
    5fa6:	20 e0       	ldi	r18, 0x00	; 0
    5fa8:	30 e0       	ldi	r19, 0x00	; 0
    5faa:	40 e8       	ldi	r20, 0x80	; 128
    5fac:	5f e3       	ldi	r21, 0x3F	; 63
    5fae:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    5fb2:	88 23       	and	r24, r24
    5fb4:	2c f4       	brge	.+10     	; 0x5fc0 <HSTEP_voidMotorAngle+0x1dc>
		__ticks = 1;
    5fb6:	81 e0       	ldi	r24, 0x01	; 1
    5fb8:	90 e0       	ldi	r25, 0x00	; 0
    5fba:	9a a3       	std	Y+34, r25	; 0x22
    5fbc:	89 a3       	std	Y+33, r24	; 0x21
    5fbe:	3f c0       	rjmp	.+126    	; 0x603e <HSTEP_voidMotorAngle+0x25a>
	else if (__tmp > 65535)
    5fc0:	6b a1       	ldd	r22, Y+35	; 0x23
    5fc2:	7c a1       	ldd	r23, Y+36	; 0x24
    5fc4:	8d a1       	ldd	r24, Y+37	; 0x25
    5fc6:	9e a1       	ldd	r25, Y+38	; 0x26
    5fc8:	20 e0       	ldi	r18, 0x00	; 0
    5fca:	3f ef       	ldi	r19, 0xFF	; 255
    5fcc:	4f e7       	ldi	r20, 0x7F	; 127
    5fce:	57 e4       	ldi	r21, 0x47	; 71
    5fd0:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    5fd4:	18 16       	cp	r1, r24
    5fd6:	4c f5       	brge	.+82     	; 0x602a <HSTEP_voidMotorAngle+0x246>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5fd8:	6f a1       	ldd	r22, Y+39	; 0x27
    5fda:	78 a5       	ldd	r23, Y+40	; 0x28
    5fdc:	89 a5       	ldd	r24, Y+41	; 0x29
    5fde:	9a a5       	ldd	r25, Y+42	; 0x2a
    5fe0:	20 e0       	ldi	r18, 0x00	; 0
    5fe2:	30 e0       	ldi	r19, 0x00	; 0
    5fe4:	40 e2       	ldi	r20, 0x20	; 32
    5fe6:	51 e4       	ldi	r21, 0x41	; 65
    5fe8:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    5fec:	dc 01       	movw	r26, r24
    5fee:	cb 01       	movw	r24, r22
    5ff0:	bc 01       	movw	r22, r24
    5ff2:	cd 01       	movw	r24, r26
    5ff4:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    5ff8:	dc 01       	movw	r26, r24
    5ffa:	cb 01       	movw	r24, r22
    5ffc:	9a a3       	std	Y+34, r25	; 0x22
    5ffe:	89 a3       	std	Y+33, r24	; 0x21
    6000:	0f c0       	rjmp	.+30     	; 0x6020 <HSTEP_voidMotorAngle+0x23c>
    6002:	88 ec       	ldi	r24, 0xC8	; 200
    6004:	90 e0       	ldi	r25, 0x00	; 0
    6006:	98 a3       	std	Y+32, r25	; 0x20
    6008:	8f 8f       	std	Y+31, r24	; 0x1f
    600a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    600c:	98 a1       	ldd	r25, Y+32	; 0x20
    600e:	01 97       	sbiw	r24, 0x01	; 1
    6010:	f1 f7       	brne	.-4      	; 0x600e <HSTEP_voidMotorAngle+0x22a>
    6012:	98 a3       	std	Y+32, r25	; 0x20
    6014:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6016:	89 a1       	ldd	r24, Y+33	; 0x21
    6018:	9a a1       	ldd	r25, Y+34	; 0x22
    601a:	01 97       	sbiw	r24, 0x01	; 1
    601c:	9a a3       	std	Y+34, r25	; 0x22
    601e:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6020:	89 a1       	ldd	r24, Y+33	; 0x21
    6022:	9a a1       	ldd	r25, Y+34	; 0x22
    6024:	00 97       	sbiw	r24, 0x00	; 0
    6026:	69 f7       	brne	.-38     	; 0x6002 <HSTEP_voidMotorAngle+0x21e>
    6028:	14 c0       	rjmp	.+40     	; 0x6052 <HSTEP_voidMotorAngle+0x26e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    602a:	6b a1       	ldd	r22, Y+35	; 0x23
    602c:	7c a1       	ldd	r23, Y+36	; 0x24
    602e:	8d a1       	ldd	r24, Y+37	; 0x25
    6030:	9e a1       	ldd	r25, Y+38	; 0x26
    6032:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    6036:	dc 01       	movw	r26, r24
    6038:	cb 01       	movw	r24, r22
    603a:	9a a3       	std	Y+34, r25	; 0x22
    603c:	89 a3       	std	Y+33, r24	; 0x21
    603e:	89 a1       	ldd	r24, Y+33	; 0x21
    6040:	9a a1       	ldd	r25, Y+34	; 0x22
    6042:	9e 8f       	std	Y+30, r25	; 0x1e
    6044:	8d 8f       	std	Y+29, r24	; 0x1d
    6046:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6048:	9e 8d       	ldd	r25, Y+30	; 0x1e
    604a:	01 97       	sbiw	r24, 0x01	; 1
    604c:	f1 f7       	brne	.-4      	; 0x604a <HSTEP_voidMotorAngle+0x266>
    604e:	9e 8f       	std	Y+30, r25	; 0x1e
    6050:	8d 8f       	std	Y+29, r24	; 0x1d
    _delay_ms(10);
    MDIO_voidSetPinValue(STEPPER_PORT,BLUE_COIL_PIN,PIN_HIGH);
    6052:	80 e0       	ldi	r24, 0x00	; 0
    6054:	60 e0       	ldi	r22, 0x00	; 0
    6056:	41 e0       	ldi	r20, 0x01	; 1
    6058:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,PINK_COIL_PIN,PIN_HIGH);
    605c:	80 e0       	ldi	r24, 0x00	; 0
    605e:	61 e0       	ldi	r22, 0x01	; 1
    6060:	41 e0       	ldi	r20, 0x01	; 1
    6062:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,YELLOW_COIL_PIN,PIN_HIGH);
    6066:	80 e0       	ldi	r24, 0x00	; 0
    6068:	62 e0       	ldi	r22, 0x02	; 2
    606a:	41 e0       	ldi	r20, 0x01	; 1
    606c:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,ORANGE_COIL_PIN,PIN_LOW);
    6070:	80 e0       	ldi	r24, 0x00	; 0
    6072:	63 e0       	ldi	r22, 0x03	; 3
    6074:	40 e0       	ldi	r20, 0x00	; 0
    6076:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    607a:	80 e0       	ldi	r24, 0x00	; 0
    607c:	90 e0       	ldi	r25, 0x00	; 0
    607e:	a0 e2       	ldi	r26, 0x20	; 32
    6080:	b1 e4       	ldi	r27, 0x41	; 65
    6082:	89 8f       	std	Y+25, r24	; 0x19
    6084:	9a 8f       	std	Y+26, r25	; 0x1a
    6086:	ab 8f       	std	Y+27, r26	; 0x1b
    6088:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    608a:	69 8d       	ldd	r22, Y+25	; 0x19
    608c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    608e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    6090:	9c 8d       	ldd	r25, Y+28	; 0x1c
    6092:	20 e0       	ldi	r18, 0x00	; 0
    6094:	30 e0       	ldi	r19, 0x00	; 0
    6096:	4a ef       	ldi	r20, 0xFA	; 250
    6098:	54 e4       	ldi	r21, 0x44	; 68
    609a:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    609e:	dc 01       	movw	r26, r24
    60a0:	cb 01       	movw	r24, r22
    60a2:	8d 8b       	std	Y+21, r24	; 0x15
    60a4:	9e 8b       	std	Y+22, r25	; 0x16
    60a6:	af 8b       	std	Y+23, r26	; 0x17
    60a8:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    60aa:	6d 89       	ldd	r22, Y+21	; 0x15
    60ac:	7e 89       	ldd	r23, Y+22	; 0x16
    60ae:	8f 89       	ldd	r24, Y+23	; 0x17
    60b0:	98 8d       	ldd	r25, Y+24	; 0x18
    60b2:	20 e0       	ldi	r18, 0x00	; 0
    60b4:	30 e0       	ldi	r19, 0x00	; 0
    60b6:	40 e8       	ldi	r20, 0x80	; 128
    60b8:	5f e3       	ldi	r21, 0x3F	; 63
    60ba:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    60be:	88 23       	and	r24, r24
    60c0:	2c f4       	brge	.+10     	; 0x60cc <HSTEP_voidMotorAngle+0x2e8>
		__ticks = 1;
    60c2:	81 e0       	ldi	r24, 0x01	; 1
    60c4:	90 e0       	ldi	r25, 0x00	; 0
    60c6:	9c 8b       	std	Y+20, r25	; 0x14
    60c8:	8b 8b       	std	Y+19, r24	; 0x13
    60ca:	3f c0       	rjmp	.+126    	; 0x614a <HSTEP_voidMotorAngle+0x366>
	else if (__tmp > 65535)
    60cc:	6d 89       	ldd	r22, Y+21	; 0x15
    60ce:	7e 89       	ldd	r23, Y+22	; 0x16
    60d0:	8f 89       	ldd	r24, Y+23	; 0x17
    60d2:	98 8d       	ldd	r25, Y+24	; 0x18
    60d4:	20 e0       	ldi	r18, 0x00	; 0
    60d6:	3f ef       	ldi	r19, 0xFF	; 255
    60d8:	4f e7       	ldi	r20, 0x7F	; 127
    60da:	57 e4       	ldi	r21, 0x47	; 71
    60dc:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    60e0:	18 16       	cp	r1, r24
    60e2:	4c f5       	brge	.+82     	; 0x6136 <HSTEP_voidMotorAngle+0x352>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    60e4:	69 8d       	ldd	r22, Y+25	; 0x19
    60e6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    60e8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    60ea:	9c 8d       	ldd	r25, Y+28	; 0x1c
    60ec:	20 e0       	ldi	r18, 0x00	; 0
    60ee:	30 e0       	ldi	r19, 0x00	; 0
    60f0:	40 e2       	ldi	r20, 0x20	; 32
    60f2:	51 e4       	ldi	r21, 0x41	; 65
    60f4:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    60f8:	dc 01       	movw	r26, r24
    60fa:	cb 01       	movw	r24, r22
    60fc:	bc 01       	movw	r22, r24
    60fe:	cd 01       	movw	r24, r26
    6100:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    6104:	dc 01       	movw	r26, r24
    6106:	cb 01       	movw	r24, r22
    6108:	9c 8b       	std	Y+20, r25	; 0x14
    610a:	8b 8b       	std	Y+19, r24	; 0x13
    610c:	0f c0       	rjmp	.+30     	; 0x612c <HSTEP_voidMotorAngle+0x348>
    610e:	88 ec       	ldi	r24, 0xC8	; 200
    6110:	90 e0       	ldi	r25, 0x00	; 0
    6112:	9a 8b       	std	Y+18, r25	; 0x12
    6114:	89 8b       	std	Y+17, r24	; 0x11
    6116:	89 89       	ldd	r24, Y+17	; 0x11
    6118:	9a 89       	ldd	r25, Y+18	; 0x12
    611a:	01 97       	sbiw	r24, 0x01	; 1
    611c:	f1 f7       	brne	.-4      	; 0x611a <HSTEP_voidMotorAngle+0x336>
    611e:	9a 8b       	std	Y+18, r25	; 0x12
    6120:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6122:	8b 89       	ldd	r24, Y+19	; 0x13
    6124:	9c 89       	ldd	r25, Y+20	; 0x14
    6126:	01 97       	sbiw	r24, 0x01	; 1
    6128:	9c 8b       	std	Y+20, r25	; 0x14
    612a:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    612c:	8b 89       	ldd	r24, Y+19	; 0x13
    612e:	9c 89       	ldd	r25, Y+20	; 0x14
    6130:	00 97       	sbiw	r24, 0x00	; 0
    6132:	69 f7       	brne	.-38     	; 0x610e <HSTEP_voidMotorAngle+0x32a>
    6134:	14 c0       	rjmp	.+40     	; 0x615e <HSTEP_voidMotorAngle+0x37a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6136:	6d 89       	ldd	r22, Y+21	; 0x15
    6138:	7e 89       	ldd	r23, Y+22	; 0x16
    613a:	8f 89       	ldd	r24, Y+23	; 0x17
    613c:	98 8d       	ldd	r25, Y+24	; 0x18
    613e:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    6142:	dc 01       	movw	r26, r24
    6144:	cb 01       	movw	r24, r22
    6146:	9c 8b       	std	Y+20, r25	; 0x14
    6148:	8b 8b       	std	Y+19, r24	; 0x13
    614a:	8b 89       	ldd	r24, Y+19	; 0x13
    614c:	9c 89       	ldd	r25, Y+20	; 0x14
    614e:	98 8b       	std	Y+16, r25	; 0x10
    6150:	8f 87       	std	Y+15, r24	; 0x0f
    6152:	8f 85       	ldd	r24, Y+15	; 0x0f
    6154:	98 89       	ldd	r25, Y+16	; 0x10
    6156:	01 97       	sbiw	r24, 0x01	; 1
    6158:	f1 f7       	brne	.-4      	; 0x6156 <HSTEP_voidMotorAngle+0x372>
    615a:	98 8b       	std	Y+16, r25	; 0x10
    615c:	8f 87       	std	Y+15, r24	; 0x0f
    _delay_ms(10);
    MDIO_voidSetPinValue(STEPPER_PORT,BLUE_COIL_PIN,PIN_LOW);
    615e:	80 e0       	ldi	r24, 0x00	; 0
    6160:	60 e0       	ldi	r22, 0x00	; 0
    6162:	40 e0       	ldi	r20, 0x00	; 0
    6164:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,PINK_COIL_PIN,PIN_HIGH);
    6168:	80 e0       	ldi	r24, 0x00	; 0
    616a:	61 e0       	ldi	r22, 0x01	; 1
    616c:	41 e0       	ldi	r20, 0x01	; 1
    616e:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,YELLOW_COIL_PIN,PIN_HIGH);
    6172:	80 e0       	ldi	r24, 0x00	; 0
    6174:	62 e0       	ldi	r22, 0x02	; 2
    6176:	41 e0       	ldi	r20, 0x01	; 1
    6178:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MDIO_voidSetPinValue(STEPPER_PORT,ORANGE_COIL_PIN,PIN_HIGH);
    617c:	80 e0       	ldi	r24, 0x00	; 0
    617e:	63 e0       	ldi	r22, 0x03	; 3
    6180:	41 e0       	ldi	r20, 0x01	; 1
    6182:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    6186:	80 e0       	ldi	r24, 0x00	; 0
    6188:	90 e0       	ldi	r25, 0x00	; 0
    618a:	a0 e2       	ldi	r26, 0x20	; 32
    618c:	b1 e4       	ldi	r27, 0x41	; 65
    618e:	8b 87       	std	Y+11, r24	; 0x0b
    6190:	9c 87       	std	Y+12, r25	; 0x0c
    6192:	ad 87       	std	Y+13, r26	; 0x0d
    6194:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6196:	6b 85       	ldd	r22, Y+11	; 0x0b
    6198:	7c 85       	ldd	r23, Y+12	; 0x0c
    619a:	8d 85       	ldd	r24, Y+13	; 0x0d
    619c:	9e 85       	ldd	r25, Y+14	; 0x0e
    619e:	20 e0       	ldi	r18, 0x00	; 0
    61a0:	30 e0       	ldi	r19, 0x00	; 0
    61a2:	4a ef       	ldi	r20, 0xFA	; 250
    61a4:	54 e4       	ldi	r21, 0x44	; 68
    61a6:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    61aa:	dc 01       	movw	r26, r24
    61ac:	cb 01       	movw	r24, r22
    61ae:	8f 83       	std	Y+7, r24	; 0x07
    61b0:	98 87       	std	Y+8, r25	; 0x08
    61b2:	a9 87       	std	Y+9, r26	; 0x09
    61b4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    61b6:	6f 81       	ldd	r22, Y+7	; 0x07
    61b8:	78 85       	ldd	r23, Y+8	; 0x08
    61ba:	89 85       	ldd	r24, Y+9	; 0x09
    61bc:	9a 85       	ldd	r25, Y+10	; 0x0a
    61be:	20 e0       	ldi	r18, 0x00	; 0
    61c0:	30 e0       	ldi	r19, 0x00	; 0
    61c2:	40 e8       	ldi	r20, 0x80	; 128
    61c4:	5f e3       	ldi	r21, 0x3F	; 63
    61c6:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    61ca:	88 23       	and	r24, r24
    61cc:	2c f4       	brge	.+10     	; 0x61d8 <HSTEP_voidMotorAngle+0x3f4>
		__ticks = 1;
    61ce:	81 e0       	ldi	r24, 0x01	; 1
    61d0:	90 e0       	ldi	r25, 0x00	; 0
    61d2:	9e 83       	std	Y+6, r25	; 0x06
    61d4:	8d 83       	std	Y+5, r24	; 0x05
    61d6:	3f c0       	rjmp	.+126    	; 0x6256 <HSTEP_voidMotorAngle+0x472>
	else if (__tmp > 65535)
    61d8:	6f 81       	ldd	r22, Y+7	; 0x07
    61da:	78 85       	ldd	r23, Y+8	; 0x08
    61dc:	89 85       	ldd	r24, Y+9	; 0x09
    61de:	9a 85       	ldd	r25, Y+10	; 0x0a
    61e0:	20 e0       	ldi	r18, 0x00	; 0
    61e2:	3f ef       	ldi	r19, 0xFF	; 255
    61e4:	4f e7       	ldi	r20, 0x7F	; 127
    61e6:	57 e4       	ldi	r21, 0x47	; 71
    61e8:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    61ec:	18 16       	cp	r1, r24
    61ee:	4c f5       	brge	.+82     	; 0x6242 <HSTEP_voidMotorAngle+0x45e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    61f0:	6b 85       	ldd	r22, Y+11	; 0x0b
    61f2:	7c 85       	ldd	r23, Y+12	; 0x0c
    61f4:	8d 85       	ldd	r24, Y+13	; 0x0d
    61f6:	9e 85       	ldd	r25, Y+14	; 0x0e
    61f8:	20 e0       	ldi	r18, 0x00	; 0
    61fa:	30 e0       	ldi	r19, 0x00	; 0
    61fc:	40 e2       	ldi	r20, 0x20	; 32
    61fe:	51 e4       	ldi	r21, 0x41	; 65
    6200:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    6204:	dc 01       	movw	r26, r24
    6206:	cb 01       	movw	r24, r22
    6208:	bc 01       	movw	r22, r24
    620a:	cd 01       	movw	r24, r26
    620c:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    6210:	dc 01       	movw	r26, r24
    6212:	cb 01       	movw	r24, r22
    6214:	9e 83       	std	Y+6, r25	; 0x06
    6216:	8d 83       	std	Y+5, r24	; 0x05
    6218:	0f c0       	rjmp	.+30     	; 0x6238 <HSTEP_voidMotorAngle+0x454>
    621a:	88 ec       	ldi	r24, 0xC8	; 200
    621c:	90 e0       	ldi	r25, 0x00	; 0
    621e:	9c 83       	std	Y+4, r25	; 0x04
    6220:	8b 83       	std	Y+3, r24	; 0x03
    6222:	8b 81       	ldd	r24, Y+3	; 0x03
    6224:	9c 81       	ldd	r25, Y+4	; 0x04
    6226:	01 97       	sbiw	r24, 0x01	; 1
    6228:	f1 f7       	brne	.-4      	; 0x6226 <HSTEP_voidMotorAngle+0x442>
    622a:	9c 83       	std	Y+4, r25	; 0x04
    622c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    622e:	8d 81       	ldd	r24, Y+5	; 0x05
    6230:	9e 81       	ldd	r25, Y+6	; 0x06
    6232:	01 97       	sbiw	r24, 0x01	; 1
    6234:	9e 83       	std	Y+6, r25	; 0x06
    6236:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6238:	8d 81       	ldd	r24, Y+5	; 0x05
    623a:	9e 81       	ldd	r25, Y+6	; 0x06
    623c:	00 97       	sbiw	r24, 0x00	; 0
    623e:	69 f7       	brne	.-38     	; 0x621a <HSTEP_voidMotorAngle+0x436>
    6240:	14 c0       	rjmp	.+40     	; 0x626a <HSTEP_voidMotorAngle+0x486>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6242:	6f 81       	ldd	r22, Y+7	; 0x07
    6244:	78 85       	ldd	r23, Y+8	; 0x08
    6246:	89 85       	ldd	r24, Y+9	; 0x09
    6248:	9a 85       	ldd	r25, Y+10	; 0x0a
    624a:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    624e:	dc 01       	movw	r26, r24
    6250:	cb 01       	movw	r24, r22
    6252:	9e 83       	std	Y+6, r25	; 0x06
    6254:	8d 83       	std	Y+5, r24	; 0x05
    6256:	8d 81       	ldd	r24, Y+5	; 0x05
    6258:	9e 81       	ldd	r25, Y+6	; 0x06
    625a:	9a 83       	std	Y+2, r25	; 0x02
    625c:	89 83       	std	Y+1, r24	; 0x01
    625e:	89 81       	ldd	r24, Y+1	; 0x01
    6260:	9a 81       	ldd	r25, Y+2	; 0x02
    6262:	01 97       	sbiw	r24, 0x01	; 1
    6264:	f1 f7       	brne	.-4      	; 0x6262 <HSTEP_voidMotorAngle+0x47e>
    6266:	9a 83       	std	Y+2, r25	; 0x02
    6268:	89 83       	std	Y+1, r24	; 0x01

void HSTEP_voidMotorAngle(u32 A_u32Angle)
{
    u32 local_u32Angle=((NO_OF_STEPS_FOR_360*A_u32Angle)/CIRCLE_ANGLE);
    u32 local_u32Steps=local_u32Angle/NO_OF_COILS; 
    for(u16 i =0;i<local_u32Steps;i++)
    626a:	89 ad       	ldd	r24, Y+57	; 0x39
    626c:	9a ad       	ldd	r25, Y+58	; 0x3a
    626e:	01 96       	adiw	r24, 0x01	; 1
    6270:	9a af       	std	Y+58, r25	; 0x3a
    6272:	89 af       	std	Y+57, r24	; 0x39
    6274:	29 ad       	ldd	r18, Y+57	; 0x39
    6276:	3a ad       	ldd	r19, Y+58	; 0x3a
    6278:	8b ad       	ldd	r24, Y+59	; 0x3b
    627a:	9c ad       	ldd	r25, Y+60	; 0x3c
    627c:	28 17       	cp	r18, r24
    627e:	39 07       	cpc	r19, r25
    6280:	08 f4       	brcc	.+2      	; 0x6284 <HSTEP_voidMotorAngle+0x4a0>
    6282:	db cd       	rjmp	.-1098   	; 0x5e3a <HSTEP_voidMotorAngle+0x56>
    MDIO_voidSetPinValue(STEPPER_PORT,PINK_COIL_PIN,PIN_HIGH);
    MDIO_voidSetPinValue(STEPPER_PORT,YELLOW_COIL_PIN,PIN_HIGH);
    MDIO_voidSetPinValue(STEPPER_PORT,ORANGE_COIL_PIN,PIN_HIGH);
    _delay_ms(10);
    }
    6284:	c0 5c       	subi	r28, 0xC0	; 192
    6286:	df 4f       	sbci	r29, 0xFF	; 255
    6288:	0f b6       	in	r0, 0x3f	; 63
    628a:	f8 94       	cli
    628c:	de bf       	out	0x3e, r29	; 62
    628e:	0f be       	out	0x3f, r0	; 63
    6290:	cd bf       	out	0x3d, r28	; 61
    6292:	cf 91       	pop	r28
    6294:	df 91       	pop	r29
    6296:	08 95       	ret

00006298 <MTIMER0_voidInit>:
static void (*TIMER0_CTC_CallBack)(void)=NULLPTR;



void MTIMER0_voidInit(TIMER0_Mode mode,TIMER0_Prescaler prescaler,TIMER0_Compare compare)
{
    6298:	df 93       	push	r29
    629a:	cf 93       	push	r28
    629c:	00 d0       	rcall	.+0      	; 0x629e <MTIMER0_voidInit+0x6>
    629e:	00 d0       	rcall	.+0      	; 0x62a0 <MTIMER0_voidInit+0x8>
    62a0:	0f 92       	push	r0
    62a2:	cd b7       	in	r28, 0x3d	; 61
    62a4:	de b7       	in	r29, 0x3e	; 62
    62a6:	89 83       	std	Y+1, r24	; 0x01
    62a8:	6a 83       	std	Y+2, r22	; 0x02
    62aa:	4b 83       	std	Y+3, r20	; 0x03
    switch (mode)
    62ac:	89 81       	ldd	r24, Y+1	; 0x01
    62ae:	28 2f       	mov	r18, r24
    62b0:	30 e0       	ldi	r19, 0x00	; 0
    62b2:	3d 83       	std	Y+5, r19	; 0x05
    62b4:	2c 83       	std	Y+4, r18	; 0x04
    62b6:	8c 81       	ldd	r24, Y+4	; 0x04
    62b8:	9d 81       	ldd	r25, Y+5	; 0x05
    62ba:	81 30       	cpi	r24, 0x01	; 1
    62bc:	91 05       	cpc	r25, r1
    62be:	61 f1       	breq	.+88     	; 0x6318 <MTIMER0_voidInit+0x80>
    62c0:	2c 81       	ldd	r18, Y+4	; 0x04
    62c2:	3d 81       	ldd	r19, Y+5	; 0x05
    62c4:	22 30       	cpi	r18, 0x02	; 2
    62c6:	31 05       	cpc	r19, r1
    62c8:	2c f4       	brge	.+10     	; 0x62d4 <MTIMER0_voidInit+0x3c>
    62ca:	8c 81       	ldd	r24, Y+4	; 0x04
    62cc:	9d 81       	ldd	r25, Y+5	; 0x05
    62ce:	00 97       	sbiw	r24, 0x00	; 0
    62d0:	69 f0       	breq	.+26     	; 0x62ec <MTIMER0_voidInit+0x54>
    62d2:	63 c0       	rjmp	.+198    	; 0x639a <MTIMER0_voidInit+0x102>
    62d4:	2c 81       	ldd	r18, Y+4	; 0x04
    62d6:	3d 81       	ldd	r19, Y+5	; 0x05
    62d8:	22 30       	cpi	r18, 0x02	; 2
    62da:	31 05       	cpc	r19, r1
    62dc:	99 f1       	breq	.+102    	; 0x6344 <MTIMER0_voidInit+0xac>
    62de:	8c 81       	ldd	r24, Y+4	; 0x04
    62e0:	9d 81       	ldd	r25, Y+5	; 0x05
    62e2:	83 30       	cpi	r24, 0x03	; 3
    62e4:	91 05       	cpc	r25, r1
    62e6:	09 f4       	brne	.+2      	; 0x62ea <MTIMER0_voidInit+0x52>
    62e8:	43 c0       	rjmp	.+134    	; 0x6370 <MTIMER0_voidInit+0xd8>
    62ea:	57 c0       	rjmp	.+174    	; 0x639a <MTIMER0_voidInit+0x102>
    {
        case TIMER0_NORMAL_MODE:
            SET_BIT(TCCR0,FOC0);
    62ec:	a3 e5       	ldi	r26, 0x53	; 83
    62ee:	b0 e0       	ldi	r27, 0x00	; 0
    62f0:	e3 e5       	ldi	r30, 0x53	; 83
    62f2:	f0 e0       	ldi	r31, 0x00	; 0
    62f4:	80 81       	ld	r24, Z
    62f6:	80 68       	ori	r24, 0x80	; 128
    62f8:	8c 93       	st	X, r24
            CLR_BIT(TCCR0,WGM00);
    62fa:	a3 e5       	ldi	r26, 0x53	; 83
    62fc:	b0 e0       	ldi	r27, 0x00	; 0
    62fe:	e3 e5       	ldi	r30, 0x53	; 83
    6300:	f0 e0       	ldi	r31, 0x00	; 0
    6302:	80 81       	ld	r24, Z
    6304:	8f 7b       	andi	r24, 0xBF	; 191
    6306:	8c 93       	st	X, r24
            CLR_BIT(TCCR0,WGM01);
    6308:	a3 e5       	ldi	r26, 0x53	; 83
    630a:	b0 e0       	ldi	r27, 0x00	; 0
    630c:	e3 e5       	ldi	r30, 0x53	; 83
    630e:	f0 e0       	ldi	r31, 0x00	; 0
    6310:	80 81       	ld	r24, Z
    6312:	87 7f       	andi	r24, 0xF7	; 247
    6314:	8c 93       	st	X, r24
    6316:	41 c0       	rjmp	.+130    	; 0x639a <MTIMER0_voidInit+0x102>
        break;

        case TIMER0_PHASE_CORRECT_MODE:
            CLR_BIT(TCCR0,FOC0);
    6318:	a3 e5       	ldi	r26, 0x53	; 83
    631a:	b0 e0       	ldi	r27, 0x00	; 0
    631c:	e3 e5       	ldi	r30, 0x53	; 83
    631e:	f0 e0       	ldi	r31, 0x00	; 0
    6320:	80 81       	ld	r24, Z
    6322:	8f 77       	andi	r24, 0x7F	; 127
    6324:	8c 93       	st	X, r24
            SET_BIT(TCCR0,WGM00);
    6326:	a3 e5       	ldi	r26, 0x53	; 83
    6328:	b0 e0       	ldi	r27, 0x00	; 0
    632a:	e3 e5       	ldi	r30, 0x53	; 83
    632c:	f0 e0       	ldi	r31, 0x00	; 0
    632e:	80 81       	ld	r24, Z
    6330:	80 64       	ori	r24, 0x40	; 64
    6332:	8c 93       	st	X, r24
            CLR_BIT(TCCR0,WGM01);
    6334:	a3 e5       	ldi	r26, 0x53	; 83
    6336:	b0 e0       	ldi	r27, 0x00	; 0
    6338:	e3 e5       	ldi	r30, 0x53	; 83
    633a:	f0 e0       	ldi	r31, 0x00	; 0
    633c:	80 81       	ld	r24, Z
    633e:	87 7f       	andi	r24, 0xF7	; 247
    6340:	8c 93       	st	X, r24
    6342:	2b c0       	rjmp	.+86     	; 0x639a <MTIMER0_voidInit+0x102>
        break;
        
        case TIMER0_CTC_MODE:
            SET_BIT(TCCR0,FOC0);
    6344:	a3 e5       	ldi	r26, 0x53	; 83
    6346:	b0 e0       	ldi	r27, 0x00	; 0
    6348:	e3 e5       	ldi	r30, 0x53	; 83
    634a:	f0 e0       	ldi	r31, 0x00	; 0
    634c:	80 81       	ld	r24, Z
    634e:	80 68       	ori	r24, 0x80	; 128
    6350:	8c 93       	st	X, r24
            CLR_BIT(TCCR0,WGM00);
    6352:	a3 e5       	ldi	r26, 0x53	; 83
    6354:	b0 e0       	ldi	r27, 0x00	; 0
    6356:	e3 e5       	ldi	r30, 0x53	; 83
    6358:	f0 e0       	ldi	r31, 0x00	; 0
    635a:	80 81       	ld	r24, Z
    635c:	8f 7b       	andi	r24, 0xBF	; 191
    635e:	8c 93       	st	X, r24
            SET_BIT(TCCR0,WGM01);
    6360:	a3 e5       	ldi	r26, 0x53	; 83
    6362:	b0 e0       	ldi	r27, 0x00	; 0
    6364:	e3 e5       	ldi	r30, 0x53	; 83
    6366:	f0 e0       	ldi	r31, 0x00	; 0
    6368:	80 81       	ld	r24, Z
    636a:	88 60       	ori	r24, 0x08	; 8
    636c:	8c 93       	st	X, r24
    636e:	15 c0       	rjmp	.+42     	; 0x639a <MTIMER0_voidInit+0x102>
        break;

        case TIMER0_FAST_PWM_MODE:
            CLR_BIT(TCCR0,FOC0);
    6370:	a3 e5       	ldi	r26, 0x53	; 83
    6372:	b0 e0       	ldi	r27, 0x00	; 0
    6374:	e3 e5       	ldi	r30, 0x53	; 83
    6376:	f0 e0       	ldi	r31, 0x00	; 0
    6378:	80 81       	ld	r24, Z
    637a:	8f 77       	andi	r24, 0x7F	; 127
    637c:	8c 93       	st	X, r24
            SET_BIT(TCCR0,WGM00);
    637e:	a3 e5       	ldi	r26, 0x53	; 83
    6380:	b0 e0       	ldi	r27, 0x00	; 0
    6382:	e3 e5       	ldi	r30, 0x53	; 83
    6384:	f0 e0       	ldi	r31, 0x00	; 0
    6386:	80 81       	ld	r24, Z
    6388:	80 64       	ori	r24, 0x40	; 64
    638a:	8c 93       	st	X, r24
            SET_BIT(TCCR0,WGM01);
    638c:	a3 e5       	ldi	r26, 0x53	; 83
    638e:	b0 e0       	ldi	r27, 0x00	; 0
    6390:	e3 e5       	ldi	r30, 0x53	; 83
    6392:	f0 e0       	ldi	r31, 0x00	; 0
    6394:	80 81       	ld	r24, Z
    6396:	88 60       	ori	r24, 0x08	; 8
    6398:	8c 93       	st	X, r24
        break;
    }

    //Clk & Compare Output Mode
    TCCR0&=(~(0b111<<CS00))&(~(0b11<<COM00));
    639a:	a3 e5       	ldi	r26, 0x53	; 83
    639c:	b0 e0       	ldi	r27, 0x00	; 0
    639e:	e3 e5       	ldi	r30, 0x53	; 83
    63a0:	f0 e0       	ldi	r31, 0x00	; 0
    63a2:	80 81       	ld	r24, Z
    63a4:	88 7c       	andi	r24, 0xC8	; 200
    63a6:	8c 93       	st	X, r24
    TCCR0|=((prescaler<<CS00)|(compare<<COM00));
    63a8:	a3 e5       	ldi	r26, 0x53	; 83
    63aa:	b0 e0       	ldi	r27, 0x00	; 0
    63ac:	e3 e5       	ldi	r30, 0x53	; 83
    63ae:	f0 e0       	ldi	r31, 0x00	; 0
    63b0:	80 81       	ld	r24, Z
    63b2:	28 2f       	mov	r18, r24
    63b4:	8b 81       	ldd	r24, Y+3	; 0x03
    63b6:	88 2f       	mov	r24, r24
    63b8:	90 e0       	ldi	r25, 0x00	; 0
    63ba:	82 95       	swap	r24
    63bc:	92 95       	swap	r25
    63be:	90 7f       	andi	r25, 0xF0	; 240
    63c0:	98 27       	eor	r25, r24
    63c2:	80 7f       	andi	r24, 0xF0	; 240
    63c4:	98 27       	eor	r25, r24
    63c6:	98 2f       	mov	r25, r24
    63c8:	8a 81       	ldd	r24, Y+2	; 0x02
    63ca:	89 2b       	or	r24, r25
    63cc:	82 2b       	or	r24, r18
    63ce:	8c 93       	st	X, r24
}
    63d0:	0f 90       	pop	r0
    63d2:	0f 90       	pop	r0
    63d4:	0f 90       	pop	r0
    63d6:	0f 90       	pop	r0
    63d8:	0f 90       	pop	r0
    63da:	cf 91       	pop	r28
    63dc:	df 91       	pop	r29
    63de:	08 95       	ret

000063e0 <MTIMER0_voidOverFlowInterruptEnable>:

/******************************************/
// Interrupt Enable/Disable
void MTIMER0_voidOverFlowInterruptEnable()
{
    63e0:	df 93       	push	r29
    63e2:	cf 93       	push	r28
    63e4:	cd b7       	in	r28, 0x3d	; 61
    63e6:	de b7       	in	r29, 0x3e	; 62
    SET_BIT(TIMSK,TOIE0);
    63e8:	a9 e5       	ldi	r26, 0x59	; 89
    63ea:	b0 e0       	ldi	r27, 0x00	; 0
    63ec:	e9 e5       	ldi	r30, 0x59	; 89
    63ee:	f0 e0       	ldi	r31, 0x00	; 0
    63f0:	80 81       	ld	r24, Z
    63f2:	81 60       	ori	r24, 0x01	; 1
    63f4:	8c 93       	st	X, r24

}
    63f6:	cf 91       	pop	r28
    63f8:	df 91       	pop	r29
    63fa:	08 95       	ret

000063fc <MTIMER0_voidOverFlowInterruptDisable>:
void MTIMER0_voidOverFlowInterruptDisable()
{
    63fc:	df 93       	push	r29
    63fe:	cf 93       	push	r28
    6400:	cd b7       	in	r28, 0x3d	; 61
    6402:	de b7       	in	r29, 0x3e	; 62
    CLR_BIT(TIMSK,TOIE0);
    6404:	a9 e5       	ldi	r26, 0x59	; 89
    6406:	b0 e0       	ldi	r27, 0x00	; 0
    6408:	e9 e5       	ldi	r30, 0x59	; 89
    640a:	f0 e0       	ldi	r31, 0x00	; 0
    640c:	80 81       	ld	r24, Z
    640e:	8e 7f       	andi	r24, 0xFE	; 254
    6410:	8c 93       	st	X, r24
}
    6412:	cf 91       	pop	r28
    6414:	df 91       	pop	r29
    6416:	08 95       	ret

00006418 <MTIMER0_voidCompareInterruptEnable>:

void MTIMER0_voidCompareInterruptEnable()
{
    6418:	df 93       	push	r29
    641a:	cf 93       	push	r28
    641c:	cd b7       	in	r28, 0x3d	; 61
    641e:	de b7       	in	r29, 0x3e	; 62
    SET_BIT(TIMSK,OCIE0);
    6420:	a9 e5       	ldi	r26, 0x59	; 89
    6422:	b0 e0       	ldi	r27, 0x00	; 0
    6424:	e9 e5       	ldi	r30, 0x59	; 89
    6426:	f0 e0       	ldi	r31, 0x00	; 0
    6428:	80 81       	ld	r24, Z
    642a:	82 60       	ori	r24, 0x02	; 2
    642c:	8c 93       	st	X, r24
}
    642e:	cf 91       	pop	r28
    6430:	df 91       	pop	r29
    6432:	08 95       	ret

00006434 <MTIMER0_voidCompareInterruptDisable>:
void MTIMER0_voidCompareInterruptDisable()
{
    6434:	df 93       	push	r29
    6436:	cf 93       	push	r28
    6438:	cd b7       	in	r28, 0x3d	; 61
    643a:	de b7       	in	r29, 0x3e	; 62
    CLR_BIT(TIMSK,OCIE0);
    643c:	a9 e5       	ldi	r26, 0x59	; 89
    643e:	b0 e0       	ldi	r27, 0x00	; 0
    6440:	e9 e5       	ldi	r30, 0x59	; 89
    6442:	f0 e0       	ldi	r31, 0x00	; 0
    6444:	80 81       	ld	r24, Z
    6446:	8d 7f       	andi	r24, 0xFD	; 253
    6448:	8c 93       	st	X, r24

}
    644a:	cf 91       	pop	r28
    644c:	df 91       	pop	r29
    644e:	08 95       	ret

00006450 <MTIMER0_voidSetPreLoad>:
/******************************************/

void MTIMER0_voidSetPreLoad(u8 A_u8PreLoadValue)
{
    6450:	df 93       	push	r29
    6452:	cf 93       	push	r28
    6454:	0f 92       	push	r0
    6456:	cd b7       	in	r28, 0x3d	; 61
    6458:	de b7       	in	r29, 0x3e	; 62
    645a:	89 83       	std	Y+1, r24	; 0x01
    TCNT0=A_u8PreLoadValue;
    645c:	e2 e5       	ldi	r30, 0x52	; 82
    645e:	f0 e0       	ldi	r31, 0x00	; 0
    6460:	89 81       	ldd	r24, Y+1	; 0x01
    6462:	80 83       	st	Z, r24
}
    6464:	0f 90       	pop	r0
    6466:	cf 91       	pop	r28
    6468:	df 91       	pop	r29
    646a:	08 95       	ret

0000646c <MTIMER0_voidSetOCR0>:



void MTIMER0_voidSetOCR0(u8 A_u8OCR0)
{
    646c:	df 93       	push	r29
    646e:	cf 93       	push	r28
    6470:	0f 92       	push	r0
    6472:	cd b7       	in	r28, 0x3d	; 61
    6474:	de b7       	in	r29, 0x3e	; 62
    6476:	89 83       	std	Y+1, r24	; 0x01
    OCR0=A_u8OCR0;
    6478:	ec e5       	ldi	r30, 0x5C	; 92
    647a:	f0 e0       	ldi	r31, 0x00	; 0
    647c:	89 81       	ldd	r24, Y+1	; 0x01
    647e:	80 83       	st	Z, r24
}
    6480:	0f 90       	pop	r0
    6482:	cf 91       	pop	r28
    6484:	df 91       	pop	r29
    6486:	08 95       	ret

00006488 <MTIMER0_voidOVFSetCallBack>:


/*Interrupt Section*/
void MTIMER0_voidOVFSetCallBack(void(*pf)(void))
{
    6488:	df 93       	push	r29
    648a:	cf 93       	push	r28
    648c:	00 d0       	rcall	.+0      	; 0x648e <MTIMER0_voidOVFSetCallBack+0x6>
    648e:	cd b7       	in	r28, 0x3d	; 61
    6490:	de b7       	in	r29, 0x3e	; 62
    6492:	9a 83       	std	Y+2, r25	; 0x02
    6494:	89 83       	std	Y+1, r24	; 0x01
    TIMER0_OVF_CallBack=pf;
    6496:	89 81       	ldd	r24, Y+1	; 0x01
    6498:	9a 81       	ldd	r25, Y+2	; 0x02
    649a:	90 93 b0 01 	sts	0x01B0, r25
    649e:	80 93 af 01 	sts	0x01AF, r24
}
    64a2:	0f 90       	pop	r0
    64a4:	0f 90       	pop	r0
    64a6:	cf 91       	pop	r28
    64a8:	df 91       	pop	r29
    64aa:	08 95       	ret

000064ac <MTIMER0_voidCTCSetCallBack>:

void MTIMER0_voidCTCSetCallBack(void(*pf)(void))
{
    64ac:	df 93       	push	r29
    64ae:	cf 93       	push	r28
    64b0:	00 d0       	rcall	.+0      	; 0x64b2 <MTIMER0_voidCTCSetCallBack+0x6>
    64b2:	cd b7       	in	r28, 0x3d	; 61
    64b4:	de b7       	in	r29, 0x3e	; 62
    64b6:	9a 83       	std	Y+2, r25	; 0x02
    64b8:	89 83       	std	Y+1, r24	; 0x01
    TIMER0_CTC_CallBack=pf;
    64ba:	89 81       	ldd	r24, Y+1	; 0x01
    64bc:	9a 81       	ldd	r25, Y+2	; 0x02
    64be:	90 93 b2 01 	sts	0x01B2, r25
    64c2:	80 93 b1 01 	sts	0x01B1, r24
}
    64c6:	0f 90       	pop	r0
    64c8:	0f 90       	pop	r0
    64ca:	cf 91       	pop	r28
    64cc:	df 91       	pop	r29
    64ce:	08 95       	ret

000064d0 <__vector_11>:

ISR(TIMER0_OVF_VECT)
{
    64d0:	1f 92       	push	r1
    64d2:	0f 92       	push	r0
    64d4:	0f b6       	in	r0, 0x3f	; 63
    64d6:	0f 92       	push	r0
    64d8:	11 24       	eor	r1, r1
    64da:	2f 93       	push	r18
    64dc:	3f 93       	push	r19
    64de:	4f 93       	push	r20
    64e0:	5f 93       	push	r21
    64e2:	6f 93       	push	r22
    64e4:	7f 93       	push	r23
    64e6:	8f 93       	push	r24
    64e8:	9f 93       	push	r25
    64ea:	af 93       	push	r26
    64ec:	bf 93       	push	r27
    64ee:	ef 93       	push	r30
    64f0:	ff 93       	push	r31
    64f2:	df 93       	push	r29
    64f4:	cf 93       	push	r28
    64f6:	cd b7       	in	r28, 0x3d	; 61
    64f8:	de b7       	in	r29, 0x3e	; 62
    if(TIMER0_OVF_CallBack!=NULLPTR) TIMER0_OVF_CallBack();
    64fa:	80 91 af 01 	lds	r24, 0x01AF
    64fe:	90 91 b0 01 	lds	r25, 0x01B0
    6502:	00 97       	sbiw	r24, 0x00	; 0
    6504:	29 f0       	breq	.+10     	; 0x6510 <__vector_11+0x40>
    6506:	e0 91 af 01 	lds	r30, 0x01AF
    650a:	f0 91 b0 01 	lds	r31, 0x01B0
    650e:	09 95       	icall
}
    6510:	cf 91       	pop	r28
    6512:	df 91       	pop	r29
    6514:	ff 91       	pop	r31
    6516:	ef 91       	pop	r30
    6518:	bf 91       	pop	r27
    651a:	af 91       	pop	r26
    651c:	9f 91       	pop	r25
    651e:	8f 91       	pop	r24
    6520:	7f 91       	pop	r23
    6522:	6f 91       	pop	r22
    6524:	5f 91       	pop	r21
    6526:	4f 91       	pop	r20
    6528:	3f 91       	pop	r19
    652a:	2f 91       	pop	r18
    652c:	0f 90       	pop	r0
    652e:	0f be       	out	0x3f, r0	; 63
    6530:	0f 90       	pop	r0
    6532:	1f 90       	pop	r1
    6534:	18 95       	reti

00006536 <__vector_10>:

ISR(TIMER0_CTC_VECT)
{
    6536:	1f 92       	push	r1
    6538:	0f 92       	push	r0
    653a:	0f b6       	in	r0, 0x3f	; 63
    653c:	0f 92       	push	r0
    653e:	11 24       	eor	r1, r1
    6540:	2f 93       	push	r18
    6542:	3f 93       	push	r19
    6544:	4f 93       	push	r20
    6546:	5f 93       	push	r21
    6548:	6f 93       	push	r22
    654a:	7f 93       	push	r23
    654c:	8f 93       	push	r24
    654e:	9f 93       	push	r25
    6550:	af 93       	push	r26
    6552:	bf 93       	push	r27
    6554:	ef 93       	push	r30
    6556:	ff 93       	push	r31
    6558:	df 93       	push	r29
    655a:	cf 93       	push	r28
    655c:	cd b7       	in	r28, 0x3d	; 61
    655e:	de b7       	in	r29, 0x3e	; 62
    if(TIMER0_CTC_CallBack!=NULLPTR) TIMER0_CTC_CallBack();
    6560:	80 91 b1 01 	lds	r24, 0x01B1
    6564:	90 91 b2 01 	lds	r25, 0x01B2
    6568:	00 97       	sbiw	r24, 0x00	; 0
    656a:	29 f0       	breq	.+10     	; 0x6576 <__vector_10+0x40>
    656c:	e0 91 b1 01 	lds	r30, 0x01B1
    6570:	f0 91 b2 01 	lds	r31, 0x01B2
    6574:	09 95       	icall

    6576:	cf 91       	pop	r28
    6578:	df 91       	pop	r29
    657a:	ff 91       	pop	r31
    657c:	ef 91       	pop	r30
    657e:	bf 91       	pop	r27
    6580:	af 91       	pop	r26
    6582:	9f 91       	pop	r25
    6584:	8f 91       	pop	r24
    6586:	7f 91       	pop	r23
    6588:	6f 91       	pop	r22
    658a:	5f 91       	pop	r21
    658c:	4f 91       	pop	r20
    658e:	3f 91       	pop	r19
    6590:	2f 91       	pop	r18
    6592:	0f 90       	pop	r0
    6594:	0f be       	out	0x3f, r0	; 63
    6596:	0f 90       	pop	r0
    6598:	1f 90       	pop	r1
    659a:	18 95       	reti

0000659c <MTIMER1_voidInit>:
static void(*TIMER1_COMB)(void)=NULLPTR;
static void(*TIMER1_OVF)(void)=NULLPTR;
static void func_ICU(void);

void MTIMER1_voidInit(TIMER1_Mode mode,TIMER1_Prescaler prescaler,TIMER1_CompareA compareA,TIMER1_CompareB compareB)
{
    659c:	df 93       	push	r29
    659e:	cf 93       	push	r28
    65a0:	00 d0       	rcall	.+0      	; 0x65a2 <MTIMER1_voidInit+0x6>
    65a2:	00 d0       	rcall	.+0      	; 0x65a4 <MTIMER1_voidInit+0x8>
    65a4:	00 d0       	rcall	.+0      	; 0x65a6 <MTIMER1_voidInit+0xa>
    65a6:	cd b7       	in	r28, 0x3d	; 61
    65a8:	de b7       	in	r29, 0x3e	; 62
    65aa:	89 83       	std	Y+1, r24	; 0x01
    65ac:	6a 83       	std	Y+2, r22	; 0x02
    65ae:	4b 83       	std	Y+3, r20	; 0x03
    65b0:	2c 83       	std	Y+4, r18	; 0x04
    switch(mode)
    65b2:	89 81       	ldd	r24, Y+1	; 0x01
    65b4:	28 2f       	mov	r18, r24
    65b6:	30 e0       	ldi	r19, 0x00	; 0
    65b8:	3e 83       	std	Y+6, r19	; 0x06
    65ba:	2d 83       	std	Y+5, r18	; 0x05
    65bc:	8d 81       	ldd	r24, Y+5	; 0x05
    65be:	9e 81       	ldd	r25, Y+6	; 0x06
    65c0:	87 30       	cpi	r24, 0x07	; 7
    65c2:	91 05       	cpc	r25, r1
    65c4:	09 f4       	brne	.+2      	; 0x65c8 <MTIMER1_voidInit+0x2c>
    65c6:	1e c1       	rjmp	.+572    	; 0x6804 <MTIMER1_voidInit+0x268>
    65c8:	2d 81       	ldd	r18, Y+5	; 0x05
    65ca:	3e 81       	ldd	r19, Y+6	; 0x06
    65cc:	28 30       	cpi	r18, 0x08	; 8
    65ce:	31 05       	cpc	r19, r1
    65d0:	4c f5       	brge	.+82     	; 0x6624 <MTIMER1_voidInit+0x88>
    65d2:	8d 81       	ldd	r24, Y+5	; 0x05
    65d4:	9e 81       	ldd	r25, Y+6	; 0x06
    65d6:	83 30       	cpi	r24, 0x03	; 3
    65d8:	91 05       	cpc	r25, r1
    65da:	09 f4       	brne	.+2      	; 0x65de <MTIMER1_voidInit+0x42>
    65dc:	a1 c0       	rjmp	.+322    	; 0x6720 <MTIMER1_voidInit+0x184>
    65de:	2d 81       	ldd	r18, Y+5	; 0x05
    65e0:	3e 81       	ldd	r19, Y+6	; 0x06
    65e2:	24 30       	cpi	r18, 0x04	; 4
    65e4:	31 05       	cpc	r19, r1
    65e6:	8c f4       	brge	.+34     	; 0x660a <MTIMER1_voidInit+0x6e>
    65e8:	8d 81       	ldd	r24, Y+5	; 0x05
    65ea:	9e 81       	ldd	r25, Y+6	; 0x06
    65ec:	81 30       	cpi	r24, 0x01	; 1
    65ee:	91 05       	cpc	r25, r1
    65f0:	09 f4       	brne	.+2      	; 0x65f4 <MTIMER1_voidInit+0x58>
    65f2:	5e c0       	rjmp	.+188    	; 0x66b0 <MTIMER1_voidInit+0x114>
    65f4:	2d 81       	ldd	r18, Y+5	; 0x05
    65f6:	3e 81       	ldd	r19, Y+6	; 0x06
    65f8:	22 30       	cpi	r18, 0x02	; 2
    65fa:	31 05       	cpc	r19, r1
    65fc:	0c f0       	brlt	.+2      	; 0x6600 <MTIMER1_voidInit+0x64>
    65fe:	74 c0       	rjmp	.+232    	; 0x66e8 <MTIMER1_voidInit+0x14c>
    6600:	8d 81       	ldd	r24, Y+5	; 0x05
    6602:	9e 81       	ldd	r25, Y+6	; 0x06
    6604:	00 97       	sbiw	r24, 0x00	; 0
    6606:	c9 f1       	breq	.+114    	; 0x667a <MTIMER1_voidInit+0xde>
    6608:	e2 c1       	rjmp	.+964    	; 0x69ce <MTIMER1_voidInit+0x432>
    660a:	2d 81       	ldd	r18, Y+5	; 0x05
    660c:	3e 81       	ldd	r19, Y+6	; 0x06
    660e:	25 30       	cpi	r18, 0x05	; 5
    6610:	31 05       	cpc	r19, r1
    6612:	09 f4       	brne	.+2      	; 0x6616 <MTIMER1_voidInit+0x7a>
    6614:	bd c0       	rjmp	.+378    	; 0x6790 <MTIMER1_voidInit+0x1f4>
    6616:	8d 81       	ldd	r24, Y+5	; 0x05
    6618:	9e 81       	ldd	r25, Y+6	; 0x06
    661a:	86 30       	cpi	r24, 0x06	; 6
    661c:	91 05       	cpc	r25, r1
    661e:	0c f0       	brlt	.+2      	; 0x6622 <MTIMER1_voidInit+0x86>
    6620:	d4 c0       	rjmp	.+424    	; 0x67ca <MTIMER1_voidInit+0x22e>
    6622:	9a c0       	rjmp	.+308    	; 0x6758 <MTIMER1_voidInit+0x1bc>
    6624:	2d 81       	ldd	r18, Y+5	; 0x05
    6626:	3e 81       	ldd	r19, Y+6	; 0x06
    6628:	2b 30       	cpi	r18, 0x0B	; 11
    662a:	31 05       	cpc	r19, r1
    662c:	09 f4       	brne	.+2      	; 0x6630 <MTIMER1_voidInit+0x94>
    662e:	5d c1       	rjmp	.+698    	; 0x68ea <MTIMER1_voidInit+0x34e>
    6630:	8d 81       	ldd	r24, Y+5	; 0x05
    6632:	9e 81       	ldd	r25, Y+6	; 0x06
    6634:	8c 30       	cpi	r24, 0x0C	; 12
    6636:	91 05       	cpc	r25, r1
    6638:	6c f4       	brge	.+26     	; 0x6654 <MTIMER1_voidInit+0xb8>
    663a:	2d 81       	ldd	r18, Y+5	; 0x05
    663c:	3e 81       	ldd	r19, Y+6	; 0x06
    663e:	29 30       	cpi	r18, 0x09	; 9
    6640:	31 05       	cpc	r19, r1
    6642:	09 f4       	brne	.+2      	; 0x6646 <MTIMER1_voidInit+0xaa>
    6644:	18 c1       	rjmp	.+560    	; 0x6876 <MTIMER1_voidInit+0x2da>
    6646:	8d 81       	ldd	r24, Y+5	; 0x05
    6648:	9e 81       	ldd	r25, Y+6	; 0x06
    664a:	8a 30       	cpi	r24, 0x0A	; 10
    664c:	91 05       	cpc	r25, r1
    664e:	0c f0       	brlt	.+2      	; 0x6652 <MTIMER1_voidInit+0xb6>
    6650:	2f c1       	rjmp	.+606    	; 0x68b0 <MTIMER1_voidInit+0x314>
    6652:	f5 c0       	rjmp	.+490    	; 0x683e <MTIMER1_voidInit+0x2a2>
    6654:	2d 81       	ldd	r18, Y+5	; 0x05
    6656:	3e 81       	ldd	r19, Y+6	; 0x06
    6658:	2d 30       	cpi	r18, 0x0D	; 13
    665a:	31 05       	cpc	r19, r1
    665c:	09 f4       	brne	.+2      	; 0x6660 <MTIMER1_voidInit+0xc4>
    665e:	7e c1       	rjmp	.+764    	; 0x695c <MTIMER1_voidInit+0x3c0>
    6660:	8d 81       	ldd	r24, Y+5	; 0x05
    6662:	9e 81       	ldd	r25, Y+6	; 0x06
    6664:	8d 30       	cpi	r24, 0x0D	; 13
    6666:	91 05       	cpc	r25, r1
    6668:	0c f4       	brge	.+2      	; 0x666c <MTIMER1_voidInit+0xd0>
    666a:	5c c1       	rjmp	.+696    	; 0x6924 <MTIMER1_voidInit+0x388>
    666c:	2d 81       	ldd	r18, Y+5	; 0x05
    666e:	3e 81       	ldd	r19, Y+6	; 0x06
    6670:	2e 30       	cpi	r18, 0x0E	; 14
    6672:	31 05       	cpc	r19, r1
    6674:	09 f4       	brne	.+2      	; 0x6678 <MTIMER1_voidInit+0xdc>
    6676:	8f c1       	rjmp	.+798    	; 0x6996 <MTIMER1_voidInit+0x3fa>
    6678:	aa c1       	rjmp	.+852    	; 0x69ce <MTIMER1_voidInit+0x432>
    {
        case TIMER1_NORMAL_MODE:
        TCCR1A&=~(0b11<<WGM10);
    667a:	af e4       	ldi	r26, 0x4F	; 79
    667c:	b0 e0       	ldi	r27, 0x00	; 0
    667e:	ef e4       	ldi	r30, 0x4F	; 79
    6680:	f0 e0       	ldi	r31, 0x00	; 0
    6682:	80 81       	ld	r24, Z
    6684:	8c 7f       	andi	r24, 0xFC	; 252
    6686:	8c 93       	st	X, r24
        TCCR1A|=(0b00<<WGM10);
    6688:	af e4       	ldi	r26, 0x4F	; 79
    668a:	b0 e0       	ldi	r27, 0x00	; 0
    668c:	ef e4       	ldi	r30, 0x4F	; 79
    668e:	f0 e0       	ldi	r31, 0x00	; 0
    6690:	80 81       	ld	r24, Z
    6692:	8c 93       	st	X, r24
        TCCR1B&=~(0b11<<WGM12);
    6694:	ae e4       	ldi	r26, 0x4E	; 78
    6696:	b0 e0       	ldi	r27, 0x00	; 0
    6698:	ee e4       	ldi	r30, 0x4E	; 78
    669a:	f0 e0       	ldi	r31, 0x00	; 0
    669c:	80 81       	ld	r24, Z
    669e:	87 7e       	andi	r24, 0xE7	; 231
    66a0:	8c 93       	st	X, r24
        TCCR1B|=(0b00<<WGM12);
    66a2:	ae e4       	ldi	r26, 0x4E	; 78
    66a4:	b0 e0       	ldi	r27, 0x00	; 0
    66a6:	ee e4       	ldi	r30, 0x4E	; 78
    66a8:	f0 e0       	ldi	r31, 0x00	; 0
    66aa:	80 81       	ld	r24, Z
    66ac:	8c 93       	st	X, r24
    66ae:	8f c1       	rjmp	.+798    	; 0x69ce <MTIMER1_voidInit+0x432>
        break;

        case TIMER1_PHASE_CORRECT_8BIT:
        TCCR1A&=~(0b11<<WGM10);
    66b0:	af e4       	ldi	r26, 0x4F	; 79
    66b2:	b0 e0       	ldi	r27, 0x00	; 0
    66b4:	ef e4       	ldi	r30, 0x4F	; 79
    66b6:	f0 e0       	ldi	r31, 0x00	; 0
    66b8:	80 81       	ld	r24, Z
    66ba:	8c 7f       	andi	r24, 0xFC	; 252
    66bc:	8c 93       	st	X, r24
        TCCR1A|=(0b01<<WGM10);
    66be:	af e4       	ldi	r26, 0x4F	; 79
    66c0:	b0 e0       	ldi	r27, 0x00	; 0
    66c2:	ef e4       	ldi	r30, 0x4F	; 79
    66c4:	f0 e0       	ldi	r31, 0x00	; 0
    66c6:	80 81       	ld	r24, Z
    66c8:	81 60       	ori	r24, 0x01	; 1
    66ca:	8c 93       	st	X, r24
        TCCR1B&=~(0b11<<WGM12);
    66cc:	ae e4       	ldi	r26, 0x4E	; 78
    66ce:	b0 e0       	ldi	r27, 0x00	; 0
    66d0:	ee e4       	ldi	r30, 0x4E	; 78
    66d2:	f0 e0       	ldi	r31, 0x00	; 0
    66d4:	80 81       	ld	r24, Z
    66d6:	87 7e       	andi	r24, 0xE7	; 231
    66d8:	8c 93       	st	X, r24
        TCCR1B|=(0b00<<WGM12);
    66da:	ae e4       	ldi	r26, 0x4E	; 78
    66dc:	b0 e0       	ldi	r27, 0x00	; 0
    66de:	ee e4       	ldi	r30, 0x4E	; 78
    66e0:	f0 e0       	ldi	r31, 0x00	; 0
    66e2:	80 81       	ld	r24, Z
    66e4:	8c 93       	st	X, r24
    66e6:	73 c1       	rjmp	.+742    	; 0x69ce <MTIMER1_voidInit+0x432>
        break;

        case TIMER1_PHASE_CORRECT_9BIT:
        TCCR1A&=~(0b11<<WGM10);
    66e8:	af e4       	ldi	r26, 0x4F	; 79
    66ea:	b0 e0       	ldi	r27, 0x00	; 0
    66ec:	ef e4       	ldi	r30, 0x4F	; 79
    66ee:	f0 e0       	ldi	r31, 0x00	; 0
    66f0:	80 81       	ld	r24, Z
    66f2:	8c 7f       	andi	r24, 0xFC	; 252
    66f4:	8c 93       	st	X, r24
        TCCR1A|=(0b10<<WGM10);
    66f6:	af e4       	ldi	r26, 0x4F	; 79
    66f8:	b0 e0       	ldi	r27, 0x00	; 0
    66fa:	ef e4       	ldi	r30, 0x4F	; 79
    66fc:	f0 e0       	ldi	r31, 0x00	; 0
    66fe:	80 81       	ld	r24, Z
    6700:	82 60       	ori	r24, 0x02	; 2
    6702:	8c 93       	st	X, r24
        TCCR1B&=~(0b11<<WGM12);
    6704:	ae e4       	ldi	r26, 0x4E	; 78
    6706:	b0 e0       	ldi	r27, 0x00	; 0
    6708:	ee e4       	ldi	r30, 0x4E	; 78
    670a:	f0 e0       	ldi	r31, 0x00	; 0
    670c:	80 81       	ld	r24, Z
    670e:	87 7e       	andi	r24, 0xE7	; 231
    6710:	8c 93       	st	X, r24
        TCCR1B|=(0b00<<WGM12);
    6712:	ae e4       	ldi	r26, 0x4E	; 78
    6714:	b0 e0       	ldi	r27, 0x00	; 0
    6716:	ee e4       	ldi	r30, 0x4E	; 78
    6718:	f0 e0       	ldi	r31, 0x00	; 0
    671a:	80 81       	ld	r24, Z
    671c:	8c 93       	st	X, r24
    671e:	57 c1       	rjmp	.+686    	; 0x69ce <MTIMER1_voidInit+0x432>
        break;

        case TIMER1_PHASE_CORRECT_10BIT:
        TCCR1A&=~(0b11<<WGM10);
    6720:	af e4       	ldi	r26, 0x4F	; 79
    6722:	b0 e0       	ldi	r27, 0x00	; 0
    6724:	ef e4       	ldi	r30, 0x4F	; 79
    6726:	f0 e0       	ldi	r31, 0x00	; 0
    6728:	80 81       	ld	r24, Z
    672a:	8c 7f       	andi	r24, 0xFC	; 252
    672c:	8c 93       	st	X, r24
        TCCR1A|=(0b11<<WGM10);
    672e:	af e4       	ldi	r26, 0x4F	; 79
    6730:	b0 e0       	ldi	r27, 0x00	; 0
    6732:	ef e4       	ldi	r30, 0x4F	; 79
    6734:	f0 e0       	ldi	r31, 0x00	; 0
    6736:	80 81       	ld	r24, Z
    6738:	83 60       	ori	r24, 0x03	; 3
    673a:	8c 93       	st	X, r24
        TCCR1B&=~(0b11<<WGM12);
    673c:	ae e4       	ldi	r26, 0x4E	; 78
    673e:	b0 e0       	ldi	r27, 0x00	; 0
    6740:	ee e4       	ldi	r30, 0x4E	; 78
    6742:	f0 e0       	ldi	r31, 0x00	; 0
    6744:	80 81       	ld	r24, Z
    6746:	87 7e       	andi	r24, 0xE7	; 231
    6748:	8c 93       	st	X, r24
        TCCR1B|=(0b00<<WGM12);
    674a:	ae e4       	ldi	r26, 0x4E	; 78
    674c:	b0 e0       	ldi	r27, 0x00	; 0
    674e:	ee e4       	ldi	r30, 0x4E	; 78
    6750:	f0 e0       	ldi	r31, 0x00	; 0
    6752:	80 81       	ld	r24, Z
    6754:	8c 93       	st	X, r24
    6756:	3b c1       	rjmp	.+630    	; 0x69ce <MTIMER1_voidInit+0x432>
        break;

        case TIMER1_CTC_OCR1A:
        TCCR1A&=~(0b11<<WGM10);
    6758:	af e4       	ldi	r26, 0x4F	; 79
    675a:	b0 e0       	ldi	r27, 0x00	; 0
    675c:	ef e4       	ldi	r30, 0x4F	; 79
    675e:	f0 e0       	ldi	r31, 0x00	; 0
    6760:	80 81       	ld	r24, Z
    6762:	8c 7f       	andi	r24, 0xFC	; 252
    6764:	8c 93       	st	X, r24
        TCCR1A|=(0b00<<WGM10);
    6766:	af e4       	ldi	r26, 0x4F	; 79
    6768:	b0 e0       	ldi	r27, 0x00	; 0
    676a:	ef e4       	ldi	r30, 0x4F	; 79
    676c:	f0 e0       	ldi	r31, 0x00	; 0
    676e:	80 81       	ld	r24, Z
    6770:	8c 93       	st	X, r24
        TCCR1B&=~(0b11<<WGM12);
    6772:	ae e4       	ldi	r26, 0x4E	; 78
    6774:	b0 e0       	ldi	r27, 0x00	; 0
    6776:	ee e4       	ldi	r30, 0x4E	; 78
    6778:	f0 e0       	ldi	r31, 0x00	; 0
    677a:	80 81       	ld	r24, Z
    677c:	87 7e       	andi	r24, 0xE7	; 231
    677e:	8c 93       	st	X, r24
        TCCR1B|=(0b01<<WGM12);
    6780:	ae e4       	ldi	r26, 0x4E	; 78
    6782:	b0 e0       	ldi	r27, 0x00	; 0
    6784:	ee e4       	ldi	r30, 0x4E	; 78
    6786:	f0 e0       	ldi	r31, 0x00	; 0
    6788:	80 81       	ld	r24, Z
    678a:	88 60       	ori	r24, 0x08	; 8
    678c:	8c 93       	st	X, r24
    678e:	1f c1       	rjmp	.+574    	; 0x69ce <MTIMER1_voidInit+0x432>
        break;
        
        case TIMER1_FAST_PWM_8BIT:
        TCCR1A&=~(0b11<<WGM10);
    6790:	af e4       	ldi	r26, 0x4F	; 79
    6792:	b0 e0       	ldi	r27, 0x00	; 0
    6794:	ef e4       	ldi	r30, 0x4F	; 79
    6796:	f0 e0       	ldi	r31, 0x00	; 0
    6798:	80 81       	ld	r24, Z
    679a:	8c 7f       	andi	r24, 0xFC	; 252
    679c:	8c 93       	st	X, r24
        TCCR1A|=(0b01<<WGM10);
    679e:	af e4       	ldi	r26, 0x4F	; 79
    67a0:	b0 e0       	ldi	r27, 0x00	; 0
    67a2:	ef e4       	ldi	r30, 0x4F	; 79
    67a4:	f0 e0       	ldi	r31, 0x00	; 0
    67a6:	80 81       	ld	r24, Z
    67a8:	81 60       	ori	r24, 0x01	; 1
    67aa:	8c 93       	st	X, r24
        TCCR1B&=~(0b11<<WGM12);
    67ac:	ae e4       	ldi	r26, 0x4E	; 78
    67ae:	b0 e0       	ldi	r27, 0x00	; 0
    67b0:	ee e4       	ldi	r30, 0x4E	; 78
    67b2:	f0 e0       	ldi	r31, 0x00	; 0
    67b4:	80 81       	ld	r24, Z
    67b6:	87 7e       	andi	r24, 0xE7	; 231
    67b8:	8c 93       	st	X, r24
        TCCR1B|=(0b01<<WGM12);
    67ba:	ae e4       	ldi	r26, 0x4E	; 78
    67bc:	b0 e0       	ldi	r27, 0x00	; 0
    67be:	ee e4       	ldi	r30, 0x4E	; 78
    67c0:	f0 e0       	ldi	r31, 0x00	; 0
    67c2:	80 81       	ld	r24, Z
    67c4:	88 60       	ori	r24, 0x08	; 8
    67c6:	8c 93       	st	X, r24
    67c8:	02 c1       	rjmp	.+516    	; 0x69ce <MTIMER1_voidInit+0x432>
        break;
        
        case TIMER1_FAST_PWM_9BIT:
        TCCR1A&=~(0b11<<WGM10);
    67ca:	af e4       	ldi	r26, 0x4F	; 79
    67cc:	b0 e0       	ldi	r27, 0x00	; 0
    67ce:	ef e4       	ldi	r30, 0x4F	; 79
    67d0:	f0 e0       	ldi	r31, 0x00	; 0
    67d2:	80 81       	ld	r24, Z
    67d4:	8c 7f       	andi	r24, 0xFC	; 252
    67d6:	8c 93       	st	X, r24
        TCCR1A|=(0b10<<WGM10);
    67d8:	af e4       	ldi	r26, 0x4F	; 79
    67da:	b0 e0       	ldi	r27, 0x00	; 0
    67dc:	ef e4       	ldi	r30, 0x4F	; 79
    67de:	f0 e0       	ldi	r31, 0x00	; 0
    67e0:	80 81       	ld	r24, Z
    67e2:	82 60       	ori	r24, 0x02	; 2
    67e4:	8c 93       	st	X, r24
        TCCR1B&=~(0b11<<WGM12);
    67e6:	ae e4       	ldi	r26, 0x4E	; 78
    67e8:	b0 e0       	ldi	r27, 0x00	; 0
    67ea:	ee e4       	ldi	r30, 0x4E	; 78
    67ec:	f0 e0       	ldi	r31, 0x00	; 0
    67ee:	80 81       	ld	r24, Z
    67f0:	87 7e       	andi	r24, 0xE7	; 231
    67f2:	8c 93       	st	X, r24
        TCCR1B|=(0b01<<WGM12);
    67f4:	ae e4       	ldi	r26, 0x4E	; 78
    67f6:	b0 e0       	ldi	r27, 0x00	; 0
    67f8:	ee e4       	ldi	r30, 0x4E	; 78
    67fa:	f0 e0       	ldi	r31, 0x00	; 0
    67fc:	80 81       	ld	r24, Z
    67fe:	88 60       	ori	r24, 0x08	; 8
    6800:	8c 93       	st	X, r24
    6802:	e5 c0       	rjmp	.+458    	; 0x69ce <MTIMER1_voidInit+0x432>
        break;
        
        case TIMER1_FAST_PWM_10BIT:
        TCCR1A&=~(0b11<<WGM10);
    6804:	af e4       	ldi	r26, 0x4F	; 79
    6806:	b0 e0       	ldi	r27, 0x00	; 0
    6808:	ef e4       	ldi	r30, 0x4F	; 79
    680a:	f0 e0       	ldi	r31, 0x00	; 0
    680c:	80 81       	ld	r24, Z
    680e:	8c 7f       	andi	r24, 0xFC	; 252
    6810:	8c 93       	st	X, r24
        TCCR1A|=(0b11<<WGM10);
    6812:	af e4       	ldi	r26, 0x4F	; 79
    6814:	b0 e0       	ldi	r27, 0x00	; 0
    6816:	ef e4       	ldi	r30, 0x4F	; 79
    6818:	f0 e0       	ldi	r31, 0x00	; 0
    681a:	80 81       	ld	r24, Z
    681c:	83 60       	ori	r24, 0x03	; 3
    681e:	8c 93       	st	X, r24
        TCCR1B&=~(0b11<<WGM12);
    6820:	ae e4       	ldi	r26, 0x4E	; 78
    6822:	b0 e0       	ldi	r27, 0x00	; 0
    6824:	ee e4       	ldi	r30, 0x4E	; 78
    6826:	f0 e0       	ldi	r31, 0x00	; 0
    6828:	80 81       	ld	r24, Z
    682a:	87 7e       	andi	r24, 0xE7	; 231
    682c:	8c 93       	st	X, r24
        TCCR1B|=(0b01<<WGM12);
    682e:	ae e4       	ldi	r26, 0x4E	; 78
    6830:	b0 e0       	ldi	r27, 0x00	; 0
    6832:	ee e4       	ldi	r30, 0x4E	; 78
    6834:	f0 e0       	ldi	r31, 0x00	; 0
    6836:	80 81       	ld	r24, Z
    6838:	88 60       	ori	r24, 0x08	; 8
    683a:	8c 93       	st	X, r24
    683c:	c8 c0       	rjmp	.+400    	; 0x69ce <MTIMER1_voidInit+0x432>
        break;
        
        case TIMER1_PHASE_AND_FREQUENCY_CORRECT_ICR1:
        TCCR1A&=~(0b11<<WGM10);
    683e:	af e4       	ldi	r26, 0x4F	; 79
    6840:	b0 e0       	ldi	r27, 0x00	; 0
    6842:	ef e4       	ldi	r30, 0x4F	; 79
    6844:	f0 e0       	ldi	r31, 0x00	; 0
    6846:	80 81       	ld	r24, Z
    6848:	8c 7f       	andi	r24, 0xFC	; 252
    684a:	8c 93       	st	X, r24
        TCCR1A|=(0b00<<WGM10);
    684c:	af e4       	ldi	r26, 0x4F	; 79
    684e:	b0 e0       	ldi	r27, 0x00	; 0
    6850:	ef e4       	ldi	r30, 0x4F	; 79
    6852:	f0 e0       	ldi	r31, 0x00	; 0
    6854:	80 81       	ld	r24, Z
    6856:	8c 93       	st	X, r24
        TCCR1B&=~(0b11<<WGM12);
    6858:	ae e4       	ldi	r26, 0x4E	; 78
    685a:	b0 e0       	ldi	r27, 0x00	; 0
    685c:	ee e4       	ldi	r30, 0x4E	; 78
    685e:	f0 e0       	ldi	r31, 0x00	; 0
    6860:	80 81       	ld	r24, Z
    6862:	87 7e       	andi	r24, 0xE7	; 231
    6864:	8c 93       	st	X, r24
        TCCR1B|=(0b10<<WGM12);
    6866:	ae e4       	ldi	r26, 0x4E	; 78
    6868:	b0 e0       	ldi	r27, 0x00	; 0
    686a:	ee e4       	ldi	r30, 0x4E	; 78
    686c:	f0 e0       	ldi	r31, 0x00	; 0
    686e:	80 81       	ld	r24, Z
    6870:	80 61       	ori	r24, 0x10	; 16
    6872:	8c 93       	st	X, r24
    6874:	ac c0       	rjmp	.+344    	; 0x69ce <MTIMER1_voidInit+0x432>
        break;
        
        case TIMER1_PHASE_AND_FREQUENCY_CORRECT_OCRA1:
        TCCR1A&=~(0b11<<WGM10);
    6876:	af e4       	ldi	r26, 0x4F	; 79
    6878:	b0 e0       	ldi	r27, 0x00	; 0
    687a:	ef e4       	ldi	r30, 0x4F	; 79
    687c:	f0 e0       	ldi	r31, 0x00	; 0
    687e:	80 81       	ld	r24, Z
    6880:	8c 7f       	andi	r24, 0xFC	; 252
    6882:	8c 93       	st	X, r24
        TCCR1A|=(0b01<<WGM10);
    6884:	af e4       	ldi	r26, 0x4F	; 79
    6886:	b0 e0       	ldi	r27, 0x00	; 0
    6888:	ef e4       	ldi	r30, 0x4F	; 79
    688a:	f0 e0       	ldi	r31, 0x00	; 0
    688c:	80 81       	ld	r24, Z
    688e:	81 60       	ori	r24, 0x01	; 1
    6890:	8c 93       	st	X, r24
        TCCR1B&=~(0b11<<WGM12);
    6892:	ae e4       	ldi	r26, 0x4E	; 78
    6894:	b0 e0       	ldi	r27, 0x00	; 0
    6896:	ee e4       	ldi	r30, 0x4E	; 78
    6898:	f0 e0       	ldi	r31, 0x00	; 0
    689a:	80 81       	ld	r24, Z
    689c:	87 7e       	andi	r24, 0xE7	; 231
    689e:	8c 93       	st	X, r24
        TCCR1B|=(0b10<<WGM12);
    68a0:	ae e4       	ldi	r26, 0x4E	; 78
    68a2:	b0 e0       	ldi	r27, 0x00	; 0
    68a4:	ee e4       	ldi	r30, 0x4E	; 78
    68a6:	f0 e0       	ldi	r31, 0x00	; 0
    68a8:	80 81       	ld	r24, Z
    68aa:	80 61       	ori	r24, 0x10	; 16
    68ac:	8c 93       	st	X, r24
    68ae:	8f c0       	rjmp	.+286    	; 0x69ce <MTIMER1_voidInit+0x432>
        break;
        
        case TIMER1_PHASE_CORRECT_ICR1:
        TCCR1A&=~(0b11<<WGM10);
    68b0:	af e4       	ldi	r26, 0x4F	; 79
    68b2:	b0 e0       	ldi	r27, 0x00	; 0
    68b4:	ef e4       	ldi	r30, 0x4F	; 79
    68b6:	f0 e0       	ldi	r31, 0x00	; 0
    68b8:	80 81       	ld	r24, Z
    68ba:	8c 7f       	andi	r24, 0xFC	; 252
    68bc:	8c 93       	st	X, r24
        TCCR1A|=(0b10<<WGM10);
    68be:	af e4       	ldi	r26, 0x4F	; 79
    68c0:	b0 e0       	ldi	r27, 0x00	; 0
    68c2:	ef e4       	ldi	r30, 0x4F	; 79
    68c4:	f0 e0       	ldi	r31, 0x00	; 0
    68c6:	80 81       	ld	r24, Z
    68c8:	82 60       	ori	r24, 0x02	; 2
    68ca:	8c 93       	st	X, r24
        TCCR1B&=~(0b11<<WGM12);
    68cc:	ae e4       	ldi	r26, 0x4E	; 78
    68ce:	b0 e0       	ldi	r27, 0x00	; 0
    68d0:	ee e4       	ldi	r30, 0x4E	; 78
    68d2:	f0 e0       	ldi	r31, 0x00	; 0
    68d4:	80 81       	ld	r24, Z
    68d6:	87 7e       	andi	r24, 0xE7	; 231
    68d8:	8c 93       	st	X, r24
        TCCR1B|=(0b10<<WGM12);
    68da:	ae e4       	ldi	r26, 0x4E	; 78
    68dc:	b0 e0       	ldi	r27, 0x00	; 0
    68de:	ee e4       	ldi	r30, 0x4E	; 78
    68e0:	f0 e0       	ldi	r31, 0x00	; 0
    68e2:	80 81       	ld	r24, Z
    68e4:	80 61       	ori	r24, 0x10	; 16
    68e6:	8c 93       	st	X, r24
    68e8:	72 c0       	rjmp	.+228    	; 0x69ce <MTIMER1_voidInit+0x432>
        break;
        
        case TIMER1_PHASE_CORRECT_OCRA1:
        TCCR1A&=~(0b11<<WGM10);
    68ea:	af e4       	ldi	r26, 0x4F	; 79
    68ec:	b0 e0       	ldi	r27, 0x00	; 0
    68ee:	ef e4       	ldi	r30, 0x4F	; 79
    68f0:	f0 e0       	ldi	r31, 0x00	; 0
    68f2:	80 81       	ld	r24, Z
    68f4:	8c 7f       	andi	r24, 0xFC	; 252
    68f6:	8c 93       	st	X, r24
        TCCR1A|=(0b11<<WGM10);
    68f8:	af e4       	ldi	r26, 0x4F	; 79
    68fa:	b0 e0       	ldi	r27, 0x00	; 0
    68fc:	ef e4       	ldi	r30, 0x4F	; 79
    68fe:	f0 e0       	ldi	r31, 0x00	; 0
    6900:	80 81       	ld	r24, Z
    6902:	83 60       	ori	r24, 0x03	; 3
    6904:	8c 93       	st	X, r24
        TCCR1B&=~(0b11<<WGM12);
    6906:	ae e4       	ldi	r26, 0x4E	; 78
    6908:	b0 e0       	ldi	r27, 0x00	; 0
    690a:	ee e4       	ldi	r30, 0x4E	; 78
    690c:	f0 e0       	ldi	r31, 0x00	; 0
    690e:	80 81       	ld	r24, Z
    6910:	87 7e       	andi	r24, 0xE7	; 231
    6912:	8c 93       	st	X, r24
        TCCR1B|=(0b10<<WGM12);
    6914:	ae e4       	ldi	r26, 0x4E	; 78
    6916:	b0 e0       	ldi	r27, 0x00	; 0
    6918:	ee e4       	ldi	r30, 0x4E	; 78
    691a:	f0 e0       	ldi	r31, 0x00	; 0
    691c:	80 81       	ld	r24, Z
    691e:	80 61       	ori	r24, 0x10	; 16
    6920:	8c 93       	st	X, r24
    6922:	55 c0       	rjmp	.+170    	; 0x69ce <MTIMER1_voidInit+0x432>
        break;
        
        case TIMER1_CTC_ICR1:
        TCCR1A&=~(0b11<<WGM10);
    6924:	af e4       	ldi	r26, 0x4F	; 79
    6926:	b0 e0       	ldi	r27, 0x00	; 0
    6928:	ef e4       	ldi	r30, 0x4F	; 79
    692a:	f0 e0       	ldi	r31, 0x00	; 0
    692c:	80 81       	ld	r24, Z
    692e:	8c 7f       	andi	r24, 0xFC	; 252
    6930:	8c 93       	st	X, r24
        TCCR1A|=(0b00<<WGM10);
    6932:	af e4       	ldi	r26, 0x4F	; 79
    6934:	b0 e0       	ldi	r27, 0x00	; 0
    6936:	ef e4       	ldi	r30, 0x4F	; 79
    6938:	f0 e0       	ldi	r31, 0x00	; 0
    693a:	80 81       	ld	r24, Z
    693c:	8c 93       	st	X, r24
        TCCR1B&=~(0b11<<WGM12);
    693e:	ae e4       	ldi	r26, 0x4E	; 78
    6940:	b0 e0       	ldi	r27, 0x00	; 0
    6942:	ee e4       	ldi	r30, 0x4E	; 78
    6944:	f0 e0       	ldi	r31, 0x00	; 0
    6946:	80 81       	ld	r24, Z
    6948:	87 7e       	andi	r24, 0xE7	; 231
    694a:	8c 93       	st	X, r24
        TCCR1B|=(0b11<<WGM12);
    694c:	ae e4       	ldi	r26, 0x4E	; 78
    694e:	b0 e0       	ldi	r27, 0x00	; 0
    6950:	ee e4       	ldi	r30, 0x4E	; 78
    6952:	f0 e0       	ldi	r31, 0x00	; 0
    6954:	80 81       	ld	r24, Z
    6956:	88 61       	ori	r24, 0x18	; 24
    6958:	8c 93       	st	X, r24
    695a:	39 c0       	rjmp	.+114    	; 0x69ce <MTIMER1_voidInit+0x432>
        break;
        
        case TIMER1_FAST_PWM_ICR1:
        TCCR1A&=~(0b11<<WGM10);
    695c:	af e4       	ldi	r26, 0x4F	; 79
    695e:	b0 e0       	ldi	r27, 0x00	; 0
    6960:	ef e4       	ldi	r30, 0x4F	; 79
    6962:	f0 e0       	ldi	r31, 0x00	; 0
    6964:	80 81       	ld	r24, Z
    6966:	8c 7f       	andi	r24, 0xFC	; 252
    6968:	8c 93       	st	X, r24
        TCCR1A|=(0b10<<WGM10);
    696a:	af e4       	ldi	r26, 0x4F	; 79
    696c:	b0 e0       	ldi	r27, 0x00	; 0
    696e:	ef e4       	ldi	r30, 0x4F	; 79
    6970:	f0 e0       	ldi	r31, 0x00	; 0
    6972:	80 81       	ld	r24, Z
    6974:	82 60       	ori	r24, 0x02	; 2
    6976:	8c 93       	st	X, r24
        TCCR1B&=~(0b11<<WGM12);
    6978:	ae e4       	ldi	r26, 0x4E	; 78
    697a:	b0 e0       	ldi	r27, 0x00	; 0
    697c:	ee e4       	ldi	r30, 0x4E	; 78
    697e:	f0 e0       	ldi	r31, 0x00	; 0
    6980:	80 81       	ld	r24, Z
    6982:	87 7e       	andi	r24, 0xE7	; 231
    6984:	8c 93       	st	X, r24
        TCCR1B|=(0b11<<WGM12);
    6986:	ae e4       	ldi	r26, 0x4E	; 78
    6988:	b0 e0       	ldi	r27, 0x00	; 0
    698a:	ee e4       	ldi	r30, 0x4E	; 78
    698c:	f0 e0       	ldi	r31, 0x00	; 0
    698e:	80 81       	ld	r24, Z
    6990:	88 61       	ori	r24, 0x18	; 24
    6992:	8c 93       	st	X, r24
    6994:	1c c0       	rjmp	.+56     	; 0x69ce <MTIMER1_voidInit+0x432>
        break;
        
        case TIMER1_FAST_PWM_OCRA1:
        TCCR1A&=~(0b11<<WGM10);
    6996:	af e4       	ldi	r26, 0x4F	; 79
    6998:	b0 e0       	ldi	r27, 0x00	; 0
    699a:	ef e4       	ldi	r30, 0x4F	; 79
    699c:	f0 e0       	ldi	r31, 0x00	; 0
    699e:	80 81       	ld	r24, Z
    69a0:	8c 7f       	andi	r24, 0xFC	; 252
    69a2:	8c 93       	st	X, r24
        TCCR1A|=(0b11<<WGM10);
    69a4:	af e4       	ldi	r26, 0x4F	; 79
    69a6:	b0 e0       	ldi	r27, 0x00	; 0
    69a8:	ef e4       	ldi	r30, 0x4F	; 79
    69aa:	f0 e0       	ldi	r31, 0x00	; 0
    69ac:	80 81       	ld	r24, Z
    69ae:	83 60       	ori	r24, 0x03	; 3
    69b0:	8c 93       	st	X, r24
        TCCR1B&=~(0b11<<WGM12);
    69b2:	ae e4       	ldi	r26, 0x4E	; 78
    69b4:	b0 e0       	ldi	r27, 0x00	; 0
    69b6:	ee e4       	ldi	r30, 0x4E	; 78
    69b8:	f0 e0       	ldi	r31, 0x00	; 0
    69ba:	80 81       	ld	r24, Z
    69bc:	87 7e       	andi	r24, 0xE7	; 231
    69be:	8c 93       	st	X, r24
        TCCR1B|=(0b11<<WGM12);
    69c0:	ae e4       	ldi	r26, 0x4E	; 78
    69c2:	b0 e0       	ldi	r27, 0x00	; 0
    69c4:	ee e4       	ldi	r30, 0x4E	; 78
    69c6:	f0 e0       	ldi	r31, 0x00	; 0
    69c8:	80 81       	ld	r24, Z
    69ca:	88 61       	ori	r24, 0x18	; 24
    69cc:	8c 93       	st	X, r24
        break;
    }


    // Mode of Compare output mdoe for OC1A & OC1B
    TCCR1A&=(~(0b11<<COM1A0))&(~(0b11<<COM1B0));
    69ce:	af e4       	ldi	r26, 0x4F	; 79
    69d0:	b0 e0       	ldi	r27, 0x00	; 0
    69d2:	ef e4       	ldi	r30, 0x4F	; 79
    69d4:	f0 e0       	ldi	r31, 0x00	; 0
    69d6:	80 81       	ld	r24, Z
    69d8:	8f 70       	andi	r24, 0x0F	; 15
    69da:	8c 93       	st	X, r24
    TCCR1A|=((compareA<<COM1A0)|(compareB<<COM1B0));
    69dc:	af e4       	ldi	r26, 0x4F	; 79
    69de:	b0 e0       	ldi	r27, 0x00	; 0
    69e0:	ef e4       	ldi	r30, 0x4F	; 79
    69e2:	f0 e0       	ldi	r31, 0x00	; 0
    69e4:	80 81       	ld	r24, Z
    69e6:	38 2f       	mov	r19, r24
    69e8:	8b 81       	ldd	r24, Y+3	; 0x03
    69ea:	88 2f       	mov	r24, r24
    69ec:	90 e0       	ldi	r25, 0x00	; 0
    69ee:	00 24       	eor	r0, r0
    69f0:	96 95       	lsr	r25
    69f2:	87 95       	ror	r24
    69f4:	07 94       	ror	r0
    69f6:	96 95       	lsr	r25
    69f8:	87 95       	ror	r24
    69fa:	07 94       	ror	r0
    69fc:	98 2f       	mov	r25, r24
    69fe:	80 2d       	mov	r24, r0
    6a00:	28 2f       	mov	r18, r24
    6a02:	8c 81       	ldd	r24, Y+4	; 0x04
    6a04:	88 2f       	mov	r24, r24
    6a06:	90 e0       	ldi	r25, 0x00	; 0
    6a08:	82 95       	swap	r24
    6a0a:	92 95       	swap	r25
    6a0c:	90 7f       	andi	r25, 0xF0	; 240
    6a0e:	98 27       	eor	r25, r24
    6a10:	80 7f       	andi	r24, 0xF0	; 240
    6a12:	98 27       	eor	r25, r24
    6a14:	82 2b       	or	r24, r18
    6a16:	83 2b       	or	r24, r19
    6a18:	8c 93       	st	X, r24

    //prescaler
    TCCR1B&=~(0b111<<CS10);
    6a1a:	ae e4       	ldi	r26, 0x4E	; 78
    6a1c:	b0 e0       	ldi	r27, 0x00	; 0
    6a1e:	ee e4       	ldi	r30, 0x4E	; 78
    6a20:	f0 e0       	ldi	r31, 0x00	; 0
    6a22:	80 81       	ld	r24, Z
    6a24:	88 7f       	andi	r24, 0xF8	; 248
    6a26:	8c 93       	st	X, r24
    TCCR1B|=(prescaler<<CS10);
    6a28:	ae e4       	ldi	r26, 0x4E	; 78
    6a2a:	b0 e0       	ldi	r27, 0x00	; 0
    6a2c:	ee e4       	ldi	r30, 0x4E	; 78
    6a2e:	f0 e0       	ldi	r31, 0x00	; 0
    6a30:	90 81       	ld	r25, Z
    6a32:	8a 81       	ldd	r24, Y+2	; 0x02
    6a34:	89 2b       	or	r24, r25
    6a36:	8c 93       	st	X, r24

}
    6a38:	26 96       	adiw	r28, 0x06	; 6
    6a3a:	0f b6       	in	r0, 0x3f	; 63
    6a3c:	f8 94       	cli
    6a3e:	de bf       	out	0x3e, r29	; 62
    6a40:	0f be       	out	0x3f, r0	; 63
    6a42:	cd bf       	out	0x3d, r28	; 61
    6a44:	cf 91       	pop	r28
    6a46:	df 91       	pop	r29
    6a48:	08 95       	ret

00006a4a <MTIMER1_voidInputCaptureEdge>:

#define ICES1 6
void MTIMER1_voidInputCaptureEdge(ICU_Edge_type edge)
{
    6a4a:	df 93       	push	r29
    6a4c:	cf 93       	push	r28
    6a4e:	0f 92       	push	r0
    6a50:	cd b7       	in	r28, 0x3d	; 61
    6a52:	de b7       	in	r29, 0x3e	; 62
    6a54:	89 83       	std	Y+1, r24	; 0x01
    if(edge==RISING) SET_BIT(TCCR1B,ICES1);
    6a56:	89 81       	ldd	r24, Y+1	; 0x01
    6a58:	88 23       	and	r24, r24
    6a5a:	41 f4       	brne	.+16     	; 0x6a6c <MTIMER1_voidInputCaptureEdge+0x22>
    6a5c:	ae e4       	ldi	r26, 0x4E	; 78
    6a5e:	b0 e0       	ldi	r27, 0x00	; 0
    6a60:	ee e4       	ldi	r30, 0x4E	; 78
    6a62:	f0 e0       	ldi	r31, 0x00	; 0
    6a64:	80 81       	ld	r24, Z
    6a66:	80 64       	ori	r24, 0x40	; 64
    6a68:	8c 93       	st	X, r24
    6a6a:	0a c0       	rjmp	.+20     	; 0x6a80 <MTIMER1_voidInputCaptureEdge+0x36>
    else if (edge==FALLING) CLR_BIT(TCCR1B,ICES1);
    6a6c:	89 81       	ldd	r24, Y+1	; 0x01
    6a6e:	81 30       	cpi	r24, 0x01	; 1
    6a70:	39 f4       	brne	.+14     	; 0x6a80 <MTIMER1_voidInputCaptureEdge+0x36>
    6a72:	ae e4       	ldi	r26, 0x4E	; 78
    6a74:	b0 e0       	ldi	r27, 0x00	; 0
    6a76:	ee e4       	ldi	r30, 0x4E	; 78
    6a78:	f0 e0       	ldi	r31, 0x00	; 0
    6a7a:	80 81       	ld	r24, Z
    6a7c:	8f 7b       	andi	r24, 0xBF	; 191
    6a7e:	8c 93       	st	X, r24
}
    6a80:	0f 90       	pop	r0
    6a82:	cf 91       	pop	r28
    6a84:	df 91       	pop	r29
    6a86:	08 95       	ret

00006a88 <MTIMER1_voidMeasurePWM>:

static u8 global_u8Flag,t1,t2,t3;

//Synchronus Function
void MTIMER1_voidMeasurePWM(u32 *Pfreq,u8*Pduty)
{
    6a88:	df 93       	push	r29
    6a8a:	cf 93       	push	r28
    6a8c:	cd b7       	in	r28, 0x3d	; 61
    6a8e:	de b7       	in	r29, 0x3e	; 62
    6a90:	28 97       	sbiw	r28, 0x08	; 8
    6a92:	0f b6       	in	r0, 0x3f	; 63
    6a94:	f8 94       	cli
    6a96:	de bf       	out	0x3e, r29	; 62
    6a98:	0f be       	out	0x3f, r0	; 63
    6a9a:	cd bf       	out	0x3d, r28	; 61
    6a9c:	9e 83       	std	Y+6, r25	; 0x06
    6a9e:	8d 83       	std	Y+5, r24	; 0x05
    6aa0:	78 87       	std	Y+8, r23	; 0x08
    6aa2:	6f 83       	std	Y+7, r22	; 0x07
    u32 Ton,Toff;
    TCNT1=0;
    6aa4:	ec e4       	ldi	r30, 0x4C	; 76
    6aa6:	f0 e0       	ldi	r31, 0x00	; 0
    6aa8:	11 82       	std	Z+1, r1	; 0x01
    6aaa:	10 82       	st	Z, r1
    MTIMER1_voidSetCallBackCapture(func_ICU);
    6aac:	8a e8       	ldi	r24, 0x8A	; 138
    6aae:	97 e3       	ldi	r25, 0x37	; 55
    6ab0:	0e 94 76 36 	call	0x6cec	; 0x6cec <MTIMER1_voidSetCallBackCapture>
    MTIMER1_voidInputCaptureEdge(RISING);
    6ab4:	80 e0       	ldi	r24, 0x00	; 0
    6ab6:	0e 94 25 35 	call	0x6a4a	; 0x6a4a <MTIMER1_voidInputCaptureEdge>
    MTIMER1_voidCaptureInterruptEnable();
    6aba:	0e 94 be 35 	call	0x6b7c	; 0x6b7c <MTIMER1_voidCaptureInterruptEnable>
    global_u8Flag=0;
    6abe:	10 92 bb 01 	sts	0x01BB, r1
    / ----->----                ----------                 _________
    / |        |               ^                         ^         |
    __|        |_______________|         |________________|         |
    /  wrong indicat           t1        t2               t3
    */
    while(global_u8Flag<3);
    6ac2:	80 91 bb 01 	lds	r24, 0x01BB
    6ac6:	83 30       	cpi	r24, 0x03	; 3
    6ac8:	e0 f3       	brcs	.-8      	; 0x6ac2 <MTIMER1_voidMeasurePWM+0x3a>
    Ton=t2-t1;
    6aca:	80 91 bd 01 	lds	r24, 0x01BD
    6ace:	28 2f       	mov	r18, r24
    6ad0:	30 e0       	ldi	r19, 0x00	; 0
    6ad2:	80 91 bc 01 	lds	r24, 0x01BC
    6ad6:	88 2f       	mov	r24, r24
    6ad8:	90 e0       	ldi	r25, 0x00	; 0
    6ada:	a9 01       	movw	r20, r18
    6adc:	48 1b       	sub	r20, r24
    6ade:	59 0b       	sbc	r21, r25
    6ae0:	ca 01       	movw	r24, r20
    6ae2:	9c 83       	std	Y+4, r25	; 0x04
    6ae4:	8b 83       	std	Y+3, r24	; 0x03
    Toff=t3-t2;
    6ae6:	80 91 be 01 	lds	r24, 0x01BE
    6aea:	28 2f       	mov	r18, r24
    6aec:	30 e0       	ldi	r19, 0x00	; 0
    6aee:	80 91 bd 01 	lds	r24, 0x01BD
    6af2:	88 2f       	mov	r24, r24
    6af4:	90 e0       	ldi	r25, 0x00	; 0
    6af6:	a9 01       	movw	r20, r18
    6af8:	48 1b       	sub	r20, r24
    6afa:	59 0b       	sbc	r21, r25
    6afc:	ca 01       	movw	r24, r20
    6afe:	9a 83       	std	Y+2, r25	; 0x02
    6b00:	89 83       	std	Y+1, r24	; 0x01
    *Pduty=((u32)Ton*100)/((u32)Ton+(u32)Toff);
    6b02:	2b 81       	ldd	r18, Y+3	; 0x03
    6b04:	3c 81       	ldd	r19, Y+4	; 0x04
    6b06:	84 e6       	ldi	r24, 0x64	; 100
    6b08:	90 e0       	ldi	r25, 0x00	; 0
    6b0a:	28 9f       	mul	r18, r24
    6b0c:	a0 01       	movw	r20, r0
    6b0e:	29 9f       	mul	r18, r25
    6b10:	50 0d       	add	r21, r0
    6b12:	38 9f       	mul	r19, r24
    6b14:	50 0d       	add	r21, r0
    6b16:	11 24       	eor	r1, r1
    6b18:	2b 81       	ldd	r18, Y+3	; 0x03
    6b1a:	3c 81       	ldd	r19, Y+4	; 0x04
    6b1c:	89 81       	ldd	r24, Y+1	; 0x01
    6b1e:	9a 81       	ldd	r25, Y+2	; 0x02
    6b20:	28 0f       	add	r18, r24
    6b22:	39 1f       	adc	r19, r25
    6b24:	ca 01       	movw	r24, r20
    6b26:	b9 01       	movw	r22, r18
    6b28:	0e 94 b4 42 	call	0x8568	; 0x8568 <__udivmodhi4>
    6b2c:	cb 01       	movw	r24, r22
    6b2e:	ef 81       	ldd	r30, Y+7	; 0x07
    6b30:	f8 85       	ldd	r31, Y+8	; 0x08
    6b32:	80 83       	st	Z, r24
    *Pfreq=(u32)1000000/((u32)Toff+Ton);
    6b34:	29 81       	ldd	r18, Y+1	; 0x01
    6b36:	3a 81       	ldd	r19, Y+2	; 0x02
    6b38:	8b 81       	ldd	r24, Y+3	; 0x03
    6b3a:	9c 81       	ldd	r25, Y+4	; 0x04
    6b3c:	28 0f       	add	r18, r24
    6b3e:	39 1f       	adc	r19, r25
    6b40:	80 e4       	ldi	r24, 0x40	; 64
    6b42:	92 e4       	ldi	r25, 0x42	; 66
    6b44:	b9 01       	movw	r22, r18
    6b46:	0e 94 b4 42 	call	0x8568	; 0x8568 <__udivmodhi4>
    6b4a:	cb 01       	movw	r24, r22
    6b4c:	ed 81       	ldd	r30, Y+5	; 0x05
    6b4e:	fe 81       	ldd	r31, Y+6	; 0x06
    6b50:	91 83       	std	Z+1, r25	; 0x01
    6b52:	80 83       	st	Z, r24
}
    6b54:	28 96       	adiw	r28, 0x08	; 8
    6b56:	0f b6       	in	r0, 0x3f	; 63
    6b58:	f8 94       	cli
    6b5a:	de bf       	out	0x3e, r29	; 62
    6b5c:	0f be       	out	0x3f, r0	; 63
    6b5e:	cd bf       	out	0x3d, r28	; 61
    6b60:	cf 91       	pop	r28
    6b62:	df 91       	pop	r29
    6b64:	08 95       	ret

00006b66 <MTIMER1_voidGetICR1>:

u16 MTIMER1_voidGetICR1(void)
{
    6b66:	df 93       	push	r29
    6b68:	cf 93       	push	r28
    6b6a:	cd b7       	in	r28, 0x3d	; 61
    6b6c:	de b7       	in	r29, 0x3e	; 62
    return ICR1;
    6b6e:	e6 e4       	ldi	r30, 0x46	; 70
    6b70:	f0 e0       	ldi	r31, 0x00	; 0
    6b72:	80 81       	ld	r24, Z
    6b74:	91 81       	ldd	r25, Z+1	; 0x01
}
    6b76:	cf 91       	pop	r28
    6b78:	df 91       	pop	r29
    6b7a:	08 95       	ret

00006b7c <MTIMER1_voidCaptureInterruptEnable>:

/**********************************************/
//interrupt Enable/Disable
void MTIMER1_voidCaptureInterruptEnable(void)
{
    6b7c:	df 93       	push	r29
    6b7e:	cf 93       	push	r28
    6b80:	cd b7       	in	r28, 0x3d	; 61
    6b82:	de b7       	in	r29, 0x3e	; 62
    SET_BIT(TIMSK,TICIE1);
    6b84:	a9 e5       	ldi	r26, 0x59	; 89
    6b86:	b0 e0       	ldi	r27, 0x00	; 0
    6b88:	e9 e5       	ldi	r30, 0x59	; 89
    6b8a:	f0 e0       	ldi	r31, 0x00	; 0
    6b8c:	80 81       	ld	r24, Z
    6b8e:	80 62       	ori	r24, 0x20	; 32
    6b90:	8c 93       	st	X, r24
}
    6b92:	cf 91       	pop	r28
    6b94:	df 91       	pop	r29
    6b96:	08 95       	ret

00006b98 <MTIMER1_voidCaptureInterruptDisable>:

void MTIMER1_voidCaptureInterruptDisable(void)
{
    6b98:	df 93       	push	r29
    6b9a:	cf 93       	push	r28
    6b9c:	cd b7       	in	r28, 0x3d	; 61
    6b9e:	de b7       	in	r29, 0x3e	; 62
    CLR_BIT(TIMSK,TICIE1);
    6ba0:	a9 e5       	ldi	r26, 0x59	; 89
    6ba2:	b0 e0       	ldi	r27, 0x00	; 0
    6ba4:	e9 e5       	ldi	r30, 0x59	; 89
    6ba6:	f0 e0       	ldi	r31, 0x00	; 0
    6ba8:	80 81       	ld	r24, Z
    6baa:	8f 7d       	andi	r24, 0xDF	; 223
    6bac:	8c 93       	st	X, r24
}
    6bae:	cf 91       	pop	r28
    6bb0:	df 91       	pop	r29
    6bb2:	08 95       	ret

00006bb4 <MTIMER1_voidCompareAInterruptEnable>:

void MTIMER1_voidCompareAInterruptEnable(void)
{
    6bb4:	df 93       	push	r29
    6bb6:	cf 93       	push	r28
    6bb8:	cd b7       	in	r28, 0x3d	; 61
    6bba:	de b7       	in	r29, 0x3e	; 62
    SET_BIT(TIMSK,OCIE1A);
    6bbc:	a9 e5       	ldi	r26, 0x59	; 89
    6bbe:	b0 e0       	ldi	r27, 0x00	; 0
    6bc0:	e9 e5       	ldi	r30, 0x59	; 89
    6bc2:	f0 e0       	ldi	r31, 0x00	; 0
    6bc4:	80 81       	ld	r24, Z
    6bc6:	80 61       	ori	r24, 0x10	; 16
    6bc8:	8c 93       	st	X, r24
}
    6bca:	cf 91       	pop	r28
    6bcc:	df 91       	pop	r29
    6bce:	08 95       	ret

00006bd0 <MTIMER1_voidCompareAInterruptDisable>:

void MTIMER1_voidCompareAInterruptDisable(void)
{
    6bd0:	df 93       	push	r29
    6bd2:	cf 93       	push	r28
    6bd4:	cd b7       	in	r28, 0x3d	; 61
    6bd6:	de b7       	in	r29, 0x3e	; 62
    CLR_BIT(TIMSK,OCIE1A);
    6bd8:	a9 e5       	ldi	r26, 0x59	; 89
    6bda:	b0 e0       	ldi	r27, 0x00	; 0
    6bdc:	e9 e5       	ldi	r30, 0x59	; 89
    6bde:	f0 e0       	ldi	r31, 0x00	; 0
    6be0:	80 81       	ld	r24, Z
    6be2:	8f 7e       	andi	r24, 0xEF	; 239
    6be4:	8c 93       	st	X, r24
}
    6be6:	cf 91       	pop	r28
    6be8:	df 91       	pop	r29
    6bea:	08 95       	ret

00006bec <MTIMER1_voidCompareBInterruptEnable>:

void MTIMER1_voidCompareBInterruptEnable(void)
{
    6bec:	df 93       	push	r29
    6bee:	cf 93       	push	r28
    6bf0:	cd b7       	in	r28, 0x3d	; 61
    6bf2:	de b7       	in	r29, 0x3e	; 62
    SET_BIT(TIMSK,OCIE1B);
    6bf4:	a9 e5       	ldi	r26, 0x59	; 89
    6bf6:	b0 e0       	ldi	r27, 0x00	; 0
    6bf8:	e9 e5       	ldi	r30, 0x59	; 89
    6bfa:	f0 e0       	ldi	r31, 0x00	; 0
    6bfc:	80 81       	ld	r24, Z
    6bfe:	88 60       	ori	r24, 0x08	; 8
    6c00:	8c 93       	st	X, r24
}
    6c02:	cf 91       	pop	r28
    6c04:	df 91       	pop	r29
    6c06:	08 95       	ret

00006c08 <MTIMER1_voidCompareBInterruptDisable>:

void MTIMER1_voidCompareBInterruptDisable(void)
{
    6c08:	df 93       	push	r29
    6c0a:	cf 93       	push	r28
    6c0c:	cd b7       	in	r28, 0x3d	; 61
    6c0e:	de b7       	in	r29, 0x3e	; 62
    CLR_BIT(TIMSK,OCIE1B);
    6c10:	a9 e5       	ldi	r26, 0x59	; 89
    6c12:	b0 e0       	ldi	r27, 0x00	; 0
    6c14:	e9 e5       	ldi	r30, 0x59	; 89
    6c16:	f0 e0       	ldi	r31, 0x00	; 0
    6c18:	80 81       	ld	r24, Z
    6c1a:	87 7f       	andi	r24, 0xF7	; 247
    6c1c:	8c 93       	st	X, r24
}
    6c1e:	cf 91       	pop	r28
    6c20:	df 91       	pop	r29
    6c22:	08 95       	ret

00006c24 <MTIMER1_voidOverFlowInterruptEnable>:

void MTIMER1_voidOverFlowInterruptEnable(void)
{
    6c24:	df 93       	push	r29
    6c26:	cf 93       	push	r28
    6c28:	cd b7       	in	r28, 0x3d	; 61
    6c2a:	de b7       	in	r29, 0x3e	; 62
    SET_BIT(TIMSK,TOIE1);
    6c2c:	a9 e5       	ldi	r26, 0x59	; 89
    6c2e:	b0 e0       	ldi	r27, 0x00	; 0
    6c30:	e9 e5       	ldi	r30, 0x59	; 89
    6c32:	f0 e0       	ldi	r31, 0x00	; 0
    6c34:	80 81       	ld	r24, Z
    6c36:	84 60       	ori	r24, 0x04	; 4
    6c38:	8c 93       	st	X, r24
}
    6c3a:	cf 91       	pop	r28
    6c3c:	df 91       	pop	r29
    6c3e:	08 95       	ret

00006c40 <MTIMER1_voidOverFlowInterruptDisable>:

void MTIMER1_voidOverFlowInterruptDisable(void)
{
    6c40:	df 93       	push	r29
    6c42:	cf 93       	push	r28
    6c44:	cd b7       	in	r28, 0x3d	; 61
    6c46:	de b7       	in	r29, 0x3e	; 62
    CLR_BIT(TIMSK,TOIE1);
    6c48:	a9 e5       	ldi	r26, 0x59	; 89
    6c4a:	b0 e0       	ldi	r27, 0x00	; 0
    6c4c:	e9 e5       	ldi	r30, 0x59	; 89
    6c4e:	f0 e0       	ldi	r31, 0x00	; 0
    6c50:	80 81       	ld	r24, Z
    6c52:	8b 7f       	andi	r24, 0xFB	; 251
    6c54:	8c 93       	st	X, r24
}
    6c56:	cf 91       	pop	r28
    6c58:	df 91       	pop	r29
    6c5a:	08 95       	ret

00006c5c <MTIMER1_voidSetICR1Value>:
/**********************************************/


void MTIMER1_voidSetICR1Value(u16 A_u16ICR1Value)
{
    6c5c:	df 93       	push	r29
    6c5e:	cf 93       	push	r28
    6c60:	00 d0       	rcall	.+0      	; 0x6c62 <MTIMER1_voidSetICR1Value+0x6>
    6c62:	cd b7       	in	r28, 0x3d	; 61
    6c64:	de b7       	in	r29, 0x3e	; 62
    6c66:	9a 83       	std	Y+2, r25	; 0x02
    6c68:	89 83       	std	Y+1, r24	; 0x01
    ICR1=A_u16ICR1Value;
    6c6a:	e6 e4       	ldi	r30, 0x46	; 70
    6c6c:	f0 e0       	ldi	r31, 0x00	; 0
    6c6e:	89 81       	ldd	r24, Y+1	; 0x01
    6c70:	9a 81       	ldd	r25, Y+2	; 0x02
    6c72:	91 83       	std	Z+1, r25	; 0x01
    6c74:	80 83       	st	Z, r24
}
    6c76:	0f 90       	pop	r0
    6c78:	0f 90       	pop	r0
    6c7a:	cf 91       	pop	r28
    6c7c:	df 91       	pop	r29
    6c7e:	08 95       	ret

00006c80 <MTIMER1_voidSetOCR1AValue>:

void MTIMER1_voidSetOCR1AValue(u16 A_u16OCR1AValue)
{
    6c80:	df 93       	push	r29
    6c82:	cf 93       	push	r28
    6c84:	00 d0       	rcall	.+0      	; 0x6c86 <MTIMER1_voidSetOCR1AValue+0x6>
    6c86:	cd b7       	in	r28, 0x3d	; 61
    6c88:	de b7       	in	r29, 0x3e	; 62
    6c8a:	9a 83       	std	Y+2, r25	; 0x02
    6c8c:	89 83       	std	Y+1, r24	; 0x01
    OCR1A=A_u16OCR1AValue;
    6c8e:	ea e4       	ldi	r30, 0x4A	; 74
    6c90:	f0 e0       	ldi	r31, 0x00	; 0
    6c92:	89 81       	ldd	r24, Y+1	; 0x01
    6c94:	9a 81       	ldd	r25, Y+2	; 0x02
    6c96:	91 83       	std	Z+1, r25	; 0x01
    6c98:	80 83       	st	Z, r24
}
    6c9a:	0f 90       	pop	r0
    6c9c:	0f 90       	pop	r0
    6c9e:	cf 91       	pop	r28
    6ca0:	df 91       	pop	r29
    6ca2:	08 95       	ret

00006ca4 <MTIMER1_voidSetOCR1BValue>:

void MTIMER1_voidSetOCR1BValue(u16 A_u16OCR1AValue)
{
    6ca4:	df 93       	push	r29
    6ca6:	cf 93       	push	r28
    6ca8:	00 d0       	rcall	.+0      	; 0x6caa <MTIMER1_voidSetOCR1BValue+0x6>
    6caa:	cd b7       	in	r28, 0x3d	; 61
    6cac:	de b7       	in	r29, 0x3e	; 62
    6cae:	9a 83       	std	Y+2, r25	; 0x02
    6cb0:	89 83       	std	Y+1, r24	; 0x01
    OCR1B=A_u16OCR1AValue;
    6cb2:	e8 e4       	ldi	r30, 0x48	; 72
    6cb4:	f0 e0       	ldi	r31, 0x00	; 0
    6cb6:	89 81       	ldd	r24, Y+1	; 0x01
    6cb8:	9a 81       	ldd	r25, Y+2	; 0x02
    6cba:	91 83       	std	Z+1, r25	; 0x01
    6cbc:	80 83       	st	Z, r24
}
    6cbe:	0f 90       	pop	r0
    6cc0:	0f 90       	pop	r0
    6cc2:	cf 91       	pop	r28
    6cc4:	df 91       	pop	r29
    6cc6:	08 95       	ret

00006cc8 <MTIMER1_voidSetTCNT1Value>:

//Set Preload Value in TCNT1
void MTIMER1_voidSetTCNT1Value(u16 A_u16TCNT1Value)
{
    6cc8:	df 93       	push	r29
    6cca:	cf 93       	push	r28
    6ccc:	00 d0       	rcall	.+0      	; 0x6cce <MTIMER1_voidSetTCNT1Value+0x6>
    6cce:	cd b7       	in	r28, 0x3d	; 61
    6cd0:	de b7       	in	r29, 0x3e	; 62
    6cd2:	9a 83       	std	Y+2, r25	; 0x02
    6cd4:	89 83       	std	Y+1, r24	; 0x01
    TCNT1=A_u16TCNT1Value;
    6cd6:	ec e4       	ldi	r30, 0x4C	; 76
    6cd8:	f0 e0       	ldi	r31, 0x00	; 0
    6cda:	89 81       	ldd	r24, Y+1	; 0x01
    6cdc:	9a 81       	ldd	r25, Y+2	; 0x02
    6cde:	91 83       	std	Z+1, r25	; 0x01
    6ce0:	80 83       	st	Z, r24
}
    6ce2:	0f 90       	pop	r0
    6ce4:	0f 90       	pop	r0
    6ce6:	cf 91       	pop	r28
    6ce8:	df 91       	pop	r29
    6cea:	08 95       	ret

00006cec <MTIMER1_voidSetCallBackCapture>:

//interrupt section

void MTIMER1_voidSetCallBackCapture(void(*pf)(void))
{
    6cec:	df 93       	push	r29
    6cee:	cf 93       	push	r28
    6cf0:	00 d0       	rcall	.+0      	; 0x6cf2 <MTIMER1_voidSetCallBackCapture+0x6>
    6cf2:	cd b7       	in	r28, 0x3d	; 61
    6cf4:	de b7       	in	r29, 0x3e	; 62
    6cf6:	9a 83       	std	Y+2, r25	; 0x02
    6cf8:	89 83       	std	Y+1, r24	; 0x01
    TIMER1_CAPTURE=pf;
    6cfa:	89 81       	ldd	r24, Y+1	; 0x01
    6cfc:	9a 81       	ldd	r25, Y+2	; 0x02
    6cfe:	90 93 b4 01 	sts	0x01B4, r25
    6d02:	80 93 b3 01 	sts	0x01B3, r24
}
    6d06:	0f 90       	pop	r0
    6d08:	0f 90       	pop	r0
    6d0a:	cf 91       	pop	r28
    6d0c:	df 91       	pop	r29
    6d0e:	08 95       	ret

00006d10 <MTIMER1_voidSetCallBackCOMA>:
void MTIMER1_voidSetCallBackCOMA(void(*pf)(void))
{
    6d10:	df 93       	push	r29
    6d12:	cf 93       	push	r28
    6d14:	00 d0       	rcall	.+0      	; 0x6d16 <MTIMER1_voidSetCallBackCOMA+0x6>
    6d16:	cd b7       	in	r28, 0x3d	; 61
    6d18:	de b7       	in	r29, 0x3e	; 62
    6d1a:	9a 83       	std	Y+2, r25	; 0x02
    6d1c:	89 83       	std	Y+1, r24	; 0x01
    TIMER1_COMA=pf;
    6d1e:	89 81       	ldd	r24, Y+1	; 0x01
    6d20:	9a 81       	ldd	r25, Y+2	; 0x02
    6d22:	90 93 b6 01 	sts	0x01B6, r25
    6d26:	80 93 b5 01 	sts	0x01B5, r24
}
    6d2a:	0f 90       	pop	r0
    6d2c:	0f 90       	pop	r0
    6d2e:	cf 91       	pop	r28
    6d30:	df 91       	pop	r29
    6d32:	08 95       	ret

00006d34 <MTIMER1_voidSetCallBackCOMB>:
void MTIMER1_voidSetCallBackCOMB(void(*pf)(void))
{
    6d34:	df 93       	push	r29
    6d36:	cf 93       	push	r28
    6d38:	00 d0       	rcall	.+0      	; 0x6d3a <MTIMER1_voidSetCallBackCOMB+0x6>
    6d3a:	cd b7       	in	r28, 0x3d	; 61
    6d3c:	de b7       	in	r29, 0x3e	; 62
    6d3e:	9a 83       	std	Y+2, r25	; 0x02
    6d40:	89 83       	std	Y+1, r24	; 0x01
    TIMER1_COMB=pf;
    6d42:	89 81       	ldd	r24, Y+1	; 0x01
    6d44:	9a 81       	ldd	r25, Y+2	; 0x02
    6d46:	90 93 b8 01 	sts	0x01B8, r25
    6d4a:	80 93 b7 01 	sts	0x01B7, r24
}
    6d4e:	0f 90       	pop	r0
    6d50:	0f 90       	pop	r0
    6d52:	cf 91       	pop	r28
    6d54:	df 91       	pop	r29
    6d56:	08 95       	ret

00006d58 <MTIMER1_voidSetCallBackOVF>:

void MTIMER1_voidSetCallBackOVF(void(*pf)(void))
{
    6d58:	df 93       	push	r29
    6d5a:	cf 93       	push	r28
    6d5c:	00 d0       	rcall	.+0      	; 0x6d5e <MTIMER1_voidSetCallBackOVF+0x6>
    6d5e:	cd b7       	in	r28, 0x3d	; 61
    6d60:	de b7       	in	r29, 0x3e	; 62
    6d62:	9a 83       	std	Y+2, r25	; 0x02
    6d64:	89 83       	std	Y+1, r24	; 0x01
    TIMER1_OVF=pf;
    6d66:	89 81       	ldd	r24, Y+1	; 0x01
    6d68:	9a 81       	ldd	r25, Y+2	; 0x02
    6d6a:	90 93 ba 01 	sts	0x01BA, r25
    6d6e:	80 93 b9 01 	sts	0x01B9, r24
}
    6d72:	0f 90       	pop	r0
    6d74:	0f 90       	pop	r0
    6d76:	cf 91       	pop	r28
    6d78:	df 91       	pop	r29
    6d7a:	08 95       	ret

00006d7c <__vector_6>:



//ISR section
ISR(TIMER1_CAPT_VECT)
{
    6d7c:	1f 92       	push	r1
    6d7e:	0f 92       	push	r0
    6d80:	0f b6       	in	r0, 0x3f	; 63
    6d82:	0f 92       	push	r0
    6d84:	11 24       	eor	r1, r1
    6d86:	2f 93       	push	r18
    6d88:	3f 93       	push	r19
    6d8a:	4f 93       	push	r20
    6d8c:	5f 93       	push	r21
    6d8e:	6f 93       	push	r22
    6d90:	7f 93       	push	r23
    6d92:	8f 93       	push	r24
    6d94:	9f 93       	push	r25
    6d96:	af 93       	push	r26
    6d98:	bf 93       	push	r27
    6d9a:	ef 93       	push	r30
    6d9c:	ff 93       	push	r31
    6d9e:	df 93       	push	r29
    6da0:	cf 93       	push	r28
    6da2:	cd b7       	in	r28, 0x3d	; 61
    6da4:	de b7       	in	r29, 0x3e	; 62
    if(TIMER1_CAPTURE!=NULLPTR) TIMER1_CAPTURE();
    6da6:	80 91 b3 01 	lds	r24, 0x01B3
    6daa:	90 91 b4 01 	lds	r25, 0x01B4
    6dae:	00 97       	sbiw	r24, 0x00	; 0
    6db0:	29 f0       	breq	.+10     	; 0x6dbc <__vector_6+0x40>
    6db2:	e0 91 b3 01 	lds	r30, 0x01B3
    6db6:	f0 91 b4 01 	lds	r31, 0x01B4
    6dba:	09 95       	icall
}
    6dbc:	cf 91       	pop	r28
    6dbe:	df 91       	pop	r29
    6dc0:	ff 91       	pop	r31
    6dc2:	ef 91       	pop	r30
    6dc4:	bf 91       	pop	r27
    6dc6:	af 91       	pop	r26
    6dc8:	9f 91       	pop	r25
    6dca:	8f 91       	pop	r24
    6dcc:	7f 91       	pop	r23
    6dce:	6f 91       	pop	r22
    6dd0:	5f 91       	pop	r21
    6dd2:	4f 91       	pop	r20
    6dd4:	3f 91       	pop	r19
    6dd6:	2f 91       	pop	r18
    6dd8:	0f 90       	pop	r0
    6dda:	0f be       	out	0x3f, r0	; 63
    6ddc:	0f 90       	pop	r0
    6dde:	1f 90       	pop	r1
    6de0:	18 95       	reti

00006de2 <__vector_7>:
ISR(TIMER1_COMA_VECT)
{
    6de2:	1f 92       	push	r1
    6de4:	0f 92       	push	r0
    6de6:	0f b6       	in	r0, 0x3f	; 63
    6de8:	0f 92       	push	r0
    6dea:	11 24       	eor	r1, r1
    6dec:	2f 93       	push	r18
    6dee:	3f 93       	push	r19
    6df0:	4f 93       	push	r20
    6df2:	5f 93       	push	r21
    6df4:	6f 93       	push	r22
    6df6:	7f 93       	push	r23
    6df8:	8f 93       	push	r24
    6dfa:	9f 93       	push	r25
    6dfc:	af 93       	push	r26
    6dfe:	bf 93       	push	r27
    6e00:	ef 93       	push	r30
    6e02:	ff 93       	push	r31
    6e04:	df 93       	push	r29
    6e06:	cf 93       	push	r28
    6e08:	cd b7       	in	r28, 0x3d	; 61
    6e0a:	de b7       	in	r29, 0x3e	; 62
    if(TIMER1_COMA!=NULLPTR) TIMER1_COMA();
    6e0c:	80 91 b5 01 	lds	r24, 0x01B5
    6e10:	90 91 b6 01 	lds	r25, 0x01B6
    6e14:	00 97       	sbiw	r24, 0x00	; 0
    6e16:	29 f0       	breq	.+10     	; 0x6e22 <__vector_7+0x40>
    6e18:	e0 91 b5 01 	lds	r30, 0x01B5
    6e1c:	f0 91 b6 01 	lds	r31, 0x01B6
    6e20:	09 95       	icall
}
    6e22:	cf 91       	pop	r28
    6e24:	df 91       	pop	r29
    6e26:	ff 91       	pop	r31
    6e28:	ef 91       	pop	r30
    6e2a:	bf 91       	pop	r27
    6e2c:	af 91       	pop	r26
    6e2e:	9f 91       	pop	r25
    6e30:	8f 91       	pop	r24
    6e32:	7f 91       	pop	r23
    6e34:	6f 91       	pop	r22
    6e36:	5f 91       	pop	r21
    6e38:	4f 91       	pop	r20
    6e3a:	3f 91       	pop	r19
    6e3c:	2f 91       	pop	r18
    6e3e:	0f 90       	pop	r0
    6e40:	0f be       	out	0x3f, r0	; 63
    6e42:	0f 90       	pop	r0
    6e44:	1f 90       	pop	r1
    6e46:	18 95       	reti

00006e48 <__vector_8>:
ISR(TIMER1_COMB_VECT)
{
    6e48:	1f 92       	push	r1
    6e4a:	0f 92       	push	r0
    6e4c:	0f b6       	in	r0, 0x3f	; 63
    6e4e:	0f 92       	push	r0
    6e50:	11 24       	eor	r1, r1
    6e52:	2f 93       	push	r18
    6e54:	3f 93       	push	r19
    6e56:	4f 93       	push	r20
    6e58:	5f 93       	push	r21
    6e5a:	6f 93       	push	r22
    6e5c:	7f 93       	push	r23
    6e5e:	8f 93       	push	r24
    6e60:	9f 93       	push	r25
    6e62:	af 93       	push	r26
    6e64:	bf 93       	push	r27
    6e66:	ef 93       	push	r30
    6e68:	ff 93       	push	r31
    6e6a:	df 93       	push	r29
    6e6c:	cf 93       	push	r28
    6e6e:	cd b7       	in	r28, 0x3d	; 61
    6e70:	de b7       	in	r29, 0x3e	; 62
    if(TIMER1_COMB!=NULLPTR) TIMER1_COMB();
    6e72:	80 91 b7 01 	lds	r24, 0x01B7
    6e76:	90 91 b8 01 	lds	r25, 0x01B8
    6e7a:	00 97       	sbiw	r24, 0x00	; 0
    6e7c:	29 f0       	breq	.+10     	; 0x6e88 <__vector_8+0x40>
    6e7e:	e0 91 b7 01 	lds	r30, 0x01B7
    6e82:	f0 91 b8 01 	lds	r31, 0x01B8
    6e86:	09 95       	icall
}
    6e88:	cf 91       	pop	r28
    6e8a:	df 91       	pop	r29
    6e8c:	ff 91       	pop	r31
    6e8e:	ef 91       	pop	r30
    6e90:	bf 91       	pop	r27
    6e92:	af 91       	pop	r26
    6e94:	9f 91       	pop	r25
    6e96:	8f 91       	pop	r24
    6e98:	7f 91       	pop	r23
    6e9a:	6f 91       	pop	r22
    6e9c:	5f 91       	pop	r21
    6e9e:	4f 91       	pop	r20
    6ea0:	3f 91       	pop	r19
    6ea2:	2f 91       	pop	r18
    6ea4:	0f 90       	pop	r0
    6ea6:	0f be       	out	0x3f, r0	; 63
    6ea8:	0f 90       	pop	r0
    6eaa:	1f 90       	pop	r1
    6eac:	18 95       	reti

00006eae <__vector_9>:
ISR(TIMER1_OVF_VECT)
{
    6eae:	1f 92       	push	r1
    6eb0:	0f 92       	push	r0
    6eb2:	0f b6       	in	r0, 0x3f	; 63
    6eb4:	0f 92       	push	r0
    6eb6:	11 24       	eor	r1, r1
    6eb8:	2f 93       	push	r18
    6eba:	3f 93       	push	r19
    6ebc:	4f 93       	push	r20
    6ebe:	5f 93       	push	r21
    6ec0:	6f 93       	push	r22
    6ec2:	7f 93       	push	r23
    6ec4:	8f 93       	push	r24
    6ec6:	9f 93       	push	r25
    6ec8:	af 93       	push	r26
    6eca:	bf 93       	push	r27
    6ecc:	ef 93       	push	r30
    6ece:	ff 93       	push	r31
    6ed0:	df 93       	push	r29
    6ed2:	cf 93       	push	r28
    6ed4:	cd b7       	in	r28, 0x3d	; 61
    6ed6:	de b7       	in	r29, 0x3e	; 62
    if(TIMER1_OVF!=NULLPTR) TIMER1_OVF();
    6ed8:	80 91 b9 01 	lds	r24, 0x01B9
    6edc:	90 91 ba 01 	lds	r25, 0x01BA
    6ee0:	00 97       	sbiw	r24, 0x00	; 0
    6ee2:	29 f0       	breq	.+10     	; 0x6eee <__vector_9+0x40>
    6ee4:	e0 91 b9 01 	lds	r30, 0x01B9
    6ee8:	f0 91 ba 01 	lds	r31, 0x01BA
    6eec:	09 95       	icall
}
    6eee:	cf 91       	pop	r28
    6ef0:	df 91       	pop	r29
    6ef2:	ff 91       	pop	r31
    6ef4:	ef 91       	pop	r30
    6ef6:	bf 91       	pop	r27
    6ef8:	af 91       	pop	r26
    6efa:	9f 91       	pop	r25
    6efc:	8f 91       	pop	r24
    6efe:	7f 91       	pop	r23
    6f00:	6f 91       	pop	r22
    6f02:	5f 91       	pop	r21
    6f04:	4f 91       	pop	r20
    6f06:	3f 91       	pop	r19
    6f08:	2f 91       	pop	r18
    6f0a:	0f 90       	pop	r0
    6f0c:	0f be       	out	0x3f, r0	; 63
    6f0e:	0f 90       	pop	r0
    6f10:	1f 90       	pop	r1
    6f12:	18 95       	reti

00006f14 <func_ICU>:

static void func_ICU(void)
{
    6f14:	df 93       	push	r29
    6f16:	cf 93       	push	r28
    6f18:	cd b7       	in	r28, 0x3d	; 61
    6f1a:	de b7       	in	r29, 0x3e	; 62
    if(global_u8Flag == 0)
    6f1c:	80 91 bb 01 	lds	r24, 0x01BB
    6f20:	88 23       	and	r24, r24
    6f22:	69 f4       	brne	.+26     	; 0x6f3e <func_ICU+0x2a>
    {
        t1=ICR1;
    6f24:	e6 e4       	ldi	r30, 0x46	; 70
    6f26:	f0 e0       	ldi	r31, 0x00	; 0
    6f28:	80 81       	ld	r24, Z
    6f2a:	91 81       	ldd	r25, Z+1	; 0x01
    6f2c:	80 93 bc 01 	sts	0x01BC, r24
        MTIMER1_voidInputCaptureEdge(FALLING);
    6f30:	81 e0       	ldi	r24, 0x01	; 1
    6f32:	0e 94 25 35 	call	0x6a4a	; 0x6a4a <MTIMER1_voidInputCaptureEdge>
        global_u8Flag=1;
    6f36:	81 e0       	ldi	r24, 0x01	; 1
    6f38:	80 93 bb 01 	sts	0x01BB, r24
    6f3c:	20 c0       	rjmp	.+64     	; 0x6f7e <func_ICU+0x6a>
    }
    else if (global_u8Flag==1)
    6f3e:	80 91 bb 01 	lds	r24, 0x01BB
    6f42:	81 30       	cpi	r24, 0x01	; 1
    6f44:	69 f4       	brne	.+26     	; 0x6f60 <func_ICU+0x4c>
    {
        t2=ICR1;
    6f46:	e6 e4       	ldi	r30, 0x46	; 70
    6f48:	f0 e0       	ldi	r31, 0x00	; 0
    6f4a:	80 81       	ld	r24, Z
    6f4c:	91 81       	ldd	r25, Z+1	; 0x01
    6f4e:	80 93 bd 01 	sts	0x01BD, r24
        MTIMER1_voidInputCaptureEdge(RISING);
    6f52:	80 e0       	ldi	r24, 0x00	; 0
    6f54:	0e 94 25 35 	call	0x6a4a	; 0x6a4a <MTIMER1_voidInputCaptureEdge>
        global_u8Flag=2;
    6f58:	82 e0       	ldi	r24, 0x02	; 2
    6f5a:	80 93 bb 01 	sts	0x01BB, r24
    6f5e:	0f c0       	rjmp	.+30     	; 0x6f7e <func_ICU+0x6a>
    }
    else if(global_u8Flag==2)
    6f60:	80 91 bb 01 	lds	r24, 0x01BB
    6f64:	82 30       	cpi	r24, 0x02	; 2
    6f66:	59 f4       	brne	.+22     	; 0x6f7e <func_ICU+0x6a>
    {
        t3=ICR1;
    6f68:	e6 e4       	ldi	r30, 0x46	; 70
    6f6a:	f0 e0       	ldi	r31, 0x00	; 0
    6f6c:	80 81       	ld	r24, Z
    6f6e:	91 81       	ldd	r25, Z+1	; 0x01
    6f70:	80 93 be 01 	sts	0x01BE, r24
        MTIMER1_voidCaptureInterruptDisable();
    6f74:	0e 94 cc 35 	call	0x6b98	; 0x6b98 <MTIMER1_voidCaptureInterruptDisable>
        global_u8Flag=3;
    6f78:	83 e0       	ldi	r24, 0x03	; 3
    6f7a:	80 93 bb 01 	sts	0x01BB, r24
    }
}
    6f7e:	cf 91       	pop	r28
    6f80:	df 91       	pop	r29
    6f82:	08 95       	ret

00006f84 <MTIMER2_voidInit>:

static void (*TIMER2_OVF_CALL)(void)=NULLPTR;
static void (*TIMER2_CTC_CALL)(void)=NULLPTR;

void MTIMER2_voidInit(TIMER2_Mode mode,TIMER2_Compare Compare,TIMER2_Prescaler Prescaler)
{
    6f84:	df 93       	push	r29
    6f86:	cf 93       	push	r28
    6f88:	00 d0       	rcall	.+0      	; 0x6f8a <MTIMER2_voidInit+0x6>
    6f8a:	00 d0       	rcall	.+0      	; 0x6f8c <MTIMER2_voidInit+0x8>
    6f8c:	0f 92       	push	r0
    6f8e:	cd b7       	in	r28, 0x3d	; 61
    6f90:	de b7       	in	r29, 0x3e	; 62
    6f92:	89 83       	std	Y+1, r24	; 0x01
    6f94:	6a 83       	std	Y+2, r22	; 0x02
    6f96:	4b 83       	std	Y+3, r20	; 0x03
    switch (mode)
    6f98:	89 81       	ldd	r24, Y+1	; 0x01
    6f9a:	28 2f       	mov	r18, r24
    6f9c:	30 e0       	ldi	r19, 0x00	; 0
    6f9e:	3d 83       	std	Y+5, r19	; 0x05
    6fa0:	2c 83       	std	Y+4, r18	; 0x04
    6fa2:	8c 81       	ldd	r24, Y+4	; 0x04
    6fa4:	9d 81       	ldd	r25, Y+5	; 0x05
    6fa6:	81 30       	cpi	r24, 0x01	; 1
    6fa8:	91 05       	cpc	r25, r1
    6faa:	21 f1       	breq	.+72     	; 0x6ff4 <MTIMER2_voidInit+0x70>
    6fac:	2c 81       	ldd	r18, Y+4	; 0x04
    6fae:	3d 81       	ldd	r19, Y+5	; 0x05
    6fb0:	22 30       	cpi	r18, 0x02	; 2
    6fb2:	31 05       	cpc	r19, r1
    6fb4:	2c f4       	brge	.+10     	; 0x6fc0 <MTIMER2_voidInit+0x3c>
    6fb6:	8c 81       	ldd	r24, Y+4	; 0x04
    6fb8:	9d 81       	ldd	r25, Y+5	; 0x05
    6fba:	00 97       	sbiw	r24, 0x00	; 0
    6fbc:	61 f0       	breq	.+24     	; 0x6fd6 <MTIMER2_voidInit+0x52>
    6fbe:	46 c0       	rjmp	.+140    	; 0x704c <MTIMER2_voidInit+0xc8>
    6fc0:	2c 81       	ldd	r18, Y+4	; 0x04
    6fc2:	3d 81       	ldd	r19, Y+5	; 0x05
    6fc4:	22 30       	cpi	r18, 0x02	; 2
    6fc6:	31 05       	cpc	r19, r1
    6fc8:	21 f1       	breq	.+72     	; 0x7012 <MTIMER2_voidInit+0x8e>
    6fca:	8c 81       	ldd	r24, Y+4	; 0x04
    6fcc:	9d 81       	ldd	r25, Y+5	; 0x05
    6fce:	83 30       	cpi	r24, 0x03	; 3
    6fd0:	91 05       	cpc	r25, r1
    6fd2:	71 f1       	breq	.+92     	; 0x7030 <MTIMER2_voidInit+0xac>
    6fd4:	3b c0       	rjmp	.+118    	; 0x704c <MTIMER2_voidInit+0xc8>
    {
        case TIMER2_NORMAL_MODE:
        CLR_BIT(TCCR2,WGM20);
    6fd6:	a5 e4       	ldi	r26, 0x45	; 69
    6fd8:	b0 e0       	ldi	r27, 0x00	; 0
    6fda:	e5 e4       	ldi	r30, 0x45	; 69
    6fdc:	f0 e0       	ldi	r31, 0x00	; 0
    6fde:	80 81       	ld	r24, Z
    6fe0:	8f 7b       	andi	r24, 0xBF	; 191
    6fe2:	8c 93       	st	X, r24
        CLR_BIT(TCCR2,WGM21);
    6fe4:	a5 e4       	ldi	r26, 0x45	; 69
    6fe6:	b0 e0       	ldi	r27, 0x00	; 0
    6fe8:	e5 e4       	ldi	r30, 0x45	; 69
    6fea:	f0 e0       	ldi	r31, 0x00	; 0
    6fec:	80 81       	ld	r24, Z
    6fee:	87 7f       	andi	r24, 0xF7	; 247
    6ff0:	8c 93       	st	X, r24
    6ff2:	2c c0       	rjmp	.+88     	; 0x704c <MTIMER2_voidInit+0xc8>
        break;

        case TIMER2_PHASE_CORRECT_MODE:
        SET_BIT(TCCR2,WGM20);
    6ff4:	a5 e4       	ldi	r26, 0x45	; 69
    6ff6:	b0 e0       	ldi	r27, 0x00	; 0
    6ff8:	e5 e4       	ldi	r30, 0x45	; 69
    6ffa:	f0 e0       	ldi	r31, 0x00	; 0
    6ffc:	80 81       	ld	r24, Z
    6ffe:	80 64       	ori	r24, 0x40	; 64
    7000:	8c 93       	st	X, r24
        CLR_BIT(TCCR2,WGM21);
    7002:	a5 e4       	ldi	r26, 0x45	; 69
    7004:	b0 e0       	ldi	r27, 0x00	; 0
    7006:	e5 e4       	ldi	r30, 0x45	; 69
    7008:	f0 e0       	ldi	r31, 0x00	; 0
    700a:	80 81       	ld	r24, Z
    700c:	87 7f       	andi	r24, 0xF7	; 247
    700e:	8c 93       	st	X, r24
    7010:	1d c0       	rjmp	.+58     	; 0x704c <MTIMER2_voidInit+0xc8>
        break;

        case TIMER2_CTC_MODE:
        CLR_BIT(TCCR2,WGM20);
    7012:	a5 e4       	ldi	r26, 0x45	; 69
    7014:	b0 e0       	ldi	r27, 0x00	; 0
    7016:	e5 e4       	ldi	r30, 0x45	; 69
    7018:	f0 e0       	ldi	r31, 0x00	; 0
    701a:	80 81       	ld	r24, Z
    701c:	8f 7b       	andi	r24, 0xBF	; 191
    701e:	8c 93       	st	X, r24
        SET_BIT(TCCR2,WGM21);
    7020:	a5 e4       	ldi	r26, 0x45	; 69
    7022:	b0 e0       	ldi	r27, 0x00	; 0
    7024:	e5 e4       	ldi	r30, 0x45	; 69
    7026:	f0 e0       	ldi	r31, 0x00	; 0
    7028:	80 81       	ld	r24, Z
    702a:	88 60       	ori	r24, 0x08	; 8
    702c:	8c 93       	st	X, r24
    702e:	0e c0       	rjmp	.+28     	; 0x704c <MTIMER2_voidInit+0xc8>
        break;

        case TIMER2_FAST_PWM_MODE:
        SET_BIT(TCCR2,WGM20);
    7030:	a5 e4       	ldi	r26, 0x45	; 69
    7032:	b0 e0       	ldi	r27, 0x00	; 0
    7034:	e5 e4       	ldi	r30, 0x45	; 69
    7036:	f0 e0       	ldi	r31, 0x00	; 0
    7038:	80 81       	ld	r24, Z
    703a:	80 64       	ori	r24, 0x40	; 64
    703c:	8c 93       	st	X, r24
        SET_BIT(TCCR2,WGM21);
    703e:	a5 e4       	ldi	r26, 0x45	; 69
    7040:	b0 e0       	ldi	r27, 0x00	; 0
    7042:	e5 e4       	ldi	r30, 0x45	; 69
    7044:	f0 e0       	ldi	r31, 0x00	; 0
    7046:	80 81       	ld	r24, Z
    7048:	88 60       	ori	r24, 0x08	; 8
    704a:	8c 93       	st	X, r24
    
        default:
        break;
    }

    TCCR2&=(~(0b11<<COM20)) & (~(0b111<<CS20));
    704c:	a5 e4       	ldi	r26, 0x45	; 69
    704e:	b0 e0       	ldi	r27, 0x00	; 0
    7050:	e5 e4       	ldi	r30, 0x45	; 69
    7052:	f0 e0       	ldi	r31, 0x00	; 0
    7054:	80 81       	ld	r24, Z
    7056:	88 7c       	andi	r24, 0xC8	; 200
    7058:	8c 93       	st	X, r24
    TCCR2|=(Compare<<COM20) | (Prescaler<<CS20);
    705a:	a5 e4       	ldi	r26, 0x45	; 69
    705c:	b0 e0       	ldi	r27, 0x00	; 0
    705e:	e5 e4       	ldi	r30, 0x45	; 69
    7060:	f0 e0       	ldi	r31, 0x00	; 0
    7062:	80 81       	ld	r24, Z
    7064:	28 2f       	mov	r18, r24
    7066:	8a 81       	ldd	r24, Y+2	; 0x02
    7068:	88 2f       	mov	r24, r24
    706a:	90 e0       	ldi	r25, 0x00	; 0
    706c:	82 95       	swap	r24
    706e:	92 95       	swap	r25
    7070:	90 7f       	andi	r25, 0xF0	; 240
    7072:	98 27       	eor	r25, r24
    7074:	80 7f       	andi	r24, 0xF0	; 240
    7076:	98 27       	eor	r25, r24
    7078:	98 2f       	mov	r25, r24
    707a:	8b 81       	ldd	r24, Y+3	; 0x03
    707c:	89 2b       	or	r24, r25
    707e:	82 2b       	or	r24, r18
    7080:	8c 93       	st	X, r24

}
    7082:	0f 90       	pop	r0
    7084:	0f 90       	pop	r0
    7086:	0f 90       	pop	r0
    7088:	0f 90       	pop	r0
    708a:	0f 90       	pop	r0
    708c:	cf 91       	pop	r28
    708e:	df 91       	pop	r29
    7090:	08 95       	ret

00007092 <MTIMER2_voidSetTCNT2>:

void MTIMER2_voidSetTCNT2(u8 A_u8Value)
{
    7092:	df 93       	push	r29
    7094:	cf 93       	push	r28
    7096:	0f 92       	push	r0
    7098:	cd b7       	in	r28, 0x3d	; 61
    709a:	de b7       	in	r29, 0x3e	; 62
    709c:	89 83       	std	Y+1, r24	; 0x01
    TCNT2=A_u8Value;
    709e:	e4 e4       	ldi	r30, 0x44	; 68
    70a0:	f0 e0       	ldi	r31, 0x00	; 0
    70a2:	89 81       	ldd	r24, Y+1	; 0x01
    70a4:	80 83       	st	Z, r24
}
    70a6:	0f 90       	pop	r0
    70a8:	cf 91       	pop	r28
    70aa:	df 91       	pop	r29
    70ac:	08 95       	ret

000070ae <MTIMER2_voidSetOCR2>:

void MTIMER2_voidSetOCR2(u8 A_u8Value)
{
    70ae:	df 93       	push	r29
    70b0:	cf 93       	push	r28
    70b2:	0f 92       	push	r0
    70b4:	cd b7       	in	r28, 0x3d	; 61
    70b6:	de b7       	in	r29, 0x3e	; 62
    70b8:	89 83       	std	Y+1, r24	; 0x01
    OCR2=A_u8Value;
    70ba:	e3 e4       	ldi	r30, 0x43	; 67
    70bc:	f0 e0       	ldi	r31, 0x00	; 0
    70be:	89 81       	ldd	r24, Y+1	; 0x01
    70c0:	80 83       	st	Z, r24
}
    70c2:	0f 90       	pop	r0
    70c4:	cf 91       	pop	r28
    70c6:	df 91       	pop	r29
    70c8:	08 95       	ret

000070ca <MTIMER2_voidOverFlowInterruptEnable>:




void MTIMER2_voidOverFlowInterruptEnable()
{
    70ca:	df 93       	push	r29
    70cc:	cf 93       	push	r28
    70ce:	cd b7       	in	r28, 0x3d	; 61
    70d0:	de b7       	in	r29, 0x3e	; 62
    SET_BIT(TIMSK,TOIE);
    70d2:	a9 e5       	ldi	r26, 0x59	; 89
    70d4:	b0 e0       	ldi	r27, 0x00	; 0
    70d6:	e9 e5       	ldi	r30, 0x59	; 89
    70d8:	f0 e0       	ldi	r31, 0x00	; 0
    70da:	80 81       	ld	r24, Z
    70dc:	80 64       	ori	r24, 0x40	; 64
    70de:	8c 93       	st	X, r24
}
    70e0:	cf 91       	pop	r28
    70e2:	df 91       	pop	r29
    70e4:	08 95       	ret

000070e6 <MTIMER2_voidOverFlowInterruptDisable>:

void MTIMER2_voidOverFlowInterruptDisable()
{
    70e6:	df 93       	push	r29
    70e8:	cf 93       	push	r28
    70ea:	cd b7       	in	r28, 0x3d	; 61
    70ec:	de b7       	in	r29, 0x3e	; 62
    CLR_BIT(TIMSK,TOIE);
    70ee:	a9 e5       	ldi	r26, 0x59	; 89
    70f0:	b0 e0       	ldi	r27, 0x00	; 0
    70f2:	e9 e5       	ldi	r30, 0x59	; 89
    70f4:	f0 e0       	ldi	r31, 0x00	; 0
    70f6:	80 81       	ld	r24, Z
    70f8:	8f 7b       	andi	r24, 0xBF	; 191
    70fa:	8c 93       	st	X, r24
}
    70fc:	cf 91       	pop	r28
    70fe:	df 91       	pop	r29
    7100:	08 95       	ret

00007102 <MTIMER2_voidCompareInterruptEnable>:

void MTIMER2_voidCompareInterruptEnable()
{
    7102:	df 93       	push	r29
    7104:	cf 93       	push	r28
    7106:	cd b7       	in	r28, 0x3d	; 61
    7108:	de b7       	in	r29, 0x3e	; 62
    SET_BIT(TIMSK,OCIE2);
    710a:	a9 e5       	ldi	r26, 0x59	; 89
    710c:	b0 e0       	ldi	r27, 0x00	; 0
    710e:	e9 e5       	ldi	r30, 0x59	; 89
    7110:	f0 e0       	ldi	r31, 0x00	; 0
    7112:	80 81       	ld	r24, Z
    7114:	80 68       	ori	r24, 0x80	; 128
    7116:	8c 93       	st	X, r24
}
    7118:	cf 91       	pop	r28
    711a:	df 91       	pop	r29
    711c:	08 95       	ret

0000711e <MTIMER2_voidCompareInterruptDisable>:
void MTIMER2_voidCompareInterruptDisable()
{
    711e:	df 93       	push	r29
    7120:	cf 93       	push	r28
    7122:	cd b7       	in	r28, 0x3d	; 61
    7124:	de b7       	in	r29, 0x3e	; 62
    CLR_BIT(TIMSK,OCIE2);
    7126:	a9 e5       	ldi	r26, 0x59	; 89
    7128:	b0 e0       	ldi	r27, 0x00	; 0
    712a:	e9 e5       	ldi	r30, 0x59	; 89
    712c:	f0 e0       	ldi	r31, 0x00	; 0
    712e:	80 81       	ld	r24, Z
    7130:	8f 77       	andi	r24, 0x7F	; 127
    7132:	8c 93       	st	X, r24
}
    7134:	cf 91       	pop	r28
    7136:	df 91       	pop	r29
    7138:	08 95       	ret

0000713a <MTIMER2_voidSetCallBackOVF>:

void MTIMER2_voidSetCallBackOVF(void (*pf)())
{
    713a:	df 93       	push	r29
    713c:	cf 93       	push	r28
    713e:	00 d0       	rcall	.+0      	; 0x7140 <MTIMER2_voidSetCallBackOVF+0x6>
    7140:	cd b7       	in	r28, 0x3d	; 61
    7142:	de b7       	in	r29, 0x3e	; 62
    7144:	9a 83       	std	Y+2, r25	; 0x02
    7146:	89 83       	std	Y+1, r24	; 0x01
    TIMER2_OVF_CALL=pf;
    7148:	89 81       	ldd	r24, Y+1	; 0x01
    714a:	9a 81       	ldd	r25, Y+2	; 0x02
    714c:	90 93 c0 01 	sts	0x01C0, r25
    7150:	80 93 bf 01 	sts	0x01BF, r24
}
    7154:	0f 90       	pop	r0
    7156:	0f 90       	pop	r0
    7158:	cf 91       	pop	r28
    715a:	df 91       	pop	r29
    715c:	08 95       	ret

0000715e <MTIMER2_voidSetCallBackCTC>:

void MTIMER2_voidSetCallBackCTC(void (*pf)())
{
    715e:	df 93       	push	r29
    7160:	cf 93       	push	r28
    7162:	00 d0       	rcall	.+0      	; 0x7164 <MTIMER2_voidSetCallBackCTC+0x6>
    7164:	cd b7       	in	r28, 0x3d	; 61
    7166:	de b7       	in	r29, 0x3e	; 62
    7168:	9a 83       	std	Y+2, r25	; 0x02
    716a:	89 83       	std	Y+1, r24	; 0x01
    TIMER2_CTC_CALL=pf;
    716c:	89 81       	ldd	r24, Y+1	; 0x01
    716e:	9a 81       	ldd	r25, Y+2	; 0x02
    7170:	90 93 c2 01 	sts	0x01C2, r25
    7174:	80 93 c1 01 	sts	0x01C1, r24
}
    7178:	0f 90       	pop	r0
    717a:	0f 90       	pop	r0
    717c:	cf 91       	pop	r28
    717e:	df 91       	pop	r29
    7180:	08 95       	ret

00007182 <__vector_5>:

ISR(TIMER2_OVF_VECT)
{
    7182:	1f 92       	push	r1
    7184:	0f 92       	push	r0
    7186:	0f b6       	in	r0, 0x3f	; 63
    7188:	0f 92       	push	r0
    718a:	11 24       	eor	r1, r1
    718c:	2f 93       	push	r18
    718e:	3f 93       	push	r19
    7190:	4f 93       	push	r20
    7192:	5f 93       	push	r21
    7194:	6f 93       	push	r22
    7196:	7f 93       	push	r23
    7198:	8f 93       	push	r24
    719a:	9f 93       	push	r25
    719c:	af 93       	push	r26
    719e:	bf 93       	push	r27
    71a0:	ef 93       	push	r30
    71a2:	ff 93       	push	r31
    71a4:	df 93       	push	r29
    71a6:	cf 93       	push	r28
    71a8:	cd b7       	in	r28, 0x3d	; 61
    71aa:	de b7       	in	r29, 0x3e	; 62
    if(TIMER2_OVF_CALL != NULLPTR) TIMER2_OVF_CALL();
    71ac:	80 91 bf 01 	lds	r24, 0x01BF
    71b0:	90 91 c0 01 	lds	r25, 0x01C0
    71b4:	00 97       	sbiw	r24, 0x00	; 0
    71b6:	29 f0       	breq	.+10     	; 0x71c2 <__vector_5+0x40>
    71b8:	e0 91 bf 01 	lds	r30, 0x01BF
    71bc:	f0 91 c0 01 	lds	r31, 0x01C0
    71c0:	09 95       	icall
}
    71c2:	cf 91       	pop	r28
    71c4:	df 91       	pop	r29
    71c6:	ff 91       	pop	r31
    71c8:	ef 91       	pop	r30
    71ca:	bf 91       	pop	r27
    71cc:	af 91       	pop	r26
    71ce:	9f 91       	pop	r25
    71d0:	8f 91       	pop	r24
    71d2:	7f 91       	pop	r23
    71d4:	6f 91       	pop	r22
    71d6:	5f 91       	pop	r21
    71d8:	4f 91       	pop	r20
    71da:	3f 91       	pop	r19
    71dc:	2f 91       	pop	r18
    71de:	0f 90       	pop	r0
    71e0:	0f be       	out	0x3f, r0	; 63
    71e2:	0f 90       	pop	r0
    71e4:	1f 90       	pop	r1
    71e6:	18 95       	reti

000071e8 <__vector_4>:

ISR(TIMER2_CTC_VECT)
{
    71e8:	1f 92       	push	r1
    71ea:	0f 92       	push	r0
    71ec:	0f b6       	in	r0, 0x3f	; 63
    71ee:	0f 92       	push	r0
    71f0:	11 24       	eor	r1, r1
    71f2:	2f 93       	push	r18
    71f4:	3f 93       	push	r19
    71f6:	4f 93       	push	r20
    71f8:	5f 93       	push	r21
    71fa:	6f 93       	push	r22
    71fc:	7f 93       	push	r23
    71fe:	8f 93       	push	r24
    7200:	9f 93       	push	r25
    7202:	af 93       	push	r26
    7204:	bf 93       	push	r27
    7206:	ef 93       	push	r30
    7208:	ff 93       	push	r31
    720a:	df 93       	push	r29
    720c:	cf 93       	push	r28
    720e:	cd b7       	in	r28, 0x3d	; 61
    7210:	de b7       	in	r29, 0x3e	; 62
    if(TIMER2_CTC_CALL != NULLPTR) TIMER2_CTC_CALL();
    7212:	80 91 c1 01 	lds	r24, 0x01C1
    7216:	90 91 c2 01 	lds	r25, 0x01C2
    721a:	00 97       	sbiw	r24, 0x00	; 0
    721c:	29 f0       	breq	.+10     	; 0x7228 <__vector_4+0x40>
    721e:	e0 91 c1 01 	lds	r30, 0x01C1
    7222:	f0 91 c2 01 	lds	r31, 0x01C2
    7226:	09 95       	icall
    7228:	cf 91       	pop	r28
    722a:	df 91       	pop	r29
    722c:	ff 91       	pop	r31
    722e:	ef 91       	pop	r30
    7230:	bf 91       	pop	r27
    7232:	af 91       	pop	r26
    7234:	9f 91       	pop	r25
    7236:	8f 91       	pop	r24
    7238:	7f 91       	pop	r23
    723a:	6f 91       	pop	r22
    723c:	5f 91       	pop	r21
    723e:	4f 91       	pop	r20
    7240:	3f 91       	pop	r19
    7242:	2f 91       	pop	r18
    7244:	0f 90       	pop	r0
    7246:	0f be       	out	0x3f, r0	; 63
    7248:	0f 90       	pop	r0
    724a:	1f 90       	pop	r1
    724c:	18 95       	reti

0000724e <MTWI_voidInit>:
SCL_FREQ= ----------------------- = ------
            16+2*(TWBR)* 4^(TWPS)   16+2*12*4
*/

void MTWI_voidInit(u8 A_u8Slave)
{
    724e:	df 93       	push	r29
    7250:	cf 93       	push	r28
    7252:	0f 92       	push	r0
    7254:	cd b7       	in	r28, 0x3d	; 61
    7256:	de b7       	in	r29, 0x3e	; 62
    7258:	89 83       	std	Y+1, r24	; 0x01
    // enable TWI
    TWCR = (1 << TWEN);
    725a:	e6 e5       	ldi	r30, 0x56	; 86
    725c:	f0 e0       	ldi	r31, 0x00	; 0
    725e:	84 e0       	ldi	r24, 0x04	; 4
    7260:	80 83       	st	Z, r24
    // the follwoing two line of code is to set frequency
    TWSR = 0x00;
    7262:	e1 e2       	ldi	r30, 0x21	; 33
    7264:	f0 e0       	ldi	r31, 0x00	; 0
    7266:	10 82       	st	Z, r1
    TWBR = 0x0C;
    7268:	e0 e2       	ldi	r30, 0x20	; 32
    726a:	f0 e0       	ldi	r31, 0x00	; 0
    726c:	8c e0       	ldi	r24, 0x0C	; 12
    726e:	80 83       	st	Z, r24
    // Enable Ack & enable TWI
    TWAR = A_u8Slave << 1;
    7270:	e2 e2       	ldi	r30, 0x22	; 34
    7272:	f0 e0       	ldi	r31, 0x00	; 0
    7274:	89 81       	ldd	r24, Y+1	; 0x01
    7276:	88 0f       	add	r24, r24
    7278:	80 83       	st	Z, r24
}
    727a:	0f 90       	pop	r0
    727c:	cf 91       	pop	r28
    727e:	df 91       	pop	r29
    7280:	08 95       	ret

00007282 <MTWI_u8Start>:

TWI_STATUS MTWI_u8Start(void)
{
    7282:	df 93       	push	r29
    7284:	cf 93       	push	r28
    7286:	0f 92       	push	r0
    7288:	cd b7       	in	r28, 0x3d	; 61
    728a:	de b7       	in	r29, 0x3e	; 62
    // 01- Send Start Condition & Clearing Flag & Enabling TWI
    TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
    728c:	e6 e5       	ldi	r30, 0x56	; 86
    728e:	f0 e0       	ldi	r31, 0x00	; 0
    7290:	84 ea       	ldi	r24, 0xA4	; 164
    7292:	80 83       	st	Z, r24
    // Polling untill Start Condition to be snet
    while (GET_BIT(TWCR, TWINT) != 1)
    7294:	e6 e5       	ldi	r30, 0x56	; 86
    7296:	f0 e0       	ldi	r31, 0x00	; 0
    7298:	80 81       	ld	r24, Z
    729a:	88 2f       	mov	r24, r24
    729c:	90 e0       	ldi	r25, 0x00	; 0
    729e:	9c 01       	movw	r18, r24
    72a0:	2f 77       	andi	r18, 0x7F	; 127
    72a2:	e6 e5       	ldi	r30, 0x56	; 86
    72a4:	f0 e0       	ldi	r31, 0x00	; 0
    72a6:	80 81       	ld	r24, Z
    72a8:	88 2f       	mov	r24, r24
    72aa:	90 e0       	ldi	r25, 0x00	; 0
    72ac:	28 17       	cp	r18, r24
    72ae:	39 07       	cpc	r19, r25
    72b0:	89 f3       	breq	.-30     	; 0x7294 <MTWI_u8Start+0x12>
        ;
    if ((TWSR & 0xF8) != START_TWI)
    72b2:	e1 e2       	ldi	r30, 0x21	; 33
    72b4:	f0 e0       	ldi	r31, 0x00	; 0
    72b6:	80 81       	ld	r24, Z
    72b8:	88 2f       	mov	r24, r24
    72ba:	90 e0       	ldi	r25, 0x00	; 0
    72bc:	88 7f       	andi	r24, 0xF8	; 248
    72be:	90 70       	andi	r25, 0x00	; 0
    72c0:	88 30       	cpi	r24, 0x08	; 8
    72c2:	91 05       	cpc	r25, r1
    72c4:	19 f0       	breq	.+6      	; 0x72cc <MTWI_u8Start+0x4a>
        return START_TWI_ERORR;
    72c6:	81 e0       	ldi	r24, 0x01	; 1
    72c8:	89 83       	std	Y+1, r24	; 0x01
    72ca:	01 c0       	rjmp	.+2      	; 0x72ce <MTWI_u8Start+0x4c>
    return TWI_OK;
    72cc:	19 82       	std	Y+1, r1	; 0x01
    72ce:	89 81       	ldd	r24, Y+1	; 0x01
}
    72d0:	0f 90       	pop	r0
    72d2:	cf 91       	pop	r28
    72d4:	df 91       	pop	r29
    72d6:	08 95       	ret

000072d8 <MTWI_u8SendSlaveAddWrite>:

TWI_STATUS MTWI_u8SendSlaveAddWrite(u8 A_u8SlaveAdd)
{
    72d8:	df 93       	push	r29
    72da:	cf 93       	push	r28
    72dc:	00 d0       	rcall	.+0      	; 0x72de <MTWI_u8SendSlaveAddWrite+0x6>
    72de:	cd b7       	in	r28, 0x3d	; 61
    72e0:	de b7       	in	r29, 0x3e	; 62
    72e2:	89 83       	std	Y+1, r24	; 0x01

    // 02- sending slave address + writed Operation
    TWDR = A_u8SlaveAdd << 1;
    72e4:	e3 e2       	ldi	r30, 0x23	; 35
    72e6:	f0 e0       	ldi	r31, 0x00	; 0
    72e8:	89 81       	ldd	r24, Y+1	; 0x01
    72ea:	88 0f       	add	r24, r24
    72ec:	80 83       	st	Z, r24
    // Clearing flag & Enabling TWI
    TWCR = (1 << TWINT) | (1 << TWEN);
    72ee:	e6 e5       	ldi	r30, 0x56	; 86
    72f0:	f0 e0       	ldi	r31, 0x00	; 0
    72f2:	84 e8       	ldi	r24, 0x84	; 132
    72f4:	80 83       	st	Z, r24
    while (GET_BIT(TWCR, TWINT) != 1)
    72f6:	e6 e5       	ldi	r30, 0x56	; 86
    72f8:	f0 e0       	ldi	r31, 0x00	; 0
    72fa:	80 81       	ld	r24, Z
    72fc:	88 2f       	mov	r24, r24
    72fe:	90 e0       	ldi	r25, 0x00	; 0
    7300:	9c 01       	movw	r18, r24
    7302:	2f 77       	andi	r18, 0x7F	; 127
    7304:	e6 e5       	ldi	r30, 0x56	; 86
    7306:	f0 e0       	ldi	r31, 0x00	; 0
    7308:	80 81       	ld	r24, Z
    730a:	88 2f       	mov	r24, r24
    730c:	90 e0       	ldi	r25, 0x00	; 0
    730e:	28 17       	cp	r18, r24
    7310:	39 07       	cpc	r19, r25
    7312:	89 f3       	breq	.-30     	; 0x72f6 <MTWI_u8SendSlaveAddWrite+0x1e>
        ;
    // Handelling errors
    if (TWSR & 0xF8 != MT_SLA_ACK)
    7314:	e1 e2       	ldi	r30, 0x21	; 33
    7316:	f0 e0       	ldi	r31, 0x00	; 0
    7318:	80 81       	ld	r24, Z
    731a:	88 2f       	mov	r24, r24
    731c:	90 e0       	ldi	r25, 0x00	; 0
    731e:	81 70       	andi	r24, 0x01	; 1
    7320:	90 70       	andi	r25, 0x00	; 0
    7322:	88 23       	and	r24, r24
    7324:	19 f0       	breq	.+6      	; 0x732c <MTWI_u8SendSlaveAddWrite+0x54>
        return TWI_SLA_ACK;
    7326:	82 e0       	ldi	r24, 0x02	; 2
    7328:	8a 83       	std	Y+2, r24	; 0x02
    732a:	01 c0       	rjmp	.+2      	; 0x732e <MTWI_u8SendSlaveAddWrite+0x56>

    return TWI_OK;
    732c:	1a 82       	std	Y+2, r1	; 0x02
    732e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    7330:	0f 90       	pop	r0
    7332:	0f 90       	pop	r0
    7334:	cf 91       	pop	r28
    7336:	df 91       	pop	r29
    7338:	08 95       	ret

0000733a <MTWI_u8SendData>:

TWI_STATUS MTWI_u8SendData(u8 A_u8Data)
{
    733a:	df 93       	push	r29
    733c:	cf 93       	push	r28
    733e:	00 d0       	rcall	.+0      	; 0x7340 <MTWI_u8SendData+0x6>
    7340:	cd b7       	in	r28, 0x3d	; 61
    7342:	de b7       	in	r29, 0x3e	; 62
    7344:	89 83       	std	Y+1, r24	; 0x01
    // 03- Sending Data
    TWDR = A_u8Data;
    7346:	e3 e2       	ldi	r30, 0x23	; 35
    7348:	f0 e0       	ldi	r31, 0x00	; 0
    734a:	89 81       	ldd	r24, Y+1	; 0x01
    734c:	80 83       	st	Z, r24
    // Clearing flag & Enabling TWI
    TWCR = (1 << TWINT) | (1 << TWEN);
    734e:	e6 e5       	ldi	r30, 0x56	; 86
    7350:	f0 e0       	ldi	r31, 0x00	; 0
    7352:	84 e8       	ldi	r24, 0x84	; 132
    7354:	80 83       	st	Z, r24
    while (GET_BIT(TWCR, TWINT) != 1)
    7356:	e6 e5       	ldi	r30, 0x56	; 86
    7358:	f0 e0       	ldi	r31, 0x00	; 0
    735a:	80 81       	ld	r24, Z
    735c:	88 2f       	mov	r24, r24
    735e:	90 e0       	ldi	r25, 0x00	; 0
    7360:	9c 01       	movw	r18, r24
    7362:	2f 77       	andi	r18, 0x7F	; 127
    7364:	e6 e5       	ldi	r30, 0x56	; 86
    7366:	f0 e0       	ldi	r31, 0x00	; 0
    7368:	80 81       	ld	r24, Z
    736a:	88 2f       	mov	r24, r24
    736c:	90 e0       	ldi	r25, 0x00	; 0
    736e:	28 17       	cp	r18, r24
    7370:	39 07       	cpc	r19, r25
    7372:	89 f3       	breq	.-30     	; 0x7356 <MTWI_u8SendData+0x1c>
        ;
    if ((TWSR & 0xF8) != MT_DATA_ACK)
    7374:	e1 e2       	ldi	r30, 0x21	; 33
    7376:	f0 e0       	ldi	r31, 0x00	; 0
    7378:	80 81       	ld	r24, Z
    737a:	88 2f       	mov	r24, r24
    737c:	90 e0       	ldi	r25, 0x00	; 0
    737e:	88 7f       	andi	r24, 0xF8	; 248
    7380:	90 70       	andi	r25, 0x00	; 0
    7382:	88 32       	cpi	r24, 0x28	; 40
    7384:	91 05       	cpc	r25, r1
    7386:	19 f0       	breq	.+6      	; 0x738e <MTWI_u8SendData+0x54>
        return TWI_DATA_TRANSMITTED_ACK;
    7388:	83 e0       	ldi	r24, 0x03	; 3
    738a:	8a 83       	std	Y+2, r24	; 0x02
    738c:	01 c0       	rjmp	.+2      	; 0x7390 <MTWI_u8SendData+0x56>

    return TWI_OK;
    738e:	1a 82       	std	Y+2, r1	; 0x02
    7390:	8a 81       	ldd	r24, Y+2	; 0x02
}
    7392:	0f 90       	pop	r0
    7394:	0f 90       	pop	r0
    7396:	cf 91       	pop	r28
    7398:	df 91       	pop	r29
    739a:	08 95       	ret

0000739c <MTWI_u8SendReStart>:

TWI_STATUS MTWI_u8SendReStart(void)
{
    739c:	df 93       	push	r29
    739e:	cf 93       	push	r28
    73a0:	0f 92       	push	r0
    73a2:	cd b7       	in	r28, 0x3d	; 61
    73a4:	de b7       	in	r29, 0x3e	; 62
    // 04- Repeated Start
    // Clearing Flag & Enabling TWI & Setting Start Bit
    TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
    73a6:	e6 e5       	ldi	r30, 0x56	; 86
    73a8:	f0 e0       	ldi	r31, 0x00	; 0
    73aa:	84 ea       	ldi	r24, 0xA4	; 164
    73ac:	80 83       	st	Z, r24
    // Polling untill flag become one
    while (GET_BIT(TWCR, TWINT) != 1)
    73ae:	e6 e5       	ldi	r30, 0x56	; 86
    73b0:	f0 e0       	ldi	r31, 0x00	; 0
    73b2:	80 81       	ld	r24, Z
    73b4:	88 2f       	mov	r24, r24
    73b6:	90 e0       	ldi	r25, 0x00	; 0
    73b8:	9c 01       	movw	r18, r24
    73ba:	2f 77       	andi	r18, 0x7F	; 127
    73bc:	e6 e5       	ldi	r30, 0x56	; 86
    73be:	f0 e0       	ldi	r31, 0x00	; 0
    73c0:	80 81       	ld	r24, Z
    73c2:	88 2f       	mov	r24, r24
    73c4:	90 e0       	ldi	r25, 0x00	; 0
    73c6:	28 17       	cp	r18, r24
    73c8:	39 07       	cpc	r19, r25
    73ca:	89 f3       	breq	.-30     	; 0x73ae <MTWI_u8SendReStart+0x12>
        ;
    if ((TWSR & 0xF8) != RE_START_ACK)
    73cc:	e1 e2       	ldi	r30, 0x21	; 33
    73ce:	f0 e0       	ldi	r31, 0x00	; 0
    73d0:	80 81       	ld	r24, Z
    73d2:	88 2f       	mov	r24, r24
    73d4:	90 e0       	ldi	r25, 0x00	; 0
    73d6:	88 7f       	andi	r24, 0xF8	; 248
    73d8:	90 70       	andi	r25, 0x00	; 0
    73da:	80 31       	cpi	r24, 0x10	; 16
    73dc:	91 05       	cpc	r25, r1
    73de:	19 f0       	breq	.+6      	; 0x73e6 <MTWI_u8SendReStart+0x4a>
        return RE_START_ACK_ERORR;
    73e0:	85 e0       	ldi	r24, 0x05	; 5
    73e2:	89 83       	std	Y+1, r24	; 0x01
    73e4:	01 c0       	rjmp	.+2      	; 0x73e8 <MTWI_u8SendReStart+0x4c>

    return TWI_OK;
    73e6:	19 82       	std	Y+1, r1	; 0x01
    73e8:	89 81       	ldd	r24, Y+1	; 0x01
}
    73ea:	0f 90       	pop	r0
    73ec:	cf 91       	pop	r28
    73ee:	df 91       	pop	r29
    73f0:	08 95       	ret

000073f2 <MTWI_u8SendSlaveAddRead>:

TWI_STATUS MTWI_u8SendSlaveAddRead(u8 A_u8SlaveAdd)
{
    73f2:	df 93       	push	r29
    73f4:	cf 93       	push	r28
    73f6:	00 d0       	rcall	.+0      	; 0x73f8 <MTWI_u8SendSlaveAddRead+0x6>
    73f8:	cd b7       	in	r28, 0x3d	; 61
    73fa:	de b7       	in	r29, 0x3e	; 62
    73fc:	89 83       	std	Y+1, r24	; 0x01
    // 05- Send Slave address + Read
    TWDR = (A_u8SlaveAdd << 1) | (1 << 0);
    73fe:	e3 e2       	ldi	r30, 0x23	; 35
    7400:	f0 e0       	ldi	r31, 0x00	; 0
    7402:	89 81       	ldd	r24, Y+1	; 0x01
    7404:	88 2f       	mov	r24, r24
    7406:	90 e0       	ldi	r25, 0x00	; 0
    7408:	88 0f       	add	r24, r24
    740a:	99 1f       	adc	r25, r25
    740c:	81 60       	ori	r24, 0x01	; 1
    740e:	80 83       	st	Z, r24
    // clearing flag & Enabling TWI
    TWCR = (1 << TWINT) | (1 << TWEN);
    7410:	e6 e5       	ldi	r30, 0x56	; 86
    7412:	f0 e0       	ldi	r31, 0x00	; 0
    7414:	84 e8       	ldi	r24, 0x84	; 132
    7416:	80 83       	st	Z, r24
    // Polling untill flag become one
    while (GET_BIT(TWCR, TWINT) != 1)
    7418:	e6 e5       	ldi	r30, 0x56	; 86
    741a:	f0 e0       	ldi	r31, 0x00	; 0
    741c:	80 81       	ld	r24, Z
    741e:	88 2f       	mov	r24, r24
    7420:	90 e0       	ldi	r25, 0x00	; 0
    7422:	9c 01       	movw	r18, r24
    7424:	2f 77       	andi	r18, 0x7F	; 127
    7426:	e6 e5       	ldi	r30, 0x56	; 86
    7428:	f0 e0       	ldi	r31, 0x00	; 0
    742a:	80 81       	ld	r24, Z
    742c:	88 2f       	mov	r24, r24
    742e:	90 e0       	ldi	r25, 0x00	; 0
    7430:	28 17       	cp	r18, r24
    7432:	39 07       	cpc	r19, r25
    7434:	89 f3       	breq	.-30     	; 0x7418 <MTWI_u8SendSlaveAddRead+0x26>
        ;
    if ((TWSR & 0xF8) != MR_SLA_ACK)
    7436:	e1 e2       	ldi	r30, 0x21	; 33
    7438:	f0 e0       	ldi	r31, 0x00	; 0
    743a:	80 81       	ld	r24, Z
    743c:	88 2f       	mov	r24, r24
    743e:	90 e0       	ldi	r25, 0x00	; 0
    7440:	88 7f       	andi	r24, 0xF8	; 248
    7442:	90 70       	andi	r25, 0x00	; 0
    7444:	80 34       	cpi	r24, 0x40	; 64
    7446:	91 05       	cpc	r25, r1
    7448:	19 f0       	breq	.+6      	; 0x7450 <MTWI_u8SendSlaveAddRead+0x5e>
        return MR_SLA_ACK_ERROR;
    744a:	86 e0       	ldi	r24, 0x06	; 6
    744c:	8a 83       	std	Y+2, r24	; 0x02
    744e:	01 c0       	rjmp	.+2      	; 0x7452 <MTWI_u8SendSlaveAddRead+0x60>
    return TWI_OK;
    7450:	1a 82       	std	Y+2, r1	; 0x02
    7452:	8a 81       	ldd	r24, Y+2	; 0x02
}
    7454:	0f 90       	pop	r0
    7456:	0f 90       	pop	r0
    7458:	cf 91       	pop	r28
    745a:	df 91       	pop	r29
    745c:	08 95       	ret

0000745e <MTWI_u8ReadData>:

TWI_STATUS MTWI_u8ReadData(u8 ack, u8 *A_u8data)
{
    745e:	df 93       	push	r29
    7460:	cf 93       	push	r28
    7462:	00 d0       	rcall	.+0      	; 0x7464 <MTWI_u8ReadData+0x6>
    7464:	00 d0       	rcall	.+0      	; 0x7466 <MTWI_u8ReadData+0x8>
    7466:	cd b7       	in	r28, 0x3d	; 61
    7468:	de b7       	in	r29, 0x3e	; 62
    746a:	89 83       	std	Y+1, r24	; 0x01
    746c:	7b 83       	std	Y+3, r23	; 0x03
    746e:	6a 83       	std	Y+2, r22	; 0x02
    /*
        Clear Flag & enabling TWI
        we can set acknolwedge to receive more data
        or clear it to stop the transfer of data
    */
    TWCR = (1 << TWINT) | (1 << TWEN) | (ack << TWEA);
    7470:	e6 e5       	ldi	r30, 0x56	; 86
    7472:	f0 e0       	ldi	r31, 0x00	; 0
    7474:	89 81       	ldd	r24, Y+1	; 0x01
    7476:	88 2f       	mov	r24, r24
    7478:	90 e0       	ldi	r25, 0x00	; 0
    747a:	00 24       	eor	r0, r0
    747c:	96 95       	lsr	r25
    747e:	87 95       	ror	r24
    7480:	07 94       	ror	r0
    7482:	96 95       	lsr	r25
    7484:	87 95       	ror	r24
    7486:	07 94       	ror	r0
    7488:	98 2f       	mov	r25, r24
    748a:	80 2d       	mov	r24, r0
    748c:	84 68       	ori	r24, 0x84	; 132
    748e:	80 83       	st	Z, r24
    while (GET_BIT(TWCR, TWINT) != 1)
    7490:	e6 e5       	ldi	r30, 0x56	; 86
    7492:	f0 e0       	ldi	r31, 0x00	; 0
    7494:	80 81       	ld	r24, Z
    7496:	88 2f       	mov	r24, r24
    7498:	90 e0       	ldi	r25, 0x00	; 0
    749a:	9c 01       	movw	r18, r24
    749c:	2f 77       	andi	r18, 0x7F	; 127
    749e:	e6 e5       	ldi	r30, 0x56	; 86
    74a0:	f0 e0       	ldi	r31, 0x00	; 0
    74a2:	80 81       	ld	r24, Z
    74a4:	88 2f       	mov	r24, r24
    74a6:	90 e0       	ldi	r25, 0x00	; 0
    74a8:	28 17       	cp	r18, r24
    74aa:	39 07       	cpc	r19, r25
    74ac:	89 f3       	breq	.-30     	; 0x7490 <MTWI_u8ReadData+0x32>
        ;
    if (TWSR != MR_DATA_ACK)
    74ae:	e1 e2       	ldi	r30, 0x21	; 33
    74b0:	f0 e0       	ldi	r31, 0x00	; 0
    74b2:	80 81       	ld	r24, Z
    74b4:	80 35       	cpi	r24, 0x50	; 80
    74b6:	19 f0       	breq	.+6      	; 0x74be <MTWI_u8ReadData+0x60>
        return TWI_DATA_RECEIVED_ACK;
    74b8:	84 e0       	ldi	r24, 0x04	; 4
    74ba:	8c 83       	std	Y+4, r24	; 0x04
    74bc:	07 c0       	rjmp	.+14     	; 0x74cc <MTWI_u8ReadData+0x6e>
    else
    {
        *A_u8data = TWDR;
    74be:	e3 e2       	ldi	r30, 0x23	; 35
    74c0:	f0 e0       	ldi	r31, 0x00	; 0
    74c2:	80 81       	ld	r24, Z
    74c4:	ea 81       	ldd	r30, Y+2	; 0x02
    74c6:	fb 81       	ldd	r31, Y+3	; 0x03
    74c8:	80 83       	st	Z, r24
    }
    return TWI_OK;
    74ca:	1c 82       	std	Y+4, r1	; 0x04
    74cc:	8c 81       	ldd	r24, Y+4	; 0x04
}
    74ce:	0f 90       	pop	r0
    74d0:	0f 90       	pop	r0
    74d2:	0f 90       	pop	r0
    74d4:	0f 90       	pop	r0
    74d6:	cf 91       	pop	r28
    74d8:	df 91       	pop	r29
    74da:	08 95       	ret

000074dc <MTWI_voidStop>:

void MTWI_voidStop(void)
{
    74dc:	df 93       	push	r29
    74de:	cf 93       	push	r28
    74e0:	cd b7       	in	r28, 0x3d	; 61
    74e2:	de b7       	in	r29, 0x3e	; 62
    // 07- Transmit Stop bit & Clearing Flag & Enabling TWI
    TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
    74e4:	e6 e5       	ldi	r30, 0x56	; 86
    74e6:	f0 e0       	ldi	r31, 0x00	; 0
    74e8:	84 e9       	ldi	r24, 0x94	; 148
    74ea:	80 83       	st	Z, r24
}
    74ec:	cf 91       	pop	r28
    74ee:	df 91       	pop	r29
    74f0:	08 95       	ret

000074f2 <MTWI_voidSetCallBack>:

/******************************interrupt section ****************************/
void MTWI_voidSetCallBack(void (*pf)(void))
{
    74f2:	df 93       	push	r29
    74f4:	cf 93       	push	r28
    74f6:	00 d0       	rcall	.+0      	; 0x74f8 <MTWI_voidSetCallBack+0x6>
    74f8:	cd b7       	in	r28, 0x3d	; 61
    74fa:	de b7       	in	r29, 0x3e	; 62
    74fc:	9a 83       	std	Y+2, r25	; 0x02
    74fe:	89 83       	std	Y+1, r24	; 0x01
    TWI_INT_FUNC = pf;
    7500:	89 81       	ldd	r24, Y+1	; 0x01
    7502:	9a 81       	ldd	r25, Y+2	; 0x02
    7504:	90 93 c4 01 	sts	0x01C4, r25
    7508:	80 93 c3 01 	sts	0x01C3, r24
}
    750c:	0f 90       	pop	r0
    750e:	0f 90       	pop	r0
    7510:	cf 91       	pop	r28
    7512:	df 91       	pop	r29
    7514:	08 95       	ret

00007516 <MTWI_voidSetInterruptEnable>:
void MTWI_voidSetInterruptEnable()
{
    7516:	df 93       	push	r29
    7518:	cf 93       	push	r28
    751a:	cd b7       	in	r28, 0x3d	; 61
    751c:	de b7       	in	r29, 0x3e	; 62
    SET_BIT(TWCR, TWIE);
    751e:	a6 e5       	ldi	r26, 0x56	; 86
    7520:	b0 e0       	ldi	r27, 0x00	; 0
    7522:	e6 e5       	ldi	r30, 0x56	; 86
    7524:	f0 e0       	ldi	r31, 0x00	; 0
    7526:	80 81       	ld	r24, Z
    7528:	81 60       	ori	r24, 0x01	; 1
    752a:	8c 93       	st	X, r24
}
    752c:	cf 91       	pop	r28
    752e:	df 91       	pop	r29
    7530:	08 95       	ret

00007532 <MTWI_voidSetIntDisable>:
void MTWI_voidSetIntDisable()
{
    7532:	df 93       	push	r29
    7534:	cf 93       	push	r28
    7536:	cd b7       	in	r28, 0x3d	; 61
    7538:	de b7       	in	r29, 0x3e	; 62
    CLR_BIT(TWCR, TWIE);
    753a:	a6 e5       	ldi	r26, 0x56	; 86
    753c:	b0 e0       	ldi	r27, 0x00	; 0
    753e:	e6 e5       	ldi	r30, 0x56	; 86
    7540:	f0 e0       	ldi	r31, 0x00	; 0
    7542:	80 81       	ld	r24, Z
    7544:	8e 7f       	andi	r24, 0xFE	; 254
    7546:	8c 93       	st	X, r24
}
    7548:	cf 91       	pop	r28
    754a:	df 91       	pop	r29
    754c:	08 95       	ret

0000754e <__vector_19>:

ISR(TWI_VECT)
{
    754e:	1f 92       	push	r1
    7550:	0f 92       	push	r0
    7552:	0f b6       	in	r0, 0x3f	; 63
    7554:	0f 92       	push	r0
    7556:	11 24       	eor	r1, r1
    7558:	2f 93       	push	r18
    755a:	3f 93       	push	r19
    755c:	4f 93       	push	r20
    755e:	5f 93       	push	r21
    7560:	6f 93       	push	r22
    7562:	7f 93       	push	r23
    7564:	8f 93       	push	r24
    7566:	9f 93       	push	r25
    7568:	af 93       	push	r26
    756a:	bf 93       	push	r27
    756c:	ef 93       	push	r30
    756e:	ff 93       	push	r31
    7570:	df 93       	push	r29
    7572:	cf 93       	push	r28
    7574:	cd b7       	in	r28, 0x3d	; 61
    7576:	de b7       	in	r29, 0x3e	; 62
    if (TWI_INT_FUNC != NULLPTR)
    7578:	80 91 c3 01 	lds	r24, 0x01C3
    757c:	90 91 c4 01 	lds	r25, 0x01C4
    7580:	00 97       	sbiw	r24, 0x00	; 0
    7582:	29 f0       	breq	.+10     	; 0x758e <__vector_19+0x40>
        TWI_INT_FUNC();
    7584:	e0 91 c3 01 	lds	r30, 0x01C3
    7588:	f0 91 c4 01 	lds	r31, 0x01C4
    758c:	09 95       	icall
}
    758e:	cf 91       	pop	r28
    7590:	df 91       	pop	r29
    7592:	ff 91       	pop	r31
    7594:	ef 91       	pop	r30
    7596:	bf 91       	pop	r27
    7598:	af 91       	pop	r26
    759a:	9f 91       	pop	r25
    759c:	8f 91       	pop	r24
    759e:	7f 91       	pop	r23
    75a0:	6f 91       	pop	r22
    75a2:	5f 91       	pop	r21
    75a4:	4f 91       	pop	r20
    75a6:	3f 91       	pop	r19
    75a8:	2f 91       	pop	r18
    75aa:	0f 90       	pop	r0
    75ac:	0f be       	out	0x3f, r0	; 63
    75ae:	0f 90       	pop	r0
    75b0:	1f 90       	pop	r1
    75b2:	18 95       	reti

000075b4 <MUSART_voidInit>:
static void (*USART_RXC_CALL)(void)=NULLPTR;
static void (*USART_UDRE_CALL)(void)=NULLPTR;
static void (*USART_TXC_CALL)(void)=NULLPTR;

void MUSART_voidInit(void)
{
    75b4:	df 93       	push	r29
    75b6:	cf 93       	push	r28
    75b8:	00 d0       	rcall	.+0      	; 0x75ba <MUSART_voidInit+0x6>
    75ba:	0f 92       	push	r0
    75bc:	cd b7       	in	r28, 0x3d	; 61
    75be:	de b7       	in	r29, 0x3e	; 62
    u8 UCSRC_var=0;
    75c0:	1b 82       	std	Y+3, r1	; 0x03
    u16 local_u16BaudRateValue=BAUD_RATE_EQN;
    75c2:	83 e3       	ldi	r24, 0x33	; 51
    75c4:	90 e0       	ldi	r25, 0x00	; 0
    75c6:	9a 83       	std	Y+2, r25	; 0x02
    75c8:	89 83       	std	Y+1, r24	; 0x01
    UBRRL=(u8)local_u16BaudRateValue;
    75ca:	e9 e2       	ldi	r30, 0x29	; 41
    75cc:	f0 e0       	ldi	r31, 0x00	; 0
    75ce:	89 81       	ldd	r24, Y+1	; 0x01
    75d0:	80 83       	st	Z, r24
    
    /*
        note: shifting bits firstly then casting
        if you cast firt, the bits from 8 will be zeros 
    */
    UBRRH=(u8)((local_u16BaudRateValue)>>8);
    75d2:	e0 e4       	ldi	r30, 0x40	; 64
    75d4:	f0 e0       	ldi	r31, 0x00	; 0
    75d6:	89 81       	ldd	r24, Y+1	; 0x01
    75d8:	9a 81       	ldd	r25, Y+2	; 0x02
    75da:	89 2f       	mov	r24, r25
    75dc:	99 27       	eor	r25, r25
    75de:	80 83       	st	Z, r24

    #if USART_SPPED == DOUBLE_SPEED
    SET_BIT(UCSRA,U2X);
    #else
    CLR_BIT(UCSRA,U2X);
    75e0:	ab e2       	ldi	r26, 0x2B	; 43
    75e2:	b0 e0       	ldi	r27, 0x00	; 0
    75e4:	eb e2       	ldi	r30, 0x2B	; 43
    75e6:	f0 e0       	ldi	r31, 0x00	; 0
    75e8:	80 81       	ld	r24, Z
    75ea:	8d 7f       	andi	r24, 0xFD	; 253
    75ec:	8c 93       	st	X, r24
    /*
        Register Select
        this first bit must be configured, if you configure any bits before it
        it will not work correctly
    */
    SET_BIT(UCSRC_var,URSEL);
    75ee:	8b 81       	ldd	r24, Y+3	; 0x03
    75f0:	80 68       	ori	r24, 0x80	; 128
    75f2:	8b 83       	std	Y+3, r24	; 0x03
    #elif CHARACTER_SIZE == CHARACTER_SIZE_7BIT
    CLR_BIT(UCSRB,UCSZ2);
    SET_BIT(UCSRC_var,UCSZ1);
    CLR_BIT(UCSRC_var,UCSZ0);
    #elif CHARACTER_SIZE == CHARACTER_SIZE_8BIT
    CLR_BIT(UCSRB,UCSZ2);
    75f4:	aa e2       	ldi	r26, 0x2A	; 42
    75f6:	b0 e0       	ldi	r27, 0x00	; 0
    75f8:	ea e2       	ldi	r30, 0x2A	; 42
    75fa:	f0 e0       	ldi	r31, 0x00	; 0
    75fc:	80 81       	ld	r24, Z
    75fe:	8b 7f       	andi	r24, 0xFB	; 251
    7600:	8c 93       	st	X, r24
    SET_BIT(UCSRC_var,UCSZ1);
    7602:	8b 81       	ldd	r24, Y+3	; 0x03
    7604:	84 60       	ori	r24, 0x04	; 4
    7606:	8b 83       	std	Y+3, r24	; 0x03
    SET_BIT(UCSRC_var,UCSZ0);
    7608:	8b 81       	ldd	r24, Y+3	; 0x03
    760a:	82 60       	ori	r24, 0x02	; 2
    760c:	8b 83       	std	Y+3, r24	; 0x03
    SET_BIT(UCSRB,UCSZ2);
    SET_BIT(UCSRC_var,UCSZ1);
    SET_BIT(UCSRC_var,UCSZ0);
    #endif
    //Enabling Receiver
    SET_BIT(UCSRB,RXEN); 
    760e:	aa e2       	ldi	r26, 0x2A	; 42
    7610:	b0 e0       	ldi	r27, 0x00	; 0
    7612:	ea e2       	ldi	r30, 0x2A	; 42
    7614:	f0 e0       	ldi	r31, 0x00	; 0
    7616:	80 81       	ld	r24, Z
    7618:	80 61       	ori	r24, 0x10	; 16
    761a:	8c 93       	st	X, r24
    //Enabling Transmitter
    SET_BIT(UCSRB,TXEN); 
    761c:	aa e2       	ldi	r26, 0x2A	; 42
    761e:	b0 e0       	ldi	r27, 0x00	; 0
    7620:	ea e2       	ldi	r30, 0x2A	; 42
    7622:	f0 e0       	ldi	r31, 0x00	; 0
    7624:	80 81       	ld	r24, Z
    7626:	88 60       	ori	r24, 0x08	; 8
    7628:	8c 93       	st	X, r24

    
    #if USART_MODE == SYNCH_OPERATION
    SET_BIT(UCSRC_var,UMSEL);
    #else
    CLR_BIT(UCSRC_var,UMSEL);
    762a:	8b 81       	ldd	r24, Y+3	; 0x03
    762c:	8f 7b       	andi	r24, 0xBF	; 191
    762e:	8b 83       	std	Y+3, r24	; 0x03
    #endif



    #if PARITY_MODE == PARITY_DISABLED
    UCSRC_var&=~(0b11<<UPM0);
    7630:	8b 81       	ldd	r24, Y+3	; 0x03
    7632:	8f 7c       	andi	r24, 0xCF	; 207
    7634:	8b 83       	std	Y+3, r24	; 0x03
    UCSRC_var&=~(0b11<<UPM0);
    UCSRC_var|=(PARITY_EN_ODD<<UPM0);
    #endif

    #if STOP_BIT_SLECT == ONE_STOP_BIT
    CLR_BIT(UCSRC_var,USBS);
    7636:	8b 81       	ldd	r24, Y+3	; 0x03
    7638:	87 7f       	andi	r24, 0xF7	; 247
    763a:	8b 83       	std	Y+3, r24	; 0x03
    #else
    SET(UCSRC_var,USBS);
    #endif

    #if CLK_POLARITY == RISING_THEN_FALLING_UART
    CLR_BIT(UCSRC_var,UCPOL);
    763c:	8b 81       	ldd	r24, Y+3	; 0x03
    763e:	8e 7f       	andi	r24, 0xFE	; 254
    7640:	8b 83       	std	Y+3, r24	; 0x03
    #endif

    /*
        to set all bits once
    */
    UCSRC=UCSRC_var;
    7642:	e0 e4       	ldi	r30, 0x40	; 64
    7644:	f0 e0       	ldi	r31, 0x00	; 0
    7646:	8b 81       	ldd	r24, Y+3	; 0x03
    7648:	80 83       	st	Z, r24

}
    764a:	0f 90       	pop	r0
    764c:	0f 90       	pop	r0
    764e:	0f 90       	pop	r0
    7650:	cf 91       	pop	r28
    7652:	df 91       	pop	r29
    7654:	08 95       	ret

00007656 <MUSART_voidSendByteSynchNonBlocking>:

void MUSART_voidSendByteSynchNonBlocking(u8 A_u8Byte)
{
    7656:	df 93       	push	r29
    7658:	cf 93       	push	r28
    765a:	00 d0       	rcall	.+0      	; 0x765c <MUSART_voidSendByteSynchNonBlocking+0x6>
    765c:	0f 92       	push	r0
    765e:	cd b7       	in	r28, 0x3d	; 61
    7660:	de b7       	in	r29, 0x3e	; 62
    7662:	8b 83       	std	Y+3, r24	; 0x03
    u32 local_u32TimeOut=0;
    7664:	1a 82       	std	Y+2, r1	; 0x02
    7666:	19 82       	std	Y+1, r1	; 0x01
    7668:	05 c0       	rjmp	.+10     	; 0x7674 <MUSART_voidSendByteSynchNonBlocking+0x1e>
    while(GET_BIT(UCSRA,UDRE) == 0)
    {
        local_u32TimeOut++;
    766a:	89 81       	ldd	r24, Y+1	; 0x01
    766c:	9a 81       	ldd	r25, Y+2	; 0x02
    766e:	01 96       	adiw	r24, 0x01	; 1
    7670:	9a 83       	std	Y+2, r25	; 0x02
    7672:	89 83       	std	Y+1, r24	; 0x01
}

void MUSART_voidSendByteSynchNonBlocking(u8 A_u8Byte)
{
    u32 local_u32TimeOut=0;
    while(GET_BIT(UCSRA,UDRE) == 0)
    7674:	eb e2       	ldi	r30, 0x2B	; 43
    7676:	f0 e0       	ldi	r31, 0x00	; 0
    7678:	80 81       	ld	r24, Z
    767a:	88 2f       	mov	r24, r24
    767c:	90 e0       	ldi	r25, 0x00	; 0
    767e:	9c 01       	movw	r18, r24
    7680:	2f 7d       	andi	r18, 0xDF	; 223
    7682:	eb e2       	ldi	r30, 0x2B	; 43
    7684:	f0 e0       	ldi	r31, 0x00	; 0
    7686:	80 81       	ld	r24, Z
    7688:	88 2f       	mov	r24, r24
    768a:	90 e0       	ldi	r25, 0x00	; 0
    768c:	28 17       	cp	r18, r24
    768e:	39 07       	cpc	r19, r25
    7690:	61 f3       	breq	.-40     	; 0x766a <MUSART_voidSendByteSynchNonBlocking+0x14>
        if(local_u32TimeOut == TIME_OUT) break;
    }

    if(local_u32TimeOut  != TIME_OUT)
    {
        local_u32TimeOut=0;
    7692:	1a 82       	std	Y+2, r1	; 0x02
    7694:	19 82       	std	Y+1, r1	; 0x01
        UDR=A_u8Byte;
    7696:	ec e2       	ldi	r30, 0x2C	; 44
    7698:	f0 e0       	ldi	r31, 0x00	; 0
    769a:	8b 81       	ldd	r24, Y+3	; 0x03
    769c:	80 83       	st	Z, r24
    769e:	05 c0       	rjmp	.+10     	; 0x76aa <MUSART_voidSendByteSynchNonBlocking+0x54>
        while(GET_BIT(UCSRA,UDRE) == 0)
        {
            local_u32TimeOut++;
    76a0:	89 81       	ldd	r24, Y+1	; 0x01
    76a2:	9a 81       	ldd	r25, Y+2	; 0x02
    76a4:	01 96       	adiw	r24, 0x01	; 1
    76a6:	9a 83       	std	Y+2, r25	; 0x02
    76a8:	89 83       	std	Y+1, r24	; 0x01

    if(local_u32TimeOut  != TIME_OUT)
    {
        local_u32TimeOut=0;
        UDR=A_u8Byte;
        while(GET_BIT(UCSRA,UDRE) == 0)
    76aa:	eb e2       	ldi	r30, 0x2B	; 43
    76ac:	f0 e0       	ldi	r31, 0x00	; 0
    76ae:	80 81       	ld	r24, Z
    76b0:	88 2f       	mov	r24, r24
    76b2:	90 e0       	ldi	r25, 0x00	; 0
    76b4:	9c 01       	movw	r18, r24
    76b6:	2f 7d       	andi	r18, 0xDF	; 223
    76b8:	eb e2       	ldi	r30, 0x2B	; 43
    76ba:	f0 e0       	ldi	r31, 0x00	; 0
    76bc:	80 81       	ld	r24, Z
    76be:	88 2f       	mov	r24, r24
    76c0:	90 e0       	ldi	r25, 0x00	; 0
    76c2:	28 17       	cp	r18, r24
    76c4:	39 07       	cpc	r19, r25
    76c6:	61 f3       	breq	.-40     	; 0x76a0 <MUSART_voidSendByteSynchNonBlocking+0x4a>

    }

    //set the flag by one to be cleared
    //you can skip this step cause it's already cleared automatically
    SET_BIT(UCSRA,TXC);
    76c8:	ab e2       	ldi	r26, 0x2B	; 43
    76ca:	b0 e0       	ldi	r27, 0x00	; 0
    76cc:	eb e2       	ldi	r30, 0x2B	; 43
    76ce:	f0 e0       	ldi	r31, 0x00	; 0
    76d0:	80 81       	ld	r24, Z
    76d2:	80 64       	ori	r24, 0x40	; 64
    76d4:	8c 93       	st	X, r24

}
    76d6:	0f 90       	pop	r0
    76d8:	0f 90       	pop	r0
    76da:	0f 90       	pop	r0
    76dc:	cf 91       	pop	r28
    76de:	df 91       	pop	r29
    76e0:	08 95       	ret

000076e2 <MUSART_voidSendByteSynchBlocking>:

void MUSART_voidSendByteSynchBlocking(u8 A_u8Byte)
{
    76e2:	df 93       	push	r29
    76e4:	cf 93       	push	r28
    76e6:	0f 92       	push	r0
    76e8:	cd b7       	in	r28, 0x3d	; 61
    76ea:	de b7       	in	r29, 0x3e	; 62
    76ec:	89 83       	std	Y+1, r24	; 0x01
    while(GET_BIT(UCSRA,UDRE)==0);
    76ee:	eb e2       	ldi	r30, 0x2B	; 43
    76f0:	f0 e0       	ldi	r31, 0x00	; 0
    76f2:	80 81       	ld	r24, Z
    76f4:	88 2f       	mov	r24, r24
    76f6:	90 e0       	ldi	r25, 0x00	; 0
    76f8:	9c 01       	movw	r18, r24
    76fa:	2f 7d       	andi	r18, 0xDF	; 223
    76fc:	eb e2       	ldi	r30, 0x2B	; 43
    76fe:	f0 e0       	ldi	r31, 0x00	; 0
    7700:	80 81       	ld	r24, Z
    7702:	88 2f       	mov	r24, r24
    7704:	90 e0       	ldi	r25, 0x00	; 0
    7706:	28 17       	cp	r18, r24
    7708:	39 07       	cpc	r19, r25
    770a:	89 f3       	breq	.-30     	; 0x76ee <MUSART_voidSendByteSynchBlocking+0xc>
    UDR=A_u8Byte;
    770c:	ec e2       	ldi	r30, 0x2C	; 44
    770e:	f0 e0       	ldi	r31, 0x00	; 0
    7710:	89 81       	ldd	r24, Y+1	; 0x01
    7712:	80 83       	st	Z, r24
    
}
    7714:	0f 90       	pop	r0
    7716:	cf 91       	pop	r28
    7718:	df 91       	pop	r29
    771a:	08 95       	ret

0000771c <MUSART_voidSendByteAsynch>:

void MUSART_voidSendByteAsynch(u8 A_u8Byte)
{
    771c:	df 93       	push	r29
    771e:	cf 93       	push	r28
    7720:	0f 92       	push	r0
    7722:	cd b7       	in	r28, 0x3d	; 61
    7724:	de b7       	in	r29, 0x3e	; 62
    7726:	89 83       	std	Y+1, r24	; 0x01
    UDR=A_u8Byte;
    7728:	ec e2       	ldi	r30, 0x2C	; 44
    772a:	f0 e0       	ldi	r31, 0x00	; 0
    772c:	89 81       	ldd	r24, Y+1	; 0x01
    772e:	80 83       	st	Z, r24
}
    7730:	0f 90       	pop	r0
    7732:	cf 91       	pop	r28
    7734:	df 91       	pop	r29
    7736:	08 95       	ret

00007738 <MUSART_u8ReadByteSynchBlocking>:

u8 MUSART_u8ReadByteSynchBlocking(void)
{
    7738:	df 93       	push	r29
    773a:	cf 93       	push	r28
    773c:	cd b7       	in	r28, 0x3d	; 61
    773e:	de b7       	in	r29, 0x3e	; 62
    while (GET_BIT(UCSRA,RXC)==0);
    7740:	eb e2       	ldi	r30, 0x2B	; 43
    7742:	f0 e0       	ldi	r31, 0x00	; 0
    7744:	80 81       	ld	r24, Z
    7746:	88 2f       	mov	r24, r24
    7748:	90 e0       	ldi	r25, 0x00	; 0
    774a:	9c 01       	movw	r18, r24
    774c:	2f 77       	andi	r18, 0x7F	; 127
    774e:	eb e2       	ldi	r30, 0x2B	; 43
    7750:	f0 e0       	ldi	r31, 0x00	; 0
    7752:	80 81       	ld	r24, Z
    7754:	88 2f       	mov	r24, r24
    7756:	90 e0       	ldi	r25, 0x00	; 0
    7758:	28 17       	cp	r18, r24
    775a:	39 07       	cpc	r19, r25
    775c:	89 f3       	breq	.-30     	; 0x7740 <MUSART_u8ReadByteSynchBlocking+0x8>
    return UDR;
    775e:	ec e2       	ldi	r30, 0x2C	; 44
    7760:	f0 e0       	ldi	r31, 0x00	; 0
    7762:	80 81       	ld	r24, Z
}
    7764:	cf 91       	pop	r28
    7766:	df 91       	pop	r29
    7768:	08 95       	ret

0000776a <MUSART_u8ReadByteSynchNonBlocking>:
u8 MUSART_u8ReadByteSynchNonBlocking(void)
{
    776a:	df 93       	push	r29
    776c:	cf 93       	push	r28
    776e:	00 d0       	rcall	.+0      	; 0x7770 <MUSART_u8ReadByteSynchNonBlocking+0x6>
    7770:	cd b7       	in	r28, 0x3d	; 61
    7772:	de b7       	in	r29, 0x3e	; 62
    u32 local_u32TimeOut=0;
    7774:	1a 82       	std	Y+2, r1	; 0x02
    7776:	19 82       	std	Y+1, r1	; 0x01
    7778:	05 c0       	rjmp	.+10     	; 0x7784 <MUSART_u8ReadByteSynchNonBlocking+0x1a>
    while(GET_BIT(UCSRA,RXC)==0)
    {
        local_u32TimeOut++;
    777a:	89 81       	ldd	r24, Y+1	; 0x01
    777c:	9a 81       	ldd	r25, Y+2	; 0x02
    777e:	01 96       	adiw	r24, 0x01	; 1
    7780:	9a 83       	std	Y+2, r25	; 0x02
    7782:	89 83       	std	Y+1, r24	; 0x01
    return UDR;
}
u8 MUSART_u8ReadByteSynchNonBlocking(void)
{
    u32 local_u32TimeOut=0;
    while(GET_BIT(UCSRA,RXC)==0)
    7784:	eb e2       	ldi	r30, 0x2B	; 43
    7786:	f0 e0       	ldi	r31, 0x00	; 0
    7788:	80 81       	ld	r24, Z
    778a:	88 2f       	mov	r24, r24
    778c:	90 e0       	ldi	r25, 0x00	; 0
    778e:	9c 01       	movw	r18, r24
    7790:	2f 77       	andi	r18, 0x7F	; 127
    7792:	eb e2       	ldi	r30, 0x2B	; 43
    7794:	f0 e0       	ldi	r31, 0x00	; 0
    7796:	80 81       	ld	r24, Z
    7798:	88 2f       	mov	r24, r24
    779a:	90 e0       	ldi	r25, 0x00	; 0
    779c:	28 17       	cp	r18, r24
    779e:	39 07       	cpc	r19, r25
    77a0:	61 f3       	breq	.-40     	; 0x777a <MUSART_u8ReadByteSynchNonBlocking+0x10>
    {
        local_u32TimeOut++;
        if(local_u32TimeOut == TIME_OUT)break; 
    }
    if(local_u32TimeOut!=TIME_OUT)return UDR;
    77a2:	ec e2       	ldi	r30, 0x2C	; 44
    77a4:	f0 e0       	ldi	r31, 0x00	; 0
    77a6:	80 81       	ld	r24, Z
    return DUMMY_DATA;
}
    77a8:	0f 90       	pop	r0
    77aa:	0f 90       	pop	r0
    77ac:	cf 91       	pop	r28
    77ae:	df 91       	pop	r29
    77b0:	08 95       	ret

000077b2 <MUSART_u8ReadByteAsynch>:

u8 MUSART_u8ReadByteAsynch(void)
{
    77b2:	df 93       	push	r29
    77b4:	cf 93       	push	r28
    77b6:	cd b7       	in	r28, 0x3d	; 61
    77b8:	de b7       	in	r29, 0x3e	; 62
    return UDR;
    77ba:	ec e2       	ldi	r30, 0x2C	; 44
    77bc:	f0 e0       	ldi	r31, 0x00	; 0
    77be:	80 81       	ld	r24, Z
}
    77c0:	cf 91       	pop	r28
    77c2:	df 91       	pop	r29
    77c4:	08 95       	ret

000077c6 <MUSART_voidRXCompleteInterruptEnable>:


/*****************************************************************************/
                            /* Interrupt Section */
void MUSART_voidRXCompleteInterruptEnable(void)
{
    77c6:	df 93       	push	r29
    77c8:	cf 93       	push	r28
    77ca:	cd b7       	in	r28, 0x3d	; 61
    77cc:	de b7       	in	r29, 0x3e	; 62
    SET_BIT(UCSRB,RXCIE);
    77ce:	aa e2       	ldi	r26, 0x2A	; 42
    77d0:	b0 e0       	ldi	r27, 0x00	; 0
    77d2:	ea e2       	ldi	r30, 0x2A	; 42
    77d4:	f0 e0       	ldi	r31, 0x00	; 0
    77d6:	80 81       	ld	r24, Z
    77d8:	80 68       	ori	r24, 0x80	; 128
    77da:	8c 93       	st	X, r24
}
    77dc:	cf 91       	pop	r28
    77de:	df 91       	pop	r29
    77e0:	08 95       	ret

000077e2 <MUSART_voidRXCompleteInterruptDisable>:

void MUSART_voidRXCompleteInterruptDisable(void)
{
    77e2:	df 93       	push	r29
    77e4:	cf 93       	push	r28
    77e6:	cd b7       	in	r28, 0x3d	; 61
    77e8:	de b7       	in	r29, 0x3e	; 62
    CLR_BIT(UCSRB,RXCIE);
    77ea:	aa e2       	ldi	r26, 0x2A	; 42
    77ec:	b0 e0       	ldi	r27, 0x00	; 0
    77ee:	ea e2       	ldi	r30, 0x2A	; 42
    77f0:	f0 e0       	ldi	r31, 0x00	; 0
    77f2:	80 81       	ld	r24, Z
    77f4:	8f 77       	andi	r24, 0x7F	; 127
    77f6:	8c 93       	st	X, r24
}
    77f8:	cf 91       	pop	r28
    77fa:	df 91       	pop	r29
    77fc:	08 95       	ret

000077fe <MUSART_voidTXCompleteInterruptEnable>:

void MUSART_voidTXCompleteInterruptEnable(void)
{
    77fe:	df 93       	push	r29
    7800:	cf 93       	push	r28
    7802:	cd b7       	in	r28, 0x3d	; 61
    7804:	de b7       	in	r29, 0x3e	; 62
    SET_BIT(UCSRB,TXCIE);
    7806:	aa e2       	ldi	r26, 0x2A	; 42
    7808:	b0 e0       	ldi	r27, 0x00	; 0
    780a:	ea e2       	ldi	r30, 0x2A	; 42
    780c:	f0 e0       	ldi	r31, 0x00	; 0
    780e:	80 81       	ld	r24, Z
    7810:	80 64       	ori	r24, 0x40	; 64
    7812:	8c 93       	st	X, r24
}
    7814:	cf 91       	pop	r28
    7816:	df 91       	pop	r29
    7818:	08 95       	ret

0000781a <MUSART_voidTXCompleteInterruptDisable>:

void MUSART_voidTXCompleteInterruptDisable(void)
{
    781a:	df 93       	push	r29
    781c:	cf 93       	push	r28
    781e:	cd b7       	in	r28, 0x3d	; 61
    7820:	de b7       	in	r29, 0x3e	; 62
    CLR_BIT(UCSRB,TXCIE);
    7822:	aa e2       	ldi	r26, 0x2A	; 42
    7824:	b0 e0       	ldi	r27, 0x00	; 0
    7826:	ea e2       	ldi	r30, 0x2A	; 42
    7828:	f0 e0       	ldi	r31, 0x00	; 0
    782a:	80 81       	ld	r24, Z
    782c:	8f 7b       	andi	r24, 0xBF	; 191
    782e:	8c 93       	st	X, r24
}
    7830:	cf 91       	pop	r28
    7832:	df 91       	pop	r29
    7834:	08 95       	ret

00007836 <MUSART_voidUDRInterruptEnable>:

void MUSART_voidUDRInterruptEnable(void)
{
    7836:	df 93       	push	r29
    7838:	cf 93       	push	r28
    783a:	cd b7       	in	r28, 0x3d	; 61
    783c:	de b7       	in	r29, 0x3e	; 62
    SET_BIT(UCSRB,UDRIE);
    783e:	aa e2       	ldi	r26, 0x2A	; 42
    7840:	b0 e0       	ldi	r27, 0x00	; 0
    7842:	ea e2       	ldi	r30, 0x2A	; 42
    7844:	f0 e0       	ldi	r31, 0x00	; 0
    7846:	80 81       	ld	r24, Z
    7848:	80 62       	ori	r24, 0x20	; 32
    784a:	8c 93       	st	X, r24
}
    784c:	cf 91       	pop	r28
    784e:	df 91       	pop	r29
    7850:	08 95       	ret

00007852 <MUSART_voidUDRInterruptDisable>:

void MUSART_voidUDRInterruptDisable(void)
{
    7852:	df 93       	push	r29
    7854:	cf 93       	push	r28
    7856:	cd b7       	in	r28, 0x3d	; 61
    7858:	de b7       	in	r29, 0x3e	; 62
    CLR_BIT(UCSRB,UDRIE);
    785a:	aa e2       	ldi	r26, 0x2A	; 42
    785c:	b0 e0       	ldi	r27, 0x00	; 0
    785e:	ea e2       	ldi	r30, 0x2A	; 42
    7860:	f0 e0       	ldi	r31, 0x00	; 0
    7862:	80 81       	ld	r24, Z
    7864:	8f 7d       	andi	r24, 0xDF	; 223
    7866:	8c 93       	st	X, r24
}
    7868:	cf 91       	pop	r28
    786a:	df 91       	pop	r29
    786c:	08 95       	ret

0000786e <MUSART_voidSetCallRXC>:


/*****************************************************************************/
                            /* Callback Section */
void MUSART_voidSetCallRXC(void(*pf)(void))
{
    786e:	df 93       	push	r29
    7870:	cf 93       	push	r28
    7872:	00 d0       	rcall	.+0      	; 0x7874 <MUSART_voidSetCallRXC+0x6>
    7874:	cd b7       	in	r28, 0x3d	; 61
    7876:	de b7       	in	r29, 0x3e	; 62
    7878:	9a 83       	std	Y+2, r25	; 0x02
    787a:	89 83       	std	Y+1, r24	; 0x01
    USART_RXC_CALL=pf;
    787c:	89 81       	ldd	r24, Y+1	; 0x01
    787e:	9a 81       	ldd	r25, Y+2	; 0x02
    7880:	90 93 c6 01 	sts	0x01C6, r25
    7884:	80 93 c5 01 	sts	0x01C5, r24
}
    7888:	0f 90       	pop	r0
    788a:	0f 90       	pop	r0
    788c:	cf 91       	pop	r28
    788e:	df 91       	pop	r29
    7890:	08 95       	ret

00007892 <MUSART_voidSetCallUDRE>:

void MUSART_voidSetCallUDRE(void(*pf)(void))
{
    7892:	df 93       	push	r29
    7894:	cf 93       	push	r28
    7896:	00 d0       	rcall	.+0      	; 0x7898 <MUSART_voidSetCallUDRE+0x6>
    7898:	cd b7       	in	r28, 0x3d	; 61
    789a:	de b7       	in	r29, 0x3e	; 62
    789c:	9a 83       	std	Y+2, r25	; 0x02
    789e:	89 83       	std	Y+1, r24	; 0x01
    USART_UDRE_CALL=pf;
    78a0:	89 81       	ldd	r24, Y+1	; 0x01
    78a2:	9a 81       	ldd	r25, Y+2	; 0x02
    78a4:	90 93 c8 01 	sts	0x01C8, r25
    78a8:	80 93 c7 01 	sts	0x01C7, r24
}
    78ac:	0f 90       	pop	r0
    78ae:	0f 90       	pop	r0
    78b0:	cf 91       	pop	r28
    78b2:	df 91       	pop	r29
    78b4:	08 95       	ret

000078b6 <MUSART_voidSetCallTXC>:

void MUSART_voidSetCallTXC(void(*pf)(void))
{
    78b6:	df 93       	push	r29
    78b8:	cf 93       	push	r28
    78ba:	00 d0       	rcall	.+0      	; 0x78bc <MUSART_voidSetCallTXC+0x6>
    78bc:	cd b7       	in	r28, 0x3d	; 61
    78be:	de b7       	in	r29, 0x3e	; 62
    78c0:	9a 83       	std	Y+2, r25	; 0x02
    78c2:	89 83       	std	Y+1, r24	; 0x01
    USART_TXC_CALL=pf;
    78c4:	89 81       	ldd	r24, Y+1	; 0x01
    78c6:	9a 81       	ldd	r25, Y+2	; 0x02
    78c8:	90 93 ca 01 	sts	0x01CA, r25
    78cc:	80 93 c9 01 	sts	0x01C9, r24
}
    78d0:	0f 90       	pop	r0
    78d2:	0f 90       	pop	r0
    78d4:	cf 91       	pop	r28
    78d6:	df 91       	pop	r29
    78d8:	08 95       	ret

000078da <__vector_13>:
/*****************************************************************************/

ISR(USART_RXC_VECT)
{
    78da:	1f 92       	push	r1
    78dc:	0f 92       	push	r0
    78de:	0f b6       	in	r0, 0x3f	; 63
    78e0:	0f 92       	push	r0
    78e2:	11 24       	eor	r1, r1
    78e4:	2f 93       	push	r18
    78e6:	3f 93       	push	r19
    78e8:	4f 93       	push	r20
    78ea:	5f 93       	push	r21
    78ec:	6f 93       	push	r22
    78ee:	7f 93       	push	r23
    78f0:	8f 93       	push	r24
    78f2:	9f 93       	push	r25
    78f4:	af 93       	push	r26
    78f6:	bf 93       	push	r27
    78f8:	ef 93       	push	r30
    78fa:	ff 93       	push	r31
    78fc:	df 93       	push	r29
    78fe:	cf 93       	push	r28
    7900:	cd b7       	in	r28, 0x3d	; 61
    7902:	de b7       	in	r29, 0x3e	; 62
    if(USART_RXC_CALL != NULLPTR)USART_RXC_CALL();
    7904:	80 91 c5 01 	lds	r24, 0x01C5
    7908:	90 91 c6 01 	lds	r25, 0x01C6
    790c:	00 97       	sbiw	r24, 0x00	; 0
    790e:	29 f0       	breq	.+10     	; 0x791a <__vector_13+0x40>
    7910:	e0 91 c5 01 	lds	r30, 0x01C5
    7914:	f0 91 c6 01 	lds	r31, 0x01C6
    7918:	09 95       	icall
}
    791a:	cf 91       	pop	r28
    791c:	df 91       	pop	r29
    791e:	ff 91       	pop	r31
    7920:	ef 91       	pop	r30
    7922:	bf 91       	pop	r27
    7924:	af 91       	pop	r26
    7926:	9f 91       	pop	r25
    7928:	8f 91       	pop	r24
    792a:	7f 91       	pop	r23
    792c:	6f 91       	pop	r22
    792e:	5f 91       	pop	r21
    7930:	4f 91       	pop	r20
    7932:	3f 91       	pop	r19
    7934:	2f 91       	pop	r18
    7936:	0f 90       	pop	r0
    7938:	0f be       	out	0x3f, r0	; 63
    793a:	0f 90       	pop	r0
    793c:	1f 90       	pop	r1
    793e:	18 95       	reti

00007940 <__vector_14>:

ISR(USART_UDRE_VECT)
{
    7940:	1f 92       	push	r1
    7942:	0f 92       	push	r0
    7944:	0f b6       	in	r0, 0x3f	; 63
    7946:	0f 92       	push	r0
    7948:	11 24       	eor	r1, r1
    794a:	2f 93       	push	r18
    794c:	3f 93       	push	r19
    794e:	4f 93       	push	r20
    7950:	5f 93       	push	r21
    7952:	6f 93       	push	r22
    7954:	7f 93       	push	r23
    7956:	8f 93       	push	r24
    7958:	9f 93       	push	r25
    795a:	af 93       	push	r26
    795c:	bf 93       	push	r27
    795e:	ef 93       	push	r30
    7960:	ff 93       	push	r31
    7962:	df 93       	push	r29
    7964:	cf 93       	push	r28
    7966:	cd b7       	in	r28, 0x3d	; 61
    7968:	de b7       	in	r29, 0x3e	; 62
    if(USART_UDRE_CALL != NULLPTR)USART_UDRE_CALL();
    796a:	80 91 c7 01 	lds	r24, 0x01C7
    796e:	90 91 c8 01 	lds	r25, 0x01C8
    7972:	00 97       	sbiw	r24, 0x00	; 0
    7974:	29 f0       	breq	.+10     	; 0x7980 <__vector_14+0x40>
    7976:	e0 91 c7 01 	lds	r30, 0x01C7
    797a:	f0 91 c8 01 	lds	r31, 0x01C8
    797e:	09 95       	icall
}
    7980:	cf 91       	pop	r28
    7982:	df 91       	pop	r29
    7984:	ff 91       	pop	r31
    7986:	ef 91       	pop	r30
    7988:	bf 91       	pop	r27
    798a:	af 91       	pop	r26
    798c:	9f 91       	pop	r25
    798e:	8f 91       	pop	r24
    7990:	7f 91       	pop	r23
    7992:	6f 91       	pop	r22
    7994:	5f 91       	pop	r21
    7996:	4f 91       	pop	r20
    7998:	3f 91       	pop	r19
    799a:	2f 91       	pop	r18
    799c:	0f 90       	pop	r0
    799e:	0f be       	out	0x3f, r0	; 63
    79a0:	0f 90       	pop	r0
    79a2:	1f 90       	pop	r1
    79a4:	18 95       	reti

000079a6 <__vector_15>:

ISR(USART_TXC_VECT)
{
    79a6:	1f 92       	push	r1
    79a8:	0f 92       	push	r0
    79aa:	0f b6       	in	r0, 0x3f	; 63
    79ac:	0f 92       	push	r0
    79ae:	11 24       	eor	r1, r1
    79b0:	2f 93       	push	r18
    79b2:	3f 93       	push	r19
    79b4:	4f 93       	push	r20
    79b6:	5f 93       	push	r21
    79b8:	6f 93       	push	r22
    79ba:	7f 93       	push	r23
    79bc:	8f 93       	push	r24
    79be:	9f 93       	push	r25
    79c0:	af 93       	push	r26
    79c2:	bf 93       	push	r27
    79c4:	ef 93       	push	r30
    79c6:	ff 93       	push	r31
    79c8:	df 93       	push	r29
    79ca:	cf 93       	push	r28
    79cc:	cd b7       	in	r28, 0x3d	; 61
    79ce:	de b7       	in	r29, 0x3e	; 62
    if(USART_TXC_CALL != NULLPTR)USART_TXC_CALL();
    79d0:	80 91 c9 01 	lds	r24, 0x01C9
    79d4:	90 91 ca 01 	lds	r25, 0x01CA
    79d8:	00 97       	sbiw	r24, 0x00	; 0
    79da:	29 f0       	breq	.+10     	; 0x79e6 <__vector_15+0x40>
    79dc:	e0 91 c9 01 	lds	r30, 0x01C9
    79e0:	f0 91 ca 01 	lds	r31, 0x01CA
    79e4:	09 95       	icall
}
    79e6:	cf 91       	pop	r28
    79e8:	df 91       	pop	r29
    79ea:	ff 91       	pop	r31
    79ec:	ef 91       	pop	r30
    79ee:	bf 91       	pop	r27
    79f0:	af 91       	pop	r26
    79f2:	9f 91       	pop	r25
    79f4:	8f 91       	pop	r24
    79f6:	7f 91       	pop	r23
    79f8:	6f 91       	pop	r22
    79fa:	5f 91       	pop	r21
    79fc:	4f 91       	pop	r20
    79fe:	3f 91       	pop	r19
    7a00:	2f 91       	pop	r18
    7a02:	0f 90       	pop	r0
    7a04:	0f be       	out	0x3f, r0	; 63
    7a06:	0f 90       	pop	r0
    7a08:	1f 90       	pop	r1
    7a0a:	18 95       	reti

00007a0c <HULTRASONIC_voidInit>:
u8 global_u8Flag=0,noOVF=0;
u16 t1,t2;


void HULTRASONIC_voidInit(void)
{
    7a0c:	df 93       	push	r29
    7a0e:	cf 93       	push	r28
    7a10:	cd b7       	in	r28, 0x3d	; 61
    7a12:	de b7       	in	r29, 0x3e	; 62
    MTIMER1_voidInit(TIMER1_NORMAL_MODE,TIMER1_PRESCALER_8,TIMER1_COMPARE_OUTPUT_MODE_A_NORMAL,TIMER1_COMPARE_OUTPUT_MODE_B_NORMAL);
    7a14:	80 e0       	ldi	r24, 0x00	; 0
    7a16:	62 e0       	ldi	r22, 0x02	; 2
    7a18:	40 e0       	ldi	r20, 0x00	; 0
    7a1a:	20 e0       	ldi	r18, 0x00	; 0
    7a1c:	0e 94 ce 32 	call	0x659c	; 0x659c <MTIMER1_voidInit>
    MTIMER1_voidSetCallBackOVF(Func_OVF);
    7a20:	86 ea       	ldi	r24, 0xA6	; 166
    7a22:	9f e3       	ldi	r25, 0x3F	; 63
    7a24:	0e 94 ac 36 	call	0x6d58	; 0x6d58 <MTIMER1_voidSetCallBackOVF>
    MTIMER1_voidSetCallBackCapture(Func_ICU);
    7a28:	88 e7       	ldi	r24, 0x78	; 120
    7a2a:	9f e3       	ldi	r25, 0x3F	; 63
    7a2c:	0e 94 76 36 	call	0x6cec	; 0x6cec <MTIMER1_voidSetCallBackCapture>
}
    7a30:	cf 91       	pop	r28
    7a32:	df 91       	pop	r29
    7a34:	08 95       	ret

00007a36 <HULTRSONIC_u16GetDistance>:

u16 HULTRSONIC_u16GetDistance()
{
    7a36:	0f 93       	push	r16
    7a38:	1f 93       	push	r17
    7a3a:	df 93       	push	r29
    7a3c:	cf 93       	push	r28
    7a3e:	cd b7       	in	r28, 0x3d	; 61
    7a40:	de b7       	in	r29, 0x3e	; 62
    7a42:	6c 97       	sbiw	r28, 0x1c	; 28
    7a44:	0f b6       	in	r0, 0x3f	; 63
    7a46:	f8 94       	cli
    7a48:	de bf       	out	0x3e, r29	; 62
    7a4a:	0f be       	out	0x3f, r0	; 63
    7a4c:	cd bf       	out	0x3d, r28	; 61
    u16 time;
    /*
        this line not be valid if we use timer in another application
        but for simplicity we consider the timer register equal to zero
    */
    MTIMER1_voidSetTCNT1Value(0);
    7a4e:	80 e0       	ldi	r24, 0x00	; 0
    7a50:	90 e0       	ldi	r25, 0x00	; 0
    7a52:	0e 94 64 36 	call	0x6cc8	; 0x6cc8 <MTIMER1_voidSetTCNT1Value>
    //making number of overflow equal to zero to remove its time from calculation, cause
    //it happens before we gave trigger to ultrasonic
    noOVF=0;
    7a56:	10 92 cc 01 	sts	0x01CC, r1
    global_u8Flag=0;
    7a5a:	10 92 cb 01 	sts	0x01CB, r1
    MDIO_voidSetPinValue(ULTRSONIC_PORT,ULTRSONIC_PIN,PIN_HIGH);
    7a5e:	83 e0       	ldi	r24, 0x03	; 3
    7a60:	64 e0       	ldi	r22, 0x04	; 4
    7a62:	41 e0       	ldi	r20, 0x01	; 1
    7a64:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    7a68:	80 e0       	ldi	r24, 0x00	; 0
    7a6a:	90 e0       	ldi	r25, 0x00	; 0
    7a6c:	a0 e2       	ldi	r26, 0x20	; 32
    7a6e:	b1 e4       	ldi	r27, 0x41	; 65
    7a70:	8d 8b       	std	Y+21, r24	; 0x15
    7a72:	9e 8b       	std	Y+22, r25	; 0x16
    7a74:	af 8b       	std	Y+23, r26	; 0x17
    7a76:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    7a78:	6d 89       	ldd	r22, Y+21	; 0x15
    7a7a:	7e 89       	ldd	r23, Y+22	; 0x16
    7a7c:	8f 89       	ldd	r24, Y+23	; 0x17
    7a7e:	98 8d       	ldd	r25, Y+24	; 0x18
    7a80:	2b ea       	ldi	r18, 0xAB	; 171
    7a82:	3a ea       	ldi	r19, 0xAA	; 170
    7a84:	4a e2       	ldi	r20, 0x2A	; 42
    7a86:	50 e4       	ldi	r21, 0x40	; 64
    7a88:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    7a8c:	dc 01       	movw	r26, r24
    7a8e:	cb 01       	movw	r24, r22
    7a90:	89 8b       	std	Y+17, r24	; 0x11
    7a92:	9a 8b       	std	Y+18, r25	; 0x12
    7a94:	ab 8b       	std	Y+19, r26	; 0x13
    7a96:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    7a98:	69 89       	ldd	r22, Y+17	; 0x11
    7a9a:	7a 89       	ldd	r23, Y+18	; 0x12
    7a9c:	8b 89       	ldd	r24, Y+19	; 0x13
    7a9e:	9c 89       	ldd	r25, Y+20	; 0x14
    7aa0:	20 e0       	ldi	r18, 0x00	; 0
    7aa2:	30 e0       	ldi	r19, 0x00	; 0
    7aa4:	40 e8       	ldi	r20, 0x80	; 128
    7aa6:	5f e3       	ldi	r21, 0x3F	; 63
    7aa8:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    7aac:	88 23       	and	r24, r24
    7aae:	1c f4       	brge	.+6      	; 0x7ab6 <HULTRSONIC_u16GetDistance+0x80>
		__ticks = 1;
    7ab0:	81 e0       	ldi	r24, 0x01	; 1
    7ab2:	88 8b       	std	Y+16, r24	; 0x10
    7ab4:	91 c0       	rjmp	.+290    	; 0x7bd8 <HULTRSONIC_u16GetDistance+0x1a2>
	else if (__tmp > 255)
    7ab6:	69 89       	ldd	r22, Y+17	; 0x11
    7ab8:	7a 89       	ldd	r23, Y+18	; 0x12
    7aba:	8b 89       	ldd	r24, Y+19	; 0x13
    7abc:	9c 89       	ldd	r25, Y+20	; 0x14
    7abe:	20 e0       	ldi	r18, 0x00	; 0
    7ac0:	30 e0       	ldi	r19, 0x00	; 0
    7ac2:	4f e7       	ldi	r20, 0x7F	; 127
    7ac4:	53 e4       	ldi	r21, 0x43	; 67
    7ac6:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    7aca:	18 16       	cp	r1, r24
    7acc:	0c f0       	brlt	.+2      	; 0x7ad0 <HULTRSONIC_u16GetDistance+0x9a>
    7ace:	7b c0       	rjmp	.+246    	; 0x7bc6 <HULTRSONIC_u16GetDistance+0x190>
	{
		_delay_ms(__us / 1000.0);
    7ad0:	6d 89       	ldd	r22, Y+21	; 0x15
    7ad2:	7e 89       	ldd	r23, Y+22	; 0x16
    7ad4:	8f 89       	ldd	r24, Y+23	; 0x17
    7ad6:	98 8d       	ldd	r25, Y+24	; 0x18
    7ad8:	20 e0       	ldi	r18, 0x00	; 0
    7ada:	30 e0       	ldi	r19, 0x00	; 0
    7adc:	4a e7       	ldi	r20, 0x7A	; 122
    7ade:	54 e4       	ldi	r21, 0x44	; 68
    7ae0:	0e 94 0d 0a 	call	0x141a	; 0x141a <__divsf3>
    7ae4:	dc 01       	movw	r26, r24
    7ae6:	cb 01       	movw	r24, r22
    7ae8:	8c 87       	std	Y+12, r24	; 0x0c
    7aea:	9d 87       	std	Y+13, r25	; 0x0d
    7aec:	ae 87       	std	Y+14, r26	; 0x0e
    7aee:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7af0:	6c 85       	ldd	r22, Y+12	; 0x0c
    7af2:	7d 85       	ldd	r23, Y+13	; 0x0d
    7af4:	8e 85       	ldd	r24, Y+14	; 0x0e
    7af6:	9f 85       	ldd	r25, Y+15	; 0x0f
    7af8:	20 e0       	ldi	r18, 0x00	; 0
    7afa:	30 e0       	ldi	r19, 0x00	; 0
    7afc:	4a ef       	ldi	r20, 0xFA	; 250
    7afe:	54 e4       	ldi	r21, 0x44	; 68
    7b00:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    7b04:	dc 01       	movw	r26, r24
    7b06:	cb 01       	movw	r24, r22
    7b08:	88 87       	std	Y+8, r24	; 0x08
    7b0a:	99 87       	std	Y+9, r25	; 0x09
    7b0c:	aa 87       	std	Y+10, r26	; 0x0a
    7b0e:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    7b10:	68 85       	ldd	r22, Y+8	; 0x08
    7b12:	79 85       	ldd	r23, Y+9	; 0x09
    7b14:	8a 85       	ldd	r24, Y+10	; 0x0a
    7b16:	9b 85       	ldd	r25, Y+11	; 0x0b
    7b18:	20 e0       	ldi	r18, 0x00	; 0
    7b1a:	30 e0       	ldi	r19, 0x00	; 0
    7b1c:	40 e8       	ldi	r20, 0x80	; 128
    7b1e:	5f e3       	ldi	r21, 0x3F	; 63
    7b20:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    7b24:	88 23       	and	r24, r24
    7b26:	2c f4       	brge	.+10     	; 0x7b32 <HULTRSONIC_u16GetDistance+0xfc>
		__ticks = 1;
    7b28:	81 e0       	ldi	r24, 0x01	; 1
    7b2a:	90 e0       	ldi	r25, 0x00	; 0
    7b2c:	9f 83       	std	Y+7, r25	; 0x07
    7b2e:	8e 83       	std	Y+6, r24	; 0x06
    7b30:	3f c0       	rjmp	.+126    	; 0x7bb0 <HULTRSONIC_u16GetDistance+0x17a>
	else if (__tmp > 65535)
    7b32:	68 85       	ldd	r22, Y+8	; 0x08
    7b34:	79 85       	ldd	r23, Y+9	; 0x09
    7b36:	8a 85       	ldd	r24, Y+10	; 0x0a
    7b38:	9b 85       	ldd	r25, Y+11	; 0x0b
    7b3a:	20 e0       	ldi	r18, 0x00	; 0
    7b3c:	3f ef       	ldi	r19, 0xFF	; 255
    7b3e:	4f e7       	ldi	r20, 0x7F	; 127
    7b40:	57 e4       	ldi	r21, 0x47	; 71
    7b42:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    7b46:	18 16       	cp	r1, r24
    7b48:	4c f5       	brge	.+82     	; 0x7b9c <HULTRSONIC_u16GetDistance+0x166>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7b4a:	6c 85       	ldd	r22, Y+12	; 0x0c
    7b4c:	7d 85       	ldd	r23, Y+13	; 0x0d
    7b4e:	8e 85       	ldd	r24, Y+14	; 0x0e
    7b50:	9f 85       	ldd	r25, Y+15	; 0x0f
    7b52:	20 e0       	ldi	r18, 0x00	; 0
    7b54:	30 e0       	ldi	r19, 0x00	; 0
    7b56:	40 e2       	ldi	r20, 0x20	; 32
    7b58:	51 e4       	ldi	r21, 0x41	; 65
    7b5a:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    7b5e:	dc 01       	movw	r26, r24
    7b60:	cb 01       	movw	r24, r22
    7b62:	bc 01       	movw	r22, r24
    7b64:	cd 01       	movw	r24, r26
    7b66:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    7b6a:	dc 01       	movw	r26, r24
    7b6c:	cb 01       	movw	r24, r22
    7b6e:	9f 83       	std	Y+7, r25	; 0x07
    7b70:	8e 83       	std	Y+6, r24	; 0x06
    7b72:	0f c0       	rjmp	.+30     	; 0x7b92 <HULTRSONIC_u16GetDistance+0x15c>
    7b74:	88 ec       	ldi	r24, 0xC8	; 200
    7b76:	90 e0       	ldi	r25, 0x00	; 0
    7b78:	9d 83       	std	Y+5, r25	; 0x05
    7b7a:	8c 83       	std	Y+4, r24	; 0x04
    7b7c:	8c 81       	ldd	r24, Y+4	; 0x04
    7b7e:	9d 81       	ldd	r25, Y+5	; 0x05
    7b80:	01 97       	sbiw	r24, 0x01	; 1
    7b82:	f1 f7       	brne	.-4      	; 0x7b80 <HULTRSONIC_u16GetDistance+0x14a>
    7b84:	9d 83       	std	Y+5, r25	; 0x05
    7b86:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7b88:	8e 81       	ldd	r24, Y+6	; 0x06
    7b8a:	9f 81       	ldd	r25, Y+7	; 0x07
    7b8c:	01 97       	sbiw	r24, 0x01	; 1
    7b8e:	9f 83       	std	Y+7, r25	; 0x07
    7b90:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7b92:	8e 81       	ldd	r24, Y+6	; 0x06
    7b94:	9f 81       	ldd	r25, Y+7	; 0x07
    7b96:	00 97       	sbiw	r24, 0x00	; 0
    7b98:	69 f7       	brne	.-38     	; 0x7b74 <HULTRSONIC_u16GetDistance+0x13e>
    7b9a:	24 c0       	rjmp	.+72     	; 0x7be4 <HULTRSONIC_u16GetDistance+0x1ae>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7b9c:	68 85       	ldd	r22, Y+8	; 0x08
    7b9e:	79 85       	ldd	r23, Y+9	; 0x09
    7ba0:	8a 85       	ldd	r24, Y+10	; 0x0a
    7ba2:	9b 85       	ldd	r25, Y+11	; 0x0b
    7ba4:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    7ba8:	dc 01       	movw	r26, r24
    7baa:	cb 01       	movw	r24, r22
    7bac:	9f 83       	std	Y+7, r25	; 0x07
    7bae:	8e 83       	std	Y+6, r24	; 0x06
    7bb0:	8e 81       	ldd	r24, Y+6	; 0x06
    7bb2:	9f 81       	ldd	r25, Y+7	; 0x07
    7bb4:	9b 83       	std	Y+3, r25	; 0x03
    7bb6:	8a 83       	std	Y+2, r24	; 0x02
    7bb8:	8a 81       	ldd	r24, Y+2	; 0x02
    7bba:	9b 81       	ldd	r25, Y+3	; 0x03
    7bbc:	01 97       	sbiw	r24, 0x01	; 1
    7bbe:	f1 f7       	brne	.-4      	; 0x7bbc <HULTRSONIC_u16GetDistance+0x186>
    7bc0:	9b 83       	std	Y+3, r25	; 0x03
    7bc2:	8a 83       	std	Y+2, r24	; 0x02
    7bc4:	0f c0       	rjmp	.+30     	; 0x7be4 <HULTRSONIC_u16GetDistance+0x1ae>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7bc6:	69 89       	ldd	r22, Y+17	; 0x11
    7bc8:	7a 89       	ldd	r23, Y+18	; 0x12
    7bca:	8b 89       	ldd	r24, Y+19	; 0x13
    7bcc:	9c 89       	ldd	r25, Y+20	; 0x14
    7bce:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    7bd2:	dc 01       	movw	r26, r24
    7bd4:	cb 01       	movw	r24, r22
    7bd6:	88 8b       	std	Y+16, r24	; 0x10
    7bd8:	88 89       	ldd	r24, Y+16	; 0x10
    7bda:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7bdc:	89 81       	ldd	r24, Y+1	; 0x01
    7bde:	8a 95       	dec	r24
    7be0:	f1 f7       	brne	.-4      	; 0x7bde <HULTRSONIC_u16GetDistance+0x1a8>
    7be2:	89 83       	std	Y+1, r24	; 0x01
    _delay_us(10);
    MDIO_voidSetPinValue(ULTRSONIC_PORT,ULTRSONIC_PIN,PIN_LOW);
    7be4:	83 e0       	ldi	r24, 0x03	; 3
    7be6:	64 e0       	ldi	r22, 0x04	; 4
    7be8:	40 e0       	ldi	r20, 0x00	; 0
    7bea:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    MTIMER1_voidInputCaptureEdge(RISING);
    7bee:	80 e0       	ldi	r24, 0x00	; 0
    7bf0:	0e 94 25 35 	call	0x6a4a	; 0x6a4a <MTIMER1_voidInputCaptureEdge>
    MTIMER1_voidCaptureInterruptEnable();
    7bf4:	0e 94 be 35 	call	0x6b7c	; 0x6b7c <MTIMER1_voidCaptureInterruptEnable>
    while(global_u8Flag<2);
    7bf8:	80 91 cb 01 	lds	r24, 0x01CB
    7bfc:	82 30       	cpi	r24, 0x02	; 2
    7bfe:	e0 f3       	brcs	.-8      	; 0x7bf8 <HULTRSONIC_u16GetDistance+0x1c2>
    time =t2-t1+((u32)noOVF*65535);
    7c00:	20 91 e4 01 	lds	r18, 0x01E4
    7c04:	30 91 e5 01 	lds	r19, 0x01E5
    7c08:	80 91 e6 01 	lds	r24, 0x01E6
    7c0c:	90 91 e7 01 	lds	r25, 0x01E7
    7c10:	89 01       	movw	r16, r18
    7c12:	08 1b       	sub	r16, r24
    7c14:	19 0b       	sbc	r17, r25
    7c16:	80 91 cc 01 	lds	r24, 0x01CC
    7c1a:	88 2f       	mov	r24, r24
    7c1c:	90 e0       	ldi	r25, 0x00	; 0
    7c1e:	a0 e0       	ldi	r26, 0x00	; 0
    7c20:	b0 e0       	ldi	r27, 0x00	; 0
    7c22:	2f ef       	ldi	r18, 0xFF	; 255
    7c24:	3f ef       	ldi	r19, 0xFF	; 255
    7c26:	40 e0       	ldi	r20, 0x00	; 0
    7c28:	50 e0       	ldi	r21, 0x00	; 0
    7c2a:	bc 01       	movw	r22, r24
    7c2c:	cd 01       	movw	r24, r26
    7c2e:	0e 94 95 42 	call	0x852a	; 0x852a <__mulsi3>
    7c32:	dc 01       	movw	r26, r24
    7c34:	cb 01       	movw	r24, r22
    7c36:	80 0f       	add	r24, r16
    7c38:	91 1f       	adc	r25, r17
    7c3a:	9a 8f       	std	Y+26, r25	; 0x1a
    7c3c:	89 8f       	std	Y+25, r24	; 0x19
    distance=time/58;
    7c3e:	89 8d       	ldd	r24, Y+25	; 0x19
    7c40:	9a 8d       	ldd	r25, Y+26	; 0x1a
    7c42:	2a e3       	ldi	r18, 0x3A	; 58
    7c44:	30 e0       	ldi	r19, 0x00	; 0
    7c46:	b9 01       	movw	r22, r18
    7c48:	0e 94 b4 42 	call	0x8568	; 0x8568 <__udivmodhi4>
    7c4c:	cb 01       	movw	r24, r22
    7c4e:	9c 8f       	std	Y+28, r25	; 0x1c
    7c50:	8b 8f       	std	Y+27, r24	; 0x1b
    MTIMER1_voidCaptureInterruptDisable();
    7c52:	0e 94 cc 35 	call	0x6b98	; 0x6b98 <MTIMER1_voidCaptureInterruptDisable>
    return distance;
    7c56:	8b 8d       	ldd	r24, Y+27	; 0x1b
    7c58:	9c 8d       	ldd	r25, Y+28	; 0x1c
}
    7c5a:	6c 96       	adiw	r28, 0x1c	; 28
    7c5c:	0f b6       	in	r0, 0x3f	; 63
    7c5e:	f8 94       	cli
    7c60:	de bf       	out	0x3e, r29	; 62
    7c62:	0f be       	out	0x3f, r0	; 63
    7c64:	cd bf       	out	0x3d, r28	; 61
    7c66:	cf 91       	pop	r28
    7c68:	df 91       	pop	r29
    7c6a:	1f 91       	pop	r17
    7c6c:	0f 91       	pop	r16
    7c6e:	08 95       	ret

00007c70 <HULTRASONIC_voidStart>:
    the following method is called periodic check 
    it will not be polling on the flag waiting for ultrasonic to finish measurement, No it will 
    just give the trigger to ultrasonic and get distance at any time
*/
void HULTRASONIC_voidStart()
{
    7c70:	df 93       	push	r29
    7c72:	cf 93       	push	r28
    7c74:	cd b7       	in	r28, 0x3d	; 61
    7c76:	de b7       	in	r29, 0x3e	; 62
    7c78:	68 97       	sbiw	r28, 0x18	; 24
    7c7a:	0f b6       	in	r0, 0x3f	; 63
    7c7c:	f8 94       	cli
    7c7e:	de bf       	out	0x3e, r29	; 62
    7c80:	0f be       	out	0x3f, r0	; 63
    7c82:	cd bf       	out	0x3d, r28	; 61
    if(global_u8Flag==0)
    7c84:	80 91 cb 01 	lds	r24, 0x01CB
    7c88:	88 23       	and	r24, r24
    7c8a:	09 f0       	breq	.+2      	; 0x7c8e <HULTRASONIC_voidStart+0x1e>
    7c8c:	cf c0       	rjmp	.+414    	; 0x7e2c <HULTRASONIC_voidStart+0x1bc>
    {
        MDIO_voidSetPinValue(ULTRSONIC_PORT,ULTRSONIC_PIN,PIN_HIGH);
    7c8e:	83 e0       	ldi	r24, 0x03	; 3
    7c90:	64 e0       	ldi	r22, 0x04	; 4
    7c92:	41 e0       	ldi	r20, 0x01	; 1
    7c94:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
    7c98:	80 e0       	ldi	r24, 0x00	; 0
    7c9a:	90 e0       	ldi	r25, 0x00	; 0
    7c9c:	a0 e2       	ldi	r26, 0x20	; 32
    7c9e:	b1 e4       	ldi	r27, 0x41	; 65
    7ca0:	8d 8b       	std	Y+21, r24	; 0x15
    7ca2:	9e 8b       	std	Y+22, r25	; 0x16
    7ca4:	af 8b       	std	Y+23, r26	; 0x17
    7ca6:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    7ca8:	6d 89       	ldd	r22, Y+21	; 0x15
    7caa:	7e 89       	ldd	r23, Y+22	; 0x16
    7cac:	8f 89       	ldd	r24, Y+23	; 0x17
    7cae:	98 8d       	ldd	r25, Y+24	; 0x18
    7cb0:	2b ea       	ldi	r18, 0xAB	; 171
    7cb2:	3a ea       	ldi	r19, 0xAA	; 170
    7cb4:	4a e2       	ldi	r20, 0x2A	; 42
    7cb6:	50 e4       	ldi	r21, 0x40	; 64
    7cb8:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    7cbc:	dc 01       	movw	r26, r24
    7cbe:	cb 01       	movw	r24, r22
    7cc0:	89 8b       	std	Y+17, r24	; 0x11
    7cc2:	9a 8b       	std	Y+18, r25	; 0x12
    7cc4:	ab 8b       	std	Y+19, r26	; 0x13
    7cc6:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    7cc8:	69 89       	ldd	r22, Y+17	; 0x11
    7cca:	7a 89       	ldd	r23, Y+18	; 0x12
    7ccc:	8b 89       	ldd	r24, Y+19	; 0x13
    7cce:	9c 89       	ldd	r25, Y+20	; 0x14
    7cd0:	20 e0       	ldi	r18, 0x00	; 0
    7cd2:	30 e0       	ldi	r19, 0x00	; 0
    7cd4:	40 e8       	ldi	r20, 0x80	; 128
    7cd6:	5f e3       	ldi	r21, 0x3F	; 63
    7cd8:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    7cdc:	88 23       	and	r24, r24
    7cde:	1c f4       	brge	.+6      	; 0x7ce6 <HULTRASONIC_voidStart+0x76>
		__ticks = 1;
    7ce0:	81 e0       	ldi	r24, 0x01	; 1
    7ce2:	88 8b       	std	Y+16, r24	; 0x10
    7ce4:	91 c0       	rjmp	.+290    	; 0x7e08 <HULTRASONIC_voidStart+0x198>
	else if (__tmp > 255)
    7ce6:	69 89       	ldd	r22, Y+17	; 0x11
    7ce8:	7a 89       	ldd	r23, Y+18	; 0x12
    7cea:	8b 89       	ldd	r24, Y+19	; 0x13
    7cec:	9c 89       	ldd	r25, Y+20	; 0x14
    7cee:	20 e0       	ldi	r18, 0x00	; 0
    7cf0:	30 e0       	ldi	r19, 0x00	; 0
    7cf2:	4f e7       	ldi	r20, 0x7F	; 127
    7cf4:	53 e4       	ldi	r21, 0x43	; 67
    7cf6:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    7cfa:	18 16       	cp	r1, r24
    7cfc:	0c f0       	brlt	.+2      	; 0x7d00 <HULTRASONIC_voidStart+0x90>
    7cfe:	7b c0       	rjmp	.+246    	; 0x7df6 <HULTRASONIC_voidStart+0x186>
	{
		_delay_ms(__us / 1000.0);
    7d00:	6d 89       	ldd	r22, Y+21	; 0x15
    7d02:	7e 89       	ldd	r23, Y+22	; 0x16
    7d04:	8f 89       	ldd	r24, Y+23	; 0x17
    7d06:	98 8d       	ldd	r25, Y+24	; 0x18
    7d08:	20 e0       	ldi	r18, 0x00	; 0
    7d0a:	30 e0       	ldi	r19, 0x00	; 0
    7d0c:	4a e7       	ldi	r20, 0x7A	; 122
    7d0e:	54 e4       	ldi	r21, 0x44	; 68
    7d10:	0e 94 0d 0a 	call	0x141a	; 0x141a <__divsf3>
    7d14:	dc 01       	movw	r26, r24
    7d16:	cb 01       	movw	r24, r22
    7d18:	8c 87       	std	Y+12, r24	; 0x0c
    7d1a:	9d 87       	std	Y+13, r25	; 0x0d
    7d1c:	ae 87       	std	Y+14, r26	; 0x0e
    7d1e:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7d20:	6c 85       	ldd	r22, Y+12	; 0x0c
    7d22:	7d 85       	ldd	r23, Y+13	; 0x0d
    7d24:	8e 85       	ldd	r24, Y+14	; 0x0e
    7d26:	9f 85       	ldd	r25, Y+15	; 0x0f
    7d28:	20 e0       	ldi	r18, 0x00	; 0
    7d2a:	30 e0       	ldi	r19, 0x00	; 0
    7d2c:	4a ef       	ldi	r20, 0xFA	; 250
    7d2e:	54 e4       	ldi	r21, 0x44	; 68
    7d30:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    7d34:	dc 01       	movw	r26, r24
    7d36:	cb 01       	movw	r24, r22
    7d38:	88 87       	std	Y+8, r24	; 0x08
    7d3a:	99 87       	std	Y+9, r25	; 0x09
    7d3c:	aa 87       	std	Y+10, r26	; 0x0a
    7d3e:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    7d40:	68 85       	ldd	r22, Y+8	; 0x08
    7d42:	79 85       	ldd	r23, Y+9	; 0x09
    7d44:	8a 85       	ldd	r24, Y+10	; 0x0a
    7d46:	9b 85       	ldd	r25, Y+11	; 0x0b
    7d48:	20 e0       	ldi	r18, 0x00	; 0
    7d4a:	30 e0       	ldi	r19, 0x00	; 0
    7d4c:	40 e8       	ldi	r20, 0x80	; 128
    7d4e:	5f e3       	ldi	r21, 0x3F	; 63
    7d50:	0e 94 19 0b 	call	0x1632	; 0x1632 <__ltsf2>
    7d54:	88 23       	and	r24, r24
    7d56:	2c f4       	brge	.+10     	; 0x7d62 <HULTRASONIC_voidStart+0xf2>
		__ticks = 1;
    7d58:	81 e0       	ldi	r24, 0x01	; 1
    7d5a:	90 e0       	ldi	r25, 0x00	; 0
    7d5c:	9f 83       	std	Y+7, r25	; 0x07
    7d5e:	8e 83       	std	Y+6, r24	; 0x06
    7d60:	3f c0       	rjmp	.+126    	; 0x7de0 <HULTRASONIC_voidStart+0x170>
	else if (__tmp > 65535)
    7d62:	68 85       	ldd	r22, Y+8	; 0x08
    7d64:	79 85       	ldd	r23, Y+9	; 0x09
    7d66:	8a 85       	ldd	r24, Y+10	; 0x0a
    7d68:	9b 85       	ldd	r25, Y+11	; 0x0b
    7d6a:	20 e0       	ldi	r18, 0x00	; 0
    7d6c:	3f ef       	ldi	r19, 0xFF	; 255
    7d6e:	4f e7       	ldi	r20, 0x7F	; 127
    7d70:	57 e4       	ldi	r21, 0x47	; 71
    7d72:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__gtsf2>
    7d76:	18 16       	cp	r1, r24
    7d78:	4c f5       	brge	.+82     	; 0x7dcc <HULTRASONIC_voidStart+0x15c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7d7a:	6c 85       	ldd	r22, Y+12	; 0x0c
    7d7c:	7d 85       	ldd	r23, Y+13	; 0x0d
    7d7e:	8e 85       	ldd	r24, Y+14	; 0x0e
    7d80:	9f 85       	ldd	r25, Y+15	; 0x0f
    7d82:	20 e0       	ldi	r18, 0x00	; 0
    7d84:	30 e0       	ldi	r19, 0x00	; 0
    7d86:	40 e2       	ldi	r20, 0x20	; 32
    7d88:	51 e4       	ldi	r21, 0x41	; 65
    7d8a:	0e 94 13 09 	call	0x1226	; 0x1226 <__mulsf3>
    7d8e:	dc 01       	movw	r26, r24
    7d90:	cb 01       	movw	r24, r22
    7d92:	bc 01       	movw	r22, r24
    7d94:	cd 01       	movw	r24, r26
    7d96:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    7d9a:	dc 01       	movw	r26, r24
    7d9c:	cb 01       	movw	r24, r22
    7d9e:	9f 83       	std	Y+7, r25	; 0x07
    7da0:	8e 83       	std	Y+6, r24	; 0x06
    7da2:	0f c0       	rjmp	.+30     	; 0x7dc2 <HULTRASONIC_voidStart+0x152>
    7da4:	88 ec       	ldi	r24, 0xC8	; 200
    7da6:	90 e0       	ldi	r25, 0x00	; 0
    7da8:	9d 83       	std	Y+5, r25	; 0x05
    7daa:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7dac:	8c 81       	ldd	r24, Y+4	; 0x04
    7dae:	9d 81       	ldd	r25, Y+5	; 0x05
    7db0:	01 97       	sbiw	r24, 0x01	; 1
    7db2:	f1 f7       	brne	.-4      	; 0x7db0 <HULTRASONIC_voidStart+0x140>
    7db4:	9d 83       	std	Y+5, r25	; 0x05
    7db6:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7db8:	8e 81       	ldd	r24, Y+6	; 0x06
    7dba:	9f 81       	ldd	r25, Y+7	; 0x07
    7dbc:	01 97       	sbiw	r24, 0x01	; 1
    7dbe:	9f 83       	std	Y+7, r25	; 0x07
    7dc0:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7dc2:	8e 81       	ldd	r24, Y+6	; 0x06
    7dc4:	9f 81       	ldd	r25, Y+7	; 0x07
    7dc6:	00 97       	sbiw	r24, 0x00	; 0
    7dc8:	69 f7       	brne	.-38     	; 0x7da4 <HULTRASONIC_voidStart+0x134>
    7dca:	24 c0       	rjmp	.+72     	; 0x7e14 <HULTRASONIC_voidStart+0x1a4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7dcc:	68 85       	ldd	r22, Y+8	; 0x08
    7dce:	79 85       	ldd	r23, Y+9	; 0x09
    7dd0:	8a 85       	ldd	r24, Y+10	; 0x0a
    7dd2:	9b 85       	ldd	r25, Y+11	; 0x0b
    7dd4:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    7dd8:	dc 01       	movw	r26, r24
    7dda:	cb 01       	movw	r24, r22
    7ddc:	9f 83       	std	Y+7, r25	; 0x07
    7dde:	8e 83       	std	Y+6, r24	; 0x06
    7de0:	8e 81       	ldd	r24, Y+6	; 0x06
    7de2:	9f 81       	ldd	r25, Y+7	; 0x07
    7de4:	9b 83       	std	Y+3, r25	; 0x03
    7de6:	8a 83       	std	Y+2, r24	; 0x02
    7de8:	8a 81       	ldd	r24, Y+2	; 0x02
    7dea:	9b 81       	ldd	r25, Y+3	; 0x03
    7dec:	01 97       	sbiw	r24, 0x01	; 1
    7dee:	f1 f7       	brne	.-4      	; 0x7dec <HULTRASONIC_voidStart+0x17c>
    7df0:	9b 83       	std	Y+3, r25	; 0x03
    7df2:	8a 83       	std	Y+2, r24	; 0x02
    7df4:	0f c0       	rjmp	.+30     	; 0x7e14 <HULTRASONIC_voidStart+0x1a4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7df6:	69 89       	ldd	r22, Y+17	; 0x11
    7df8:	7a 89       	ldd	r23, Y+18	; 0x12
    7dfa:	8b 89       	ldd	r24, Y+19	; 0x13
    7dfc:	9c 89       	ldd	r25, Y+20	; 0x14
    7dfe:	0e 94 c8 00 	call	0x190	; 0x190 <__fixunssfsi>
    7e02:	dc 01       	movw	r26, r24
    7e04:	cb 01       	movw	r24, r22
    7e06:	88 8b       	std	Y+16, r24	; 0x10
    7e08:	88 89       	ldd	r24, Y+16	; 0x10
    7e0a:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7e0c:	89 81       	ldd	r24, Y+1	; 0x01
    7e0e:	8a 95       	dec	r24
    7e10:	f1 f7       	brne	.-4      	; 0x7e0e <HULTRASONIC_voidStart+0x19e>
    7e12:	89 83       	std	Y+1, r24	; 0x01
        _delay_us(10);
        MDIO_voidSetPinValue(ULTRSONIC_PORT,ULTRSONIC_PIN,PIN_LOW);
    7e14:	83 e0       	ldi	r24, 0x03	; 3
    7e16:	64 e0       	ldi	r22, 0x04	; 4
    7e18:	40 e0       	ldi	r20, 0x00	; 0
    7e1a:	0e 94 14 10 	call	0x2028	; 0x2028 <MDIO_voidSetPinValue>
        MTIMER1_voidInputCaptureEdge(RISING);
    7e1e:	80 e0       	ldi	r24, 0x00	; 0
    7e20:	0e 94 25 35 	call	0x6a4a	; 0x6a4a <MTIMER1_voidInputCaptureEdge>
        MTIMER1_voidCaptureInterruptEnable();
    7e24:	0e 94 be 35 	call	0x6b7c	; 0x6b7c <MTIMER1_voidCaptureInterruptEnable>
        MTIMER1_voidOverFlowInterruptEnable();
    7e28:	0e 94 12 36 	call	0x6c24	; 0x6c24 <MTIMER1_voidOverFlowInterruptEnable>
    }
}
    7e2c:	68 96       	adiw	r28, 0x18	; 24
    7e2e:	0f b6       	in	r0, 0x3f	; 63
    7e30:	f8 94       	cli
    7e32:	de bf       	out	0x3e, r29	; 62
    7e34:	0f be       	out	0x3f, r0	; 63
    7e36:	cd bf       	out	0x3d, r28	; 61
    7e38:	cf 91       	pop	r28
    7e3a:	df 91       	pop	r29
    7e3c:	08 95       	ret

00007e3e <HULTRASONIC_u8GetDistanceNoBlock>:
u16 HULTRASONIC_u8GetDistanceNoBlock(u16*Pdistance)
{
    7e3e:	0f 93       	push	r16
    7e40:	1f 93       	push	r17
    7e42:	df 93       	push	r29
    7e44:	cf 93       	push	r28
    7e46:	cd b7       	in	r28, 0x3d	; 61
    7e48:	de b7       	in	r29, 0x3e	; 62
    7e4a:	28 97       	sbiw	r28, 0x08	; 8
    7e4c:	0f b6       	in	r0, 0x3f	; 63
    7e4e:	f8 94       	cli
    7e50:	de bf       	out	0x3e, r29	; 62
    7e52:	0f be       	out	0x3f, r0	; 63
    7e54:	cd bf       	out	0x3d, r28	; 61
    7e56:	9e 83       	std	Y+6, r25	; 0x06
    7e58:	8d 83       	std	Y+5, r24	; 0x05
    u16 distance;
    u16 time;
    if(global_u8Flag==2)
    7e5a:	80 91 cb 01 	lds	r24, 0x01CB
    7e5e:	82 30       	cpi	r24, 0x02	; 2
    7e60:	c1 f5       	brne	.+112    	; 0x7ed2 <HULTRASONIC_u8GetDistanceNoBlock+0x94>
    {
        time =t2-t1+((u32)noOVF*65535);
    7e62:	20 91 e4 01 	lds	r18, 0x01E4
    7e66:	30 91 e5 01 	lds	r19, 0x01E5
    7e6a:	80 91 e6 01 	lds	r24, 0x01E6
    7e6e:	90 91 e7 01 	lds	r25, 0x01E7
    7e72:	89 01       	movw	r16, r18
    7e74:	08 1b       	sub	r16, r24
    7e76:	19 0b       	sbc	r17, r25
    7e78:	80 91 cc 01 	lds	r24, 0x01CC
    7e7c:	88 2f       	mov	r24, r24
    7e7e:	90 e0       	ldi	r25, 0x00	; 0
    7e80:	a0 e0       	ldi	r26, 0x00	; 0
    7e82:	b0 e0       	ldi	r27, 0x00	; 0
    7e84:	2f ef       	ldi	r18, 0xFF	; 255
    7e86:	3f ef       	ldi	r19, 0xFF	; 255
    7e88:	40 e0       	ldi	r20, 0x00	; 0
    7e8a:	50 e0       	ldi	r21, 0x00	; 0
    7e8c:	bc 01       	movw	r22, r24
    7e8e:	cd 01       	movw	r24, r26
    7e90:	0e 94 95 42 	call	0x852a	; 0x852a <__mulsi3>
    7e94:	dc 01       	movw	r26, r24
    7e96:	cb 01       	movw	r24, r22
    7e98:	80 0f       	add	r24, r16
    7e9a:	91 1f       	adc	r25, r17
    7e9c:	9a 83       	std	Y+2, r25	; 0x02
    7e9e:	89 83       	std	Y+1, r24	; 0x01
        distance=time/58;
    7ea0:	89 81       	ldd	r24, Y+1	; 0x01
    7ea2:	9a 81       	ldd	r25, Y+2	; 0x02
    7ea4:	2a e3       	ldi	r18, 0x3A	; 58
    7ea6:	30 e0       	ldi	r19, 0x00	; 0
    7ea8:	b9 01       	movw	r22, r18
    7eaa:	0e 94 b4 42 	call	0x8568	; 0x8568 <__udivmodhi4>
    7eae:	cb 01       	movw	r24, r22
    7eb0:	9c 83       	std	Y+4, r25	; 0x04
    7eb2:	8b 83       	std	Y+3, r24	; 0x03
        *Pdistance=distance;
    7eb4:	ed 81       	ldd	r30, Y+5	; 0x05
    7eb6:	fe 81       	ldd	r31, Y+6	; 0x06
    7eb8:	8b 81       	ldd	r24, Y+3	; 0x03
    7eba:	9c 81       	ldd	r25, Y+4	; 0x04
    7ebc:	91 83       	std	Z+1, r25	; 0x01
    7ebe:	80 83       	st	Z, r24
        MTIMER1_voidOverFlowInterruptEnable();
    7ec0:	0e 94 12 36 	call	0x6c24	; 0x6c24 <MTIMER1_voidOverFlowInterruptEnable>
        global_u8Flag=0;
    7ec4:	10 92 cb 01 	sts	0x01CB, r1
        return 1;
    7ec8:	81 e0       	ldi	r24, 0x01	; 1
    7eca:	90 e0       	ldi	r25, 0x00	; 0
    7ecc:	98 87       	std	Y+8, r25	; 0x08
    7ece:	8f 83       	std	Y+7, r24	; 0x07
    7ed0:	02 c0       	rjmp	.+4      	; 0x7ed6 <HULTRASONIC_u8GetDistanceNoBlock+0x98>
    }
    return 0;
    7ed2:	18 86       	std	Y+8, r1	; 0x08
    7ed4:	1f 82       	std	Y+7, r1	; 0x07
    7ed6:	8f 81       	ldd	r24, Y+7	; 0x07
    7ed8:	98 85       	ldd	r25, Y+8	; 0x08
}
    7eda:	28 96       	adiw	r28, 0x08	; 8
    7edc:	0f b6       	in	r0, 0x3f	; 63
    7ede:	f8 94       	cli
    7ee0:	de bf       	out	0x3e, r29	; 62
    7ee2:	0f be       	out	0x3f, r0	; 63
    7ee4:	cd bf       	out	0x3d, r28	; 61
    7ee6:	cf 91       	pop	r28
    7ee8:	df 91       	pop	r29
    7eea:	1f 91       	pop	r17
    7eec:	0f 91       	pop	r16
    7eee:	08 95       	ret

00007ef0 <Func_ICU>:

static void Func_ICU(void)
{
    7ef0:	df 93       	push	r29
    7ef2:	cf 93       	push	r28
    7ef4:	cd b7       	in	r28, 0x3d	; 61
    7ef6:	de b7       	in	r29, 0x3e	; 62
    if(global_u8Flag==0)
    7ef8:	80 91 cb 01 	lds	r24, 0x01CB
    7efc:	88 23       	and	r24, r24
    7efe:	79 f4       	brne	.+30     	; 0x7f1e <Func_ICU+0x2e>
    {
        noOVF=0;
    7f00:	10 92 cc 01 	sts	0x01CC, r1
        t1=MTIMER1_voidGetICR1();
    7f04:	0e 94 b3 35 	call	0x6b66	; 0x6b66 <MTIMER1_voidGetICR1>
    7f08:	90 93 e7 01 	sts	0x01E7, r25
    7f0c:	80 93 e6 01 	sts	0x01E6, r24
        global_u8Flag=1;
    7f10:	81 e0       	ldi	r24, 0x01	; 1
    7f12:	80 93 cb 01 	sts	0x01CB, r24
        MTIMER1_voidInputCaptureEdge(FALLING);
    7f16:	81 e0       	ldi	r24, 0x01	; 1
    7f18:	0e 94 25 35 	call	0x6a4a	; 0x6a4a <MTIMER1_voidInputCaptureEdge>
    7f1c:	14 c0       	rjmp	.+40     	; 0x7f46 <Func_ICU+0x56>
    }
    else if(global_u8Flag==1)
    7f1e:	80 91 cb 01 	lds	r24, 0x01CB
    7f22:	81 30       	cpi	r24, 0x01	; 1
    7f24:	81 f4       	brne	.+32     	; 0x7f46 <Func_ICU+0x56>
    {
        t2=MTIMER1_voidGetICR1();
    7f26:	0e 94 b3 35 	call	0x6b66	; 0x6b66 <MTIMER1_voidGetICR1>
    7f2a:	90 93 e5 01 	sts	0x01E5, r25
    7f2e:	80 93 e4 01 	sts	0x01E4, r24
        global_u8Flag=2;
    7f32:	82 e0       	ldi	r24, 0x02	; 2
    7f34:	80 93 cb 01 	sts	0x01CB, r24
        MTIMER1_voidInputCaptureEdge(RISING);
    7f38:	80 e0       	ldi	r24, 0x00	; 0
    7f3a:	0e 94 25 35 	call	0x6a4a	; 0x6a4a <MTIMER1_voidInputCaptureEdge>
        MTIMER1_voidOverFlowInterruptDisable();
    7f3e:	0e 94 20 36 	call	0x6c40	; 0x6c40 <MTIMER1_voidOverFlowInterruptDisable>
        MTIMER1_voidCaptureInterruptDisable();
    7f42:	0e 94 cc 35 	call	0x6b98	; 0x6b98 <MTIMER1_voidCaptureInterruptDisable>
    }
}
    7f46:	cf 91       	pop	r28
    7f48:	df 91       	pop	r29
    7f4a:	08 95       	ret

00007f4c <Func_OVF>:

static void Func_OVF(void)
{
    7f4c:	df 93       	push	r29
    7f4e:	cf 93       	push	r28
    7f50:	cd b7       	in	r28, 0x3d	; 61
    7f52:	de b7       	in	r29, 0x3e	; 62
    noOVF++;
    7f54:	80 91 cc 01 	lds	r24, 0x01CC
    7f58:	8f 5f       	subi	r24, 0xFF	; 255
    7f5a:	80 93 cc 01 	sts	0x01CC, r24
}
    7f5e:	cf 91       	pop	r28
    7f60:	df 91       	pop	r29
    7f62:	08 95       	ret

00007f64 <MWDT_voidEnableWDT>:
#include "../Include/MCAL/WDT/WDT_Configurations.h"
#include "../Include/MCAL/WDT/WDT_Interface.h"
#include "../Include/MCAL/WDT/WDT_Private.h"

void MWDT_voidEnableWDT(void)
{
    7f64:	df 93       	push	r29
    7f66:	cf 93       	push	r28
    7f68:	cd b7       	in	r28, 0x3d	; 61
    7f6a:	de b7       	in	r29, 0x3e	; 62
    WDTCR &=~(0b111<<WDP0);
    7f6c:	a1 e4       	ldi	r26, 0x41	; 65
    7f6e:	b0 e0       	ldi	r27, 0x00	; 0
    7f70:	e1 e4       	ldi	r30, 0x41	; 65
    7f72:	f0 e0       	ldi	r31, 0x00	; 0
    7f74:	80 81       	ld	r24, Z
    7f76:	88 7f       	andi	r24, 0xF8	; 248
    7f78:	8c 93       	st	X, r24
    WDTCR |=(WDT_PRESCALER<<WDP0);
    7f7a:	a1 e4       	ldi	r26, 0x41	; 65
    7f7c:	b0 e0       	ldi	r27, 0x00	; 0
    7f7e:	e1 e4       	ldi	r30, 0x41	; 65
    7f80:	f0 e0       	ldi	r31, 0x00	; 0
    7f82:	80 81       	ld	r24, Z
    7f84:	87 60       	ori	r24, 0x07	; 7
    7f86:	8c 93       	st	X, r24
    SET_BIT(WDTCR,WDE);
    7f88:	a1 e4       	ldi	r26, 0x41	; 65
    7f8a:	b0 e0       	ldi	r27, 0x00	; 0
    7f8c:	e1 e4       	ldi	r30, 0x41	; 65
    7f8e:	f0 e0       	ldi	r31, 0x00	; 0
    7f90:	80 81       	ld	r24, Z
    7f92:	88 60       	ori	r24, 0x08	; 8
    7f94:	8c 93       	st	X, r24
    CLR_BIT(WDTCR,WDTOE);
    7f96:	a1 e4       	ldi	r26, 0x41	; 65
    7f98:	b0 e0       	ldi	r27, 0x00	; 0
    7f9a:	e1 e4       	ldi	r30, 0x41	; 65
    7f9c:	f0 e0       	ldi	r31, 0x00	; 0
    7f9e:	80 81       	ld	r24, Z
    7fa0:	8f 7e       	andi	r24, 0xEF	; 239
    7fa2:	8c 93       	st	X, r24
}
    7fa4:	cf 91       	pop	r28
    7fa6:	df 91       	pop	r29
    7fa8:	08 95       	ret

00007faa <MWDT_voidDisableWDT>:

void MWDT_voidDisableWDT(void)
{
    7faa:	df 93       	push	r29
    7fac:	cf 93       	push	r28
    7fae:	cd b7       	in	r28, 0x3d	; 61
    7fb0:	de b7       	in	r29, 0x3e	; 62
    CLR_BIT(WDTCR,WDE);
    7fb2:	a1 e4       	ldi	r26, 0x41	; 65
    7fb4:	b0 e0       	ldi	r27, 0x00	; 0
    7fb6:	e1 e4       	ldi	r30, 0x41	; 65
    7fb8:	f0 e0       	ldi	r31, 0x00	; 0
    7fba:	80 81       	ld	r24, Z
    7fbc:	87 7f       	andi	r24, 0xF7	; 247
    7fbe:	8c 93       	st	X, r24
    SET_BIT(WDTCR,WDTOE);
    7fc0:	a1 e4       	ldi	r26, 0x41	; 65
    7fc2:	b0 e0       	ldi	r27, 0x00	; 0
    7fc4:	e1 e4       	ldi	r30, 0x41	; 65
    7fc6:	f0 e0       	ldi	r31, 0x00	; 0
    7fc8:	80 81       	ld	r24, Z
    7fca:	80 61       	ori	r24, 0x10	; 16
    7fcc:	8c 93       	st	X, r24
}
    7fce:	cf 91       	pop	r28
    7fd0:	df 91       	pop	r29
    7fd2:	08 95       	ret

00007fd4 <main>:
#define F_CPU 8000000UL 	 	

u16 ton =10;
//void func2();
void main(void)
{
    7fd4:	df 93       	push	r29
    7fd6:	cf 93       	push	r28
    7fd8:	cd b7       	in	r28, 0x3d	; 61
    7fda:	de b7       	in	r29, 0x3e	; 62
    7fdc:	c4 56       	subi	r28, 0x64	; 100
    7fde:	d0 40       	sbci	r29, 0x00	; 0
    7fe0:	0f b6       	in	r0, 0x3f	; 63
    7fe2:	f8 94       	cli
    7fe4:	de bf       	out	0x3e, r29	; 62
    7fe6:	0f be       	out	0x3f, r0	; 63
    7fe8:	cd bf       	out	0x3d, r28	; 61
	u8 str[100];
	MDIO_voidInit();
    7fea:	0e 94 3d 0f 	call	0x1e7a	; 0x1e7a <MDIO_voidInit>
	MGI_voidEnable();
    7fee:	0e 94 74 15 	call	0x2ae8	; 0x2ae8 <MGI_voidEnable>
	MUSART_voidInit();
    7ff2:	0e 94 da 3a 	call	0x75b4	; 0x75b4 <MUSART_voidInit>
	MUSART_voidSendStingAsynch("Ahmed Nabil");
    7ff6:	80 e6       	ldi	r24, 0x60	; 96
    7ff8:	90 e0       	ldi	r25, 0x00	; 0
    7ffa:	0e 94 29 40 	call	0x8052	; 0x8052 <MUSART_voidSendStingAsynch>
    7ffe:	ff cf       	rjmp	.-2      	; 0x7ffe <main+0x2a>

00008000 <MUSART_voidSendStringSynchBlocking>:
/**********************************************************************************/
                            /*send string techniques*/

//Send String synch blocking
void MUSART_voidSendStringSynchBlocking(u8* A_u8Word)
{
    8000:	df 93       	push	r29
    8002:	cf 93       	push	r28
    8004:	00 d0       	rcall	.+0      	; 0x8006 <MUSART_voidSendStringSynchBlocking+0x6>
    8006:	0f 92       	push	r0
    8008:	cd b7       	in	r28, 0x3d	; 61
    800a:	de b7       	in	r29, 0x3e	; 62
    800c:	9b 83       	std	Y+3, r25	; 0x03
    800e:	8a 83       	std	Y+2, r24	; 0x02
    u8 local_u8Counter=0;
    8010:	19 82       	std	Y+1, r1	; 0x01
    8012:	0e c0       	rjmp	.+28     	; 0x8030 <MUSART_voidSendStringSynchBlocking+0x30>
    while(A_u8Word[local_u8Counter] != '\0')
    {
        MUSART_voidSendByteSynchBlocking(A_u8Word[local_u8Counter]);
    8014:	89 81       	ldd	r24, Y+1	; 0x01
    8016:	28 2f       	mov	r18, r24
    8018:	30 e0       	ldi	r19, 0x00	; 0
    801a:	8a 81       	ldd	r24, Y+2	; 0x02
    801c:	9b 81       	ldd	r25, Y+3	; 0x03
    801e:	fc 01       	movw	r30, r24
    8020:	e2 0f       	add	r30, r18
    8022:	f3 1f       	adc	r31, r19
    8024:	80 81       	ld	r24, Z
    8026:	0e 94 71 3b 	call	0x76e2	; 0x76e2 <MUSART_voidSendByteSynchBlocking>
        local_u8Counter++;
    802a:	89 81       	ldd	r24, Y+1	; 0x01
    802c:	8f 5f       	subi	r24, 0xFF	; 255
    802e:	89 83       	std	Y+1, r24	; 0x01

//Send String synch blocking
void MUSART_voidSendStringSynchBlocking(u8* A_u8Word)
{
    u8 local_u8Counter=0;
    while(A_u8Word[local_u8Counter] != '\0')
    8030:	89 81       	ldd	r24, Y+1	; 0x01
    8032:	28 2f       	mov	r18, r24
    8034:	30 e0       	ldi	r19, 0x00	; 0
    8036:	8a 81       	ldd	r24, Y+2	; 0x02
    8038:	9b 81       	ldd	r25, Y+3	; 0x03
    803a:	fc 01       	movw	r30, r24
    803c:	e2 0f       	add	r30, r18
    803e:	f3 1f       	adc	r31, r19
    8040:	80 81       	ld	r24, Z
    8042:	88 23       	and	r24, r24
    8044:	39 f7       	brne	.-50     	; 0x8014 <MUSART_voidSendStringSynchBlocking+0x14>
    {
        MUSART_voidSendByteSynchBlocking(A_u8Word[local_u8Counter]);
        local_u8Counter++;
    }
}
    8046:	0f 90       	pop	r0
    8048:	0f 90       	pop	r0
    804a:	0f 90       	pop	r0
    804c:	cf 91       	pop	r28
    804e:	df 91       	pop	r29
    8050:	08 95       	ret

00008052 <MUSART_voidSendStingAsynch>:

//send string asynch non-blocking
void MUSART_voidSendStingAsynch(u8 *ptr)
{
    8052:	df 93       	push	r29
    8054:	cf 93       	push	r28
    8056:	00 d0       	rcall	.+0      	; 0x8058 <MUSART_voidSendStingAsynch+0x6>
    8058:	cd b7       	in	r28, 0x3d	; 61
    805a:	de b7       	in	r29, 0x3e	; 62
    805c:	9a 83       	std	Y+2, r25	; 0x02
    805e:	89 83       	std	Y+1, r24	; 0x01
    MUSART_voidSetCallTXC(FUNC_TX);
    8060:	86 e4       	ldi	r24, 0x46	; 70
    8062:	90 e4       	ldi	r25, 0x40	; 64
    8064:	0e 94 5b 3c 	call	0x78b6	; 0x78b6 <MUSART_voidSetCallTXC>
    MUSART_voidTXCompleteInterruptEnable();
    8068:	0e 94 ff 3b 	call	0x77fe	; 0x77fe <MUSART_voidTXCompleteInterruptEnable>
    MUSART_voidSendByteAsynch(ptr[0]);
    806c:	e9 81       	ldd	r30, Y+1	; 0x01
    806e:	fa 81       	ldd	r31, Y+2	; 0x02
    8070:	80 81       	ld	r24, Z
    8072:	0e 94 8e 3b 	call	0x771c	; 0x771c <MUSART_voidSendByteAsynch>
    Asynch_Sent_Str=ptr;
    8076:	89 81       	ldd	r24, Y+1	; 0x01
    8078:	9a 81       	ldd	r25, Y+2	; 0x02
    807a:	90 93 ce 01 	sts	0x01CE, r25
    807e:	80 93 cd 01 	sts	0x01CD, r24
}
    8082:	0f 90       	pop	r0
    8084:	0f 90       	pop	r0
    8086:	cf 91       	pop	r28
    8088:	df 91       	pop	r29
    808a:	08 95       	ret

0000808c <FUNC_TX>:

//send this function to ISR
void FUNC_TX()
{
    808c:	df 93       	push	r29
    808e:	cf 93       	push	r28
    8090:	cd b7       	in	r28, 0x3d	; 61
    8092:	de b7       	in	r29, 0x3e	; 62
    static u8 i=1;
    if(Asynch_Sent_Str[i]!='\0')
    8094:	20 91 cd 01 	lds	r18, 0x01CD
    8098:	30 91 ce 01 	lds	r19, 0x01CE
    809c:	80 91 8e 01 	lds	r24, 0x018E
    80a0:	88 2f       	mov	r24, r24
    80a2:	90 e0       	ldi	r25, 0x00	; 0
    80a4:	f9 01       	movw	r30, r18
    80a6:	e8 0f       	add	r30, r24
    80a8:	f9 1f       	adc	r31, r25
    80aa:	80 81       	ld	r24, Z
    80ac:	88 23       	and	r24, r24
    80ae:	a1 f0       	breq	.+40     	; 0x80d8 <FUNC_TX+0x4c>
    {
        MUSART_voidSendByteAsynch(Asynch_Sent_Str[i]);
    80b0:	20 91 cd 01 	lds	r18, 0x01CD
    80b4:	30 91 ce 01 	lds	r19, 0x01CE
    80b8:	80 91 8e 01 	lds	r24, 0x018E
    80bc:	88 2f       	mov	r24, r24
    80be:	90 e0       	ldi	r25, 0x00	; 0
    80c0:	f9 01       	movw	r30, r18
    80c2:	e8 0f       	add	r30, r24
    80c4:	f9 1f       	adc	r31, r25
    80c6:	80 81       	ld	r24, Z
    80c8:	0e 94 8e 3b 	call	0x771c	; 0x771c <MUSART_voidSendByteAsynch>
        i++;
    80cc:	80 91 8e 01 	lds	r24, 0x018E
    80d0:	8f 5f       	subi	r24, 0xFF	; 255
    80d2:	80 93 8e 01 	sts	0x018E, r24
    80d6:	03 c0       	rjmp	.+6      	; 0x80de <FUNC_TX+0x52>
    }
    else i=1;
    80d8:	81 e0       	ldi	r24, 0x01	; 1
    80da:	80 93 8e 01 	sts	0x018E, r24
}
    80de:	cf 91       	pop	r28
    80e0:	df 91       	pop	r29
    80e2:	08 95       	ret

000080e4 <MUSART_voidReceiveString>:


/**********************************************************************************/
                            /*receive string techniques*/
void MUSART_voidReceiveString(u8 *ptr)
{
    80e4:	0f 93       	push	r16
    80e6:	1f 93       	push	r17
    80e8:	df 93       	push	r29
    80ea:	cf 93       	push	r28
    80ec:	00 d0       	rcall	.+0      	; 0x80ee <MUSART_voidReceiveString+0xa>
    80ee:	0f 92       	push	r0
    80f0:	cd b7       	in	r28, 0x3d	; 61
    80f2:	de b7       	in	r29, 0x3e	; 62
    80f4:	9b 83       	std	Y+3, r25	; 0x03
    80f6:	8a 83       	std	Y+2, r24	; 0x02
    u8 i=0;
    80f8:	19 82       	std	Y+1, r1	; 0x01
    ptr[i]=MUSART_u8ReadByteSynchBlocking();
    80fa:	89 81       	ldd	r24, Y+1	; 0x01
    80fc:	28 2f       	mov	r18, r24
    80fe:	30 e0       	ldi	r19, 0x00	; 0
    8100:	8a 81       	ldd	r24, Y+2	; 0x02
    8102:	9b 81       	ldd	r25, Y+3	; 0x03
    8104:	8c 01       	movw	r16, r24
    8106:	02 0f       	add	r16, r18
    8108:	13 1f       	adc	r17, r19
    810a:	0e 94 9c 3b 	call	0x7738	; 0x7738 <MUSART_u8ReadByteSynchBlocking>
    810e:	f8 01       	movw	r30, r16
    8110:	80 83       	st	Z, r24
    8112:	0f c0       	rjmp	.+30     	; 0x8132 <MUSART_voidReceiveString+0x4e>
        0x0d is hex code for enter in proteus
        in docklight you send two numbers when you push enter 10 13 for example
    */
    while(ptr[i]!=0x0d)
    {
        i++;
    8114:	89 81       	ldd	r24, Y+1	; 0x01
    8116:	8f 5f       	subi	r24, 0xFF	; 255
    8118:	89 83       	std	Y+1, r24	; 0x01
        ptr[i]=MUSART_u8ReadByteSynchBlocking();
    811a:	89 81       	ldd	r24, Y+1	; 0x01
    811c:	28 2f       	mov	r18, r24
    811e:	30 e0       	ldi	r19, 0x00	; 0
    8120:	8a 81       	ldd	r24, Y+2	; 0x02
    8122:	9b 81       	ldd	r25, Y+3	; 0x03
    8124:	8c 01       	movw	r16, r24
    8126:	02 0f       	add	r16, r18
    8128:	13 1f       	adc	r17, r19
    812a:	0e 94 9c 3b 	call	0x7738	; 0x7738 <MUSART_u8ReadByteSynchBlocking>
    812e:	f8 01       	movw	r30, r16
    8130:	80 83       	st	Z, r24
    ptr[i]=MUSART_u8ReadByteSynchBlocking();
    /*
        0x0d is hex code for enter in proteus
        in docklight you send two numbers when you push enter 10 13 for example
    */
    while(ptr[i]!=0x0d)
    8132:	89 81       	ldd	r24, Y+1	; 0x01
    8134:	28 2f       	mov	r18, r24
    8136:	30 e0       	ldi	r19, 0x00	; 0
    8138:	8a 81       	ldd	r24, Y+2	; 0x02
    813a:	9b 81       	ldd	r25, Y+3	; 0x03
    813c:	fc 01       	movw	r30, r24
    813e:	e2 0f       	add	r30, r18
    8140:	f3 1f       	adc	r31, r19
    8142:	80 81       	ld	r24, Z
    8144:	8d 30       	cpi	r24, 0x0D	; 13
    8146:	31 f7       	brne	.-52     	; 0x8114 <MUSART_voidReceiveString+0x30>
    {
        i++;
        ptr[i]=MUSART_u8ReadByteSynchBlocking();
    }
    ptr[i]='\0';
    8148:	89 81       	ldd	r24, Y+1	; 0x01
    814a:	28 2f       	mov	r18, r24
    814c:	30 e0       	ldi	r19, 0x00	; 0
    814e:	8a 81       	ldd	r24, Y+2	; 0x02
    8150:	9b 81       	ldd	r25, Y+3	; 0x03
    8152:	fc 01       	movw	r30, r24
    8154:	e2 0f       	add	r30, r18
    8156:	f3 1f       	adc	r31, r19
    8158:	10 82       	st	Z, r1
}
    815a:	0f 90       	pop	r0
    815c:	0f 90       	pop	r0
    815e:	0f 90       	pop	r0
    8160:	cf 91       	pop	r28
    8162:	df 91       	pop	r29
    8164:	1f 91       	pop	r17
    8166:	0f 91       	pop	r16
    8168:	08 95       	ret

0000816a <MUSART_voidReceiveStringAsynch>:

void MUSART_voidReceiveStringAsynch(u8*str)
{
    816a:	df 93       	push	r29
    816c:	cf 93       	push	r28
    816e:	00 d0       	rcall	.+0      	; 0x8170 <MUSART_voidReceiveStringAsynch+0x6>
    8170:	cd b7       	in	r28, 0x3d	; 61
    8172:	de b7       	in	r29, 0x3e	; 62
    8174:	9a 83       	std	Y+2, r25	; 0x02
    8176:	89 83       	std	Y+1, r24	; 0x01
    MUSART_voidSetCallRXC(FUNC_RX);
    8178:	8d ec       	ldi	r24, 0xCD	; 205
    817a:	90 e4       	ldi	r25, 0x40	; 64
    817c:	0e 94 37 3c 	call	0x786e	; 0x786e <MUSART_voidSetCallRXC>
    MUSART_voidRXCompleteInterruptEnable();
    8180:	0e 94 e3 3b 	call	0x77c6	; 0x77c6 <MUSART_voidRXCompleteInterruptEnable>
    Asynch_receive_Str=str;
    8184:	89 81       	ldd	r24, Y+1	; 0x01
    8186:	9a 81       	ldd	r25, Y+2	; 0x02
    8188:	90 93 d0 01 	sts	0x01D0, r25
    818c:	80 93 cf 01 	sts	0x01CF, r24
}
    8190:	0f 90       	pop	r0
    8192:	0f 90       	pop	r0
    8194:	cf 91       	pop	r28
    8196:	df 91       	pop	r29
    8198:	08 95       	ret

0000819a <FUNC_RX>:

void FUNC_RX()
{
    819a:	0f 93       	push	r16
    819c:	1f 93       	push	r17
    819e:	df 93       	push	r29
    81a0:	cf 93       	push	r28
    81a2:	cd b7       	in	r28, 0x3d	; 61
    81a4:	de b7       	in	r29, 0x3e	; 62
    static u8 i=0;
    Asynch_receive_Str[i]=MUSART_u8ReadByteAsynch();
    81a6:	20 91 cf 01 	lds	r18, 0x01CF
    81aa:	30 91 d0 01 	lds	r19, 0x01D0
    81ae:	80 91 d1 01 	lds	r24, 0x01D1
    81b2:	88 2f       	mov	r24, r24
    81b4:	90 e0       	ldi	r25, 0x00	; 0
    81b6:	89 01       	movw	r16, r18
    81b8:	08 0f       	add	r16, r24
    81ba:	19 1f       	adc	r17, r25
    81bc:	0e 94 d9 3b 	call	0x77b2	; 0x77b2 <MUSART_u8ReadByteAsynch>
    81c0:	f8 01       	movw	r30, r16
    81c2:	80 83       	st	Z, r24
    i++;
    81c4:	80 91 d1 01 	lds	r24, 0x01D1
    81c8:	8f 5f       	subi	r24, 0xFF	; 255
    81ca:	80 93 d1 01 	sts	0x01D1, r24
}
    81ce:	cf 91       	pop	r28
    81d0:	df 91       	pop	r29
    81d2:	1f 91       	pop	r17
    81d4:	0f 91       	pop	r16
    81d6:	08 95       	ret

000081d8 <MUSART_voidSendStringMyProtocol>:


/**********************************************************************************/
                            /*My Protocol to send And receive*/
void MUSART_voidSendStringMyProtocol(u8 *str)
{
    81d8:	df 93       	push	r29
    81da:	cf 93       	push	r28
    81dc:	00 d0       	rcall	.+0      	; 0x81de <MUSART_voidSendStringMyProtocol+0x6>
    81de:	00 d0       	rcall	.+0      	; 0x81e0 <MUSART_voidSendStringMyProtocol+0x8>
    81e0:	0f 92       	push	r0
    81e2:	cd b7       	in	r28, 0x3d	; 61
    81e4:	de b7       	in	r29, 0x3e	; 62
    81e6:	9d 83       	std	Y+5, r25	; 0x05
    81e8:	8c 83       	std	Y+4, r24	; 0x04
    u8 lens=0,sum=0,i=0;
    81ea:	1b 82       	std	Y+3, r1	; 0x03
    81ec:	1a 82       	std	Y+2, r1	; 0x02
    81ee:	19 82       	std	Y+1, r1	; 0x01
    81f0:	0f c0       	rjmp	.+30     	; 0x8210 <MUSART_voidSendStringMyProtocol+0x38>
    while(str[lens]!='\0')
    {
        sum+=str[lens];
    81f2:	8b 81       	ldd	r24, Y+3	; 0x03
    81f4:	28 2f       	mov	r18, r24
    81f6:	30 e0       	ldi	r19, 0x00	; 0
    81f8:	8c 81       	ldd	r24, Y+4	; 0x04
    81fa:	9d 81       	ldd	r25, Y+5	; 0x05
    81fc:	fc 01       	movw	r30, r24
    81fe:	e2 0f       	add	r30, r18
    8200:	f3 1f       	adc	r31, r19
    8202:	90 81       	ld	r25, Z
    8204:	8a 81       	ldd	r24, Y+2	; 0x02
    8206:	89 0f       	add	r24, r25
    8208:	8a 83       	std	Y+2, r24	; 0x02
        lens++;
    820a:	8b 81       	ldd	r24, Y+3	; 0x03
    820c:	8f 5f       	subi	r24, 0xFF	; 255
    820e:	8b 83       	std	Y+3, r24	; 0x03
/**********************************************************************************/
                            /*My Protocol to send And receive*/
void MUSART_voidSendStringMyProtocol(u8 *str)
{
    u8 lens=0,sum=0,i=0;
    while(str[lens]!='\0')
    8210:	8b 81       	ldd	r24, Y+3	; 0x03
    8212:	28 2f       	mov	r18, r24
    8214:	30 e0       	ldi	r19, 0x00	; 0
    8216:	8c 81       	ldd	r24, Y+4	; 0x04
    8218:	9d 81       	ldd	r25, Y+5	; 0x05
    821a:	fc 01       	movw	r30, r24
    821c:	e2 0f       	add	r30, r18
    821e:	f3 1f       	adc	r31, r19
    8220:	80 81       	ld	r24, Z
    8222:	88 23       	and	r24, r24
    8224:	31 f7       	brne	.-52     	; 0x81f2 <MUSART_voidSendStringMyProtocol+0x1a>
    {
        sum+=str[lens];
        lens++;
    }
    MUSART_voidSendByteSynchBlocking(lens);
    8226:	8b 81       	ldd	r24, Y+3	; 0x03
    8228:	0e 94 71 3b 	call	0x76e2	; 0x76e2 <MUSART_voidSendByteSynchBlocking>
    822c:	0b c0       	rjmp	.+22     	; 0x8244 <MUSART_voidSendStringMyProtocol+0x6c>

    while(str[i]!='\0')
    {
        MUSART_voidSendByteSynchBlocking(str[i]);
    822e:	89 81       	ldd	r24, Y+1	; 0x01
    8230:	28 2f       	mov	r18, r24
    8232:	30 e0       	ldi	r19, 0x00	; 0
    8234:	8c 81       	ldd	r24, Y+4	; 0x04
    8236:	9d 81       	ldd	r25, Y+5	; 0x05
    8238:	fc 01       	movw	r30, r24
    823a:	e2 0f       	add	r30, r18
    823c:	f3 1f       	adc	r31, r19
    823e:	80 81       	ld	r24, Z
    8240:	0e 94 71 3b 	call	0x76e2	; 0x76e2 <MUSART_voidSendByteSynchBlocking>
        sum+=str[lens];
        lens++;
    }
    MUSART_voidSendByteSynchBlocking(lens);

    while(str[i]!='\0')
    8244:	89 81       	ldd	r24, Y+1	; 0x01
    8246:	28 2f       	mov	r18, r24
    8248:	30 e0       	ldi	r19, 0x00	; 0
    824a:	8c 81       	ldd	r24, Y+4	; 0x04
    824c:	9d 81       	ldd	r25, Y+5	; 0x05
    824e:	fc 01       	movw	r30, r24
    8250:	e2 0f       	add	r30, r18
    8252:	f3 1f       	adc	r31, r19
    8254:	80 81       	ld	r24, Z
    8256:	88 23       	and	r24, r24
    8258:	51 f7       	brne	.-44     	; 0x822e <MUSART_voidSendStringMyProtocol+0x56>
    {
        MUSART_voidSendByteSynchBlocking(str[i]);
    }
    MUSART_voidSendByteSynchBlocking((u8)sum);
    825a:	8a 81       	ldd	r24, Y+2	; 0x02
    825c:	0e 94 71 3b 	call	0x76e2	; 0x76e2 <MUSART_voidSendByteSynchBlocking>
    MUSART_voidSendByteSynchBlocking((u8)(sum>>8));
    8260:	8a 81       	ldd	r24, Y+2	; 0x02
    8262:	88 2f       	mov	r24, r24
    8264:	90 e0       	ldi	r25, 0x00	; 0
    8266:	89 2f       	mov	r24, r25
    8268:	99 0f       	add	r25, r25
    826a:	99 0b       	sbc	r25, r25
    826c:	0e 94 71 3b 	call	0x76e2	; 0x76e2 <MUSART_voidSendByteSynchBlocking>

}
    8270:	0f 90       	pop	r0
    8272:	0f 90       	pop	r0
    8274:	0f 90       	pop	r0
    8276:	0f 90       	pop	r0
    8278:	0f 90       	pop	r0
    827a:	cf 91       	pop	r28
    827c:	df 91       	pop	r29
    827e:	08 95       	ret

00008280 <MUSART_voidReceiveStringMyProtocol>:

u8 MUSART_voidReceiveStringMyProtocol(u8 *str)
{
    8280:	0f 93       	push	r16
    8282:	1f 93       	push	r17
    8284:	df 93       	push	r29
    8286:	cf 93       	push	r28
    8288:	cd b7       	in	r28, 0x3d	; 61
    828a:	de b7       	in	r29, 0x3e	; 62
    828c:	2b 97       	sbiw	r28, 0x0b	; 11
    828e:	0f b6       	in	r0, 0x3f	; 63
    8290:	f8 94       	cli
    8292:	de bf       	out	0x3e, r29	; 62
    8294:	0f be       	out	0x3f, r0	; 63
    8296:	cd bf       	out	0x3d, r28	; 61
    8298:	9a 87       	std	Y+10, r25	; 0x0a
    829a:	89 87       	std	Y+9, r24	; 0x09
    u8 i,lens=MUSART_u8ReadByteSynchBlocking();
    829c:	0e 94 9c 3b 	call	0x7738	; 0x7738 <MUSART_u8ReadByteSynchBlocking>
    82a0:	8f 83       	std	Y+7, r24	; 0x07
    u16 sum_rec=0,sum_cal=0;
    82a2:	1e 82       	std	Y+6, r1	; 0x06
    82a4:	1d 82       	std	Y+5, r1	; 0x05
    82a6:	1c 82       	std	Y+4, r1	; 0x04
    82a8:	1b 82       	std	Y+3, r1	; 0x03
    u8 first_byte,second_byte;

    for(i=0;i<lens;i++)
    82aa:	18 86       	std	Y+8, r1	; 0x08
    82ac:	20 c0       	rjmp	.+64     	; 0x82ee <MUSART_voidReceiveStringMyProtocol+0x6e>
    {
        str[i]=MUSART_u8ReadByteSynchBlocking();
    82ae:	88 85       	ldd	r24, Y+8	; 0x08
    82b0:	28 2f       	mov	r18, r24
    82b2:	30 e0       	ldi	r19, 0x00	; 0
    82b4:	89 85       	ldd	r24, Y+9	; 0x09
    82b6:	9a 85       	ldd	r25, Y+10	; 0x0a
    82b8:	8c 01       	movw	r16, r24
    82ba:	02 0f       	add	r16, r18
    82bc:	13 1f       	adc	r17, r19
    82be:	0e 94 9c 3b 	call	0x7738	; 0x7738 <MUSART_u8ReadByteSynchBlocking>
    82c2:	f8 01       	movw	r30, r16
    82c4:	80 83       	st	Z, r24
        sum_cal+=str[i];
    82c6:	88 85       	ldd	r24, Y+8	; 0x08
    82c8:	28 2f       	mov	r18, r24
    82ca:	30 e0       	ldi	r19, 0x00	; 0
    82cc:	89 85       	ldd	r24, Y+9	; 0x09
    82ce:	9a 85       	ldd	r25, Y+10	; 0x0a
    82d0:	fc 01       	movw	r30, r24
    82d2:	e2 0f       	add	r30, r18
    82d4:	f3 1f       	adc	r31, r19
    82d6:	80 81       	ld	r24, Z
    82d8:	28 2f       	mov	r18, r24
    82da:	30 e0       	ldi	r19, 0x00	; 0
    82dc:	8b 81       	ldd	r24, Y+3	; 0x03
    82de:	9c 81       	ldd	r25, Y+4	; 0x04
    82e0:	82 0f       	add	r24, r18
    82e2:	93 1f       	adc	r25, r19
    82e4:	9c 83       	std	Y+4, r25	; 0x04
    82e6:	8b 83       	std	Y+3, r24	; 0x03
{
    u8 i,lens=MUSART_u8ReadByteSynchBlocking();
    u16 sum_rec=0,sum_cal=0;
    u8 first_byte,second_byte;

    for(i=0;i<lens;i++)
    82e8:	88 85       	ldd	r24, Y+8	; 0x08
    82ea:	8f 5f       	subi	r24, 0xFF	; 255
    82ec:	88 87       	std	Y+8, r24	; 0x08
    82ee:	98 85       	ldd	r25, Y+8	; 0x08
    82f0:	8f 81       	ldd	r24, Y+7	; 0x07
    82f2:	98 17       	cp	r25, r24
    82f4:	e0 f2       	brcs	.-72     	; 0x82ae <MUSART_voidReceiveStringMyProtocol+0x2e>
    {
        str[i]=MUSART_u8ReadByteSynchBlocking();
        sum_cal+=str[i];
    }
    first_byte=MUSART_u8ReadByteSynchBlocking();
    82f6:	0e 94 9c 3b 	call	0x7738	; 0x7738 <MUSART_u8ReadByteSynchBlocking>
    82fa:	8a 83       	std	Y+2, r24	; 0x02
    second_byte=MUSART_u8ReadByteSynchBlocking();
    82fc:	0e 94 9c 3b 	call	0x7738	; 0x7738 <MUSART_u8ReadByteSynchBlocking>
    8300:	89 83       	std	Y+1, r24	; 0x01
    sum_cal=first_byte | (second_byte<<8);
    8302:	8a 81       	ldd	r24, Y+2	; 0x02
    8304:	28 2f       	mov	r18, r24
    8306:	30 e0       	ldi	r19, 0x00	; 0
    8308:	89 81       	ldd	r24, Y+1	; 0x01
    830a:	88 2f       	mov	r24, r24
    830c:	90 e0       	ldi	r25, 0x00	; 0
    830e:	98 2f       	mov	r25, r24
    8310:	88 27       	eor	r24, r24
    8312:	82 2b       	or	r24, r18
    8314:	93 2b       	or	r25, r19
    8316:	9c 83       	std	Y+4, r25	; 0x04
    8318:	8b 83       	std	Y+3, r24	; 0x03
    if(sum_cal == sum_rec) return 1;
    831a:	2b 81       	ldd	r18, Y+3	; 0x03
    831c:	3c 81       	ldd	r19, Y+4	; 0x04
    831e:	8d 81       	ldd	r24, Y+5	; 0x05
    8320:	9e 81       	ldd	r25, Y+6	; 0x06
    8322:	28 17       	cp	r18, r24
    8324:	39 07       	cpc	r19, r25
    8326:	19 f4       	brne	.+6      	; 0x832e <MUSART_voidReceiveStringMyProtocol+0xae>
    8328:	f1 e0       	ldi	r31, 0x01	; 1
    832a:	fb 87       	std	Y+11, r31	; 0x0b
    832c:	01 c0       	rjmp	.+2      	; 0x8330 <MUSART_voidReceiveStringMyProtocol+0xb0>
    return 0;
    832e:	1b 86       	std	Y+11, r1	; 0x0b
    8330:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    8332:	2b 96       	adiw	r28, 0x0b	; 11
    8334:	0f b6       	in	r0, 0x3f	; 63
    8336:	f8 94       	cli
    8338:	de bf       	out	0x3e, r29	; 62
    833a:	0f be       	out	0x3f, r0	; 63
    833c:	cd bf       	out	0x3d, r28	; 61
    833e:	cf 91       	pop	r28
    8340:	df 91       	pop	r29
    8342:	1f 91       	pop	r17
    8344:	0f 91       	pop	r16
    8346:	08 95       	ret

00008348 <MUSART_u8Frame>:

/**********************************************************************************/
u8 MUSART_u8Frame(u8 *str,u8 *s1,u8 *s2,u8 *pnum1,u8 *pnum2)
{
    8348:	0f 93       	push	r16
    834a:	1f 93       	push	r17
    834c:	df 93       	push	r29
    834e:	cf 93       	push	r28
    8350:	cd b7       	in	r28, 0x3d	; 61
    8352:	de b7       	in	r29, 0x3e	; 62
    8354:	63 97       	sbiw	r28, 0x13	; 19
    8356:	0f b6       	in	r0, 0x3f	; 63
    8358:	f8 94       	cli
    835a:	de bf       	out	0x3e, r29	; 62
    835c:	0f be       	out	0x3f, r0	; 63
    835e:	cd bf       	out	0x3d, r28	; 61
    8360:	9a 87       	std	Y+10, r25	; 0x0a
    8362:	89 87       	std	Y+9, r24	; 0x09
    8364:	7c 87       	std	Y+12, r23	; 0x0c
    8366:	6b 87       	std	Y+11, r22	; 0x0b
    8368:	5e 87       	std	Y+14, r21	; 0x0e
    836a:	4d 87       	std	Y+13, r20	; 0x0d
    836c:	38 8b       	std	Y+16, r19	; 0x10
    836e:	2f 87       	std	Y+15, r18	; 0x0f
    8370:	1a 8b       	std	Y+18, r17	; 0x12
    8372:	09 8b       	std	Y+17, r16	; 0x11
	//our frame: hello,509,hi,76
	
	u8 i=0,flag=0,j=0,k=0;
    8374:	18 86       	std	Y+8, r1	; 0x08
    8376:	1f 82       	std	Y+7, r1	; 0x07
    8378:	1e 82       	std	Y+6, r1	; 0x06
    837a:	1d 82       	std	Y+5, r1	; 0x05
    837c:	9d c0       	rjmp	.+314    	; 0x84b8 <MUSART_u8Frame+0x170>
	u16 num1,num2;
	
	while(str[i]!='\0')
	{
		if(str[i]==',') flag++;
    837e:	88 85       	ldd	r24, Y+8	; 0x08
    8380:	28 2f       	mov	r18, r24
    8382:	30 e0       	ldi	r19, 0x00	; 0
    8384:	89 85       	ldd	r24, Y+9	; 0x09
    8386:	9a 85       	ldd	r25, Y+10	; 0x0a
    8388:	fc 01       	movw	r30, r24
    838a:	e2 0f       	add	r30, r18
    838c:	f3 1f       	adc	r31, r19
    838e:	80 81       	ld	r24, Z
    8390:	8c 32       	cpi	r24, 0x2C	; 44
    8392:	21 f4       	brne	.+8      	; 0x839c <MUSART_u8Frame+0x54>
    8394:	8f 81       	ldd	r24, Y+7	; 0x07
    8396:	8f 5f       	subi	r24, 0xFF	; 255
    8398:	8f 83       	std	Y+7, r24	; 0x07
    839a:	8b c0       	rjmp	.+278    	; 0x84b2 <MUSART_u8Frame+0x16a>
		else
		{
			if(flag==0)
    839c:	8f 81       	ldd	r24, Y+7	; 0x07
    839e:	88 23       	and	r24, r24
    83a0:	b1 f4       	brne	.+44     	; 0x83ce <MUSART_u8Frame+0x86>
			{
				s1[j]=str[i];
    83a2:	8e 81       	ldd	r24, Y+6	; 0x06
    83a4:	28 2f       	mov	r18, r24
    83a6:	30 e0       	ldi	r19, 0x00	; 0
    83a8:	8b 85       	ldd	r24, Y+11	; 0x0b
    83aa:	9c 85       	ldd	r25, Y+12	; 0x0c
    83ac:	dc 01       	movw	r26, r24
    83ae:	a2 0f       	add	r26, r18
    83b0:	b3 1f       	adc	r27, r19
    83b2:	88 85       	ldd	r24, Y+8	; 0x08
    83b4:	28 2f       	mov	r18, r24
    83b6:	30 e0       	ldi	r19, 0x00	; 0
    83b8:	89 85       	ldd	r24, Y+9	; 0x09
    83ba:	9a 85       	ldd	r25, Y+10	; 0x0a
    83bc:	fc 01       	movw	r30, r24
    83be:	e2 0f       	add	r30, r18
    83c0:	f3 1f       	adc	r31, r19
    83c2:	80 81       	ld	r24, Z
    83c4:	8c 93       	st	X, r24
				j++; 
    83c6:	8e 81       	ldd	r24, Y+6	; 0x06
    83c8:	8f 5f       	subi	r24, 0xFF	; 255
    83ca:	8e 83       	std	Y+6, r24	; 0x06
    83cc:	72 c0       	rjmp	.+228    	; 0x84b2 <MUSART_u8Frame+0x16a>
			}
			else if(flag==1)
    83ce:	8f 81       	ldd	r24, Y+7	; 0x07
    83d0:	81 30       	cpi	r24, 0x01	; 1
    83d2:	b1 f5       	brne	.+108    	; 0x8440 <MUSART_u8Frame+0xf8>
			{
				if(str[i] >='0' && str[i] <='9')
    83d4:	88 85       	ldd	r24, Y+8	; 0x08
    83d6:	28 2f       	mov	r18, r24
    83d8:	30 e0       	ldi	r19, 0x00	; 0
    83da:	89 85       	ldd	r24, Y+9	; 0x09
    83dc:	9a 85       	ldd	r25, Y+10	; 0x0a
    83de:	fc 01       	movw	r30, r24
    83e0:	e2 0f       	add	r30, r18
    83e2:	f3 1f       	adc	r31, r19
    83e4:	80 81       	ld	r24, Z
    83e6:	80 33       	cpi	r24, 0x30	; 48
    83e8:	08 f4       	brcc	.+2      	; 0x83ec <MUSART_u8Frame+0xa4>
    83ea:	63 c0       	rjmp	.+198    	; 0x84b2 <MUSART_u8Frame+0x16a>
    83ec:	88 85       	ldd	r24, Y+8	; 0x08
    83ee:	28 2f       	mov	r18, r24
    83f0:	30 e0       	ldi	r19, 0x00	; 0
    83f2:	89 85       	ldd	r24, Y+9	; 0x09
    83f4:	9a 85       	ldd	r25, Y+10	; 0x0a
    83f6:	fc 01       	movw	r30, r24
    83f8:	e2 0f       	add	r30, r18
    83fa:	f3 1f       	adc	r31, r19
    83fc:	80 81       	ld	r24, Z
    83fe:	8a 33       	cpi	r24, 0x3A	; 58
    8400:	08 f0       	brcs	.+2      	; 0x8404 <MUSART_u8Frame+0xbc>
    8402:	57 c0       	rjmp	.+174    	; 0x84b2 <MUSART_u8Frame+0x16a>
				{
					num1=num1*10+(str[i]-'0');
    8404:	8b 81       	ldd	r24, Y+3	; 0x03
    8406:	9c 81       	ldd	r25, Y+4	; 0x04
    8408:	9c 01       	movw	r18, r24
    840a:	22 0f       	add	r18, r18
    840c:	33 1f       	adc	r19, r19
    840e:	c9 01       	movw	r24, r18
    8410:	88 0f       	add	r24, r24
    8412:	99 1f       	adc	r25, r25
    8414:	88 0f       	add	r24, r24
    8416:	99 1f       	adc	r25, r25
    8418:	a9 01       	movw	r20, r18
    841a:	48 0f       	add	r20, r24
    841c:	59 1f       	adc	r21, r25
    841e:	88 85       	ldd	r24, Y+8	; 0x08
    8420:	28 2f       	mov	r18, r24
    8422:	30 e0       	ldi	r19, 0x00	; 0
    8424:	89 85       	ldd	r24, Y+9	; 0x09
    8426:	9a 85       	ldd	r25, Y+10	; 0x0a
    8428:	fc 01       	movw	r30, r24
    842a:	e2 0f       	add	r30, r18
    842c:	f3 1f       	adc	r31, r19
    842e:	80 81       	ld	r24, Z
    8430:	88 2f       	mov	r24, r24
    8432:	90 e0       	ldi	r25, 0x00	; 0
    8434:	84 0f       	add	r24, r20
    8436:	95 1f       	adc	r25, r21
    8438:	c0 97       	sbiw	r24, 0x30	; 48
    843a:	9c 83       	std	Y+4, r25	; 0x04
    843c:	8b 83       	std	Y+3, r24	; 0x03
    843e:	39 c0       	rjmp	.+114    	; 0x84b2 <MUSART_u8Frame+0x16a>
				}
			}
			else if(flag==2)
    8440:	8f 81       	ldd	r24, Y+7	; 0x07
    8442:	82 30       	cpi	r24, 0x02	; 2
    8444:	b1 f4       	brne	.+44     	; 0x8472 <MUSART_u8Frame+0x12a>
			{
				s2[k]=str[i];
    8446:	8d 81       	ldd	r24, Y+5	; 0x05
    8448:	28 2f       	mov	r18, r24
    844a:	30 e0       	ldi	r19, 0x00	; 0
    844c:	8d 85       	ldd	r24, Y+13	; 0x0d
    844e:	9e 85       	ldd	r25, Y+14	; 0x0e
    8450:	dc 01       	movw	r26, r24
    8452:	a2 0f       	add	r26, r18
    8454:	b3 1f       	adc	r27, r19
    8456:	88 85       	ldd	r24, Y+8	; 0x08
    8458:	28 2f       	mov	r18, r24
    845a:	30 e0       	ldi	r19, 0x00	; 0
    845c:	89 85       	ldd	r24, Y+9	; 0x09
    845e:	9a 85       	ldd	r25, Y+10	; 0x0a
    8460:	fc 01       	movw	r30, r24
    8462:	e2 0f       	add	r30, r18
    8464:	f3 1f       	adc	r31, r19
    8466:	80 81       	ld	r24, Z
    8468:	8c 93       	st	X, r24
				k++; 
    846a:	8d 81       	ldd	r24, Y+5	; 0x05
    846c:	8f 5f       	subi	r24, 0xFF	; 255
    846e:	8d 83       	std	Y+5, r24	; 0x05
    8470:	20 c0       	rjmp	.+64     	; 0x84b2 <MUSART_u8Frame+0x16a>
			}
			else if(flag==3) num2=num2*10+(str[i]-'0');
    8472:	8f 81       	ldd	r24, Y+7	; 0x07
    8474:	83 30       	cpi	r24, 0x03	; 3
    8476:	e9 f4       	brne	.+58     	; 0x84b2 <MUSART_u8Frame+0x16a>
    8478:	89 81       	ldd	r24, Y+1	; 0x01
    847a:	9a 81       	ldd	r25, Y+2	; 0x02
    847c:	9c 01       	movw	r18, r24
    847e:	22 0f       	add	r18, r18
    8480:	33 1f       	adc	r19, r19
    8482:	c9 01       	movw	r24, r18
    8484:	88 0f       	add	r24, r24
    8486:	99 1f       	adc	r25, r25
    8488:	88 0f       	add	r24, r24
    848a:	99 1f       	adc	r25, r25
    848c:	a9 01       	movw	r20, r18
    848e:	48 0f       	add	r20, r24
    8490:	59 1f       	adc	r21, r25
    8492:	88 85       	ldd	r24, Y+8	; 0x08
    8494:	28 2f       	mov	r18, r24
    8496:	30 e0       	ldi	r19, 0x00	; 0
    8498:	89 85       	ldd	r24, Y+9	; 0x09
    849a:	9a 85       	ldd	r25, Y+10	; 0x0a
    849c:	fc 01       	movw	r30, r24
    849e:	e2 0f       	add	r30, r18
    84a0:	f3 1f       	adc	r31, r19
    84a2:	80 81       	ld	r24, Z
    84a4:	88 2f       	mov	r24, r24
    84a6:	90 e0       	ldi	r25, 0x00	; 0
    84a8:	84 0f       	add	r24, r20
    84aa:	95 1f       	adc	r25, r21
    84ac:	c0 97       	sbiw	r24, 0x30	; 48
    84ae:	9a 83       	std	Y+2, r25	; 0x02
    84b0:	89 83       	std	Y+1, r24	; 0x01
		}
		i++;
    84b2:	88 85       	ldd	r24, Y+8	; 0x08
    84b4:	8f 5f       	subi	r24, 0xFF	; 255
    84b6:	88 87       	std	Y+8, r24	; 0x08
	//our frame: hello,509,hi,76
	
	u8 i=0,flag=0,j=0,k=0;
	u16 num1,num2;
	
	while(str[i]!='\0')
    84b8:	88 85       	ldd	r24, Y+8	; 0x08
    84ba:	28 2f       	mov	r18, r24
    84bc:	30 e0       	ldi	r19, 0x00	; 0
    84be:	89 85       	ldd	r24, Y+9	; 0x09
    84c0:	9a 85       	ldd	r25, Y+10	; 0x0a
    84c2:	fc 01       	movw	r30, r24
    84c4:	e2 0f       	add	r30, r18
    84c6:	f3 1f       	adc	r31, r19
    84c8:	80 81       	ld	r24, Z
    84ca:	88 23       	and	r24, r24
    84cc:	09 f0       	breq	.+2      	; 0x84d0 <MUSART_u8Frame+0x188>
    84ce:	57 cf       	rjmp	.-338    	; 0x837e <MUSART_u8Frame+0x36>
			}
			else if(flag==3) num2=num2*10+(str[i]-'0');
		}
		i++;
	}
	s1[j]='\0';
    84d0:	8e 81       	ldd	r24, Y+6	; 0x06
    84d2:	28 2f       	mov	r18, r24
    84d4:	30 e0       	ldi	r19, 0x00	; 0
    84d6:	8b 85       	ldd	r24, Y+11	; 0x0b
    84d8:	9c 85       	ldd	r25, Y+12	; 0x0c
    84da:	fc 01       	movw	r30, r24
    84dc:	e2 0f       	add	r30, r18
    84de:	f3 1f       	adc	r31, r19
    84e0:	10 82       	st	Z, r1
	s2[k]='\0';
    84e2:	8d 81       	ldd	r24, Y+5	; 0x05
    84e4:	28 2f       	mov	r18, r24
    84e6:	30 e0       	ldi	r19, 0x00	; 0
    84e8:	8d 85       	ldd	r24, Y+13	; 0x0d
    84ea:	9e 85       	ldd	r25, Y+14	; 0x0e
    84ec:	fc 01       	movw	r30, r24
    84ee:	e2 0f       	add	r30, r18
    84f0:	f3 1f       	adc	r31, r19
    84f2:	10 82       	st	Z, r1
	*pnum1=num1;
    84f4:	8b 81       	ldd	r24, Y+3	; 0x03
    84f6:	ef 85       	ldd	r30, Y+15	; 0x0f
    84f8:	f8 89       	ldd	r31, Y+16	; 0x10
    84fa:	80 83       	st	Z, r24
	*pnum2=num2;
    84fc:	89 81       	ldd	r24, Y+1	; 0x01
    84fe:	e9 89       	ldd	r30, Y+17	; 0x11
    8500:	fa 89       	ldd	r31, Y+18	; 0x12
    8502:	80 83       	st	Z, r24
	if(flag!=3) return 0;
    8504:	8f 81       	ldd	r24, Y+7	; 0x07
    8506:	83 30       	cpi	r24, 0x03	; 3
    8508:	11 f0       	breq	.+4      	; 0x850e <MUSART_u8Frame+0x1c6>
    850a:	1b 8a       	std	Y+19, r1	; 0x13
    850c:	02 c0       	rjmp	.+4      	; 0x8512 <MUSART_u8Frame+0x1ca>
	return 1;
    850e:	81 e0       	ldi	r24, 0x01	; 1
    8510:	8b 8b       	std	Y+19, r24	; 0x13
    8512:	8b 89       	ldd	r24, Y+19	; 0x13
}
    8514:	63 96       	adiw	r28, 0x13	; 19
    8516:	0f b6       	in	r0, 0x3f	; 63
    8518:	f8 94       	cli
    851a:	de bf       	out	0x3e, r29	; 62
    851c:	0f be       	out	0x3f, r0	; 63
    851e:	cd bf       	out	0x3d, r28	; 61
    8520:	cf 91       	pop	r28
    8522:	df 91       	pop	r29
    8524:	1f 91       	pop	r17
    8526:	0f 91       	pop	r16
    8528:	08 95       	ret

0000852a <__mulsi3>:
    852a:	62 9f       	mul	r22, r18
    852c:	d0 01       	movw	r26, r0
    852e:	73 9f       	mul	r23, r19
    8530:	f0 01       	movw	r30, r0
    8532:	82 9f       	mul	r24, r18
    8534:	e0 0d       	add	r30, r0
    8536:	f1 1d       	adc	r31, r1
    8538:	64 9f       	mul	r22, r20
    853a:	e0 0d       	add	r30, r0
    853c:	f1 1d       	adc	r31, r1
    853e:	92 9f       	mul	r25, r18
    8540:	f0 0d       	add	r31, r0
    8542:	83 9f       	mul	r24, r19
    8544:	f0 0d       	add	r31, r0
    8546:	74 9f       	mul	r23, r20
    8548:	f0 0d       	add	r31, r0
    854a:	65 9f       	mul	r22, r21
    854c:	f0 0d       	add	r31, r0
    854e:	99 27       	eor	r25, r25
    8550:	72 9f       	mul	r23, r18
    8552:	b0 0d       	add	r27, r0
    8554:	e1 1d       	adc	r30, r1
    8556:	f9 1f       	adc	r31, r25
    8558:	63 9f       	mul	r22, r19
    855a:	b0 0d       	add	r27, r0
    855c:	e1 1d       	adc	r30, r1
    855e:	f9 1f       	adc	r31, r25
    8560:	bd 01       	movw	r22, r26
    8562:	cf 01       	movw	r24, r30
    8564:	11 24       	eor	r1, r1
    8566:	08 95       	ret

00008568 <__udivmodhi4>:
    8568:	aa 1b       	sub	r26, r26
    856a:	bb 1b       	sub	r27, r27
    856c:	51 e1       	ldi	r21, 0x11	; 17
    856e:	07 c0       	rjmp	.+14     	; 0x857e <__udivmodhi4_ep>

00008570 <__udivmodhi4_loop>:
    8570:	aa 1f       	adc	r26, r26
    8572:	bb 1f       	adc	r27, r27
    8574:	a6 17       	cp	r26, r22
    8576:	b7 07       	cpc	r27, r23
    8578:	10 f0       	brcs	.+4      	; 0x857e <__udivmodhi4_ep>
    857a:	a6 1b       	sub	r26, r22
    857c:	b7 0b       	sbc	r27, r23

0000857e <__udivmodhi4_ep>:
    857e:	88 1f       	adc	r24, r24
    8580:	99 1f       	adc	r25, r25
    8582:	5a 95       	dec	r21
    8584:	a9 f7       	brne	.-22     	; 0x8570 <__udivmodhi4_loop>
    8586:	80 95       	com	r24
    8588:	90 95       	com	r25
    858a:	bc 01       	movw	r22, r24
    858c:	cd 01       	movw	r24, r26
    858e:	08 95       	ret

00008590 <__udivmodsi4>:
    8590:	a1 e2       	ldi	r26, 0x21	; 33
    8592:	1a 2e       	mov	r1, r26
    8594:	aa 1b       	sub	r26, r26
    8596:	bb 1b       	sub	r27, r27
    8598:	fd 01       	movw	r30, r26
    859a:	0d c0       	rjmp	.+26     	; 0x85b6 <__udivmodsi4_ep>

0000859c <__udivmodsi4_loop>:
    859c:	aa 1f       	adc	r26, r26
    859e:	bb 1f       	adc	r27, r27
    85a0:	ee 1f       	adc	r30, r30
    85a2:	ff 1f       	adc	r31, r31
    85a4:	a2 17       	cp	r26, r18
    85a6:	b3 07       	cpc	r27, r19
    85a8:	e4 07       	cpc	r30, r20
    85aa:	f5 07       	cpc	r31, r21
    85ac:	20 f0       	brcs	.+8      	; 0x85b6 <__udivmodsi4_ep>
    85ae:	a2 1b       	sub	r26, r18
    85b0:	b3 0b       	sbc	r27, r19
    85b2:	e4 0b       	sbc	r30, r20
    85b4:	f5 0b       	sbc	r31, r21

000085b6 <__udivmodsi4_ep>:
    85b6:	66 1f       	adc	r22, r22
    85b8:	77 1f       	adc	r23, r23
    85ba:	88 1f       	adc	r24, r24
    85bc:	99 1f       	adc	r25, r25
    85be:	1a 94       	dec	r1
    85c0:	69 f7       	brne	.-38     	; 0x859c <__udivmodsi4_loop>
    85c2:	60 95       	com	r22
    85c4:	70 95       	com	r23
    85c6:	80 95       	com	r24
    85c8:	90 95       	com	r25
    85ca:	9b 01       	movw	r18, r22
    85cc:	ac 01       	movw	r20, r24
    85ce:	bd 01       	movw	r22, r26
    85d0:	cf 01       	movw	r24, r30
    85d2:	08 95       	ret

000085d4 <__prologue_saves__>:
    85d4:	2f 92       	push	r2
    85d6:	3f 92       	push	r3
    85d8:	4f 92       	push	r4
    85da:	5f 92       	push	r5
    85dc:	6f 92       	push	r6
    85de:	7f 92       	push	r7
    85e0:	8f 92       	push	r8
    85e2:	9f 92       	push	r9
    85e4:	af 92       	push	r10
    85e6:	bf 92       	push	r11
    85e8:	cf 92       	push	r12
    85ea:	df 92       	push	r13
    85ec:	ef 92       	push	r14
    85ee:	ff 92       	push	r15
    85f0:	0f 93       	push	r16
    85f2:	1f 93       	push	r17
    85f4:	cf 93       	push	r28
    85f6:	df 93       	push	r29
    85f8:	cd b7       	in	r28, 0x3d	; 61
    85fa:	de b7       	in	r29, 0x3e	; 62
    85fc:	ca 1b       	sub	r28, r26
    85fe:	db 0b       	sbc	r29, r27
    8600:	0f b6       	in	r0, 0x3f	; 63
    8602:	f8 94       	cli
    8604:	de bf       	out	0x3e, r29	; 62
    8606:	0f be       	out	0x3f, r0	; 63
    8608:	cd bf       	out	0x3d, r28	; 61
    860a:	09 94       	ijmp

0000860c <__epilogue_restores__>:
    860c:	2a 88       	ldd	r2, Y+18	; 0x12
    860e:	39 88       	ldd	r3, Y+17	; 0x11
    8610:	48 88       	ldd	r4, Y+16	; 0x10
    8612:	5f 84       	ldd	r5, Y+15	; 0x0f
    8614:	6e 84       	ldd	r6, Y+14	; 0x0e
    8616:	7d 84       	ldd	r7, Y+13	; 0x0d
    8618:	8c 84       	ldd	r8, Y+12	; 0x0c
    861a:	9b 84       	ldd	r9, Y+11	; 0x0b
    861c:	aa 84       	ldd	r10, Y+10	; 0x0a
    861e:	b9 84       	ldd	r11, Y+9	; 0x09
    8620:	c8 84       	ldd	r12, Y+8	; 0x08
    8622:	df 80       	ldd	r13, Y+7	; 0x07
    8624:	ee 80       	ldd	r14, Y+6	; 0x06
    8626:	fd 80       	ldd	r15, Y+5	; 0x05
    8628:	0c 81       	ldd	r16, Y+4	; 0x04
    862a:	1b 81       	ldd	r17, Y+3	; 0x03
    862c:	aa 81       	ldd	r26, Y+2	; 0x02
    862e:	b9 81       	ldd	r27, Y+1	; 0x01
    8630:	ce 0f       	add	r28, r30
    8632:	d1 1d       	adc	r29, r1
    8634:	0f b6       	in	r0, 0x3f	; 63
    8636:	f8 94       	cli
    8638:	de bf       	out	0x3e, r29	; 62
    863a:	0f be       	out	0x3f, r0	; 63
    863c:	cd bf       	out	0x3d, r28	; 61
    863e:	ed 01       	movw	r28, r26
    8640:	08 95       	ret

00008642 <_exit>:
    8642:	f8 94       	cli

00008644 <__stop_program>:
    8644:	ff cf       	rjmp	.-2      	; 0x8644 <__stop_program>
